!% $ZCODE_LESS_DICT_DATA=1;
!% $OMIT_UNUSED_ROUTINES=1;
!% -s
!% $ALLOC_CHUNK_SIZE=32000
!% $MAX_ARRAYS=10000
!% $MAX_CLASSES=200
!% $MAX_VERBS=255
!% $MAX_LABELS=200000
!% $MAX_ZCODE_SIZE=1000000
!% $MAX_STATIC_DATA=500000
!% $MAX_NUM_STATIC_STRINGS=500000
!% $MAX_PROP_TABLE_SIZE=200000
!% $MAX_INDIV_PROP_TABLE_SIZE=20000
!% $MAX_STACK_SIZE=65536
!% $MAX_SYMBOLS=20000
!% $MAX_EXPRESSION_NODES=256
!% $MAX_LOCAL_VARIABLES=256
Constant Grammar__Version 2;
Global debug_flag;
Global or_tmp_var;
Attribute absent;
Attribute animate;
Attribute clothing;
Attribute concealed;
Attribute container;
Attribute door;
Attribute edible;
Attribute enterable;
Attribute light;
Attribute lockable;
Attribute locked;
Attribute moved;
Attribute on;
Attribute open;
Attribute openable;
Attribute scenery;
Attribute static;
Attribute supporter;
Attribute switchable;
Attribute talkable;
Attribute transparent;
Attribute visited;
Attribute worn;
Attribute male;
Attribute female;
Attribute neuter;
Attribute pluralname;
Attribute ambigpluralname;
Attribute proper;
Attribute remove_proper;
Attribute privately_named;
Attribute mentioned;
Attribute pushable;
Attribute mark_as_room;
Attribute mark_as_thing;
Attribute workflag;
Attribute workflag2;
Property add_to_scope;
Property article;
Property capacity;
Property component_child;
Property component_parent;
Property component_sibling;
Property description;
Property door_dir;
Property door_to;
Property found_in;
Property initial;
Property list_together;
Property map_region;
Property parse_name;
Property plural;
Property regional_found_in;
Property room_index;
Property short_name;
Property saved_short_name;
Property vector;
Property with_key;
Property KD_Count;
Property IK1_Count;
Property IK2_Count;
Property IK4_Count;
Property IK5_Count;
Property IK6_Count;
Property IK8_Count;
Property IK3_Count;
Property IK1_link;
Property IK2_link;
Property IK5_link;
Property IK6_link;
Property IK8_link;
Property articles;
Property grammar;
Property inside_description;
Property short_name_indef;
Global unicode_gestalt_ok = 0;
Global formal_rv = 0;
Global formal_par0 = 0;
Global formal_par1 = 0;
Global formal_par2 = 0;
Global formal_par3 = 0;
Global formal_par4 = 0;
Global formal_par5 = 0;
Global formal_par6 = 0;
Global formal_par7 = 0;
Global unicode_temp = 0;
Global I7SFRAME = 0;
Global TEXT_TY_RE_Err = 0;
Global prior_named_noun = 0;
Global prior_named_list = 0;
Global prior_named_list_gender = 0;
Global story_tense = 1;
Global story_viewpoint = 2;
Global say__p = 1;
Global say__pc = 0;
Global say__pc_save = 0;
Global say__n = 0;
Global say__comp = 0;
Global los_rv = 0;
Global parameter_object = 0;
Global parameter_value = 0;
Global property_to_be_totalled = 0;
Global property_loop_sign = 0;
Global suppress_scope_loops = 0;
Global temporary_value = 0;
Global clr_fg = 1;
Global clr_bg = 1;
Global clr_fgstatus = 1;
Global clr_bgstatus = 1;
Global clr_on = 0;
Global statuswin_current = 0;
Global suppress_text_substitution = 0;
Global deadflag = 0;
Global statuswin_cursize = 0;
Global statuswin_size = 1;
Global debug_rules = 0;
Global debug_rule_nesting = 0;
Global reason_the_action_failed = 0;
Global indef_mode = 0;
Global standard_interpreter = 0;
Global gg_mainwin = 0;
Global gg_statuswin = 0;
Global gg_quotewin = 0;
Global gg_scriptfref = 0;
Global gg_scriptstr = 0;
Global gg_savestr = 0;
Global gg_commandstr = 0;
Global gg_command_reading = 0;
Global gg_foregroundchan = 0;
Global gg_backgroundchan = 0;
Global I7S_Tab = 0;
Global I7S_Col = 0;
Global I7S_Dir = 0;
Global I7S_Swap = 0;
Global I7S_Comp = 0;
Global MStack_Top = 0;
Global MStack_Frame_Extent = 0;
Global process_rulebook_count = 0;
Global debugging_rules = 0;
Global RawBufferAddress = TEXT_TY_Buffers;
Global RawBufferSize = TEXT_TY_BufferSize;
Global TEXT_TY_CastPrimitiveNesting = 0;
Global TEXT_TY_RE_Trace = 0;
Global TEXT_TY_RE_RewindCount = 0;
Global LIST_OF_TY_Sort_cf = 0;
Global location = 0;
Global sline1 = 0;
Global sline2 = 0;
Global undo_flag = 0;
Global story_complete = 0;
Global resurrect_please = 0;
Global not_yet_in_play = 1;
Global turns = 1;
Global the_time = NULL;
Global time_rate = 1;
Global score = 0;
Global last_score = 0;
Global notify_mode = 1;
Global left_hand_status_line = T_SL_Location;
Global right_hand_status_line = T_SL_Score_Moves;
Global player = 0;
Global real_location = 0;
Global visibility_ceiling = 0;
Global visibility_levels = 0;
Global SACK_OBJECT = 0;
Global act_requester = 0;
Global actor = 0;
Global actors_location = 0;
Global actor_location = 0;
Global action = 0;
Global meta = 0;
Global inp1 = 0;
Global inp2 = 0;
Global toomany_flag = 0;
Global multiflag = 0;
Global multiple_object_item = 0;
Global noun = 0;
Global second = 0;
Global keep_silent = 0;
Global trace_actions = 0;
Global untouchable_object = 0;
Global untouchable_silence = 0;
Global touch_persona = 0;
Global special_word = 0;
Global consult_from = 0;
Global consult_words = 0;
Global parsed_number = 0;
Global special_number1 = 0;
Global special_number2 = 0;
Global parser_trace = 0;
Global pronoun_word = 0;
Global pronoun_obj = 0;
Global players_command = 100;
Global matched_text = 0;
Global understand_as_mistake_number = 0;
Global particular_possession = 0;
Global parser_action = 0;
Global parser_one = 0;
Global parser_two = 0;
Global parameters = 0;
Global action_to_be = 0;
Global action_reversed = 0;
Global wn = 0;
Global num_words = 0;
Global verb_word = 0;
Global verb_wordnum = 0;
Global scope_reason = PARSING_REASON;
Global scope_token = 0;
Global scope_error = 0;
Global scope_stage = 0;
Global advance_warning = 0;
Global reason_code = NULL;
Global ats_flag = 0;
Global ats_hls = 0;
Global move_pushing = 0;
Global move_from = 0;
Global move_to = 0;
Global move_by = 0;
Global move_through = 0;
Global lookmode = KIT_CONFIGURATION_LOOKMODE;
Global c_style = 0;
Global c_depth = 0;
Global c_iterator = 0;
Global lt_value = EMPTY_TEXT_VALUE;
Global listing_together = 0;
Global listing_size = 0;
Global c_margin = 0;
Global inventory_stage = 1;
Global debug_scenes = 0;
Global MAX_SCORE = INITIAL_MAX_SCORE;
Global lightflag = 0;
Global requisition_stack_pointer = 0;
Global MarkedObjectArray = 0;
Global MarkedObjectLength = 0;
Global list_filter_routine = 0;
Global EarlyInTurnSequence = 0;
Global IterationsOfTurnSequence = 0;
Global time_step = 0;
Global converted_action_outcome = -1;
Global activities_sp = 0;
Global inhibit_flag = 0;
Global saved_debug_rules = 0;
Global pending_boxed_quotation = 0;
Global caps_mode = 0;
Global short_name_case = 0;
Global map_has_changed = 1;
Global last_filter = 0;
Global last_use_doors = 0;
Global x_scope_count = 0;
Global test_sp = 0;
Global etype = 0;
Global best_etype = 0;
Global nextbest_etype = 0;
Global parser_inflection = 0;
Global indirect_parser_inflection = 0;
Global pcount = 0;
Global pcount2 = 0;
Global nsns = 0;
Global params_wanted = 0;
Global inferfrom = 0;
Global inferword = 0;
Global dont_infer_pronoun = 0;
Global dont_infer = 0;
Global cobj_flag = 0;
Global oops_from = 0;
Global saved_oops = 0;
Global held_back_mode = 0;
Global hb_wn = 0;
Global usual_grammar_after = 0;
Global found_ttype = 0;
Global found_tdata = 0;
Global token_filter = 0;
Global length_of_noun = 0;
Global lookahead = 0;
Global multi_mode = 0;
Global multi_wanted = 0;
Global multi_had = 0;
Global multi_context = 0;
Global indef_type = 0;
Global indef_wanted = 0;
Global indef_guess_p = 0;
Global indef_owner = 0;
Global indef_cases = 0;
Global indef_possambig = 0;
Global indef_nspec_at = 0;
Global allow_plurals = 0;
Global take_all_rule = 0;
Global dict_flags_of_noun = 0;
Global pronoun__word = 0;
Global pronoun__obj = 0;
Global number_matched = 0;
Global number_of_classes = 0;
Global match_length = 0;
Global match_from = 0;
Global parsetoken_nesting = 0;
Array Global_Vars --> 0
  (0) ! -->1 = V56_number_understood (V56_number_understood)
  (0) ! -->2 = V57_real_number_understood (V57_real_number_understood)
  (0) ! -->3 = V58_truth_state_understood (V58_truth_state_understood)
  (0) ! -->4 = V59_external_file_understood (V59_external_file_understood)
  (540) ! -->5 = V60_time_understood (V60_time_understood)
  (I_entire_game_U1) ! -->6 = V61_scene_understood (V61_scene_understood)
  (I_figure_of_cover_U1) ! -->7 = V62_figure_name_understood (V62_figure_name_understood)
  (0) ! -->8 = V63_sound_name_understood (V63_sound_name_understood)
  (I_english_language_U1) ! -->9 = V64_natural_language_understo (V64_natural_language_understo)
  (I_present_tense_U1) ! -->10 = V65_grammatical_tense_underst (V65_grammatical_tense_underst)
  (I_first_person_singular_U1) ! -->11 = V66_narrative_viewpoint_under (V66_narrative_viewpoint_under)
  (I_nominative_U1) ! -->12 = V67_grammatical_case_understo (V67_grammatical_case_understo)
  (I_neuter_gender_U1) ! -->13 = V68_grammatical_gender_unders (V68_grammatical_gender_unders)
  (I_didn_t_understand_error_U1) ! -->14 = V69_command_parser_error_unde (V69_command_parser_error_unde)
  (I_english_language_U1) ! -->15 = V1_language_of_play (V1_language_of_play)
  (0) ! -->16 = V12_darkness_witnessed (V12_darkness_witnessed)
  (bc_U152) ! -->17 = V26_command_prompt (V26_command_prompt)
  (bc_U153) ! -->18 = V31_story_author (V31_story_author)
  (bc_U154) ! -->19 = V32_story_headline (V32_story_headline)
  (bc_U155) ! -->20 = V33_story_genre (V33_story_genre)
  (bc_U156) ! -->21 = V34_story_description (V34_story_description)
  (1) ! -->22 = V35_release_number (V35_release_number)
  (0) ! -->23 = V36_story_creation_year (V36_story_creation_year)
  (0) ! -->24 = V43_locale_paragraph_count (V43_locale_paragraph_count)
  (I_kitchen_U1) ! -->25 = V44_room_gone_from (V44_room_gone_from)
  (0) ! -->26 = V45_room_gone_to (V45_room_gone_to)
  (0) ! -->27 = V46_door_gone_through (V46_door_gone_through)
  (0) ! -->28 = V47_vehicle_gone_by (V47_vehicle_gone_by)
  (0) ! -->29 = V48_thing_gone_with (V48_thing_gone_with)
  (0) ! -->30 = V49_container_exited_from (V49_container_exited_from)
  (##Wait) ! -->31 = V50_room_describing_action (V50_room_describing_action)
  (0) ! -->32 = V51_abbreviated_form_allowed (V51_abbreviated_form_allowed)
  (0) ! -->33 = V52_visibility_level_count (V52_visibility_level_count)
  (0) ! -->34 = V53_visibility_ceiling (V53_visibility_ceiling)
  (0) ! -->35 = V54_examine_text_printed (V54_examine_text_printed)
  (selfobj) ! -->36 = V70_actor (V70_actor)
  (0) ! -->37 = V71_action_in_world (V71_action_in_world)
  (0) ! -->38 = V72_action_keeping_silent (V72_action_keeping_silent)
  (0) ! -->39 = V73_specific_check_rulebook (V73_specific_check_rulebook)
  (0) ! -->40 = V74_specific_carry_out_rulebo (V74_specific_carry_out_rulebo)
  (0) ! -->41 = V75_specific_report_rulebook (V75_specific_report_rulebook)
  (0) ! -->42 = V76_within_the_player_s_sight (V76_within_the_player_s_sight)
;
Constant subterfuge_1 = absent;
Constant subterfuge_2 = animate;
Constant subterfuge_3 = clothing;
Constant subterfuge_4 = concealed;
Constant subterfuge_5 = container;
Constant subterfuge_6 = door;
Constant subterfuge_7 = edible;
Constant subterfuge_8 = enterable;
Constant subterfuge_9 = light;
Constant subterfuge_10 = lockable;
Constant subterfuge_11 = locked;
Constant subterfuge_12 = moved;
Constant subterfuge_13 = on;
Constant subterfuge_14 = open;
Constant subterfuge_15 = openable;
Constant subterfuge_16 = scenery;
Constant subterfuge_17 = static;
Constant subterfuge_18 = supporter;
Constant subterfuge_19 = switchable;
Constant subterfuge_20 = talkable;
Constant subterfuge_21 = transparent;
Constant subterfuge_22 = visited;
Constant subterfuge_23 = worn;
Constant subterfuge_24 = male;
Constant subterfuge_25 = female;
Constant subterfuge_26 = neuter;
Constant subterfuge_27 = pluralname;
Constant subterfuge_28 = ambigpluralname;
Constant subterfuge_29 = proper;
Constant subterfuge_30 = remove_proper;
Constant subterfuge_31 = privately_named;
Constant subterfuge_32 = mentioned;
Constant subterfuge_33 = pushable;
Constant subterfuge_34 = mark_as_room;
Constant subterfuge_35 = mark_as_thing;
Constant subterfuge_36 = workflag;
Constant subterfuge_37 = workflag2;
Constant subterfuge_38 = add_to_scope;
Constant subterfuge_39 = article;
Constant subterfuge_40 = capacity;
Constant subterfuge_41 = component_child;
Constant subterfuge_42 = component_parent;
Constant subterfuge_43 = component_sibling;
Constant subterfuge_44 = description;
Constant subterfuge_45 = door_dir;
Constant subterfuge_46 = door_to;
Constant subterfuge_47 = found_in;
Constant subterfuge_48 = initial;
Constant subterfuge_49 = list_together;
Constant subterfuge_50 = map_region;
Constant subterfuge_51 = parse_name;
Constant subterfuge_52 = plural;
Constant subterfuge_53 = regional_found_in;
Constant subterfuge_54 = room_index;
Constant subterfuge_55 = short_name;
Constant subterfuge_56 = saved_short_name;
Constant subterfuge_57 = vector;
Constant subterfuge_58 = with_key;
Constant subterfuge_59 = KD_Count;
Constant subterfuge_60 = IK1_Count;
Constant subterfuge_61 = IK2_Count;
Constant subterfuge_62 = IK4_Count;
Constant subterfuge_63 = IK5_Count;
Constant subterfuge_64 = IK6_Count;
Constant subterfuge_65 = IK8_Count;
Constant subterfuge_66 = IK3_Count;
Constant subterfuge_67 = IK1_link;
Constant subterfuge_68 = IK2_link;
Constant subterfuge_69 = IK5_link;
Constant subterfuge_70 = IK6_link;
Constant subterfuge_71 = IK8_link;
Constant subterfuge_72 = articles;
Constant subterfuge_73 = grammar;
Constant subterfuge_74 = inside_description;
Constant subterfuge_75 = short_name_indef;
Constant subterfuge_76 = cap_short_name;
Constant subterfuge_77 = before;
Constant subterfuge_78 = action_bitmap;
Constant subterfuge_79 = name;
Constant subterfuge_80 = P_variable_initial_value;
Constant subterfuge_81 = P_specification;
Constant subterfuge_82 = P_indefinite_appearance_text;
Constant subterfuge_83 = P_adaptive_text_viewpoint;
Constant subterfuge_84 = P_opposite;
Constant subterfuge_85 = P_recurring;
Constant subterfuge_86 = K1_room_Next;
Constant subterfuge_87 = K2_thing_Next;
Constant subterfuge_88 = K3_direction_Next;
Constant subterfuge_89 = K4_door_Next;
Constant subterfuge_90 = K5_container_Next;
Constant subterfuge_91 = K6_supporter_Next;
Constant subterfuge_92 = IK7_Count;
Constant subterfuge_93 = K7_backdrop_Next;
Constant subterfuge_94 = K8_person_Next;
Constant subterfuge_95 = IK9_Count;
Constant subterfuge_96 = K9_region_Next;
Constant subterfuge_97 = IK10_Count;
Constant subterfuge_98 = K10_man_Next;
Constant subterfuge_99 = K11_woman_Count;
Constant subterfuge_100 = K11_woman_Next;
Constant subterfuge_101 = K12_animal_Count;
Constant subterfuge_102 = K12_animal_Next;
Constant subterfuge_103 = K13_device_Count;
Constant subterfuge_104 = K13_device_Next;
Constant subterfuge_105 = K14_vehicle_Count;
Constant subterfuge_106 = K14_vehicle_Next;
Constant subterfuge_107 = K15_player_s_holdall_Count;
Constant subterfuge_108 = K15_player_s_holdall_Next;
Constant subterfuge_109 = K16_little_girl_Count;
Constant subterfuge_110 = K16_little_girl_Next;
Constant I_english_language_U1 = 1;
Constant I_french_language_U1 = 2;
Constant I_german_language_U1 = 3;
Constant I_italian_language_U1 = 4;
Constant I_spanish_language_U1 = 5;
Constant I_swedish_language_U1 = 6;
Constant I_present_tense_U1 = 1;
Constant I_past_tense_U1 = 2;
Constant I_perfect_tense_U1 = 3;
Constant I_past_perfect_tense_U1 = 4;
Constant I_future_tense_U1 = 5;
Constant I_first_person_singular_U1 = 1;
Constant I_second_person_singular_U1 = 2;
Constant I_third_person_singular_U1 = 3;
Constant I_first_person_plural_U1 = 4;
Constant I_second_person_plural_U1 = 5;
Constant I_third_person_plural_U1 = 6;
Constant I_nominative_U1 = 1;
Constant I_accusative_U1 = 2;
Constant I_neuter_gender_U1 = 1;
Constant I_masculine_gender_U1 = 2;
Constant I_feminine_gender_U1 = 3;
Constant I_figure_of_cover_U1 = 1;
Constant I_entire_game_U1 = 1;
Constant I_didn_t_understand_error_U1 = 1;
Constant I_only_understood_as_far_as__U1 = 2;
Constant I_didn_t_understand_that_num_U1 = 3;
Constant I_can_only_do_that_to_someth_U1 = 4;
Constant I_can_t_see_any_such_thing_e_U1 = 5;
Constant I_said_too_little_error_U1 = 6;
Constant I_aren_t_holding_that_error_U1 = 7;
Constant I_can_t_use_multiple_objects_U1 = 8;
Constant I_can_only_use_multiple_obje_U1 = 9;
Constant I_not_sure_what_it_refers_to_U1 = 10;
Constant I_excepted_something_not_inc_U1 = 11;
Constant I_not_a_verb_i_recognise_err_U1 = 12;
Constant I_not_something_you_need_to__U1 = 13;
Constant I_can_t_see_it_at_the_moment_U1 = 14;
Constant I_didn_t_understand_the_way__U1 = 15;
Constant I_not_enough_of_those_availa_U1 = 16;
Constant I_nothing_to_do_error_U1 = 17;
Constant I_referred_to_a_determinatio_U1 = 18;
Constant I_noun_did_not_make_sense_in_U1 = 19;
Constant I_i_beg_your_pardon_error_U1 = 20;
Constant I_can_t_again_the_addressee__U1 = 21;
Constant I_comma_can_t_begin_error_U1 = 22;
Constant I_can_t_see_whom_to_talk_to__U1 = 23;
Constant I_can_t_talk_to_inanimate_th_U1 = 24;
Constant I_didn_t_understand_addresse_U1 = 25;
Constant CV_POS = -1;
Constant CV_NEG = -2;
Constant CV_MODAL = -3;
Constant CV_MEANING = -4;
Constant REPARSE_CODE = 1073741824;
Constant VERB_DIRECTIVE_META = 1;
Constant VERB_DIRECTIVE_NOUN_FILTER = 1;
Constant VERB_DIRECTIVE_SCOPE_FILTER = 1;
Constant VERB_DIRECTIVE_REVERSE = 1;
Constant VERB_DIRECTIVE_SLASH = 1;
Constant VERB_DIRECTIVE_DIVIDER = 1;
Constant VERB_DIRECTIVE_RESULT = 2;
Constant VERB_DIRECTIVE_SPECIAL = 3;
Constant VERB_DIRECTIVE_NUMBER = 4;
Constant VERB_DIRECTIVE_NOUN = 5;
Constant VERB_DIRECTIVE_MULTI = 6;
Constant VERB_DIRECTIVE_MULTIINSIDE = 7;
Constant VERB_DIRECTIVE_MULTIHELD = 8;
Constant VERB_DIRECTIVE_HELD = 9;
Constant VERB_DIRECTIVE_CREATURE = 10;
Constant VERB_DIRECTIVE_TOPIC = 11;
Constant VERB_DIRECTIVE_MULTIEXCEPT = 12;
#ifndef DICT_WORD_SIZE;
Constant DICT_WORD_SIZE = 9;
#endif;
Constant PLAYER_OBJECT_INIS = 0;
Constant START_OBJECT_INIS = 1;
Constant START_ROOM_INIS = 2;
Constant START_TIME_INIS = 3;
Constant DynamicMemoryAllocation = 8192;
Constant Computed_Constant_Value_0_U1 = 1024;
Constant Computed_Constant_Value_1_U1 = 3;
Constant MAX_FIGURE_THUMBNAILS_IN_INDEX = 50;
Constant MATCH_LIST_WORDS = 100;
Constant DONE_INIS = 4;
Constant RELS_SYMMETRIC = 32768;
Constant RELS_EQUIVALENCE = 16384;
Constant RELS_X_UNIQUE = 8192;
Constant RELS_Y_UNIQUE = 4096;
Constant RELS_TEST = 2048;
Constant RELS_ASSERT_TRUE = 1024;
Constant RELS_ASSERT_FALSE = 512;
Constant RELS_SHOW = 256;
Constant RELS_ROUTE_FIND = 128;
Constant RELS_ROUTE_FIND_COUNT = 64;
Constant RELS_LOOKUP_ANY = 8;
Constant RELS_LOOKUP_ALL_X = 4;
Constant RELS_LOOKUP_ALL_Y = 2;
Constant RELS_LIST = 1;
Constant TTF_sum = 3584;
Constant REL_BLOCK_HEADER = 101515264;
Constant relation_id_U1 = 105;
Constant relation_id_U2 = 106;
Constant relation_id_U3 = 107;
Constant relation_id_U4 = 108;
Constant relation_id_U5 = 109;
Constant relation_id_U6 = 110;
Constant relation_id_U7 = 111;
Constant relation_id_U8 = 112;
Constant relation_id_U9 = 113;
Constant relation_id_U10 = 114;
Constant relation_id_U11 = 115;
Constant relation_id_U12 = 116;
Constant relation_id_U13 = 117;
Constant relation_id_U14 = 118;
Constant relation_id_U15 = 119;
Constant relation_id_U16 = 120;
Constant kind_ref_U1 = 561;
Constant OBJECT_TY = 24;
Constant ICOUNT_OBJECT = 30;
Constant kind_ref_U2 = 561;
Constant SCENE_TY = 25;
Constant ICOUNT_SCENE = 1;
Constant kind_ref_U3 = 561;
Constant NUMBER_TY = 26;
Constant call_U8 = DecimalNumber;
Constant kind_ref_U4 = 561;
Constant REAL_NUMBER_TY = 27;
Constant call_U10 = REAL_NUMBER_TY_Say;
Constant kind_ref_U5 = 561;
Constant TRUTH_STATE_TY = 28;
Constant kind_ref_U6 = 561;
Constant TEXT_TY = 29;
Constant kind_ref_U7 = 561;
Constant SNIPPET_TY = 30;
Constant kind_ref_U8 = 561;
Constant UNICODE_CHARACTER_TY = 31;
Constant kind_ref_U9 = 561;
Constant USE_OPTION_TY = 32;
Constant kind_ref_U10 = 561;
Constant RESPONSE_TY = 33;
Constant kind_ref_U11 = 561;
Constant VERB_TY = 34;
Constant kind_ref_U12 = 561;
Constant TABLE_TY = 35;
Constant kind_ref_U13 = 561;
Constant EQUATION_TY = 36;
Constant kind_ref_U14 = 561;
Constant RULEBOOK_OUTCOME_TY = 37;
Constant kind_ref_U15 = 561;
Constant EXTERNAL_FILE_TY = 38;
Constant ICOUNT_EXTERNAL_FILE = 0;
Constant kind_ref_U16 = 561;
Constant DESCRIPTION_OF_ACTION_TY = 39;
Constant kind_ref_U17 = 561;
Constant STORED_ACTION_TY = 40;
Constant kind_ref_U18 = 561;
Constant ACTION_NAME_TY = 41;
Constant kind_ref_U19 = 561;
Constant TIME_TY = 42;
Constant call_U29 = PrintTimeOfDay;
Constant kind_ref_U20 = 561;
Constant FIGURE_NAME_TY = 43;
Constant ICOUNT_FIGURE_NAME = 1;
Constant kind_ref_U21 = 561;
Constant SOUND_NAME_TY = 44;
Constant ICOUNT_SOUND_NAME = 0;
Constant kind_ref_U22 = 561;
Constant UNDERSTANDING_TY = 45;
Constant kind_ref_U23 = 561;
Constant LIST_OF_TY = 46;
Constant kind_ref_U24 = 561;
Constant VALUE_TY = 47;
Constant kind_ref_U25 = 561;
Constant STORED_VALUE_TY = 48;
Constant kind_ref_U26 = 561;
Constant SAYABLE_VALUE_TY = 49;
Constant kind_ref_U27 = 561;
Constant UNDERSTANDABLE_VALUE_TY = 50;
Constant kind_ref_U28 = 561;
Constant ARITHMETIC_VALUE_TY = 51;
Constant kind_ref_U29 = 561;
Constant REAL_ARITHMETIC_VALUE_TY = 52;
Constant kind_ref_U30 = 561;
Constant ENUMERATED_VALUE_TY = 53;
Constant kind_ref_U31 = 561;
Constant POINTER_VALUE_TY = 54;
Constant kind_ref_U32 = 561;
Constant PHRASE_TY = 55;
Constant kind_ref_U33 = 561;
Constant VARIABLE_TY = 56;
Constant kind_ref_U34 = 561;
Constant RELATION_TY = 57;
Constant kind_ref_U35 = 561;
Constant RULE_TY = 58;
Constant kind_ref_U36 = 561;
Constant RULEBOOK_TY = 59;
Constant kind_ref_U37 = 561;
Constant ACTIVITY_TY = 60;
Constant kind_ref_U38 = 561;
Constant DESCRIPTION_OF_TY = 61;
Constant kind_ref_U39 = 561;
Constant PROPERTY_TY = 62;
Constant kind_ref_U40 = 561;
Constant TABLE_COLUMN_TY = 63;
Constant kind_ref_U41 = 561;
Constant COMBINATION_TY = 64;
Constant kind_ref_U42 = 561;
Constant NIL_TY = 65;
Constant kind_ref_U43 = 561;
Constant UNKNOWN_TY = 66;
Constant kind_ref_U44 = 561;
Constant VOID_TY = 67;
Constant kind_ref_U45 = 561;
Constant TUPLE_ENTRY_TY = 68;
Constant property_id_U1 = 41;
Constant property_id_U2 = 42;
Constant property_id_U3 = 43;
Constant property_id_U4 = 44;
Constant property_id_U5 = 45;
Constant property_id_U6 = 46;
Constant property_id_U7 = 47;
Constant property_id_U8 = 48;
Constant property_id_U9 = 49;
Constant property_id_U10 = 50;
Constant property_id_U11 = 51;
Constant property_id_U12 = 52;
Constant property_id_U13 = 53;
Constant property_id_U14 = 54;
Constant property_id_U15 = 55;
Constant property_id_U16 = 56;
Constant property_id_U17 = 57;
Constant property_id_U18 = 58;
Constant property_id_U19 = 59;
Constant property_id_U20 = 60;
Constant property_id_U21 = 61;
Constant property_id_U22 = 62;
Constant property_id_U23 = 63;
Constant property_id_U24 = 64;
Constant property_id_U25 = 65;
Constant property_id_U26 = 66;
Constant property_id_U27 = 67;
Constant property_id_U28 = 68;
Constant property_id_U29 = 69;
Constant property_id_U30 = 70;
Constant property_id_U31 = 71;
Constant property_id_U32 = 72;
Constant property_id_U33 = 73;
Constant property_id_U34 = 74;
Constant property_id_U35 = 75;
Constant property_id_U36 = 76;
Constant property_id_U37 = 77;
Constant property_id_U38 = 78;
Constant property_id_U39 = 79;
Constant property_id_U40 = 80;
Constant property_id_U41 = 81;
Constant property_id_U42 = 82;
Constant property_id_U43 = 83;
Constant property_id_U44 = 84;
Constant property_id_U45 = 85;
Constant property_id_U46 = 86;
Constant property_id_U47 = 87;
Constant property_id_U48 = 88;
Constant property_id_U49 = 89;
Constant property_id_U50 = 90;
Constant property_id_U51 = 91;
Constant property_id_U52 = 92;
Constant property_id_U53 = 93;
Constant property_id_U54 = 94;
Constant property_id_U55 = 95;
Constant CCOUNT_ACTION_NAME = 100;
Constant AD_RECORDS = 100;
Constant NO_PAST_TENSE_CONDS = 0;
Constant NO_PAST_TENSE_ACTIONS = 0;
Constant BASE_KIND_HWM = 69;
Constant RUCKSACK_CLASS = K15_player_s_holdall;
Constant NO_EXTERNAL_FILES = 0;
Constant CCOUNT_PROPERTY = 171;
Constant CCOUNT_BINARY_PREDICATE = 121;
Constant NUMBER_RULEBOOKS_CREATED = 362;
Constant NO_RESPONSES = 393;
Constant RANKING_TABLE = 0;
Constant NO_USE_OPTIONS = 28;
#ifndef WORDSIZE;
Constant WORDSIZE = 4;
#endif;
Constant NULL = -1;
Constant WORD_HIGHBIT = -2147483648;
Constant WORD_NEXTTOHIGHBIT = 1073741824;
Constant IMPROBABLE_VALUE = -559034863;
Constant MAX_POSITIVE_NUMBER = 2147483647;
Constant MIN_NEGATIVE_NUMBER = -2147483648;
#ifndef TARGET_GLULX;
Constant TARGET_GLULX = 1;
#endif;
#ifndef DEBUG;
Constant DEBUG = 1;
#endif;
Constant use_option_id_U1 = 0;
Constant use_option_id_U2 = 1;
Constant use_option_id_U3 = 2;
Constant use_option_id_U4 = 3;
Constant use_option_id_U5 = 4;
Constant use_option_id_U6 = 5;
Constant use_option_id_U7 = 6;
Constant use_option_id_U8 = 7;
Constant use_option_id_U9 = 8;
Constant use_option_id_U10 = 9;
Constant use_option_id_U11 = 10;
Constant use_option_id_U12 = 11;
Constant use_option_id_U13 = 12;
Constant use_option_id_U14 = 13;
Constant use_option_id_U15 = 14;
Constant use_option_id_U16 = 15;
Constant use_option_id_U17 = 16;
Constant property_id_U56 = 0;
Constant property_id_U57 = 1;
Constant property_id_U58 = 2;
Constant property_id_U59 = 3;
Constant property_id_U60 = 4;
Constant property_id_U61 = 5;
Constant property_id_U62 = 6;
Constant property_id_U63 = 7;
Constant property_id_U64 = 8;
Constant rulebook_id_U1 = 0;
Constant rulebook_id_U2 = 1;
Constant call_U114 = EMPTY_RULEBOOK;
Constant rulebook_id_U3 = 2;
Constant rulebook_id_U4 = 3;
Constant call_U116 = EMPTY_RULEBOOK;
Constant rulebook_id_U5 = 4;
Constant activity_id_U1 = 0;
Constant var_id_U1 = 10000;
Constant rulebook_id_U6 = 5;
Constant rulebook_id_U7 = 6;
Constant call_U119 = EMPTY_RULEBOOK;
Constant rulebook_id_U8 = 7;
Constant activity_id_U2 = 1;
Constant var_id_U2 = 10001;
Constant call_U120 = EMPTY_RULEBOOK;
Constant rulebook_id_U9 = 8;
Constant rulebook_id_U10 = 9;
Constant call_U122 = EMPTY_RULEBOOK;
Constant rulebook_id_U11 = 10;
Constant activity_id_U3 = 2;
Constant var_id_U3 = 10002;
Constant kind_ref_U46 = 561;
Constant WEAK_ID_47 = 2;
Constant ICOUNT_NATURAL_LANGUAGE = 6;
Constant extension_id_U1 = 1;
Constant anchor_U1 = 1105;
Constant anchor_U2 = 1105;
Constant anchor_U3 = 1105;
Constant relation_id_U17 = 0;
Constant relation_id_U18 = 1;
Constant relation_id_U19 = 2;
Constant relation_id_U20 = 3;
Constant relation_id_U21 = 4;
Constant relation_id_U22 = 5;
Constant kind_ref_U47 = 561;
Constant WEAK_ID_48 = 19;
Constant ICOUNT_GRAMMATICAL_TENSE = 5;
Constant kind_ref_U48 = 561;
Constant WEAK_ID_49 = 20;
Constant ICOUNT_NARRATIVE_VIEWPOINT = 6;
Constant kind_ref_U49 = 561;
Constant WEAK_ID_50 = 21;
Constant ICOUNT_GRAMMATICAL_CASE = 2;
Constant kind_ref_U50 = 561;
Constant WEAK_ID_51 = 22;
Constant ICOUNT_GRAMMATICAL_GENDER = 3;
Constant property_id_U65 = 40;
Constant extension_id_U2 = 2;
Constant relation_id_U23 = 71;
Constant property_id_U66 = 9;
Constant property_id_U67 = 10;
Constant property_id_U68 = 11;
Constant property_id_U69 = 12;
Constant property_id_U70 = 13;
Constant property_id_U71 = 14;
Constant property_id_U72 = 15;
Constant property_id_U73 = 16;
Constant property_id_U74 = 17;
Constant property_id_U75 = 18;
Constant property_id_U76 = 19;
Constant property_id_U77 = 20;
Constant property_id_U78 = 21;
Constant property_id_U79 = 22;
Constant property_id_U80 = 23;
Constant property_id_U81 = 24;
Constant property_id_U82 = 25;
Constant property_id_U83 = 26;
Constant property_id_U84 = 27;
Constant property_id_U85 = 28;
Constant property_id_U86 = 29;
Constant property_id_U87 = 30;
Constant property_id_U88 = 31;
Constant property_id_U89 = 32;
Constant property_id_U90 = 33;
Constant property_id_U91 = 34;
Constant property_id_U92 = 35;
Constant property_id_U93 = 36;
Constant property_id_U94 = 37;
Constant property_id_U95 = 38;
Constant property_id_U96 = 39;
Constant table_column_id_U1 = 100;
Constant table_column_id_U2 = 101;
Constant table_column_id_U3 = 102;
Constant table_column_id_U4 = 103;
Constant table_column_id_U5 = 104;
Constant table_column_id_U6 = 105;
Constant table_column_id_U7 = 106;
Constant use_option_id_U18 = 17;
Constant use_option_id_U19 = 18;
Constant use_option_id_U20 = 19;
Constant use_option_id_U21 = 20;
Constant use_option_id_U22 = 21;
Constant use_option_id_U23 = 22;
Constant use_option_id_U24 = 23;
Constant use_option_id_U25 = 24;
Constant use_option_id_U26 = 25;
Constant use_option_id_U27 = 26;
Constant use_option_id_U28 = 27;
Constant relation_id_U24 = 6;
Constant relation_id_U25 = 7;
Constant relation_id_U26 = 8;
Constant relation_id_U27 = 9;
Constant relation_id_U28 = 10;
Constant relation_id_U29 = 11;
Constant relation_id_U30 = 12;
Constant relation_id_U31 = 13;
Constant relation_id_U32 = 14;
Constant relation_id_U33 = 15;
Constant relation_id_U34 = 16;
Constant relation_id_U35 = 17;
Constant relation_id_U36 = 18;
Constant relation_id_U37 = 19;
Constant relation_id_U38 = 20;
Constant relation_id_U39 = 21;
Constant relation_id_U40 = 22;
Constant relation_id_U41 = 23;
Constant relation_id_U42 = 24;
Constant relation_id_U43 = 25;
Constant relation_id_U44 = 26;
Constant relation_id_U45 = 27;
Constant relation_id_U46 = 28;
Constant relation_id_U47 = 29;
Constant relation_id_U48 = 30;
Constant relation_id_U49 = 31;
Constant relation_id_U50 = 32;
Constant relation_id_U51 = 33;
Constant relation_id_U52 = 34;
Constant relation_id_U53 = 35;
Constant relation_id_U54 = 36;
Constant relation_id_U55 = 37;
Constant relation_id_U56 = 38;
Constant relation_id_U57 = 39;
Constant relation_id_U58 = 40;
Constant relation_id_U59 = 41;
Constant relation_id_U60 = 42;
Constant relation_id_U61 = 43;
Constant relation_id_U62 = 44;
Constant relation_id_U63 = 45;
Constant relation_id_U64 = 46;
Constant relation_id_U65 = 47;
Constant relation_id_U66 = 48;
Constant relation_id_U67 = 49;
Constant relation_id_U68 = 50;
Constant relation_id_U69 = 51;
Constant relation_id_U70 = 52;
Constant relation_id_U71 = 53;
Constant relation_id_U72 = 54;
Constant relation_id_U73 = 55;
Constant relation_id_U74 = 56;
Constant relation_id_U75 = 57;
Constant relation_id_U76 = 58;
Constant relation_id_U77 = 59;
Constant relation_id_U78 = 60;
Constant relation_id_U79 = 61;
Constant relation_id_U80 = 62;
Constant relation_id_U81 = 63;
Constant relation_id_U82 = 64;
Constant relation_id_U83 = 65;
Constant relation_id_U84 = 66;
Constant relation_id_U85 = 67;
Constant relation_id_U86 = 68;
Constant relation_id_U87 = 69;
Constant relation_id_U88 = 70;
Constant rulebook_id_U12 = 11;
Constant rulebook_id_U13 = 12;
Constant call_U357 = EMPTY_RULEBOOK;
Constant rulebook_id_U14 = 13;
Constant call_U358 = EMPTY_RULEBOOK;
Constant rulebook_id_U15 = 14;
Constant rulebook_id_U16 = 15;
Constant call_U360 = EMPTY_RULEBOOK;
Constant rulebook_id_U17 = 16;
Constant call_U361 = EMPTY_RULEBOOK;
Constant rulebook_id_U18 = 17;
Constant rulebook_id_U19 = 18;
Constant rulebook_id_U20 = 19;
Constant rulebook_id_U21 = 20;
Constant rulebook_id_U22 = 21;
Constant rulebook_id_U23 = 22;
Constant rulebook_id_U24 = 23;
Constant rulebook_id_U25 = 24;
Constant rulebook_id_U26 = 25;
Constant call_U372 = EMPTY_RULEBOOK;
Constant rulebook_id_U27 = 26;
Constant call_U373 = EMPTY_RULEBOOK;
Constant rulebook_id_U28 = 27;
Constant call_U374 = EMPTY_RULEBOOK;
Constant rulebook_id_U29 = 28;
Constant rulebook_id_U30 = 29;
Constant call_U376 = EMPTY_RULEBOOK;
Constant rulebook_id_U31 = 30;
Constant call_U377 = EMPTY_RULEBOOK;
Constant rulebook_id_U32 = 31;
Constant call_U378 = EMPTY_RULEBOOK;
Constant rulebook_id_U33 = 32;
Constant call_U379 = EMPTY_RULEBOOK;
Constant rulebook_id_U34 = 33;
Constant rulebook_id_U35 = 34;
Constant call_U381 = EMPTY_RULEBOOK;
Constant rulebook_id_U36 = 35;
Constant call_U382 = EMPTY_RULEBOOK;
Constant rulebook_id_U37 = 36;
Constant call_U383 = EMPTY_RULEBOOK;
Constant rulebook_id_U38 = 37;
Constant call_U384 = EMPTY_RULEBOOK;
Constant rulebook_id_U39 = 38;
Constant rulebook_id_U40 = 39;
Constant call_U386 = EMPTY_RULEBOOK;
Constant rulebook_id_U41 = 40;
Constant activity_id_U4 = 3;
Constant var_id_U4 = 10003;
Constant call_U387 = EMPTY_RULEBOOK;
Constant rulebook_id_U42 = 41;
Constant rulebook_id_U43 = 42;
Constant call_U389 = EMPTY_RULEBOOK;
Constant rulebook_id_U44 = 43;
Constant activity_id_U5 = 4;
Constant var_id_U5 = 10004;
Constant call_U390 = EMPTY_RULEBOOK;
Constant rulebook_id_U45 = 44;
Constant call_U391 = EMPTY_RULEBOOK;
Constant rulebook_id_U46 = 45;
Constant call_U392 = EMPTY_RULEBOOK;
Constant rulebook_id_U47 = 46;
Constant activity_id_U6 = 5;
Constant var_id_U6 = 10005;
Constant call_U393 = EMPTY_RULEBOOK;
Constant rulebook_id_U48 = 47;
Constant call_U394 = EMPTY_RULEBOOK;
Constant rulebook_id_U49 = 48;
Constant call_U395 = EMPTY_RULEBOOK;
Constant rulebook_id_U50 = 49;
Constant activity_id_U7 = 6;
Constant var_id_U7 = 10006;
Constant call_U396 = EMPTY_RULEBOOK;
Constant rulebook_id_U51 = 50;
Constant rulebook_id_U52 = 51;
Constant call_U398 = EMPTY_RULEBOOK;
Constant rulebook_id_U53 = 52;
Constant activity_id_U8 = 7;
Constant var_id_U8 = 10007;
Constant call_U399 = EMPTY_RULEBOOK;
Constant rulebook_id_U54 = 53;
Constant call_U400 = EMPTY_RULEBOOK;
Constant rulebook_id_U55 = 54;
Constant call_U401 = EMPTY_RULEBOOK;
Constant rulebook_id_U56 = 55;
Constant activity_id_U9 = 8;
Constant var_id_U9 = 10008;
Constant call_U402 = EMPTY_RULEBOOK;
Constant rulebook_id_U57 = 56;
Constant call_U403 = EMPTY_RULEBOOK;
Constant rulebook_id_U58 = 57;
Constant call_U404 = EMPTY_RULEBOOK;
Constant rulebook_id_U59 = 58;
Constant activity_id_U10 = 9;
Constant var_id_U10 = 10009;
Constant call_U405 = EMPTY_RULEBOOK;
Constant rulebook_id_U60 = 59;
Constant call_U406 = EMPTY_RULEBOOK;
Constant rulebook_id_U61 = 60;
Constant call_U407 = EMPTY_RULEBOOK;
Constant rulebook_id_U62 = 61;
Constant activity_id_U11 = 10;
Constant var_id_U11 = 10010;
Constant call_U408 = EMPTY_RULEBOOK;
Constant rulebook_id_U63 = 62;
Constant call_U409 = EMPTY_RULEBOOK;
Constant rulebook_id_U64 = 63;
Constant call_U410 = EMPTY_RULEBOOK;
Constant rulebook_id_U65 = 64;
Constant activity_id_U12 = 11;
Constant var_id_U12 = 10011;
Constant call_U411 = EMPTY_RULEBOOK;
Constant rulebook_id_U66 = 65;
Constant call_U412 = EMPTY_RULEBOOK;
Constant rulebook_id_U67 = 66;
Constant call_U413 = EMPTY_RULEBOOK;
Constant rulebook_id_U68 = 67;
Constant activity_id_U13 = 12;
Constant var_id_U13 = 10012;
Constant call_U414 = EMPTY_RULEBOOK;
Constant rulebook_id_U69 = 68;
Constant call_U415 = EMPTY_RULEBOOK;
Constant rulebook_id_U70 = 69;
Constant call_U416 = EMPTY_RULEBOOK;
Constant rulebook_id_U71 = 70;
Constant activity_id_U14 = 13;
Constant var_id_U14 = 10013;
Constant call_U417 = EMPTY_RULEBOOK;
Constant rulebook_id_U72 = 71;
Constant rulebook_id_U73 = 72;
Constant call_U419 = EMPTY_RULEBOOK;
Constant rulebook_id_U74 = 73;
Constant activity_id_U15 = 14;
Constant var_id_U15 = 10014;
Constant call_U420 = EMPTY_RULEBOOK;
Constant rulebook_id_U75 = 74;
Constant call_U421 = EMPTY_RULEBOOK;
Constant rulebook_id_U76 = 75;
Constant call_U422 = EMPTY_RULEBOOK;
Constant rulebook_id_U77 = 76;
Constant activity_id_U16 = 15;
Constant var_id_U16 = 10015;
Constant call_U423 = EMPTY_RULEBOOK;
Constant rulebook_id_U78 = 77;
Constant call_U424 = EMPTY_RULEBOOK;
Constant rulebook_id_U79 = 78;
Constant call_U425 = EMPTY_RULEBOOK;
Constant rulebook_id_U80 = 79;
Constant activity_id_U17 = 16;
Constant var_id_U17 = 10016;
Constant call_U426 = EMPTY_RULEBOOK;
Constant rulebook_id_U81 = 80;
Constant call_U427 = EMPTY_RULEBOOK;
Constant rulebook_id_U82 = 81;
Constant call_U428 = EMPTY_RULEBOOK;
Constant rulebook_id_U83 = 82;
Constant activity_id_U18 = 17;
Constant var_id_U18 = 10017;
Constant call_U429 = EMPTY_RULEBOOK;
Constant rulebook_id_U84 = 83;
Constant call_U430 = EMPTY_RULEBOOK;
Constant rulebook_id_U85 = 84;
Constant call_U431 = EMPTY_RULEBOOK;
Constant rulebook_id_U86 = 85;
Constant activity_id_U19 = 18;
Constant var_id_U19 = 10018;
Constant call_U432 = EMPTY_RULEBOOK;
Constant rulebook_id_U87 = 86;
Constant call_U433 = EMPTY_RULEBOOK;
Constant rulebook_id_U88 = 87;
Constant call_U434 = EMPTY_RULEBOOK;
Constant rulebook_id_U89 = 88;
Constant activity_id_U20 = 19;
Constant var_id_U20 = 10019;
Constant call_U435 = EMPTY_RULEBOOK;
Constant rulebook_id_U90 = 89;
Constant call_U436 = EMPTY_RULEBOOK;
Constant rulebook_id_U91 = 90;
Constant call_U437 = EMPTY_RULEBOOK;
Constant rulebook_id_U92 = 91;
Constant activity_id_U21 = 20;
Constant var_id_U21 = 10020;
Constant call_U438 = EMPTY_RULEBOOK;
Constant rulebook_id_U93 = 92;
Constant rulebook_id_U94 = 93;
Constant call_U440 = EMPTY_RULEBOOK;
Constant rulebook_id_U95 = 94;
Constant activity_id_U22 = 21;
Constant var_id_U22 = 10021;
Constant call_U441 = EMPTY_RULEBOOK;
Constant rulebook_id_U96 = 95;
Constant call_U442 = EMPTY_RULEBOOK;
Constant rulebook_id_U97 = 96;
Constant call_U443 = EMPTY_RULEBOOK;
Constant rulebook_id_U98 = 97;
Constant activity_id_U23 = 22;
Constant var_id_U23 = 10022;
Constant call_U444 = EMPTY_RULEBOOK;
Constant rulebook_id_U99 = 98;
Constant call_U445 = EMPTY_RULEBOOK;
Constant rulebook_id_U100 = 99;
Constant call_U446 = EMPTY_RULEBOOK;
Constant rulebook_id_U101 = 100;
Constant activity_id_U24 = 23;
Constant var_id_U24 = 10023;
Constant call_U447 = EMPTY_RULEBOOK;
Constant rulebook_id_U102 = 101;
Constant call_U448 = EMPTY_RULEBOOK;
Constant rulebook_id_U103 = 102;
Constant call_U449 = EMPTY_RULEBOOK;
Constant rulebook_id_U104 = 103;
Constant activity_id_U25 = 24;
Constant var_id_U25 = 10024;
Constant call_U450 = EMPTY_RULEBOOK;
Constant rulebook_id_U105 = 104;
Constant rulebook_id_U106 = 105;
Constant call_U452 = EMPTY_RULEBOOK;
Constant rulebook_id_U107 = 106;
Constant activity_id_U26 = 25;
Constant var_id_U26 = 10025;
Constant call_U453 = EMPTY_RULEBOOK;
Constant rulebook_id_U108 = 107;
Constant call_U454 = EMPTY_RULEBOOK;
Constant rulebook_id_U109 = 108;
Constant call_U455 = EMPTY_RULEBOOK;
Constant rulebook_id_U110 = 109;
Constant activity_id_U27 = 26;
Constant var_id_U27 = 10026;
Constant call_U456 = EMPTY_RULEBOOK;
Constant rulebook_id_U111 = 110;
Constant rulebook_id_U112 = 111;
Constant call_U458 = EMPTY_RULEBOOK;
Constant rulebook_id_U113 = 112;
Constant activity_id_U28 = 27;
Constant var_id_U28 = 10027;
Constant call_U459 = EMPTY_RULEBOOK;
Constant rulebook_id_U114 = 113;
Constant call_U460 = EMPTY_RULEBOOK;
Constant rulebook_id_U115 = 114;
Constant call_U461 = EMPTY_RULEBOOK;
Constant rulebook_id_U116 = 115;
Constant activity_id_U29 = 28;
Constant var_id_U29 = 10028;
Constant call_U462 = EMPTY_RULEBOOK;
Constant rulebook_id_U117 = 116;
Constant rulebook_id_U118 = 117;
Constant call_U464 = EMPTY_RULEBOOK;
Constant rulebook_id_U119 = 118;
Constant activity_id_U30 = 29;
Constant var_id_U30 = 10029;
Constant rulebook_id_U120 = 119;
Constant rulebook_id_U121 = 120;
Constant call_U467 = EMPTY_RULEBOOK;
Constant rulebook_id_U122 = 121;
Constant activity_id_U31 = 30;
Constant var_id_U31 = 10030;
Constant rulebook_id_U123 = 122;
Constant rulebook_id_U124 = 123;
Constant call_U470 = EMPTY_RULEBOOK;
Constant rulebook_id_U125 = 124;
Constant activity_id_U32 = 31;
Constant var_id_U32 = 10031;
Constant call_U471 = EMPTY_RULEBOOK;
Constant rulebook_id_U126 = 125;
Constant rulebook_id_U127 = 126;
Constant call_U473 = EMPTY_RULEBOOK;
Constant rulebook_id_U128 = 127;
Constant activity_id_U33 = 32;
Constant var_id_U33 = 10032;
Constant call_U474 = EMPTY_RULEBOOK;
Constant rulebook_id_U129 = 128;
Constant rulebook_id_U130 = 129;
Constant call_U476 = EMPTY_RULEBOOK;
Constant rulebook_id_U131 = 130;
Constant activity_id_U34 = 33;
Constant var_id_U34 = 10033;
Constant call_U477 = EMPTY_RULEBOOK;
Constant rulebook_id_U132 = 131;
Constant rulebook_id_U133 = 132;
Constant rulebook_id_U134 = 133;
Constant action_id_U1 = 0;
Constant var_id_U35 = 20000;
Constant rulebook_id_U135 = 134;
Constant rulebook_id_U136 = 135;
Constant rulebook_id_U137 = 136;
Constant action_id_U2 = 1;
Constant var_id_U36 = 20001;
Constant rulebook_id_U138 = 137;
Constant call_U484 = EMPTY_RULEBOOK;
Constant rulebook_id_U139 = 138;
Constant call_U485 = EMPTY_RULEBOOK;
Constant rulebook_id_U140 = 139;
Constant action_id_U3 = 2;
Constant var_id_U37 = 20002;
Constant rulebook_id_U141 = 140;
Constant rulebook_id_U142 = 141;
Constant rulebook_id_U143 = 142;
Constant action_id_U4 = 3;
Constant var_id_U38 = 20003;
Constant rulebook_id_U144 = 143;
Constant rulebook_id_U145 = 144;
Constant rulebook_id_U146 = 145;
Constant action_id_U5 = 4;
Constant var_id_U39 = 20004;
Constant rulebook_id_U147 = 146;
Constant rulebook_id_U148 = 147;
Constant rulebook_id_U149 = 148;
Constant action_id_U6 = 5;
Constant var_id_U40 = 20005;
Constant rulebook_id_U150 = 149;
Constant rulebook_id_U151 = 150;
Constant rulebook_id_U152 = 151;
Constant action_id_U7 = 6;
Constant var_id_U41 = 20006;
Constant rulebook_id_U153 = 152;
Constant rulebook_id_U154 = 153;
Constant rulebook_id_U155 = 154;
Constant action_id_U8 = 7;
Constant var_id_U42 = 20007;
Constant rulebook_id_U156 = 155;
Constant rulebook_id_U157 = 156;
Constant rulebook_id_U158 = 157;
Constant action_id_U9 = 8;
Constant var_id_U43 = 20008;
Constant rulebook_id_U159 = 158;
Constant rulebook_id_U160 = 159;
Constant rulebook_id_U161 = 160;
Constant action_id_U10 = 9;
Constant var_id_U44 = 20009;
Constant rulebook_id_U162 = 161;
Constant rulebook_id_U163 = 162;
Constant rulebook_id_U164 = 163;
Constant action_id_U11 = 10;
Constant var_id_U45 = 20010;
Constant call_U512 = EMPTY_RULEBOOK;
Constant rulebook_id_U165 = 164;
Constant rulebook_id_U166 = 165;
Constant rulebook_id_U167 = 166;
Constant action_id_U12 = 11;
Constant var_id_U46 = 20011;
Constant call_U516 = EMPTY_RULEBOOK;
Constant rulebook_id_U168 = 167;
Constant rulebook_id_U169 = 168;
Constant rulebook_id_U170 = 169;
Constant action_id_U13 = 12;
Constant var_id_U47 = 20012;
Constant call_U520 = EMPTY_RULEBOOK;
Constant rulebook_id_U171 = 170;
Constant rulebook_id_U172 = 171;
Constant rulebook_id_U173 = 172;
Constant action_id_U14 = 13;
Constant var_id_U48 = 20013;
Constant rulebook_id_U174 = 173;
Constant call_U524 = EMPTY_RULEBOOK;
Constant rulebook_id_U175 = 174;
Constant rulebook_id_U176 = 175;
Constant action_id_U15 = 14;
Constant var_id_U49 = 20014;
Constant call_U526 = EMPTY_RULEBOOK;
Constant rulebook_id_U177 = 176;
Constant call_U527 = EMPTY_RULEBOOK;
Constant rulebook_id_U178 = 177;
Constant rulebook_id_U179 = 178;
Constant action_id_U16 = 15;
Constant var_id_U50 = 20015;
Constant rulebook_id_U180 = 179;
Constant rulebook_id_U181 = 180;
Constant rulebook_id_U182 = 181;
Constant action_id_U17 = 16;
Constant var_id_U51 = 20016;
Constant rulebook_id_U183 = 182;
Constant rulebook_id_U184 = 183;
Constant rulebook_id_U185 = 184;
Constant action_id_U18 = 17;
Constant var_id_U52 = 20017;
Constant rulebook_id_U186 = 185;
Constant rulebook_id_U187 = 186;
Constant rulebook_id_U188 = 187;
Constant action_id_U19 = 18;
Constant var_id_U53 = 20018;
Constant rulebook_id_U189 = 188;
Constant rulebook_id_U190 = 189;
Constant rulebook_id_U191 = 190;
Constant action_id_U20 = 19;
Constant var_id_U54 = 20019;
Constant rulebook_id_U192 = 191;
Constant rulebook_id_U193 = 192;
Constant rulebook_id_U194 = 193;
Constant action_id_U21 = 20;
Constant var_id_U55 = 20020;
Constant rulebook_id_U195 = 194;
Constant rulebook_id_U196 = 195;
Constant rulebook_id_U197 = 196;
Constant action_id_U22 = 21;
Constant var_id_U56 = 20021;
Constant rulebook_id_U198 = 197;
Constant rulebook_id_U199 = 198;
Constant rulebook_id_U200 = 199;
Constant action_id_U23 = 22;
Constant var_id_U57 = 20022;
Constant rulebook_id_U201 = 200;
Constant rulebook_id_U202 = 201;
Constant rulebook_id_U203 = 202;
Constant action_id_U24 = 23;
Constant var_id_U58 = 20023;
Constant rulebook_id_U204 = 203;
Constant rulebook_id_U205 = 204;
Constant rulebook_id_U206 = 205;
Constant action_id_U25 = 24;
Constant var_id_U59 = 20024;
Constant rulebook_id_U207 = 206;
Constant call_U557 = EMPTY_RULEBOOK;
Constant rulebook_id_U208 = 207;
Constant call_U558 = EMPTY_RULEBOOK;
Constant rulebook_id_U209 = 208;
Constant action_id_U26 = 25;
Constant var_id_U60 = 20025;
Constant rulebook_id_U210 = 209;
Constant call_U560 = EMPTY_RULEBOOK;
Constant rulebook_id_U211 = 210;
Constant call_U561 = EMPTY_RULEBOOK;
Constant rulebook_id_U212 = 211;
Constant action_id_U27 = 26;
Constant var_id_U61 = 20026;
Constant rulebook_id_U213 = 212;
Constant call_U563 = EMPTY_RULEBOOK;
Constant rulebook_id_U214 = 213;
Constant call_U564 = EMPTY_RULEBOOK;
Constant rulebook_id_U215 = 214;
Constant action_id_U28 = 27;
Constant var_id_U62 = 20027;
Constant rulebook_id_U216 = 215;
Constant call_U566 = EMPTY_RULEBOOK;
Constant rulebook_id_U217 = 216;
Constant call_U567 = EMPTY_RULEBOOK;
Constant rulebook_id_U218 = 217;
Constant action_id_U29 = 28;
Constant var_id_U63 = 20028;
Constant rulebook_id_U219 = 218;
Constant call_U569 = EMPTY_RULEBOOK;
Constant rulebook_id_U220 = 219;
Constant call_U570 = EMPTY_RULEBOOK;
Constant rulebook_id_U221 = 220;
Constant action_id_U30 = 29;
Constant var_id_U64 = 20029;
Constant call_U571 = EMPTY_RULEBOOK;
Constant rulebook_id_U222 = 221;
Constant call_U572 = EMPTY_RULEBOOK;
Constant rulebook_id_U223 = 222;
Constant rulebook_id_U224 = 223;
Constant action_id_U31 = 30;
Constant var_id_U65 = 20030;
Constant rulebook_id_U225 = 224;
Constant call_U575 = EMPTY_RULEBOOK;
Constant rulebook_id_U226 = 225;
Constant rulebook_id_U227 = 226;
Constant action_id_U32 = 31;
Constant var_id_U66 = 20031;
Constant call_U577 = EMPTY_RULEBOOK;
Constant rulebook_id_U228 = 227;
Constant call_U578 = EMPTY_RULEBOOK;
Constant rulebook_id_U229 = 228;
Constant rulebook_id_U230 = 229;
Constant action_id_U33 = 32;
Constant var_id_U67 = 20032;
Constant rulebook_id_U231 = 230;
Constant call_U581 = EMPTY_RULEBOOK;
Constant rulebook_id_U232 = 231;
Constant call_U582 = EMPTY_RULEBOOK;
Constant rulebook_id_U233 = 232;
Constant action_id_U34 = 33;
Constant var_id_U68 = 20033;
Constant call_U583 = EMPTY_RULEBOOK;
Constant rulebook_id_U234 = 233;
Constant call_U584 = EMPTY_RULEBOOK;
Constant rulebook_id_U235 = 234;
Constant rulebook_id_U236 = 235;
Constant action_id_U35 = 34;
Constant var_id_U69 = 20034;
Constant call_U586 = EMPTY_RULEBOOK;
Constant rulebook_id_U237 = 236;
Constant call_U587 = EMPTY_RULEBOOK;
Constant rulebook_id_U238 = 237;
Constant rulebook_id_U239 = 238;
Constant action_id_U36 = 35;
Constant var_id_U70 = 20035;
Constant rulebook_id_U240 = 239;
Constant call_U590 = EMPTY_RULEBOOK;
Constant rulebook_id_U241 = 240;
Constant rulebook_id_U242 = 241;
Constant action_id_U37 = 36;
Constant var_id_U71 = 20036;
Constant rulebook_id_U243 = 242;
Constant call_U593 = EMPTY_RULEBOOK;
Constant rulebook_id_U244 = 243;
Constant rulebook_id_U245 = 244;
Constant action_id_U38 = 37;
Constant var_id_U72 = 20037;
Constant rulebook_id_U246 = 245;
Constant call_U596 = EMPTY_RULEBOOK;
Constant rulebook_id_U247 = 246;
Constant rulebook_id_U248 = 247;
Constant action_id_U39 = 38;
Constant var_id_U73 = 20038;
Constant rulebook_id_U249 = 248;
Constant call_U599 = EMPTY_RULEBOOK;
Constant rulebook_id_U250 = 249;
Constant rulebook_id_U251 = 250;
Constant action_id_U40 = 39;
Constant var_id_U74 = 20039;
Constant rulebook_id_U252 = 251;
Constant call_U602 = EMPTY_RULEBOOK;
Constant rulebook_id_U253 = 252;
Constant call_U603 = EMPTY_RULEBOOK;
Constant rulebook_id_U254 = 253;
Constant action_id_U41 = 40;
Constant var_id_U75 = 20040;
Constant rulebook_id_U255 = 254;
Constant call_U605 = EMPTY_RULEBOOK;
Constant rulebook_id_U256 = 255;
Constant rulebook_id_U257 = 256;
Constant action_id_U42 = 41;
Constant var_id_U76 = 20041;
Constant rulebook_id_U258 = 257;
Constant call_U608 = EMPTY_RULEBOOK;
Constant rulebook_id_U259 = 258;
Constant call_U609 = EMPTY_RULEBOOK;
Constant rulebook_id_U260 = 259;
Constant action_id_U43 = 42;
Constant var_id_U77 = 20042;
Constant rulebook_id_U261 = 260;
Constant call_U611 = EMPTY_RULEBOOK;
Constant rulebook_id_U262 = 261;
Constant call_U612 = EMPTY_RULEBOOK;
Constant rulebook_id_U263 = 262;
Constant action_id_U44 = 43;
Constant var_id_U78 = 20043;
Constant rulebook_id_U264 = 263;
Constant call_U614 = EMPTY_RULEBOOK;
Constant rulebook_id_U265 = 264;
Constant call_U615 = EMPTY_RULEBOOK;
Constant rulebook_id_U266 = 265;
Constant action_id_U45 = 44;
Constant var_id_U79 = 20044;
Constant rulebook_id_U267 = 266;
Constant call_U617 = EMPTY_RULEBOOK;
Constant rulebook_id_U268 = 267;
Constant call_U618 = EMPTY_RULEBOOK;
Constant rulebook_id_U269 = 268;
Constant action_id_U46 = 45;
Constant var_id_U80 = 20045;
Constant rulebook_id_U270 = 269;
Constant call_U620 = EMPTY_RULEBOOK;
Constant rulebook_id_U271 = 270;
Constant call_U621 = EMPTY_RULEBOOK;
Constant rulebook_id_U272 = 271;
Constant action_id_U47 = 46;
Constant var_id_U81 = 20046;
Constant call_U622 = EMPTY_RULEBOOK;
Constant rulebook_id_U273 = 272;
Constant call_U623 = EMPTY_RULEBOOK;
Constant rulebook_id_U274 = 273;
Constant rulebook_id_U275 = 274;
Constant action_id_U48 = 47;
Constant var_id_U82 = 20047;
Constant call_U625 = EMPTY_RULEBOOK;
Constant rulebook_id_U276 = 275;
Constant call_U626 = EMPTY_RULEBOOK;
Constant rulebook_id_U277 = 276;
Constant rulebook_id_U278 = 277;
Constant action_id_U49 = 48;
Constant var_id_U83 = 20048;
Constant call_U628 = EMPTY_RULEBOOK;
Constant rulebook_id_U279 = 278;
Constant call_U629 = EMPTY_RULEBOOK;
Constant rulebook_id_U280 = 279;
Constant rulebook_id_U281 = 280;
Constant action_id_U50 = 49;
Constant var_id_U84 = 20049;
Constant rulebook_id_U282 = 281;
Constant call_U632 = EMPTY_RULEBOOK;
Constant rulebook_id_U283 = 282;
Constant call_U633 = EMPTY_RULEBOOK;
Constant rulebook_id_U284 = 283;
Constant action_id_U51 = 50;
Constant var_id_U85 = 20050;
Constant call_U634 = EMPTY_RULEBOOK;
Constant rulebook_id_U285 = 284;
Constant call_U635 = EMPTY_RULEBOOK;
Constant rulebook_id_U286 = 285;
Constant rulebook_id_U287 = 286;
Constant action_id_U52 = 51;
Constant var_id_U86 = 20051;
Constant rulebook_id_U288 = 287;
Constant call_U638 = EMPTY_RULEBOOK;
Constant rulebook_id_U289 = 288;
Constant call_U639 = EMPTY_RULEBOOK;
Constant rulebook_id_U290 = 289;
Constant action_id_U53 = 52;
Constant var_id_U87 = 20052;
Constant rulebook_id_U291 = 290;
Constant call_U641 = EMPTY_RULEBOOK;
Constant rulebook_id_U292 = 291;
Constant call_U642 = EMPTY_RULEBOOK;
Constant rulebook_id_U293 = 292;
Constant action_id_U54 = 53;
Constant var_id_U88 = 20053;
Constant rulebook_id_U294 = 293;
Constant call_U644 = EMPTY_RULEBOOK;
Constant rulebook_id_U295 = 294;
Constant call_U645 = EMPTY_RULEBOOK;
Constant rulebook_id_U296 = 295;
Constant action_id_U55 = 54;
Constant var_id_U89 = 20054;
Constant rulebook_id_U297 = 296;
Constant call_U647 = EMPTY_RULEBOOK;
Constant rulebook_id_U298 = 297;
Constant call_U648 = EMPTY_RULEBOOK;
Constant rulebook_id_U299 = 298;
Constant action_id_U56 = 55;
Constant var_id_U90 = 20055;
Constant rulebook_id_U300 = 299;
Constant call_U650 = EMPTY_RULEBOOK;
Constant rulebook_id_U301 = 300;
Constant rulebook_id_U302 = 301;
Constant action_id_U57 = 56;
Constant var_id_U91 = 20056;
Constant rulebook_id_U303 = 302;
Constant call_U653 = EMPTY_RULEBOOK;
Constant rulebook_id_U304 = 303;
Constant call_U654 = EMPTY_RULEBOOK;
Constant rulebook_id_U305 = 304;
Constant action_id_U58 = 57;
Constant var_id_U92 = 20057;
Constant call_U655 = EMPTY_RULEBOOK;
Constant rulebook_id_U306 = 305;
Constant call_U656 = EMPTY_RULEBOOK;
Constant rulebook_id_U307 = 306;
Constant rulebook_id_U308 = 307;
Constant action_id_U59 = 58;
Constant var_id_U93 = 20058;
Constant rulebook_id_U309 = 308;
Constant call_U659 = EMPTY_RULEBOOK;
Constant rulebook_id_U310 = 309;
Constant call_U660 = EMPTY_RULEBOOK;
Constant rulebook_id_U311 = 310;
Constant action_id_U60 = 59;
Constant var_id_U94 = 20059;
Constant rulebook_id_U312 = 311;
Constant call_U662 = EMPTY_RULEBOOK;
Constant rulebook_id_U313 = 312;
Constant call_U663 = EMPTY_RULEBOOK;
Constant rulebook_id_U314 = 313;
Constant action_id_U61 = 60;
Constant var_id_U95 = 20060;
Constant rulebook_id_U315 = 314;
Constant call_U665 = EMPTY_RULEBOOK;
Constant rulebook_id_U316 = 315;
Constant call_U666 = EMPTY_RULEBOOK;
Constant rulebook_id_U317 = 316;
Constant action_id_U62 = 61;
Constant var_id_U96 = 20061;
Constant call_U667 = EMPTY_RULEBOOK;
Constant rulebook_id_U318 = 317;
Constant rulebook_id_U319 = 318;
Constant call_U669 = EMPTY_RULEBOOK;
Constant rulebook_id_U320 = 319;
Constant action_id_U63 = 62;
Constant var_id_U97 = 20062;
Constant call_U670 = EMPTY_RULEBOOK;
Constant rulebook_id_U321 = 320;
Constant rulebook_id_U322 = 321;
Constant call_U672 = EMPTY_RULEBOOK;
Constant rulebook_id_U323 = 322;
Constant action_id_U64 = 63;
Constant var_id_U98 = 20063;
Constant call_U673 = EMPTY_RULEBOOK;
Constant rulebook_id_U324 = 323;
Constant rulebook_id_U325 = 324;
Constant call_U675 = EMPTY_RULEBOOK;
Constant rulebook_id_U326 = 325;
Constant action_id_U65 = 64;
Constant var_id_U99 = 20064;
Constant call_U676 = EMPTY_RULEBOOK;
Constant rulebook_id_U327 = 326;
Constant rulebook_id_U328 = 327;
Constant call_U678 = EMPTY_RULEBOOK;
Constant rulebook_id_U329 = 328;
Constant action_id_U66 = 65;
Constant var_id_U100 = 20065;
Constant call_U679 = EMPTY_RULEBOOK;
Constant rulebook_id_U330 = 329;
Constant rulebook_id_U331 = 330;
Constant call_U681 = EMPTY_RULEBOOK;
Constant rulebook_id_U332 = 331;
Constant action_id_U67 = 66;
Constant var_id_U101 = 20066;
Constant call_U682 = EMPTY_RULEBOOK;
Constant rulebook_id_U333 = 332;
Constant rulebook_id_U334 = 333;
Constant call_U684 = EMPTY_RULEBOOK;
Constant rulebook_id_U335 = 334;
Constant action_id_U68 = 67;
Constant var_id_U102 = 20067;
Constant call_U685 = EMPTY_RULEBOOK;
Constant rulebook_id_U336 = 335;
Constant rulebook_id_U337 = 336;
Constant call_U687 = EMPTY_RULEBOOK;
Constant rulebook_id_U338 = 337;
Constant action_id_U69 = 68;
Constant var_id_U103 = 20068;
Constant call_U688 = EMPTY_RULEBOOK;
Constant rulebook_id_U339 = 338;
Constant rulebook_id_U340 = 339;
Constant call_U690 = EMPTY_RULEBOOK;
Constant rulebook_id_U341 = 340;
Constant action_id_U70 = 69;
Constant var_id_U104 = 20069;
Constant call_U691 = EMPTY_RULEBOOK;
Constant rulebook_id_U342 = 341;
Constant rulebook_id_U343 = 342;
Constant call_U693 = EMPTY_RULEBOOK;
Constant rulebook_id_U344 = 343;
Constant action_id_U71 = 70;
Constant var_id_U105 = 20070;
Constant call_U694 = EMPTY_RULEBOOK;
Constant rulebook_id_U345 = 344;
Constant rulebook_id_U346 = 345;
Constant rulebook_id_U347 = 346;
Constant action_id_U72 = 71;
Constant var_id_U106 = 20071;
Constant call_U697 = EMPTY_RULEBOOK;
Constant rulebook_id_U348 = 347;
Constant rulebook_id_U349 = 348;
Constant rulebook_id_U350 = 349;
Constant action_id_U73 = 72;
Constant var_id_U107 = 20072;
Constant call_U700 = EMPTY_RULEBOOK;
Constant rulebook_id_U351 = 350;
Constant rulebook_id_U352 = 351;
Constant rulebook_id_U353 = 352;
Constant action_id_U74 = 73;
Constant var_id_U108 = 20073;
Constant call_U703 = EMPTY_RULEBOOK;
Constant rulebook_id_U354 = 353;
Constant rulebook_id_U355 = 354;
Constant rulebook_id_U356 = 355;
Constant action_id_U75 = 74;
Constant var_id_U109 = 20074;
Constant call_U706 = EMPTY_RULEBOOK;
Constant rulebook_id_U357 = 356;
Constant rulebook_id_U358 = 357;
Constant rulebook_id_U359 = 358;
Constant action_id_U76 = 75;
Constant var_id_U110 = 20075;
Constant call_U709 = EMPTY_RULEBOOK;
Constant rulebook_id_U360 = 359;
Constant rulebook_id_U361 = 360;
Constant call_U711 = EMPTY_RULEBOOK;
Constant rulebook_id_U362 = 361;
Constant action_id_U77 = 76;
Constant var_id_U111 = 20076;
Constant response_id_U1 = 1;
Constant anchor_U4 = 1105;
Constant response_id_U2 = 2;
Constant response_id_U3 = 3;
Constant anchor_U5 = 1105;
Constant response_id_U4 = 4;
Constant anchor_U6 = 1105;
Constant response_id_U5 = 5;
Constant anchor_U7 = 1105;
Constant response_id_U6 = 6;
Constant anchor_U8 = 1105;
Constant response_id_U7 = 7;
Constant anchor_U9 = 1105;
Constant response_id_U8 = 8;
Constant anchor_U10 = 1105;
Constant response_id_U9 = 9;
Constant anchor_U11 = 1105;
Constant response_id_U10 = 10;
Constant anchor_U12 = 1105;
Constant response_id_U11 = 11;
Constant anchor_U13 = 1105;
Constant response_id_U12 = 12;
Constant response_id_U13 = 13;
Constant response_id_U14 = 14;
Constant response_id_U15 = 15;
Constant response_id_U16 = 16;
Constant response_id_U17 = 17;
Constant response_id_U18 = 18;
Constant response_id_U19 = 19;
Constant response_id_U20 = 20;
Constant response_id_U21 = 21;
Constant response_id_U22 = 22;
Constant response_id_U23 = 23;
Constant response_id_U24 = 24;
Constant response_id_U25 = 25;
Constant response_id_U26 = 26;
Constant response_id_U27 = 27;
Constant response_id_U28 = 28;
Constant response_id_U29 = 29;
Constant response_id_U30 = 30;
Constant response_id_U31 = 31;
Constant response_id_U32 = 32;
Constant response_id_U33 = 33;
Constant response_id_U34 = 34;
Constant response_id_U35 = 35;
Constant response_id_U36 = 36;
Constant anchor_U14 = 1105;
Constant response_id_U37 = 37;
Constant response_id_U38 = 38;
Constant response_id_U39 = 39;
Constant response_id_U40 = 40;
Constant response_id_U41 = 41;
Constant response_id_U42 = 42;
Constant response_id_U43 = 43;
Constant response_id_U44 = 44;
Constant response_id_U45 = 45;
Constant response_id_U46 = 46;
Constant response_id_U47 = 47;
Constant anchor_U15 = 1105;
Constant response_id_U48 = 48;
Constant response_id_U49 = 49;
Constant response_id_U50 = 50;
Constant response_id_U51 = 51;
Constant response_id_U52 = 52;
Constant response_id_U53 = 53;
Constant response_id_U54 = 54;
Constant response_id_U55 = 55;
Constant response_id_U56 = 56;
Constant response_id_U57 = 57;
Constant response_id_U58 = 58;
Constant response_id_U59 = 59;
Constant response_id_U60 = 60;
Constant response_id_U61 = 61;
Constant response_id_U62 = 62;
Constant response_id_U63 = 63;
Constant response_id_U64 = 64;
Constant response_id_U65 = 65;
Constant response_id_U66 = 66;
Constant response_id_U67 = 67;
Constant response_id_U68 = 68;
Constant response_id_U69 = 69;
Constant response_id_U70 = 70;
Constant response_id_U71 = 71;
Constant anchor_U16 = 1105;
Constant response_id_U72 = 72;
Constant response_id_U73 = 73;
Constant response_id_U74 = 74;
Constant response_id_U75 = 75;
Constant response_id_U76 = 76;
Constant response_id_U77 = 77;
Constant anchor_U17 = 1105;
Constant response_id_U78 = 78;
Constant anchor_U18 = 1105;
Constant response_id_U79 = 79;
Constant response_id_U80 = 80;
Constant response_id_U81 = 81;
Constant response_id_U82 = 82;
Constant anchor_U19 = 1105;
Constant response_id_U83 = 83;
Constant response_id_U84 = 84;
Constant response_id_U85 = 85;
Constant response_id_U86 = 86;
Constant response_id_U87 = 87;
Constant response_id_U88 = 88;
Constant response_id_U89 = 89;
Constant response_id_U90 = 90;
Constant anchor_U20 = 1105;
Constant response_id_U91 = 91;
Constant anchor_U21 = 1105;
Constant response_id_U92 = 92;
Constant response_id_U93 = 93;
Constant response_id_U94 = 94;
Constant anchor_U22 = 1105;
Constant response_id_U95 = 95;
Constant response_id_U96 = 96;
Constant anchor_U23 = 1105;
Constant response_id_U97 = 97;
Constant response_id_U98 = 98;
Constant response_id_U99 = 99;
Constant anchor_U24 = 1105;
Constant response_id_U100 = 100;
Constant response_id_U101 = 101;
Constant response_id_U102 = 102;
Constant response_id_U103 = 103;
Constant response_id_U104 = 104;
Constant response_id_U105 = 105;
Constant anchor_U25 = 1105;
Constant response_id_U106 = 106;
Constant anchor_U26 = 1105;
Constant response_id_U107 = 107;
Constant response_id_U108 = 108;
Constant anchor_U27 = 1105;
Constant response_id_U109 = 109;
Constant response_id_U110 = 110;
Constant anchor_U28 = 1105;
Constant response_id_U111 = 111;
Constant response_id_U112 = 112;
Constant anchor_U29 = 1105;
Constant response_id_U113 = 113;
Constant response_id_U114 = 114;
Constant anchor_U30 = 1105;
Constant response_id_U115 = 115;
Constant response_id_U116 = 116;
Constant response_id_U117 = 117;
Constant anchor_U31 = 1105;
Constant response_id_U118 = 118;
Constant response_id_U119 = 119;
Constant response_id_U120 = 120;
Constant anchor_U32 = 1105;
Constant response_id_U121 = 121;
Constant response_id_U122 = 122;
Constant response_id_U123 = 123;
Constant response_id_U124 = 124;
Constant response_id_U125 = 125;
Constant anchor_U33 = 1105;
Constant response_id_U126 = 126;
Constant anchor_U34 = 1105;
Constant response_id_U127 = 127;
Constant anchor_U35 = 1105;
Constant response_id_U128 = 128;
Constant anchor_U36 = 1105;
Constant response_id_U129 = 129;
Constant anchor_U37 = 1105;
Constant response_id_U130 = 130;
Constant anchor_U38 = 1105;
Constant response_id_U131 = 131;
Constant response_id_U132 = 132;
Constant response_id_U133 = 133;
Constant response_id_U134 = 134;
Constant anchor_U39 = 1105;
Constant anchor_U40 = 1105;
Constant anchor_U41 = 1105;
Constant anchor_U42 = 1105;
Constant anchor_U43 = 1105;
Constant anchor_U44 = 1105;
Constant anchor_U45 = 1105;
Constant anchor_U46 = 1105;
Constant anchor_U47 = 1105;
Constant anchor_U48 = 1105;
Constant anchor_U49 = 1105;
Constant anchor_U50 = 1105;
Constant anchor_U51 = 1105;
Constant anchor_U52 = 1105;
Constant anchor_U53 = 1105;
Constant response_id_U135 = 135;
Constant anchor_U54 = 1105;
Constant anchor_U55 = 1105;
Constant anchor_U56 = 1105;
Constant anchor_U57 = 1105;
Constant anchor_U58 = 1105;
Constant anchor_U59 = 1105;
Constant anchor_U60 = 1105;
Constant anchor_U61 = 1105;
Constant anchor_U62 = 1105;
Constant anchor_U63 = 1105;
Constant anchor_U64 = 1105;
Constant anchor_U65 = 1105;
Constant anchor_U66 = 1105;
Constant anchor_U67 = 1105;
Constant anchor_U68 = 1105;
Constant anchor_U69 = 1105;
Constant anchor_U70 = 1105;
Constant anchor_U71 = 1105;
Constant anchor_U72 = 1105;
Constant anchor_U73 = 1105;
Constant anchor_U74 = 1105;
Constant anchor_U75 = 1105;
Constant anchor_U76 = 1105;
Constant anchor_U77 = 1105;
Constant anchor_U78 = 1105;
Constant anchor_U79 = 1105;
Constant anchor_U80 = 1105;
Constant anchor_U81 = 1105;
Constant response_id_U136 = 136;
Constant anchor_U82 = 1105;
Constant response_id_U137 = 137;
Constant anchor_U83 = 1105;
Constant response_id_U138 = 138;
Constant response_id_U139 = 139;
Constant anchor_U84 = 1105;
Constant response_id_U140 = 140;
Constant anchor_U85 = 1105;
Constant anchor_U86 = 1105;
Constant anchor_U87 = 1105;
Constant anchor_U88 = 1105;
Constant response_id_U141 = 141;
Constant response_id_U142 = 142;
Constant response_id_U143 = 143;
Constant response_id_U144 = 144;
Constant response_id_U145 = 145;
Constant response_id_U146 = 146;
Constant anchor_U89 = 1105;
Constant anchor_U90 = 1105;
Constant anchor_U91 = 1105;
Constant anchor_U92 = 1105;
Constant anchor_U93 = 1105;
Constant anchor_U94 = 1105;
Constant anchor_U95 = 1105;
Constant response_id_U147 = 147;
Constant anchor_U96 = 1105;
Constant anchor_U97 = 1105;
Constant response_id_U148 = 148;
Constant anchor_U98 = 1105;
Constant response_id_U149 = 149;
Constant anchor_U99 = 1105;
Constant response_id_U150 = 150;
Constant anchor_U100 = 1105;
Constant response_id_U151 = 151;
Constant anchor_U101 = 1105;
Constant response_id_U152 = 152;
Constant anchor_U102 = 1105;
Constant response_id_U153 = 153;
Constant anchor_U103 = 1105;
Constant response_id_U154 = 154;
Constant anchor_U104 = 1105;
Constant response_id_U155 = 155;
Constant anchor_U105 = 1105;
Constant response_id_U156 = 156;
Constant anchor_U106 = 1105;
Constant response_id_U157 = 157;
Constant anchor_U107 = 1105;
Constant response_id_U158 = 158;
Constant anchor_U108 = 1105;
Constant response_id_U159 = 159;
Constant anchor_U109 = 1105;
Constant response_id_U160 = 160;
Constant anchor_U110 = 1105;
Constant response_id_U161 = 161;
Constant anchor_U111 = 1105;
Constant response_id_U162 = 162;
Constant anchor_U112 = 1105;
Constant response_id_U163 = 163;
Constant anchor_U113 = 1105;
Constant response_id_U164 = 164;
Constant anchor_U114 = 1105;
Constant anchor_U115 = 1105;
Constant response_id_U165 = 165;
Constant response_id_U166 = 166;
Constant anchor_U116 = 1105;
Constant response_id_U167 = 167;
Constant anchor_U117 = 1105;
Constant response_id_U168 = 168;
Constant anchor_U118 = 1105;
Constant anchor_U119 = 1105;
Constant response_id_U169 = 169;
Constant anchor_U120 = 1105;
Constant response_id_U170 = 170;
Constant anchor_U121 = 1105;
Constant response_id_U171 = 171;
Constant anchor_U122 = 1105;
Constant response_id_U172 = 172;
Constant anchor_U123 = 1105;
Constant response_id_U173 = 173;
Constant anchor_U124 = 1105;
Constant response_id_U174 = 174;
Constant response_id_U175 = 175;
Constant anchor_U125 = 1105;
Constant anchor_U126 = 1105;
Constant response_id_U176 = 176;
Constant response_id_U177 = 177;
Constant anchor_U127 = 1105;
Constant anchor_U128 = 1105;
Constant anchor_U129 = 1105;
Constant response_id_U178 = 178;
Constant anchor_U130 = 1105;
Constant response_id_U179 = 179;
Constant anchor_U131 = 1105;
Constant response_id_U180 = 180;
Constant anchor_U132 = 1105;
Constant response_id_U181 = 181;
Constant anchor_U133 = 1105;
Constant anchor_U134 = 1105;
Constant response_id_U182 = 182;
Constant anchor_U135 = 1105;
Constant response_id_U183 = 183;
Constant anchor_U136 = 1105;
Constant anchor_U137 = 1105;
Constant response_id_U184 = 184;
Constant anchor_U138 = 1105;
Constant response_id_U185 = 185;
Constant anchor_U139 = 1105;
Constant anchor_U140 = 1105;
Constant response_id_U186 = 186;
Constant anchor_U141 = 1105;
Constant response_id_U187 = 187;
Constant anchor_U142 = 1105;
Constant response_id_U188 = 188;
Constant anchor_U143 = 1105;
Constant response_id_U189 = 189;
Constant anchor_U144 = 1105;
Constant anchor_U145 = 1105;
Constant response_id_U190 = 190;
Constant anchor_U146 = 1105;
Constant response_id_U191 = 191;
Constant anchor_U147 = 1105;
Constant response_id_U192 = 192;
Constant anchor_U148 = 1105;
Constant response_id_U193 = 193;
Constant anchor_U149 = 1105;
Constant response_id_U194 = 194;
Constant anchor_U150 = 1105;
Constant anchor_U151 = 1105;
Constant anchor_U152 = 1105;
Constant response_id_U195 = 195;
Constant response_id_U196 = 196;
Constant anchor_U153 = 1105;
Constant anchor_U154 = 1105;
Constant response_id_U197 = 197;
Constant anchor_U155 = 1105;
Constant response_id_U198 = 198;
Constant response_id_U199 = 199;
Constant anchor_U156 = 1105;
Constant response_id_U200 = 200;
Constant anchor_U157 = 1105;
Constant response_id_U201 = 201;
Constant anchor_U158 = 1105;
Constant anchor_U159 = 1105;
Constant response_id_U202 = 202;
Constant response_id_U203 = 203;
Constant anchor_U160 = 1105;
Constant anchor_U161 = 1105;
Constant anchor_U162 = 1105;
Constant anchor_U163 = 1105;
Constant response_id_U204 = 204;
Constant response_id_U205 = 205;
Constant response_id_U206 = 206;
Constant response_id_U207 = 207;
Constant response_id_U208 = 208;
Constant response_id_U209 = 209;
Constant response_id_U210 = 210;
Constant response_id_U211 = 211;
Constant response_id_U212 = 212;
Constant response_id_U213 = 213;
Constant response_id_U214 = 214;
Constant response_id_U215 = 215;
Constant response_id_U216 = 216;
Constant response_id_U217 = 217;
Constant response_id_U218 = 218;
Constant response_id_U219 = 219;
Constant response_id_U220 = 220;
Constant response_id_U221 = 221;
Constant response_id_U222 = 222;
Constant anchor_U164 = 1105;
Constant anchor_U165 = 1105;
Constant anchor_U166 = 1105;
Constant anchor_U167 = 1105;
Constant response_id_U223 = 223;
Constant response_id_U224 = 224;
Constant anchor_U168 = 1105;
Constant response_id_U225 = 225;
Constant response_id_U226 = 226;
Constant response_id_U227 = 227;
Constant response_id_U228 = 228;
Constant anchor_U169 = 1105;
Constant response_id_U229 = 229;
Constant anchor_U170 = 1105;
Constant response_id_U230 = 230;
Constant response_id_U231 = 231;
Constant anchor_U171 = 1105;
Constant response_id_U232 = 232;
Constant anchor_U172 = 1105;
Constant response_id_U233 = 233;
Constant response_id_U234 = 234;
Constant response_id_U235 = 235;
Constant response_id_U236 = 236;
Constant response_id_U237 = 237;
Constant anchor_U173 = 1105;
Constant anchor_U174 = 1105;
Constant response_id_U238 = 238;
Constant response_id_U239 = 239;
Constant response_id_U240 = 240;
Constant response_id_U241 = 241;
Constant anchor_U175 = 1105;
Constant anchor_U176 = 1105;
Constant anchor_U177 = 1105;
Constant anchor_U178 = 1105;
Constant response_id_U242 = 242;
Constant anchor_U179 = 1105;
Constant response_id_U243 = 243;
Constant anchor_U180 = 1105;
Constant anchor_U181 = 1105;
Constant anchor_U182 = 1105;
Constant response_id_U244 = 244;
Constant response_id_U245 = 245;
Constant response_id_U246 = 246;
Constant anchor_U183 = 1105;
Constant anchor_U184 = 1105;
Constant response_id_U247 = 247;
Constant anchor_U185 = 1105;
Constant anchor_U186 = 1105;
Constant response_id_U248 = 248;
Constant anchor_U187 = 1105;
Constant anchor_U188 = 1105;
Constant anchor_U189 = 1105;
Constant anchor_U190 = 1105;
Constant response_id_U249 = 249;
Constant response_id_U250 = 250;
Constant response_id_U251 = 251;
Constant anchor_U191 = 1105;
Constant response_id_U252 = 252;
Constant anchor_U192 = 1105;
Constant anchor_U193 = 1105;
Constant anchor_U194 = 1105;
Constant response_id_U253 = 253;
Constant anchor_U195 = 1105;
Constant anchor_U196 = 1105;
Constant response_id_U254 = 254;
Constant anchor_U197 = 1105;
Constant response_id_U255 = 255;
Constant response_id_U256 = 256;
Constant anchor_U198 = 1105;
Constant response_id_U257 = 257;
Constant anchor_U199 = 1105;
Constant response_id_U258 = 258;
Constant anchor_U200 = 1105;
Constant response_id_U259 = 259;
Constant anchor_U201 = 1105;
Constant response_id_U260 = 260;
Constant anchor_U202 = 1105;
Constant response_id_U261 = 261;
Constant anchor_U203 = 1105;
Constant response_id_U262 = 262;
Constant anchor_U204 = 1105;
Constant response_id_U263 = 263;
Constant anchor_U205 = 1105;
Constant response_id_U264 = 264;
Constant anchor_U206 = 1105;
Constant response_id_U265 = 265;
Constant response_id_U266 = 266;
Constant anchor_U207 = 1105;
Constant response_id_U267 = 267;
Constant response_id_U268 = 268;
Constant anchor_U208 = 1105;
Constant response_id_U269 = 269;
Constant anchor_U209 = 1105;
Constant response_id_U270 = 270;
Constant response_id_U271 = 271;
Constant anchor_U210 = 1105;
Constant response_id_U272 = 272;
Constant anchor_U211 = 1105;
Constant response_id_U273 = 273;
Constant anchor_U212 = 1105;
Constant response_id_U274 = 274;
Constant anchor_U213 = 1105;
Constant response_id_U275 = 275;
Constant anchor_U214 = 1105;
Constant anchor_U215 = 1105;
Constant response_id_U276 = 276;
Constant response_id_U277 = 277;
Constant anchor_U216 = 1105;
Constant response_id_U278 = 278;
Constant anchor_U217 = 1105;
Constant response_id_U279 = 279;
Constant anchor_U218 = 1105;
Constant response_id_U280 = 280;
Constant anchor_U219 = 1105;
Constant anchor_U220 = 1105;
Constant response_id_U281 = 281;
Constant response_id_U282 = 282;
Constant anchor_U221 = 1105;
Constant response_id_U283 = 283;
Constant anchor_U222 = 1105;
Constant response_id_U284 = 284;
Constant anchor_U223 = 1105;
Constant anchor_U224 = 1105;
Constant response_id_U285 = 285;
Constant anchor_U225 = 1105;
Constant response_id_U286 = 286;
Constant anchor_U226 = 1105;
Constant response_id_U287 = 287;
Constant anchor_U227 = 1105;
Constant anchor_U228 = 1105;
Constant response_id_U288 = 288;
Constant anchor_U229 = 1105;
Constant response_id_U289 = 289;
Constant anchor_U230 = 1105;
Constant response_id_U290 = 290;
Constant anchor_U231 = 1105;
Constant response_id_U291 = 291;
Constant anchor_U232 = 1105;
Constant anchor_U233 = 1105;
Constant response_id_U292 = 292;
Constant anchor_U234 = 1105;
Constant response_id_U293 = 293;
Constant response_id_U294 = 294;
Constant response_id_U295 = 295;
Constant anchor_U235 = 1105;
Constant response_id_U296 = 296;
Constant anchor_U236 = 1105;
Constant response_id_U297 = 297;
Constant anchor_U237 = 1105;
Constant anchor_U238 = 1105;
Constant response_id_U298 = 298;
Constant response_id_U299 = 299;
Constant response_id_U300 = 300;
Constant anchor_U239 = 1105;
Constant response_id_U301 = 301;
Constant anchor_U240 = 1105;
Constant response_id_U302 = 302;
Constant anchor_U241 = 1105;
Constant response_id_U303 = 303;
Constant anchor_U242 = 1105;
Constant anchor_U243 = 1105;
Constant response_id_U304 = 304;
Constant response_id_U305 = 305;
Constant anchor_U244 = 1105;
Constant anchor_U245 = 1105;
Constant response_id_U306 = 306;
Constant anchor_U246 = 1105;
Constant response_id_U307 = 307;
Constant anchor_U247 = 1105;
Constant anchor_U248 = 1105;
Constant response_id_U308 = 308;
Constant response_id_U309 = 309;
Constant anchor_U249 = 1105;
Constant response_id_U310 = 310;
Constant anchor_U250 = 1105;
Constant response_id_U311 = 311;
Constant anchor_U251 = 1105;
Constant response_id_U312 = 312;
Constant anchor_U252 = 1105;
Constant response_id_U313 = 313;
Constant anchor_U253 = 1105;
Constant response_id_U314 = 314;
Constant anchor_U254 = 1105;
Constant response_id_U315 = 315;
Constant anchor_U255 = 1105;
Constant anchor_U256 = 1105;
Constant response_id_U316 = 316;
Constant response_id_U317 = 317;
Constant response_id_U318 = 318;
Constant anchor_U257 = 1105;
Constant response_id_U319 = 319;
Constant anchor_U258 = 1105;
Constant anchor_U259 = 1105;
Constant response_id_U320 = 320;
Constant anchor_U260 = 1105;
Constant response_id_U321 = 321;
Constant anchor_U261 = 1105;
Constant response_id_U322 = 322;
Constant anchor_U262 = 1105;
Constant response_id_U323 = 323;
Constant anchor_U263 = 1105;
Constant response_id_U324 = 324;
Constant anchor_U264 = 1105;
Constant response_id_U325 = 325;
Constant anchor_U265 = 1105;
Constant response_id_U326 = 326;
Constant anchor_U266 = 1105;
Constant response_id_U327 = 327;
Constant anchor_U267 = 1105;
Constant response_id_U328 = 328;
Constant anchor_U268 = 1105;
Constant response_id_U329 = 329;
Constant anchor_U269 = 1105;
Constant response_id_U330 = 330;
Constant anchor_U270 = 1105;
Constant response_id_U331 = 331;
Constant anchor_U271 = 1105;
Constant anchor_U272 = 1105;
Constant anchor_U273 = 1105;
Constant response_id_U332 = 332;
Constant response_id_U333 = 333;
Constant anchor_U274 = 1105;
Constant response_id_U334 = 334;
Constant response_id_U335 = 335;
Constant anchor_U275 = 1105;
Constant response_id_U336 = 336;
Constant response_id_U337 = 337;
Constant response_id_U338 = 338;
Constant anchor_U276 = 1105;
Constant response_id_U339 = 339;
Constant response_id_U340 = 340;
Constant anchor_U277 = 1105;
Constant response_id_U341 = 341;
Constant anchor_U278 = 1105;
Constant response_id_U342 = 342;
Constant response_id_U343 = 343;
Constant anchor_U279 = 1105;
Constant response_id_U344 = 344;
Constant anchor_U280 = 1105;
Constant response_id_U345 = 345;
Constant anchor_U281 = 1105;
Constant response_id_U346 = 346;
Constant anchor_U282 = 1105;
Constant response_id_U347 = 347;
Constant response_id_U348 = 348;
Constant anchor_U283 = 1105;
Constant response_id_U349 = 349;
Constant anchor_U284 = 1105;
Constant response_id_U350 = 350;
Constant anchor_U285 = 1105;
Constant response_id_U351 = 351;
Constant anchor_U286 = 1105;
Constant response_id_U352 = 352;
Constant response_id_U353 = 353;
Constant anchor_U287 = 1105;
Constant response_id_U354 = 354;
Constant anchor_U288 = 1105;
Constant response_id_U355 = 355;
Constant anchor_U289 = 1105;
Constant response_id_U356 = 356;
Constant anchor_U290 = 1105;
Constant response_id_U357 = 357;
Constant response_id_U358 = 358;
Constant anchor_U291 = 1105;
Constant response_id_U359 = 359;
Constant anchor_U292 = 1105;
Constant response_id_U360 = 360;
Constant anchor_U293 = 1105;
Constant response_id_U361 = 361;
Constant anchor_U294 = 1105;
Constant response_id_U362 = 362;
Constant anchor_U295 = 1105;
Constant anchor_U296 = 1105;
Constant response_id_U363 = 363;
Constant anchor_U297 = 1105;
Constant response_id_U364 = 364;
Constant anchor_U298 = 1105;
Constant response_id_U365 = 365;
Constant response_id_U366 = 366;
Constant anchor_U299 = 1105;
Constant response_id_U367 = 367;
Constant anchor_U300 = 1105;
Constant response_id_U368 = 368;
Constant anchor_U301 = 1105;
Constant response_id_U369 = 369;
Constant anchor_U302 = 1105;
Constant response_id_U370 = 370;
Constant anchor_U303 = 1105;
Constant response_id_U371 = 371;
Constant anchor_U304 = 1105;
Constant response_id_U372 = 372;
Constant response_id_U373 = 373;
Constant anchor_U305 = 1105;
Constant response_id_U374 = 374;
Constant response_id_U375 = 375;
Constant anchor_U306 = 1105;
Constant response_id_U376 = 376;
Constant response_id_U377 = 377;
Constant anchor_U307 = 1105;
Constant response_id_U378 = 378;
Constant anchor_U308 = 1105;
Constant response_id_U379 = 379;
Constant response_id_U380 = 380;
Constant anchor_U309 = 1105;
Constant response_id_U381 = 381;
Constant anchor_U310 = 1105;
Constant response_id_U382 = 382;
Constant anchor_U311 = 1105;
Constant response_id_U383 = 383;
Constant anchor_U312 = 1105;
Constant response_id_U384 = 384;
Constant anchor_U313 = 1105;
Constant response_id_U385 = 385;
Constant anchor_U314 = 1105;
Constant response_id_U386 = 386;
Constant response_id_U387 = 387;
Constant anchor_U315 = 1105;
Constant response_id_U388 = 388;
Constant anchor_U316 = 1105;
Constant response_id_U389 = 389;
Constant response_id_U390 = 390;
Constant anchor_U317 = 1105;
Constant response_id_U391 = 391;
Constant anchor_U318 = 1105;
Constant response_id_U392 = 392;
Constant anchor_U319 = 1105;
Constant response_id_U393 = 393;
Constant anchor_U320 = 1105;
Constant anchor_U321 = 1105;
Constant anchor_U322 = 1105;
Constant anchor_U323 = 1105;
Constant anchor_U324 = 1105;
Constant anchor_U325 = 1105;
Constant anchor_U326 = 1105;
Constant anchor_U327 = 1105;
Constant anchor_U328 = 1105;
Constant anchor_U329 = 1105;
Constant anchor_U330 = 1105;
Constant anchor_U331 = 1105;
Constant anchor_U332 = 1105;
Constant anchor_U333 = 1105;
Constant anchor_U334 = 1105;
Constant anchor_U335 = 1105;
Constant anchor_U336 = 1105;
Constant anchor_U337 = 1105;
Constant anchor_U338 = 1105;
Constant anchor_U339 = 1105;
Constant anchor_U340 = 1105;
Constant anchor_U341 = 1105;
Constant anchor_U342 = 1105;
Constant anchor_U343 = 1105;
Constant anchor_U344 = 1105;
Constant anchor_U345 = 1105;
Constant anchor_U346 = 1105;
Constant anchor_U347 = 1105;
Constant anchor_U348 = 1105;
Constant anchor_U349 = 1105;
Constant kind_ref_U51 = 561;
Constant WEAK_ID_52 = 3;
Constant ICOUNT_ROOM = 9;
Constant K1_room_First = I_kitchen_U1;
Constant kind_ref_U52 = 561;
Constant WEAK_ID_53 = 4;
Constant ICOUNT_THING = 9;
Constant K2_thing_First = selfobj;
Constant kind_ref_U53 = 561;
Constant WEAK_ID_54 = 5;
Constant ICOUNT_DIRECTION = 12;
Constant K3_direction_First = I_north_U1;
Constant kind_ref_U54 = 561;
Constant WEAK_ID_55 = 6;
Constant ICOUNT_DOOR = 0;
Constant kind_ref_U55 = 561;
Constant WEAK_ID_56 = 7;
Constant ICOUNT_CONTAINER = 0;
Constant kind_ref_U56 = 561;
Constant WEAK_ID_57 = 8;
Constant ICOUNT_SUPPORTER = 0;
Constant kind_ref_U57 = 561;
Constant WEAK_ID_58 = 9;
Constant ICOUNT_BACKDROP = 0;
Constant kind_ref_U58 = 561;
Constant WEAK_ID_59 = 10;
Constant ICOUNT_PERSON = 3;
Constant K8_person_First = selfobj;
Constant kind_ref_U59 = 561;
Constant WEAK_ID_60 = 11;
Constant ICOUNT_REGION = 0;
Constant kind_ref_U60 = 561;
Constant WEAK_ID_61 = 12;
Constant ICOUNT_MAN = 0;
Constant kind_ref_U61 = 561;
Constant WEAK_ID_62 = 13;
Constant ICOUNT_WOMAN = 0;
Constant kind_ref_U62 = 561;
Constant WEAK_ID_63 = 14;
Constant ICOUNT_ANIMAL = 0;
Constant kind_ref_U63 = 561;
Constant WEAK_ID_64 = 15;
Constant ICOUNT_DEVICE = 0;
Constant kind_ref_U64 = 561;
Constant WEAK_ID_65 = 16;
Constant ICOUNT_VEHICLE = 0;
Constant kind_ref_U65 = 561;
Constant WEAK_ID_66 = 17;
Constant ICOUNT_PLAYER_S_HOLDALL = 0;
Constant kind_ref_U66 = 561;
Constant WEAK_ID_67 = 18;
Constant ICOUNT_COMMAND_PARSER_ERROR = 25;
Constant INITIAL_MAX_SCORE = 0;
Constant extension_id_U3 = 3;
Constant column_bits_U1 = 1636;
Constant column_blanks_U1 = 0;
Constant column_bits_U2 = 1125;
Constant column_blanks_U2 = 1;
Constant column_bits_U3 = 8294;
Constant column_blanks_U3 = 2;
Constant column_bits_U4 = 103;
Constant column_blanks_U4 = 3;
Constant column_bits_U5 = 104;
Constant column_blanks_U5 = 4;
Constant table_id_U1 = 1;
Constant column_bits_U6 = 2153;
Constant column_bits_U7 = 17514;
Constant column_blanks_U6 = 5;
Constant table_id_U2 = 2;
Constant kind_ref_U67 = 561;
Constant WEAK_ID_68 = 23;
Constant ICOUNT_LITTLE_GIRL = 2;
Constant K16_little_girl_First = I_simi_U1;
Constant anchor_U350 = 1105;
Constant relation_id_U89 = 72;
Constant relation_id_U90 = 73;
Constant relation_id_U91 = 74;
Constant relation_id_U92 = 75;
Constant relation_id_U93 = 76;
Constant relation_id_U94 = 77;
Constant relation_id_U95 = 78;
Constant relation_id_U96 = 79;
Constant relation_id_U97 = 80;
Constant relation_id_U98 = 81;
Constant relation_id_U99 = 82;
Constant relation_id_U100 = 83;
Constant relation_id_U101 = 84;
Constant relation_id_U102 = 85;
Constant relation_id_U103 = 86;
Constant relation_id_U104 = 87;
Constant relation_id_U105 = 88;
Constant relation_id_U106 = 89;
Constant relation_id_U107 = 90;
Constant relation_id_U108 = 91;
Constant relation_id_U109 = 92;
Constant relation_id_U110 = 93;
Constant relation_id_U111 = 94;
Constant relation_id_U112 = 95;
Constant relation_id_U113 = 96;
Constant relation_id_U114 = 97;
Constant relation_id_U115 = 98;
Constant relation_id_U116 = 99;
Constant relation_id_U117 = 100;
Constant relation_id_U118 = 101;
Constant relation_id_U119 = 102;
Constant relation_id_U120 = 103;
Constant relation_id_U121 = 104;
Release 1;
Constant No_Directions = 12;
Constant line_ref_U1 = 561;
Constant line_ref_U2 = 561;
Constant line_ref_U3 = 561;
Constant line_ref_U4 = 561;
Constant line_ref_U5 = 561;
Constant line_ref_U6 = 561;
Constant line_ref_U7 = 561;
Constant line_ref_U8 = 561;
Constant line_ref_U9 = 561;
Constant line_ref_U10 = 561;
Constant line_ref_U11 = 561;
Constant line_ref_U12 = 561;
Constant line_ref_U13 = 561;
Constant line_ref_U14 = 561;
Constant line_ref_U15 = 561;
Constant line_ref_U16 = 561;
Constant line_ref_U17 = 561;
Constant line_ref_U18 = 561;
Constant line_ref_U19 = 561;
Constant line_ref_U20 = 561;
Constant line_ref_U21 = 561;
Constant line_ref_U22 = 561;
Constant line_ref_U23 = 561;
Constant line_ref_U24 = 561;
Constant line_ref_U25 = 561;
Constant line_ref_U26 = 561;
Constant line_ref_U27 = 561;
Constant line_ref_U28 = 561;
Constant line_ref_U29 = 561;
Constant line_ref_U30 = 561;
Constant line_ref_U31 = 561;
Constant line_ref_U32 = 561;
Constant line_ref_U33 = 561;
Constant line_ref_U34 = 561;
Constant line_ref_U35 = 561;
Constant line_ref_U36 = 561;
Constant line_ref_U37 = 561;
Constant line_ref_U38 = 561;
Constant line_ref_U39 = 561;
Constant line_ref_U40 = 561;
Constant line_ref_U41 = 561;
Constant line_ref_U42 = 561;
Constant line_ref_U43 = 561;
Constant line_ref_U44 = 561;
Constant line_ref_U45 = 561;
Constant line_ref_U46 = 561;
Constant line_ref_U47 = 561;
Constant line_ref_U48 = 561;
Constant line_ref_U49 = 561;
Constant line_ref_U50 = 561;
Constant line_ref_U51 = 561;
Constant line_ref_U52 = 561;
Constant line_ref_U53 = 561;
Constant line_ref_U54 = 561;
Constant line_ref_U55 = 561;
Constant line_ref_U56 = 561;
Constant line_ref_U57 = 561;
Constant line_ref_U58 = 561;
Constant line_ref_U59 = 561;
Constant line_ref_U60 = 561;
Constant line_ref_U61 = 561;
Constant line_ref_U62 = 561;
Constant line_ref_U63 = 561;
Constant line_ref_U64 = 561;
Constant line_ref_U65 = 561;
Constant line_ref_U66 = 561;
Constant line_ref_U67 = 561;
Constant line_ref_U68 = 561;
Constant line_ref_U69 = 561;
Constant line_ref_U70 = 561;
Constant line_ref_U71 = 561;
Constant line_ref_U72 = 561;
Constant line_ref_U73 = 561;
Constant line_ref_U74 = 561;
Constant line_ref_U75 = 561;
Constant line_ref_U76 = 561;
Constant line_ref_U77 = 561;
Constant line_ref_U78 = 561;
Constant line_ref_U79 = 561;
Constant line_ref_U80 = 561;
Constant line_ref_U81 = 561;
Constant line_ref_U82 = 561;
Constant line_ref_U83 = 561;
Constant line_ref_U84 = 561;
Constant line_ref_U85 = 561;
Constant line_ref_U86 = 561;
Constant line_ref_U87 = 561;
Constant line_ref_U88 = 561;
Constant line_ref_U89 = 561;
Constant line_ref_U90 = 561;
Constant line_ref_U91 = 561;
Constant line_ref_U92 = 561;
Constant line_ref_U93 = 561;
Constant line_ref_U94 = 561;
Constant line_ref_U95 = 561;
Constant line_ref_U96 = 561;
Constant line_ref_U97 = 561;
Constant line_ref_U98 = 561;
Constant line_ref_U99 = 561;
Constant line_ref_U100 = 561;
Constant line_ref_U101 = 561;
Constant line_ref_U102 = 561;
Constant line_ref_U103 = 561;
Constant line_ref_U104 = 561;
Constant line_ref_U105 = 561;
Constant line_ref_U106 = 561;
Constant line_ref_U107 = 561;
Constant line_ref_U108 = 561;
Constant line_ref_U109 = 561;
Constant line_ref_U110 = 561;
Constant line_ref_U111 = 561;
Constant line_ref_U112 = 561;
Constant line_ref_U113 = 561;
Constant line_ref_U114 = 561;
Constant line_ref_U115 = 561;
Constant line_ref_U116 = 561;
Constant line_ref_U117 = 561;
Constant line_ref_U118 = 561;
Constant line_ref_U119 = 561;
Constant line_ref_U120 = 561;
Constant line_ref_U121 = 561;
Constant line_ref_U122 = 561;
Constant line_ref_U123 = 561;
Constant line_ref_U124 = 561;
Constant line_ref_U125 = 561;
Constant line_ref_U126 = 561;
Constant line_ref_U127 = 561;
Constant line_ref_U128 = 561;
Constant line_ref_U129 = 561;
Constant line_ref_U130 = 561;
Constant line_ref_U131 = 561;
Constant line_ref_U132 = 561;
Constant line_ref_U133 = 561;
Constant line_ref_U134 = 561;
Constant line_ref_U135 = 561;
Constant line_ref_U136 = 561;
Constant line_ref_U137 = 561;
Constant line_ref_U138 = 561;
Constant line_ref_U139 = 561;
Constant line_ref_U140 = 561;
Constant line_ref_U141 = 561;
Constant line_ref_U142 = 561;
Constant line_ref_U143 = 561;
Constant line_ref_U144 = 561;
Constant line_ref_U145 = 561;
Constant line_ref_U146 = 561;
Constant line_ref_U147 = 561;
Constant line_ref_U148 = 561;
Constant line_ref_U149 = 561;
Constant line_ref_U150 = 561;
Constant line_ref_U151 = 561;
Constant line_ref_U152 = 561;
Constant line_ref_U153 = 561;
Constant line_ref_U154 = 561;
Constant line_ref_U155 = 561;
Constant line_ref_U156 = 561;
Constant line_ref_U157 = 561;
Constant line_ref_U158 = 561;
Constant line_ref_U159 = 561;
Constant line_ref_U160 = 561;
Constant line_ref_U161 = 561;
Constant line_ref_U162 = 561;
Constant line_ref_U163 = 561;
Constant line_ref_U164 = 561;
Constant line_ref_U165 = 561;
Constant line_ref_U166 = 561;
Constant line_ref_U167 = 561;
Constant line_ref_U168 = 561;
Constant line_ref_U169 = 561;
Constant KIT_CONFIGURATION_BITMAP = 256;
Constant KIT_CONFIGURATION_LOOKMODE = 2;
Constant MAX_FRAME_SIZE_NEEDED = 6;
Constant RNG_SEED_AT_START_OF_PLAY = 0;
Constant id_U1 = 561;
Constant id_U2 = 561;
Constant id_U3 = 561;
Constant id_U4 = 561;
Constant id_U5 = 561;
Constant id_U6 = 561;
Constant id_U7 = 561;
Constant id_U8 = 561;
Constant id_U9 = 561;
Constant id_U10 = 561;
Constant id_U11 = 561;
Constant id_U12 = 561;
Constant id_U13 = 561;
Constant id_U14 = 561;
Constant id_U15 = 561;
Constant id_U16 = 561;
Constant id_U17 = 561;
Constant id_U18 = 561;
Constant id_U19 = 561;
Constant id_U20 = 561;
Constant id_U21 = 561;
Constant id_U22 = 561;
Constant id_U23 = 561;
Constant id_U24 = 561;
Constant id_U25 = 561;
Constant id_U26 = 561;
Constant id_U27 = 561;
Constant id_U28 = 561;
Constant id_U29 = 561;
Constant id_U30 = 561;
Constant id_U31 = 561;
Constant id_U32 = 561;
Constant id_U33 = 561;
Constant id_U34 = 561;
Constant id_U35 = 561;
Constant id_U36 = 561;
Constant id_U37 = 561;
Constant id_U38 = 561;
Constant id_U39 = 561;
Constant id_U40 = 561;
Constant id_U41 = 561;
Constant id_U42 = 561;
Constant id_U43 = 561;
Constant id_U44 = 561;
Constant id_U45 = 561;
Constant id_U46 = 561;
Constant id_U47 = 561;
Constant id_U48 = 561;
Constant id_U49 = 561;
Constant id_U50 = 561;
Constant id_U51 = 561;
Constant id_U52 = 561;
Constant id_U53 = 561;
Constant id_U54 = 561;
Constant id_U55 = 561;
Constant id_U56 = 561;
Constant id_U57 = 561;
Constant id_U58 = 561;
Constant id_U59 = 561;
Constant id_U60 = 561;
Constant id_U61 = 561;
Constant id_U62 = 561;
Constant id_U63 = 561;
Constant id_U64 = 561;
Constant id_U65 = 561;
Constant id_U66 = 561;
Constant id_U67 = 561;
Constant id_U68 = 561;
Constant id_U69 = 561;
Constant id_U70 = 561;
Constant id_U71 = 561;
Constant id_U72 = 561;
Constant id_U73 = 561;
Constant id_U74 = 561;
Constant id_U75 = 561;
Constant id_U76 = 561;
Constant id_U77 = 561;
Constant id_U78 = 561;
Constant id_U79 = 561;
Constant id_U80 = 561;
Constant id_U81 = 561;
Constant id_U82 = 561;
Constant id_U83 = 561;
Constant id_U84 = 561;
Constant id_U85 = 561;
Constant id_U86 = 561;
Constant id_U87 = 561;
Constant id_U88 = 561;
Constant id_U89 = 561;
Constant id_U90 = 561;
Constant id_U91 = 561;
Constant id_U92 = 561;
Constant id_U93 = 561;
Constant id_U94 = 561;
Constant id_U95 = 561;
Constant id_U96 = 561;
Constant id_U97 = 561;
Constant id_U98 = 561;
Constant id_U99 = 561;
Constant id_U100 = 561;
Constant id_U101 = 561;
Constant id_U102 = 561;
Constant id_U103 = 561;
Constant id_U104 = 561;
Constant id_U105 = 561;
Constant id_U106 = 561;
Constant id_U107 = 561;
Constant id_U108 = 561;
Constant id_U109 = 561;
Constant id_U110 = 561;
Constant id_U111 = 561;
Constant id_U112 = 561;
Constant id_U113 = 561;
Constant id_U114 = 561;
Constant id_U115 = 561;
Constant id_U116 = 561;
Constant id_U117 = 561;
Constant id_U118 = 561;
Constant id_U119 = 561;
Constant id_U120 = 561;
Constant id_U121 = 561;
Constant id_U122 = 561;
Constant id_U123 = 561;
Constant id_U124 = 561;
Constant id_U125 = 561;
Constant id_U126 = 561;
Constant id_U127 = 561;
Constant id_U128 = 561;
Constant id_U129 = 561;
Constant id_U130 = 561;
Constant id_U131 = 561;
Constant id_U132 = 561;
Constant id_U133 = 561;
Constant id_U134 = 561;
Constant id_U135 = 561;
Constant id_U136 = 561;
Constant id_U137 = 561;
Constant id_U138 = 561;
Constant id_U139 = 561;
Constant id_U140 = 561;
Constant id_U141 = 561;
Constant id_U142 = 561;
Constant id_U143 = 561;
Constant id_U144 = 561;
Constant id_U145 = 561;
Constant id_U146 = 561;
Constant id_U147 = 561;
Constant id_U148 = 561;
Constant id_U149 = 561;
Constant id_U150 = 561;
Constant id_U151 = 561;
Constant id_U152 = 561;
Constant id_U153 = 561;
Constant id_U154 = 561;
Constant id_U155 = 561;
Constant id_U156 = 561;
Constant id_U157 = 561;
Constant id_U158 = 561;
Constant id_U159 = 561;
Constant id_U160 = 561;
Constant id_U161 = 561;
Constant id_U162 = 561;
Constant id_U163 = 561;
Constant id_U164 = 561;
Constant id_U165 = 561;
Constant id_U166 = 561;
Constant id_U167 = 561;
Constant id_U168 = 561;
Constant id_U169 = 561;
Constant id_U170 = 561;
Constant id_U171 = 561;
Constant id_U172 = 561;
Constant id_U173 = 561;
Constant id_U174 = 561;
Constant id_U175 = 561;
Constant id_U176 = 561;
Constant id_U177 = 561;
Constant id_U178 = 561;
Constant id_U179 = 561;
Constant id_U180 = 561;
Constant id_U181 = 561;
Constant id_U182 = 561;
Constant id_U183 = 561;
Constant id_U184 = 561;
Constant id_U185 = 561;
Constant MEMORY_HEAP_SIZE = 32768;
Constant BASICINFORMKIT = 1;
Constant HDR_MAGICNUMBER = 0;
Constant HDR_GLULXVERSION = 4;
Constant HDR_RAMSTART = 8;
Constant HDR_EXTSTART = 12;
Constant HDR_ENDMEM = 16;
Constant HDR_STACKSIZE = 20;
Constant HDR_STARTFUNC = 24;
Constant HDR_DECODINGTBL = 28;
Constant HDR_CHECKSUM = 32;
Constant ROM_INFO = 36;
Constant ROM_MEMORYLAYOUT = 40;
Constant ROM_INFORMVERSION = 44;
Constant ROM_COMPVERSION = 48;
Constant ROM_GAMERELEASE = 52;
Constant ROM_GAMESERIAL = 54;
Constant NORMAL_VMSTY = 0;
Constant HEADER_VMSTY = 3;
Constant SUBHEADER_VMSTY = 4;
Constant ALERT_VMSTY = 5;
Constant NOTE_VMSTY = 6;
Constant BLOCKQUOTE_VMSTY = 7;
Constant INPUT_VMSTY = 8;
Constant CLR_DEFAULT = 1;
Constant CLR_BLACK = 2;
Constant CLR_RED = 3;
Constant CLR_GREEN = 4;
Constant CLR_YELLOW = 5;
Constant CLR_BLUE = 6;
Constant CLR_MAGENTA = 7;
Constant CLR_PURPLE = 7;
Constant CLR_CYAN = 8;
Constant CLR_AZURE = 8;
Constant CLR_WHITE = 9;
Constant WIN_ALL = 0;
Constant WIN_STATUS = 1;
Constant WIN_MAIN = 2;
Constant PARA_COMPLETED = 1;
Constant PARA_PROMPTSKIP = 2;
Constant PARA_SUPPRESSPROMPTSKIP = 4;
Constant PARA_NORULEBOOKBREAKS = 8;
Constant PARA_CONTENTEXPECTED = 16;
Constant POSSESS_PK = 256;
Constant DEFART_PK = 257;
Constant INDEFART_PK = 258;
Constant LIGHTED_PK = 259;
Constant UNLIGHTED_PK = 260;
Constant RTP_BACKDROP = 1;
Constant RTP_EXITDOOR = 2;
Constant RTP_NOEXIT = 3;
Constant RTP_CANTCHANGE = 4;
Constant RTP_IMPREL = 5;
Constant RTP_RULESTACK = 6;
Constant RTP_TOOMANYRULEBOOKS = 7;
Constant RTP_TOOMANYEVENTS = 8;
Constant RTP_BADPROPERTY = 9;
Constant RTP_UNPROVIDED = 10;
Constant RTP_UNSET = 11;
Constant RTP_TOOMANYACTS = 12;
Constant RTP_CANTABANDON = 13;
Constant RTP_CANTEND = 14;
Constant RTP_CANTMOVENOTHING = 15;
Constant RTP_CANTREMOVENOTHING = 16;
Constant RTP_DIVZERO = 17;
Constant RTP_BADVALUEPROPERTY = 18;
Constant RTP_NOTBACKDROP = 19;
Constant RTP_TABLE_NOCOL = 20;
Constant RTP_TABLE_NOCORR = 21;
Constant RTP_TABLE_NOROW = 22;
Constant RTP_TABLE_NOENTRY = 23;
Constant RTP_TABLE_NOTABLE = 24;
Constant RTP_TABLE_NOMOREBLANKS = 25;
Constant RTP_TABLE_NOROWS = 26;
Constant RTP_TABLE_CANTSORT = 27;
Constant RTP_NOTINAROOM = 28;
Constant RTP_BADTOPIC = 29;
Constant RTP_ROUTELESS = 30;
Constant RTP_PROPOFNOTHING = 31;
Constant RTP_DECIDEONWRONGKIND = 32;
Constant RTP_DECIDEONNOTHING = 33;
Constant RTP_TABLE_CANTSAVE = 34;
Constant RTP_TABLE_WONTFIT = 35;
Constant RTP_TABLE_BADFILE = 36;
Constant RTP_LOWLEVELERROR = 37;
Constant RTP_DONTIGNORETURNSEQUENCE = 38;
Constant RTP_SAYINVALIDSNIPPET = 39;
Constant RTP_SPLICEINVALIDSNIPPET = 40;
Constant RTP_INCLUDEINVALIDSNIPPET = 41;
Constant RTP_LISTWRITERMEMORY = 42;
Constant RTP_CANTREMOVEPLAYER = 43;
Constant RTP_CANTREMOVEDOORS = 44;
Constant RTP_CANTCHANGEOFFSTAGE = 45;
Constant RTP_MSTACKMEMORY = 46;
Constant RTP_TYPECHECK = 47;
Constant RTP_FILEIOERROR = 48;
Constant RTP_HEAPERROR = 49;
Constant RTP_LISTRANGEERROR = 50;
Constant RTP_REGEXPSYNTAXERROR = 51;
Constant RTP_NOGLULXUNICODE = 52;
Constant RTP_BACKDROPONLY = 53;
Constant RTP_NOTTHING = 54;
Constant RTP_SCENEHASNTSTARTED = 55;
Constant RTP_SCENEHASNTENDED = 56;
Constant RTP_NEGATIVEROOT = 57;
Constant RTP_TABLE_CANTRUNTHROUGH = 58;
Constant RTP_CANTITERATE = 59;
Constant RTP_WRONGASSIGNEDKIND = 60;
Constant RTP_CANTBEOFFSTAGE = 61;
Constant RTP_RELKINDVIOLATION = 62;
Constant RTP_CANTMAKEPART = 63;
Constant RTP_TEXTTOKENTOOHARD = 64;
Constant RTP_TABLE_NOTABLE2 = 65;
Constant RTP_RELATIONCHANGEIMPOSSIBLE = 66;
Constant RTP_RELMINIMAL = 67;
Constant RTP_LISTSIZENEGATIVE = 68;
Constant RTP_REGIONSNOTADJACENT = 69;
Constant STARTING_VIRTUAL_MACHINE_ACT = 0;
Constant PRINTING_THE_NAME_ACT = 1;
Constant PRINTING_THE_PLURAL_NAME_ACT = 2;
Constant PRINTING_RESPONSE_ACT = 3;
Constant PRINTING_A_NUMBER_OF_ACT = 4;
Constant PRINTING_ROOM_DESC_DETAILS_ACT = 5;
Constant PRINTING_INVENTORY_DETAILS_ACT = 6;
Constant LISTING_CONTENTS_ACT = 7;
Constant GROUPING_TOGETHER_ACT = 8;
Constant WRITING_A_PARAGRAPH_ABOUT_ACT = 9;
Constant LISTING_NONDESCRIPT_ITEMS_ACT = 10;
Constant PRINTING_NAME_OF_DARK_ROOM_ACT = 11;
Constant PRINTING_DESC_OF_DARK_ROOM_ACT = 12;
Constant PRINTING_NEWS_OF_DARKNESS_ACT = 13;
Constant PRINTING_NEWS_OF_LIGHT_ACT = 14;
Constant REFUSAL_TO_ACT_IN_DARK_ACT = 15;
Constant CONSTRUCTING_STATUS_LINE_ACT = 16;
Constant PRINTING_BANNER_TEXT_ACT = 17;
Constant READING_A_COMMAND_ACT = 18;
Constant DECIDING_SCOPE_ACT = 19;
Constant DECIDING_CONCEALED_POSSESS_ACT = 20;
Constant DECIDING_WHETHER_ALL_INC_ACT = 21;
Constant CLARIFYING_PARSERS_CHOICE_ACT = 22;
Constant ASKING_WHICH_DO_YOU_MEAN_ACT = 23;
Constant PRINTING_A_PARSER_ERROR_ACT = 24;
Constant SUPPLYING_A_MISSING_NOUN_ACT = 25;
Constant SUPPLYING_A_MISSING_SECOND_ACT = 26;
Constant IMPLICITLY_TAKING_ACT = 27;
Constant AMUSING_A_VICTORIOUS_PLAYER_ACT = 28;
Constant PRINTING_PLAYERS_OBITUARY_ACT = 29;
Constant DEALING_WITH_FINAL_QUESTION_ACT = 30;
Constant PRINTING_LOCALE_DESCRIPTION_ACT = 31;
Constant CHOOSING_NOTABLE_LOCALE_OBJ_ACT = 32;
Constant PRINTING_LOCALE_PARAGRAPH_ACT = 33;
Constant STARTUP_RB = 0;
Constant SHUTDOWN_RB = 1;
Constant TURN_SEQUENCE_RB = 11;
Constant WHEN_PLAY_BEGINS_RB = 13;
Constant WHEN_PLAY_ENDS_RB = 14;
Constant WHEN_SCENE_BEGINS_RB = 15;
Constant WHEN_SCENE_ENDS_RB = 16;
Constant ACTION_PROCESSING_RB = 18;
Constant SETTING_ACTION_VARIABLES_RB = 19;
Constant SPECIFIC_ACTION_PROCESSING_RB = 20;
Constant ACCESSIBILITY_RB = 22;
Constant REACHING_INSIDE_RB = 23;
Constant REACHING_OUTSIDE_RB = 24;
Constant VISIBLE_RB = 25;
Constant PERSUADE_RB = 26;
Constant UNSUCCESSFUL_ATTEMPT_RB = 27;
Constant AFTER_RB = 32;
Constant REPORT_RB = 33;
Constant DOES_THE_PLAYER_MEAN_RB = 34;
Constant MULTIPLE_ACTION_PROCESSING_RB = 35;
Constant PARSING_REASON = 0;
Constant TALKING_REASON = 1;
Constant EACH_TURN_REASON = 2;
Constant LOOPOVERSCOPE_REASON = 5;
Constant TESTSCOPE_REASON = 6;
Constant ILLEGAL_TT = 0;
Constant ELEMENTARY_TT = 1;
Constant PREPOSITION_TT = 2;
Constant ROUTINE_FILTER_TT = 3;
Constant ATTR_FILTER_TT = 4;
Constant SCOPE_TT = 5;
Constant GPR_TT = 6;
Constant NOUN_TOKEN = 0;
Constant HELD_TOKEN = 1;
Constant MULTI_TOKEN = 2;
Constant MULTIHELD_TOKEN = 3;
Constant MULTIEXCEPT_TOKEN = 4;
Constant MULTIINSIDE_TOKEN = 5;
Constant CREATURE_TOKEN = 6;
Constant SPECIAL_TOKEN = 7;
Constant NUMBER_TOKEN = 8;
Constant TOPIC_TOKEN = 9;
Constant ENDIT_TOKEN = 15;
Constant GPR_FAIL = -1;
Constant GPR_PREPOSITION = 0;
Constant GPR_NUMBER = 1;
Constant GPR_MULTIPLE = 2;
Constant GPR_NOUN = -256;
Constant Computed_Constant_Value_0_U2 = 1;
Constant Computed_Constant_Value_2_U2 = 2;
Constant Computed_Constant_Value_4_U1 = 3;
Constant Computed_Constant_Value_6_U1 = 4;
Constant Computed_Constant_Value_8_U1 = 5;
Constant Computed_Constant_Value_10_U1 = 6;
Constant NEWLINE_BIT = 1;
Constant INDENT_BIT = 2;
Constant FULLINV_BIT = 4;
Constant ENGLISH_BIT = 8;
Constant RECURSE_BIT = 16;
Constant ALWAYS_BIT = 32;
Constant TERSE_BIT = 64;
Constant PARTINV_BIT = 128;
Constant DEFART_BIT = 256;
Constant WORKFLAG_BIT = 512;
Constant ISARE_BIT = 1024;
Constant CONCEAL_BIT = 2048;
Constant NOARTICLE_BIT = 4096;
Constant EXTRAINDENT_BIT = 8192;
Constant CFIRSTART_BIT = 16384;
Constant QUARTER_HOUR = 15;
Constant HALF_HOUR = 30;
Constant ONE_HOUR = 60;
Constant TWELVE_HOURS = 720;
Constant TWENTY_FOUR_HOURS = 1440;
Constant list_filter_permits = A_privately_named;
Constant USE_SCORING_TCBIT = 1;
Constant PREVENT_UNDO_TCBIT = 2;
Constant SERIAL_COMMA_TCBIT = 4;
Constant PROGRAMMING_EXPONENTS_TCBIT = 8;
Constant FIX_RNG_TCBIT = 16;
Constant ECHO_COMMANDS_TCBIT = 32;
Constant NO_VERB_VERB_DEFINED_TCBIT = 64;
Constant DIALECT_US_TCBIT = 128;
Constant STORY_AUTHOR_TCBIT = 256;
Constant RANKING_TABLE_TCBIT = 512;
Constant Computed_Constant_Value_12_U1 = 4;
Constant LanguageCases = 1;
Constant R_DecimalNumber = GenerateRandomNumber;
Constant R_PrintTimeOfDay = GenerateRandomNumber;
Constant GLK_NULL = 0;
Constant INPUT_BUFFER_LEN = 260;
Constant MAX_BUFFER_WORDS = 20;
Constant PARSE_BUFFER_LEN = 61;
Constant evtype_Arrange = 5;
Constant evtype_CharInput = 2;
Constant evtype_Hyperlink = 8;
Constant evtype_LineInput = 3;
Constant evtype_MouseInput = 4;
Constant evtype_None = 0;
Constant evtype_Redraw = 6;
Constant evtype_SoundNotify = 7;
Constant evtype_Timer = 1;
Constant evtype_VolumeNotify = 9;
Constant filemode_Read = 2;
Constant filemode_ReadWrite = 3;
Constant filemode_Write = 1;
Constant filemode_WriteAppend = 5;
Constant fileusage_BinaryMode = 0;
Constant fileusage_Data = 0;
Constant fileusage_InputRecord = 3;
Constant fileusage_SavedGame = 1;
Constant fileusage_TextMode = 256;
Constant fileusage_Transcript = 2;
Constant fileusage_TypeMask = 15;
Constant gestalt_CharInput = 1;
Constant gestalt_CharOutput = 3;
Constant gestalt_CharOutput_ApproxPrint = 1;
Constant gestalt_CharOutput_CannotPrint = 0;
Constant gestalt_CharOutput_ExactPrint = 2;
Constant gestalt_DateTime = 20;
Constant gestalt_DrawImage = 7;
Constant gestalt_Graphics = 6;
Constant gestalt_GraphicsCharInput = 23;
Constant gestalt_GraphicsTransparency = 14;
Constant gestalt_HyperlinkInput = 12;
Constant gestalt_Hyperlinks = 11;
Constant gestalt_LineInput = 2;
Constant gestalt_LineInputEcho = 17;
Constant gestalt_LineTerminatorKey = 19;
Constant gestalt_LineTerminators = 18;
Constant gestalt_MouseInput = 4;
Constant gestalt_ResourceStream = 22;
Constant gestalt_Sound = 8;
Constant gestalt_Sound2 = 21;
Constant gestalt_SoundMusic = 13;
Constant gestalt_SoundNotify = 10;
Constant gestalt_SoundVolume = 9;
Constant gestalt_Timer = 5;
Constant gestalt_Unicode = 15;
Constant gestalt_UnicodeNorm = 16;
Constant gestalt_Version = 0;
Constant imagealign_InlineCenter = 3;
Constant imagealign_InlineDown = 2;
Constant imagealign_MarginLeft = 4;
Constant imagealign_MarginRight = 5;
Constant imagealign_InlineUp = 1;
Constant keycode_Delete = -7;
Constant keycode_Down = -5;
Constant keycode_End = -13;
Constant keycode_Escape = -8;
Constant keycode_Func1 = -17;
Constant keycode_Func10 = -26;
Constant keycode_Func11 = -27;
Constant keycode_Func12 = -28;
Constant keycode_Func2 = -18;
Constant keycode_Func3 = -19;
Constant keycode_Func4 = -20;
Constant keycode_Func5 = -21;
Constant keycode_Func6 = -22;
Constant keycode_Func7 = -23;
Constant keycode_Func8 = -24;
Constant keycode_Func9 = -25;
Constant keycode_Home = -12;
Constant keycode_Left = -2;
Constant keycode_MAXVAL = 28;
Constant keycode_PageDown = -11;
Constant keycode_PageUp = -10;
Constant keycode_Return = -6;
Constant keycode_Right = -3;
Constant keycode_Tab = -9;
Constant keycode_Unknown = -1;
Constant keycode_Up = -4;
Constant seekmode_Current = 1;
Constant seekmode_End = 2;
Constant seekmode_Start = 0;
Constant style_Alert = 5;
Constant style_BlockQuote = 7;
Constant style_Emphasized = 1;
Constant style_Header = 3;
Constant style_Input = 8;
Constant style_NUMSTYLES = 11;
Constant style_Normal = 0;
Constant style_Note = 6;
Constant style_Preformatted = 2;
Constant style_Subheader = 4;
Constant style_User1 = 9;
Constant style_User2 = 10;
Constant stylehint_BackColor = 8;
Constant stylehint_Indentation = 0;
Constant stylehint_Justification = 2;
Constant stylehint_NUMHINTS = 10;
Constant stylehint_Oblique = 5;
Constant stylehint_ParaIndentation = 1;
Constant stylehint_Proportional = 6;
Constant stylehint_ReverseColor = 9;
Constant stylehint_Size = 3;
Constant stylehint_TextColor = 7;
Constant stylehint_Weight = 4;
Constant stylehint_just_Centered = 2;
Constant stylehint_just_LeftFlush = 0;
Constant stylehint_just_LeftRight = 1;
Constant stylehint_just_RightFlush = 3;
Constant winmethod_Above = 2;
Constant winmethod_Below = 3;
Constant winmethod_Border = 0;
Constant winmethod_BorderMask = 256;
Constant winmethod_DirMask = 15;
Constant winmethod_DivisionMask = 240;
Constant winmethod_Fixed = 16;
Constant winmethod_Left = 0;
Constant winmethod_NoBorder = 256;
Constant winmethod_Proportional = 32;
Constant winmethod_Right = 1;
Constant wintype_AllTypes = 0;
Constant wintype_Blank = 2;
Constant wintype_Graphics = 5;
Constant wintype_Pair = 1;
Constant wintype_TextBuffer = 3;
Constant wintype_TextGrid = 4;
Constant GG_MAINWIN_ROCK = 201;
Constant GG_STATUSWIN_ROCK = 202;
Constant GG_QUOTEWIN_ROCK = 203;
Constant GG_SAVESTR_ROCK = 301;
Constant GG_SCRIPTSTR_ROCK = 302;
Constant GG_COMMANDWSTR_ROCK = 303;
Constant GG_COMMANDRSTR_ROCK = 304;
Constant GG_SCRIPTFREF_ROCK = 401;
Constant GG_FOREGROUNDCHAN_ROCK = 410;
Constant GG_BACKGROUNDCHAN_ROCK = 411;
Constant GG_ANYTOSTRING_LEN = 66;
Constant M_0 = 0;
Constant M_1 = 1065353216;
Constant M_HALF = 1056964608;
Constant M_THIRD = 1051372203;
Constant M_LOG10 = 1075010958;
Constant M_N1 = -1082130432;
Constant M_PI = 1078530011;
Constant M_NPI = -1068953637;
Constant M_2PI = 1086918619;
Constant M_PI2 = 1070141403;
Constant M_NPI2 = -1077342245;
Constant M_E = 1076754516;
Constant M_E2 = 1089237798;
Constant M_N0 = -2147483648;
Constant M_INF = 2139095040;
Constant M_NINF = -8388608;
Constant M_NAN = 2139095041;
Constant M_NNAN = -8388607;
Constant AUXF_MAGIC = 0;
Constant AUXF_MAGIC_VALUE = 16339;
Constant AUXF_STATUS = 1;
Constant AUXF_STATUS_IS_CLOSED = 1;
Constant AUXF_STATUS_IS_OPEN_FOR_READ = 2;
Constant AUXF_STATUS_IS_OPEN_FOR_WRITE = 3;
Constant AUXF_STATUS_IS_OPEN_FOR_APPEND = 4;
Constant AUXF_BINARY = 2;
Constant AUXF_STREAM = 3;
Constant AUXF_FILENAME = 4;
Constant AUXF_IFID_OF_OWNER = 5;
Constant TB_COLUMN_REAL = 32768;
Constant TB_COLUMN_SIGNED = 16384;
Constant TB_COLUMN_TOPIC = 8192;
Constant TB_COLUMN_DONTSORTME = 4096;
Constant TB_COLUMN_NOBLANKBITS = 2048;
Constant TB_COLUMN_CANEXCHANGE = 1024;
Constant TB_COLUMN_ALLOCATED = 512;
Constant TB_COLUMN_NUMBER = 511;
Constant COL_HSIZE = 2;
Constant Computed_Constant_Value_16_U1 = 2;
Constant MSTACK_CAPACITY = 20;
Constant RS_NEITHER = 0;
Constant RS_SUCCEEDS = 1;
Constant RS_FAILS = 2;
Constant BLK_HEADER_N = 0;
Constant BLK_HEADER_FLAGS = 1;
Constant BLK_FLAG_MULTIPLE = 1;
Constant BLK_FLAG_16_BIT = 2;
Constant BLK_FLAG_WORD = 4;
Constant BLK_FLAG_RESIDENT = 8;
Constant BLK_FLAG_TRUNCMULT = 16;
Constant BLK_HEADER_KOV = 1;
Constant BLK_HEADER_RCOUNT = 2;
Constant Computed_Constant_Value_19_U1 = 3;
Constant Computed_Constant_Value_21_U1 = 2;
Constant BLK_NEXT = 3;
Constant BLK_PREV = 4;
Constant SMALLEST_BLK_WORTH_ALLOCATING = 12;
Constant BLK_BVBITMAP = 255;
Constant BLK_BVBITMAP_LONGBLOCK = 16;
Constant BLK_BVBITMAP_TEXT = 32;
Constant BLK_BVBITMAP_CONSTANT = 64;
Constant BLK_BVBITMAP_LONGBLOCKMASK = -240;
Constant BLK_BVBITMAP_TEXTMASK = -224;
Constant BLK_BVBITMAP_CONSTANTMASK = -192;
Constant CREATE_KOVS = 1;
Constant CAST_KOVS = 2;
Constant DESTROY_KOVS = 3;
Constant MAKEMUTABLE_KOVS = 4;
Constant COPYKIND_KOVS = 5;
Constant EXTENT_KOVS = 6;
Constant COPYQUICK_KOVS = 7;
Constant COPYSB_KOVS = 8;
Constant KINDDATA_KOVS = 9;
Constant COPY_KOVS = 10;
Constant COMPARE_KOVS = 11;
Constant READ_FILE_KOVS = 12;
Constant WRITE_FILE_KOVS = 13;
Constant HASH_KOVS = 14;
Constant DEBUG_KOVS = 15;
Constant Computed_Constant_Value_26_U1 = 1;
Constant Computed_Constant_Value_29_U1 = 2;
Constant Computed_Constant_Value_31_U1 = 3;
Constant Computed_Constant_Value_34_U1 = 4;
Constant Large_Unicode_Tables = 0;
Constant TEXT_TY_NoBuffers = 2;
Constant CHR_BLOB = 1;
Constant WORD_BLOB = 2;
Constant PWORD_BLOB = 3;
Constant UWORD_BLOB = 4;
Constant PARA_BLOB = 5;
Constant LINE_BLOB = 6;
Constant REGEXP_BLOB = 7;
Constant WS_BRM = 1;
Constant SKIPPED_BRM = 2;
Constant ACCEPTED_BRM = 3;
Constant ACCEPTEDP_BRM = 4;
Constant ACCEPTEDN_BRM = 5;
Constant ACCEPTEDPN_BRM = 6;
Constant UNIC_NCT = 10000;
Constant NEWLINE_RE_CC = -1;
Constant TAB_RE_CC = -2;
Constant DIGIT_RE_CC = -3;
Constant NONDIGIT_RE_CC = -4;
Constant WHITESPACE_RE_CC = -5;
Constant NONWHITESPACE_RE_CC = -6;
Constant PUNCTUATION_RE_CC = -7;
Constant NONPUNCTUATION_RE_CC = -8;
Constant WORD_RE_CC = -9;
Constant NONWORD_RE_CC = -10;
Constant ANYTHING_RE_CC = -11;
Constant NOTHING_RE_CC = -12;
Constant RANGE_RE_CC = -13;
Constant LCASE_RE_CC = -14;
Constant NONLCASE_RE_CC = -15;
Constant UCASE_RE_CC = -16;
Constant NONUCASE_RE_CC = -17;
Constant SUBEXP_RE_CC = -20;
Constant DISJUNCTION_RE_CC = -21;
Constant CHOICE_RE_CC = -22;
Constant QUANTIFIER_RE_CC = -23;
Constant IF_RE_CC = -24;
Constant CONDITION_RE_CC = -25;
Constant THEN_RE_CC = -26;
Constant ELSE_RE_CC = -27;
Constant VARIABLE_RE_CC = -30;
Constant LITERAL_RE_CC = -31;
Constant START_RE_CC = -40;
Constant END_RE_CC = -41;
Constant BOUNDARY_RE_CC = -42;
Constant NONBOUNDARY_RE_CC = -43;
Constant ALWAYS_RE_CC = -44;
Constant NEVER_RE_CC = -45;
Constant SENSITIVITY_RE_CC = -50;
Constant RE_MAX_PACKETS = 32;
Constant RE_PACKET_SIZE = 14;
Constant RE_CCLASS = 0;
Constant RE_PAR1 = 1;
Constant RE_PAR2 = 2;
Constant RE_PAR3 = 3;
Constant RE_NEXT = 4;
Constant RE_PREVIOUS = 5;
Constant RE_DOWN = 6;
Constant RE_UP = 7;
Constant RE_DATA1 = 8;
Constant RE_DATA2 = 9;
Constant RE_CONSTRAINT = 10;
Constant RE_CACHE1 = 11;
Constant RE_CACHE2 = 12;
Constant RE_MODES = 13;
Constant CIS_MFLAG = 1;
Constant ACCUM_MFLAG = 2;
Constant LIST_ITEM_KOV_F = 0;
Constant LIST_LENGTH_F = 1;
Constant LIST_ITEM_BASE = 2;
Constant COMBINATION_KIND_F = 0;
Constant COMBINATION_ITEM_BASE = 1;
Constant Computed_Constant_Value_42_U1 = 5;
Constant Computed_Constant_Value_44_U1 = 5;
Constant Computed_Constant_Value_46_U1 = 5;
Constant Computed_Constant_Value_48_U1 = 5;
Constant Computed_Constant_Value_50_U1 = 5;
Constant Computed_Constant_Value_52_U1 = 5;
Constant RRV_USED = 6;
Constant RRV_FILLED = 7;
Constant RRV_DATA_BASE = 8;
Constant RRVAL_V_TO_V = 0;
Constant RRF_USED = 1;
Constant RRF_DELETED = 2;
Constant RRF_SINGLE = 4;
Constant RRF_HASX = 16;
Constant RRF_HASY = 32;
Constant RRF_ENTKEYX = 64;
Constant RRF_ENTKEYY = 128;
Constant RELS_COPY = 32;
Constant RELS_DESTROY = 16;
Constant RELS_EMPTY = 3;
Constant RELS_SET_VALENCY = 5;
Constant RLANY_GET_X = 1;
Constant RLANY_GET_Y = 2;
Constant RLANY_CAN_GET_X = 3;
Constant RLANY_CAN_GET_Y = 4;
Constant RLIST_ALL_X = 1;
Constant RLIST_ALL_Y = 2;
Constant RLIST_ALL_PAIRS = 3;
Constant RRP_MIN_SIZE = 8;
Constant RRP_PERTURB_SHIFT = 5;
Constant MINUS_RRP_PERTURB_SHIFT = -5;
Constant RRP_RESIZE_SMALL = 4;
Constant RRP_RESIZE_LARGE = 2;
Constant RRP_LARGE_IS = 256;
Constant RRP_CROWDED_IS = 2;
Constant RR_NAME = 5;
Constant RR_PERMISSIONS = 6;
Constant RR_STORAGE = 7;
Constant RR_KIND = 8;
Constant RR_HANDLER = 9;
Constant RR_DESCRIPTION = 10;
Constant VTOVS_LEFT_INDEX_PROP = 0;
Constant VTOVS_RIGHT_INDEX_PROP = 1;
Constant VTOVS_LEFT_DOMAIN_SIZE = 2;
Constant VTOVS_RIGHT_DOMAIN_SIZE = 3;
Constant VTOVS_LEFT_PRINTING_ROUTINE = 4;
Constant VTOVS_RIGHT_PRINTING_ROUTINE = 5;
Constant VTOVS_CACHE_BROKEN = 6;
Constant VTOVS_CACHE = 7;
Constant Computed_Constant_Value_61_U1 = 32;
Constant MAX_TIMERS = 0;
Constant Computed_Constant_Value_14_U1 = 1;
Constant Computed_Constant_Value_37_U1 = 2;
Constant property_id_U97 = 96;
Constant property_id_U98 = 97;
Constant property_id_U99 = 98;
Constant property_id_U100 = 99;
Constant property_id_U101 = 100;
Constant property_id_U102 = 101;
Constant property_id_U103 = 102;
Constant property_id_U104 = 103;
Constant property_id_U105 = 104;
Constant property_id_U106 = 105;
Constant property_id_U107 = 106;
Constant property_id_U108 = 107;
Constant property_id_U109 = 108;
Constant property_id_U110 = 109;
Constant property_id_U111 = 110;
Constant property_id_U112 = 111;
Constant property_id_U113 = 112;
Constant property_id_U114 = 113;
Constant property_id_U115 = 114;
Constant property_id_U116 = 115;
Constant property_id_U117 = 116;
Constant property_id_U118 = 117;
Constant property_id_U119 = 118;
Constant property_id_U120 = 119;
Constant property_id_U121 = 120;
Constant property_id_U122 = 121;
Constant property_id_U123 = 122;
Constant property_id_U124 = 123;
Constant property_id_U125 = 124;
Constant property_id_U126 = 125;
Constant property_id_U127 = 126;
Constant property_id_U128 = 127;
Constant property_id_U129 = 128;
Constant property_id_U130 = 129;
Constant property_id_U131 = 130;
Constant property_id_U132 = 131;
Constant property_id_U133 = 132;
Constant property_id_U134 = 133;
Constant property_id_U135 = 134;
Constant property_id_U136 = 135;
Constant property_id_U137 = 136;
Constant property_id_U138 = 137;
Constant property_id_U139 = 138;
Constant property_id_U140 = 139;
Constant property_id_U141 = 140;
Constant property_id_U142 = 141;
Constant property_id_U143 = 142;
Constant property_id_U144 = 143;
Constant property_id_U145 = 144;
Constant property_id_U146 = 145;
Constant property_id_U147 = 146;
Constant property_id_U148 = 147;
Constant property_id_U149 = 148;
Constant property_id_U150 = 149;
Constant property_id_U151 = 150;
Constant property_id_U152 = 151;
Constant property_id_U153 = 152;
Constant property_id_U154 = 153;
Constant property_id_U155 = 154;
Constant property_id_U156 = 155;
Constant property_id_U157 = 156;
Constant property_id_U158 = 157;
Constant property_id_U159 = 158;
Constant property_id_U160 = 159;
Constant property_id_U161 = 160;
Constant property_id_U162 = 161;
Constant property_id_U163 = 162;
Constant property_id_U164 = 163;
Constant property_id_U165 = 164;
Constant property_id_U166 = 165;
Constant property_id_U167 = 166;
Constant property_id_U168 = 167;
Constant property_id_U169 = 168;
Constant property_id_U170 = 169;
Constant property_id_U171 = 170;
Constant ENGLISHLANGUAGEKIT = 1;
Constant AGAIN1__WD = 'again';
Constant AGAIN2__WD = 'g//';
Constant AGAIN3__WD = 'again';
Constant OOPS1__WD = 'oops';
Constant OOPS2__WD = 'o//';
Constant OOPS3__WD = 'oops';
Constant UNDO1__WD = 'undo';
Constant UNDO2__WD = 'undo';
Constant UNDO3__WD = 'undo';
Constant ALL1__WD = 'all';
Constant ALL2__WD = 'each';
Constant ALL3__WD = 'every';
Constant ALL4__WD = 'everything';
Constant ALL5__WD = 'both';
Constant AND1__WD = 'and';
Constant AND2__WD = 'and';
Constant AND3__WD = 'and';
Constant BUT1__WD = 'but';
Constant BUT2__WD = 'except';
Constant BUT3__WD = 'but';
Constant ME1__WD = 'me';
Constant ME2__WD = 'myself';
Constant ME3__WD = 'self';
Constant OF1__WD = 'of';
Constant OF2__WD = 'of';
Constant OF3__WD = 'of';
Constant OF4__WD = 'of';
Constant OTHER1__WD = 'another';
Constant OTHER2__WD = 'other';
Constant OTHER3__WD = 'other';
Constant THEN1__WD = 'then';
Constant THEN2__WD = 'then';
Constant THEN3__WD = 'then';
Constant NO1__WD = 'n//';
Constant NO2__WD = 'no';
Constant NO3__WD = 'no';
Constant YES1__WD = 'y//';
Constant YES2__WD = 'yes';
Constant YES3__WD = 'yes';
Constant AMUSING__WD = 'amusing';
Constant FULLSCORE1__WD = 'fullscore';
Constant FULLSCORE2__WD = 'full';
Constant QUIT1__WD = 'q//';
Constant QUIT2__WD = 'quit';
Constant RESTART__WD = 'restart';
Constant RESTORE__WD = 'restore';
Constant LanguageAnimateGender = A_male;
Constant LanguageInanimateGender = A_neuter;
Constant LanguageContractionForms = 2;
Constant WORLDMODELKIT = 1;
Constant Computed_Constant_Value_0_U3 = 2;
Constant Computed_Constant_Value_2_U3 = 3;
Constant SEEK_ITF = 0;
Constant ADVANCE_ITF = 1;
Constant COALESCE_ITF = 2;
Constant START_ITF = 3;
Constant ACTION_PRES = 0;
Constant NO_INPS_PRES = 1;
Constant INP1_PRES = 2;
Constant INP2_PRES = 3;
Constant AD_ACTION = 0;
Constant AD_REQUIREMENTS = 1;
Constant AD_NOUN_KOV = 2;
Constant AD_SECOND_KOV = 3;
Constant AD_VARIABLES_CREATOR = 4;
Constant AD_VARIABLES_ID = 5;
Constant AD_RECORD_SIZE = 6;
Constant TOUCH_NOUN_ABIT = 1;
Constant TOUCH_SECOND_ABIT = 2;
Constant LIGHT_ABIT = 4;
Constant NEED_NOUN_ABIT = 8;
Constant NEED_SECOND_ABIT = 16;
Constant OUT_OF_WORLD_ABIT = 32;
Constant CARRY_NOUN_ABIT = 64;
Constant CARRY_SECOND_ABIT = 128;
Constant MAX_NESTED_ACTIVITIES = 20;
Constant FAST_ROUTE_FINDING = 0;
Constant TEST_STACK_SIZE = 128;
Constant STORA_ACTION_F = 0;
Constant STORA_NOUN_F = 1;
Constant STORA_SECOND_F = 2;
Constant STORA_ACTOR_F = 3;
Constant STORA_REQUEST_F = 4;
Constant STORA_COMMAND_TEXT_F = 5;
Constant Computed_Constant_Value_4_U2 = 0;
Constant Computed_Constant_Value_6_U2 = 5;
Constant Computed_Constant_Value_8_U2 = 1;
Constant Computed_Constant_Value_11_U2 = 1;
Constant Computed_Constant_Value_13_U2 = 1;
Constant Computed_Constant_Value_15_U2 = 1;
Constant Computed_Constant_Value_17_U2 = 1;
Constant Computed_Constant_Value_19_U2 = 1;
Constant Computed_Constant_Value_21_U2 = 1;
Constant action_id_U78 = 77;
Constant action_id_U79 = 78;
Constant action_id_U80 = 79;
Constant action_id_U81 = 80;
Constant action_id_U82 = 81;
Constant action_id_U83 = 82;
Constant action_id_U84 = 83;
Constant action_id_U85 = 84;
Constant action_id_U86 = 85;
Constant action_id_U87 = 86;
Constant action_id_U88 = 87;
Constant action_id_U89 = 88;
Constant action_id_U90 = 89;
Constant action_id_U91 = 90;
Constant action_id_U92 = 91;
Constant action_id_U93 = 92;
Constant action_id_U94 = 93;
Constant action_id_U95 = 94;
Constant action_id_U96 = 95;
Constant action_id_U97 = 96;
Constant action_id_U98 = 97;
Constant action_id_U99 = 98;
Constant action_id_U100 = 99;
Constant COMMANDPARSERKIT = 1;
Constant STUCK_PE = 1;
Constant UPTO_PE = 2;
Constant NUMBER_PE = 3;
Constant ANIMA_PE = 4;
Constant CANTSEE_PE = 5;
Constant TOOLIT_PE = 6;
Constant NOTHELD_PE = 7;
Constant MULTI_PE = 8;
Constant MMULTI_PE = 9;
Constant VAGUE_PE = 10;
Constant EXCEPT_PE = 11;
Constant VERB_PE = 12;
Constant SCENERY_PE = 13;
Constant ITGONE_PE = 14;
Constant JUNKAFTER_PE = 15;
Constant TOOFEW_PE = 16;
Constant NOTHING_PE = 17;
Constant ASKSCOPE_PE = 18;
Constant NOTINCONTEXT_PE = 19;
Constant BLANKLINE_PE = 20;
Constant ANIMAAGAIN_PE = 21;
Constant COMMABEGIN_PE = 22;
Constant MISSINGPERSON_PE = 23;
Constant ANIMALISTEN_PE = 24;
Constant TOTALK_PE = 25;
Constant PATTERN_NULL = 65535;
Constant INDEF_ALL_WANTED = 32767;
Constant comma_word = 'comma,';
Constant OTHER_BIT = 1;
Constant MY_BIT = 2;
Constant THAT_BIT = 4;
Constant PLURAL_BIT = 8;
Constant LIT_BIT = 16;
Constant UNLIT_BIT = 32;
Constant SCORE__CHOOSEOBJ = 1000;
Constant SCORE__IFGOOD = 500;
Constant SCORE__UNCONCEALED = 100;
Constant SCORE__BESTLOC = 60;
Constant SCORE__NEXTBESTLOC = 40;
Constant SCORE__NOTCOMPASS = 20;
Constant SCORE__NOTSCENERY = 10;
Constant SCORE__NOTACTOR = 5;
Constant SCORE__GNA = 1;
Constant SCORE__DIVISOR = 20;
Constant PREFER_HELD = 0;
Constant HIGHEST_DPMR_SCORE = 4;
Constant Computed_Constant_Value_0_U4 = 1;
Constant EMPTY_TEXT_PACKED = "";
Constant I7_VERSION_NUMBER = "10.1.2";
Constant I7_FULL_VERSION_NUMBER = "10.1.2";
Serial "221030";
Constant alphabetised_text_0 = ">";
Constant alphabetised_text_1 = "An Interactive Fiction";
Constant alphabetised_text_2 = "As good-looking as ever.";
Constant alphabetised_text_3 = "Basement";
Constant alphabetised_text_4 = "Bathroom";
Constant alphabetised_text_5 = "Big Room";
Constant alphabetised_text_6 = "Fiction";
Constant alphabetised_text_7 = "Girl's Room";
Constant alphabetised_text_8 = "Hallway";
Constant alphabetised_text_9 = "If you rub it on something, the something turns light blue.";
Constant alphabetised_text_10 = "It has fallen over.";
Constant alphabetised_text_11 = "It is magical because of its colors.";
Constant alphabetised_text_12 = "Kitchen";
Constant alphabetised_text_13 = "Living Room";
Constant alphabetised_text_14 = "Pantry";
Constant alphabetised_text_15 = "Patio";
Constant alphabetised_text_16 = "QUIT";
Constant alphabetised_text_17 = "RESTART";
Constant alphabetised_text_18 = "RESTORE a saved game";
Constant alphabetised_text_19 = "Savleen";
Constant alphabetised_text_20 = "Savleen and Daddy";
Constant alphabetised_text_21 = "Simi";
Constant alphabetised_text_22 = "The Magic Kitchen";
Constant alphabetised_text_23 = "The kitchen has new white marble tiles but is not yet finished.";
Constant alphabetised_text_24 = "These are light blue squares.";
Constant alphabetised_text_25 = "UNDO the last command";
Constant alphabetised_text_26 = "Yourself";
Constant outcome_allow_access_U1 = "allow access";
Constant outcome_allow_startup_U1 = "allow startup";
Constant alphabetised_text_27 = "animals";
Constant alphabetised_text_28 = "backdrops";
Constant alphabetised_text_29 = "blue chalk";
Constant alphabetised_text_30 = "containers";
Constant outcome_deny_access_U1 = "deny access";
Constant outcome_deny_startup_U1 = "deny startup";
Constant alphabetised_text_31 = "devices";
Constant alphabetised_text_32 = "directions";
Constant alphabetised_text_33 = "doors";
Constant alphabetised_text_34 = "down";
Constant alphabetised_text_35 = "east";
Constant alphabetised_text_36 = "inside";
Constant outcome_it_does_U1 = "it does";
Constant outcome_it_does_not_U1 = "it does not";
Constant outcome_it_is_likely_U1 = "it is likely";
Constant outcome_it_is_possible_U1 = "it is possible";
Constant outcome_it_is_unlikely_U1 = "it is unlikely";
Constant outcome_it_is_very_likely_U1 = "it is very likely";
Constant outcome_it_is_very_unlikely_U1 = "it is very unlikely";
Constant alphabetised_text_37 = "little girls";
Constant alphabetised_text_38 = "magic bottle";
Constant alphabetised_text_39 = "makeup table";
Constant alphabetised_text_40 = "men";
Constant alphabetised_text_41 = "milky";
Constant alphabetised_text_42 = "north";
Constant alphabetised_text_43 = "northeast";
Constant alphabetised_text_44 = "northwest";
Constant alphabetised_text_45 = "outside";
Constant alphabetised_text_46 = "people";
Constant outcome_persuasion_fails_U1 = "persuasion fails";
Constant outcome_persuasion_succeeds_U1 = "persuasion succeeds";
Constant alphabetised_text_47 = "player's holdalls";
Constant alphabetised_text_48 = "regions";
Constant alphabetised_text_49 = "see some suggestions for AMUSING things to do";
Constant alphabetised_text_50 = "south";
Constant alphabetised_text_51 = "southeast";
Constant alphabetised_text_52 = "southwest";
Constant alphabetised_text_53 = "stool";
Constant alphabetised_text_54 = "stories";
Constant alphabetised_text_55 = "supporters";
Constant alphabetised_text_56 = "the";
Constant outcome_there_is_insufficien_U1 = "there is insufficient light";
Constant outcome_there_is_sufficient__U1 = "there is sufficient light";
Constant alphabetised_text_57 = "up";
Constant alphabetised_text_58 = "vehicles";
Constant alphabetised_text_59 = "west";
Constant alphabetised_text_60 = "women";
Constant alphabetised_text_61 = "yourself";
Constant V1_starting_the_virtual_mach = activity_id_U1;
Constant V2_printing_the_name = activity_id_U2;
Constant V3_printing_the_plural_name = activity_id_U3;
Constant text_U1 = alphabetised_text_42;
Constant text_U2 = alphabetised_text_56;
Constant text_U3 = alphabetised_text_32;
Constant text_U4 = alphabetised_text_43;
Constant text_U5 = alphabetised_text_56;
Constant text_U6 = alphabetised_text_32;
Constant text_U7 = alphabetised_text_44;
Constant text_U8 = alphabetised_text_56;
Constant text_U9 = alphabetised_text_32;
Constant text_U10 = alphabetised_text_50;
Constant text_U11 = alphabetised_text_56;
Constant text_U12 = alphabetised_text_32;
Constant text_U13 = alphabetised_text_51;
Constant text_U14 = alphabetised_text_56;
Constant text_U15 = alphabetised_text_32;
Constant text_U16 = alphabetised_text_52;
Constant text_U17 = alphabetised_text_56;
Constant text_U18 = alphabetised_text_32;
Constant text_U19 = alphabetised_text_35;
Constant text_U20 = alphabetised_text_56;
Constant text_U21 = alphabetised_text_32;
Constant text_U22 = alphabetised_text_59;
Constant text_U23 = alphabetised_text_56;
Constant text_U24 = alphabetised_text_32;
Constant text_U25 = alphabetised_text_57;
Constant text_U26 = alphabetised_text_56;
Constant text_U27 = alphabetised_text_32;
Constant text_U28 = alphabetised_text_34;
Constant text_U29 = alphabetised_text_56;
Constant text_U30 = alphabetised_text_32;
Constant text_U31 = alphabetised_text_36;
Constant text_U32 = alphabetised_text_56;
Constant text_U33 = alphabetised_text_32;
Constant text_U34 = alphabetised_text_45;
Constant text_U35 = alphabetised_text_56;
Constant text_U36 = alphabetised_text_32;
Constant text_U37 = alphabetised_text_61;
Constant text_U38 = alphabetised_text_2;
Constant text_U39 = alphabetised_text_26;
Constant text_U40 = alphabetised_text_61;
Constant text_U41 = alphabetised_text_46;
Constant RBNO0_OUTCOME_U1 = outcome_it_is_very_unlikely_U1;
Constant RBNO4_OUTCOME_U1 = outcome_it_is_very_likely_U1;
Constant RBNO3_OUTCOME_U1 = outcome_it_is_likely_U1;
Constant RBNO2_OUTCOME_U1 = outcome_it_is_possible_U1;
Constant RBNO1_OUTCOME_U1 = outcome_it_is_unlikely_U1;
Constant V4_issuing_the_response_text = activity_id_U4;
Constant V5_printing_a_number = activity_id_U5;
Constant V6_printing_room_description = activity_id_U6;
Constant V7_printing_inventory_detail = activity_id_U7;
Constant V8_listing_contents = activity_id_U8;
Constant V9_grouping_together = activity_id_U9;
Constant V10_writing_a_paragraph_about = activity_id_U10;
Constant V11_listing_nondescript_items = activity_id_U11;
Constant V12_printing_the_name_of_a_da = activity_id_U12;
Constant V13_printing_the_description_ = activity_id_U13;
Constant V14_printing_the_announcement = activity_id_U14;
Constant V15_printing_the_announcement = activity_id_U15;
Constant V16_printing_a_refusal_to_act = activity_id_U16;
Constant V17_constructing_the_status_l = activity_id_U17;
Constant V18_printing_the_banner_text = activity_id_U18;
Constant V19_reading_a_command = activity_id_U19;
Constant V20_deciding_the_scope = activity_id_U20;
Constant V21_deciding_the_concealed_po = activity_id_U21;
Constant V22_deciding_whether_all_incl = activity_id_U22;
Constant V23_clarifying_the_parser_s_c = activity_id_U23;
Constant V24_asking_which_do_you_mean = activity_id_U24;
Constant V25_printing_a_parser_error = activity_id_U25;
Constant V26_supplying_a_missing_noun = activity_id_U26;
Constant V27_supplying_a_missing_secon = activity_id_U27;
Constant V28_implicitly_taking = activity_id_U28;
Constant V29_amusing_a_victorious_play = activity_id_U29;
Constant V30_printing_the_player_s_obi = activity_id_U30;
Constant V31_handling_the_final_questi = activity_id_U31;
Constant V32_printing_the_locale_descr = activity_id_U32;
Constant V33_choosing_notable_locale_o = activity_id_U33;
Constant V34_printing_a_locale_paragra = activity_id_U34;
Constant text_U42 = alphabetised_text_32;
Constant K4_door_First = nothing;
Constant text_U43 = alphabetised_text_33;
Constant K5_container_First = nothing;
Constant text_U44 = alphabetised_text_30;
Constant K6_supporter_First = nothing;
Constant text_U45 = alphabetised_text_55;
Constant K7_backdrop_First = nothing;
Constant text_U46 = alphabetised_text_28;
Constant text_U47 = alphabetised_text_46;
Constant K9_region_First = nothing;
Constant text_U48 = alphabetised_text_48;
Constant K10_man_First = nothing;
Constant text_U49 = alphabetised_text_40;
Constant K11_woman_First = nothing;
Constant text_U50 = alphabetised_text_60;
Constant K12_animal_First = nothing;
Constant text_U51 = alphabetised_text_27;
Constant K13_device_First = nothing;
Constant text_U52 = alphabetised_text_31;
Constant K14_vehicle_First = nothing;
Constant text_U53 = alphabetised_text_58;
Constant K15_player_s_holdall_First = nothing;
Constant text_U54 = alphabetised_text_47;
Constant text_U55 = alphabetised_text_0;
Constant text_U56 = alphabetised_text_20;
Constant text_U57 = alphabetised_text_1;
Constant text_U58 = alphabetised_text_6;
Constant column_identity_U1 = table_column_id_U1;
Constant text_U59 = alphabetised_text_17;
Constant text_U60 = alphabetised_text_18;
Constant text_U61 = alphabetised_text_49;
Constant text_U62 = alphabetised_text_16;
Constant text_U63 = alphabetised_text_25;
Constant column_identity_U2 = table_column_id_U2;
Constant column_identity_U3 = table_column_id_U3;
Constant column_identity_U4 = table_column_id_U4;
Constant column_identity_U5 = table_column_id_U5;
Constant column_identity_U6 = table_column_id_U6;
Constant column_identity_U7 = table_column_id_U7;
Constant text_U64 = alphabetised_text_12;
Constant text_U65 = alphabetised_text_23;
Constant text_U66 = alphabetised_text_8;
Constant text_U67 = alphabetised_text_7;
Constant text_U68 = alphabetised_text_5;
Constant text_U69 = alphabetised_text_4;
Constant text_U70 = alphabetised_text_14;
Constant text_U71 = alphabetised_text_3;
Constant text_U72 = alphabetised_text_15;
Constant text_U73 = alphabetised_text_13;
Constant text_U74 = alphabetised_text_39;
Constant text_U75 = alphabetised_text_54;
Constant text_U76 = alphabetised_text_24;
Constant text_U77 = alphabetised_text_38;
Constant text_U78 = alphabetised_text_11;
Constant text_U79 = alphabetised_text_29;
Constant text_U80 = alphabetised_text_9;
Constant text_U81 = alphabetised_text_53;
Constant text_U82 = alphabetised_text_10;
Constant text_U83 = alphabetised_text_21;
Constant text_U84 = alphabetised_text_37;
Constant text_U85 = alphabetised_text_41;
Constant text_U86 = alphabetised_text_19;
Constant text_U87 = alphabetised_text_37;
Constant text_U88 = alphabetised_text_37;
Constant abilities_U3 = (RELS_TEST);
Constant abilities_U4 = (RELS_TEST);
Constant abilities_U6 = (RELS_TEST);
Constant abilities_U7 = (RELS_TEST);
Constant text_U89 = alphabetised_text_22;
Constant text_U90 = alphabetised_text_1;
Constant text_U91 = alphabetised_text_20;
Constant GPR_REPARSE = REPARSE_CODE;
Constant TABLE_NOVALUE = IMPROBABLE_VALUE;
Constant RC_INFINITY = MAX_POSITIVE_NUMBER;
Constant RRVAL_V_TO_O = RELS_Y_UNIQUE;
Constant RRVAL_O_TO_V = RELS_X_UNIQUE;
Constant RRVAL_SYM_V_TO_V = RELS_SYMMETRIC;
Constant NUMBER_SCENES_CREATED = ICOUNT_SCENE;
Constant ActionCount = CCOUNT_ACTION_NAME;
Constant NUM_DOORS = ICOUNT_DOOR;
Constant NUM_ROOMS = ICOUNT_ROOM;
Constant Computed_Constant_Value_2_U1 = (Computed_Constant_Value_0_U1 + Computed_Constant_Value_1_U1);
Constant Computed_Constant_Value_1_U2 = (GPR_NOUN + Computed_Constant_Value_0_U2);
Constant Computed_Constant_Value_3_U1 = (GPR_NOUN + Computed_Constant_Value_2_U2);
Constant Computed_Constant_Value_5_U1 = (GPR_NOUN + Computed_Constant_Value_4_U1);
Constant Computed_Constant_Value_7_U1 = (GPR_NOUN + Computed_Constant_Value_6_U1);
Constant Computed_Constant_Value_9_U1 = (GPR_NOUN + Computed_Constant_Value_8_U1);
Constant Computed_Constant_Value_11_U1 = (GPR_NOUN + Computed_Constant_Value_10_U1);
Constant Computed_Constant_Value_13_U1 = (DynamicMemoryAllocation / Computed_Constant_Value_12_U1);
Constant Computed_Constant_Value_17_U1 = (Computed_Constant_Value_16_U1 + MAX_FRAME_SIZE_NEEDED);
Constant Computed_Constant_Value_20_U1 = (Computed_Constant_Value_19_U1 * WORDSIZE);
Constant Computed_Constant_Value_22_U1 = (Computed_Constant_Value_21_U1 * WORDSIZE);
Constant Computed_Constant_Value_25_U1 = (BLK_BVBITMAP_TEXT + BLK_BVBITMAP_CONSTANT);
Constant Computed_Constant_Value_28_U1 = (BLK_BVBITMAP_TEXT + BLK_BVBITMAP_CONSTANT);
Constant Computed_Constant_Value_32_U1 = (BLK_BVBITMAP_TEXT + Computed_Constant_Value_31_U1);
Constant Computed_Constant_Value_33_U1 = (BLK_BVBITMAP_TEXT + BLK_BVBITMAP_LONGBLOCK);
Constant Computed_Constant_Value_36_U1 = (BLK_FLAG_MULTIPLE + BLK_FLAG_16_BIT);
Constant Computed_Constant_Value_40_U1 = (WORDSIZE * RE_PACKET_SIZE);
Constant Computed_Constant_Value_43_U1 = (RR_NAME - Computed_Constant_Value_42_U1);
Constant Computed_Constant_Value_45_U1 = (RR_PERMISSIONS - Computed_Constant_Value_44_U1);
Constant Computed_Constant_Value_47_U1 = (RR_STORAGE - Computed_Constant_Value_46_U1);
Constant Computed_Constant_Value_49_U1 = (RR_KIND - Computed_Constant_Value_48_U1);
Constant Computed_Constant_Value_51_U1 = (RR_HANDLER - Computed_Constant_Value_50_U1);
Constant Computed_Constant_Value_53_U1 = (RR_DESCRIPTION - Computed_Constant_Value_52_U1);
Constant Computed_Constant_Value_54_U1 = (RELS_X_UNIQUE + RELS_Y_UNIQUE);
Constant Computed_Constant_Value_55_U1 = (RELS_EQUIVALENCE + RELS_SYMMETRIC);
Constant Computed_Constant_Value_56_U1 = (RELS_SYMMETRIC + RELS_X_UNIQUE);
Constant Computed_Constant_Value_58_U1 = (RELS_EQUIVALENCE + RELS_SYMMETRIC);
Constant Computed_Constant_Value_62_U1 = (ICOUNT_OBJECT + Computed_Constant_Value_61_U1);
Constant Computed_Constant_Value_15_U1 = (GG_ANYTOSTRING_LEN + Computed_Constant_Value_14_U1);
Constant Computed_Constant_Value_41_U1 = (RE_MAX_PACKETS * RE_PACKET_SIZE);
Constant Computed_Constant_Value_3_U2 = (Computed_Constant_Value_2_U3 * ICOUNT_OBJECT);
Constant Computed_Constant_Value_5_U2 = (ICOUNT_FIGURE_NAME + ICOUNT_SOUND_NAME);
Constant Computed_Constant_Value_12_U2 = (NO_PAST_TENSE_ACTIONS + Computed_Constant_Value_11_U2);
Constant Computed_Constant_Value_14_U2 = (NO_PAST_TENSE_ACTIONS + Computed_Constant_Value_13_U2);
Constant Computed_Constant_Value_16_U2 = (NO_PAST_TENSE_ACTIONS + Computed_Constant_Value_15_U2);
Constant Computed_Constant_Value_18_U2 = (NO_PAST_TENSE_ACTIONS + Computed_Constant_Value_17_U2);
Constant Computed_Constant_Value_20_U2 = (NO_PAST_TENSE_CONDS + Computed_Constant_Value_19_U2);
Constant Computed_Constant_Value_22_U2 = (NO_PAST_TENSE_CONDS + Computed_Constant_Value_21_U2);
Constant Computed_Constant_Value_1_U4 = (MATCH_LIST_WORDS + Computed_Constant_Value_0_U4);
Constant TEXT_TY_BufferSize = Computed_Constant_Value_2_U1;
Constant GPR_HELD = Computed_Constant_Value_1_U2;
Constant GPR_MULTI = Computed_Constant_Value_3_U1;
Constant GPR_MULTIHELD = Computed_Constant_Value_5_U1;
Constant GPR_MULTIEXCEPT = Computed_Constant_Value_7_U1;
Constant GPR_MULTIINSIDE = Computed_Constant_Value_9_U1;
Constant GPR_CREATURE = Computed_Constant_Value_11_U1;
Constant BLOCKV_STACK_SIZE = Computed_Constant_Value_13_U1;
Constant MAX_MSTACK_FRAME = Computed_Constant_Value_17_U1;
Constant BLK_DATA_OFFSET = Computed_Constant_Value_20_U1;
Constant PACKED_TEXT_STORAGE = Computed_Constant_Value_32_U1;
Constant TEXT_TY_Storage_Flags = Computed_Constant_Value_36_U1;
Constant RE_PACKET_SIZE_IN_BYTES = Computed_Constant_Value_40_U1;
Constant RRV_NAME = Computed_Constant_Value_43_U1;
Constant RRV_PERMISSIONS = Computed_Constant_Value_45_U1;
Constant RRV_STORAGE = Computed_Constant_Value_47_U1;
Constant RRV_KIND = Computed_Constant_Value_49_U1;
Constant RRV_HANDLER = Computed_Constant_Value_51_U1;
Constant RRV_DESCRIPTION = Computed_Constant_Value_53_U1;
Constant RRVAL_O_TO_O = Computed_Constant_Value_54_U1;
Constant RRVAL_EQUIV = Computed_Constant_Value_55_U1;
Constant MAX_ROUTE_LENGTH = Computed_Constant_Value_62_U1;
Constant Computed_Constant_Value_1_U3 = (NUMBER_SCENES_CREATED + Computed_Constant_Value_0_U3);
Constant REQUISITION_STACK_SIZE = Computed_Constant_Value_3_U2;
Constant Computed_Constant_Value_9_U2 = (NUM_DOORS + Computed_Constant_Value_8_U2);
Constant strong_id_U2 = DK2_activity_on_objects;
Constant strong_id_U3 = DK3_phrase_real_number____re;
Constant strong_id_U4 = DK4_phrase_real_number____nu;
Constant SCENE_ARRAY_SIZE = Computed_Constant_Value_1_U3;
Constant Computed_Constant_Value_10_U2 = (NUM_ROOMS * NUM_ROOMS);
Constant Computed_Constant_Value_27_U1 = (Computed_Constant_Value_25_U1 + Computed_Constant_Value_26_U1);
Constant Computed_Constant_Value_30_U1 = (Computed_Constant_Value_28_U1 + Computed_Constant_Value_29_U1);
Constant Computed_Constant_Value_35_U1 = (Computed_Constant_Value_33_U1 + Computed_Constant_Value_34_U1);
Constant Computed_Constant_Value_57_U1 = (Computed_Constant_Value_56_U1 + RELS_Y_UNIQUE);
Constant Computed_Constant_Value_59_U1 = (Computed_Constant_Value_58_U1 + RELS_X_UNIQUE);
Constant Computed_Constant_Value_7_U2 = (Computed_Constant_Value_5_U2 + Computed_Constant_Value_6_U2);
Constant strong_id_U1 = DK1_rule;
Constant strong_id_U5 = DK10_relation_of_rooms_to_doo;
Constant strong_id_U6 = DK5_relation_of_values;
Constant strong_id_U7 = DK6_relation_of_objects;
Constant strong_id_U8 = DK7_relation_of_supporters_t;
Constant strong_id_U9 = DK8_relation_of_things;
Constant strong_id_U10 = DK9_relation_of_people_to_th;
Constant Computed_Constant_Value_18_U1 = (MSTACK_CAPACITY * MAX_MSTACK_FRAME);
Constant CONSTANT_PACKED_TEXT_STORAGE = Computed_Constant_Value_27_U1;
Constant CONSTANT_PERISHABLE_TEXT_STORAGE = Computed_Constant_Value_30_U1;
Constant UNPACKED_TEXT_STORAGE = Computed_Constant_Value_35_U1;
Constant RRVAL_SYM_O_TO_O = Computed_Constant_Value_57_U1;
Constant Computed_Constant_Value_38_U1 = (TEXT_TY_BufferSize + Computed_Constant_Value_37_U1);
Constant MSTACK_SIZE = Computed_Constant_Value_18_U1;
Constant abilities_U11 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant abilities_U15 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant abilities_U16 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant abilities_U17 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant abilities_U18 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST);
Constant Computed_Constant_Value_60_U1 = (Computed_Constant_Value_59_U1 + RELS_Y_UNIQUE);
Constant Computed_Constant_Value_23_U1 = (BLK_DATA_OFFSET + Computed_Constant_Value_22_U1);
Constant VALENCY_MASK = Computed_Constant_Value_60_U1;
Constant Computed_Constant_Value_39_U1 = (Computed_Constant_Value_38_U1 * TEXT_TY_NoBuffers);
Constant BLK_DATA_MULTI_OFFSET = Computed_Constant_Value_23_U1;
Constant Story = bc_U260;
Constant Headline = bc_U261;
Constant Story_Author = bc_U262;
Constant Computed_Constant_Value_24_U1 = (MEMORY_HEAP_SIZE + BLK_DATA_MULTI_OFFSET);
Constant abilities_U5 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U8 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U9 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U10 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U12 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U13 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U14 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_LOOKUP_ANY);
Constant abilities_U1 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_X_UNIQUE + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_SHOW + RELS_ROUTE_FIND);
Constant abilities_U2 = (RELS_TEST + RELS_LOOKUP_ANY + RELS_LOOKUP_ALL_X + RELS_LOOKUP_ALL_X + RELS_LIST + RELS_X_UNIQUE + RELS_ASSERT_TRUE + RELS_ASSERT_FALSE + RELS_SHOW + RELS_ROUTE_FIND);
Constant MEANINGLESS_RR = Rel_Record18;
Fake_Action ListMiscellany;
Fake_Action Miscellany;
Fake_Action PluralFound;
Fake_Action TheSame;
Array A_absent --> [ 2; subterfuge_1; 1; "absent"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_animate --> [ 2; subterfuge_2; 1; "animate"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_clothing --> [ 2; subterfuge_3; 1; "wearable"; K2_thing; NULL; ];
Array A_concealed --> [ 2; subterfuge_4; 1; "undescribed"; K2_thing; NULL; ];
Array A_container --> [ 2; subterfuge_5; 1; "container"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_door --> [ 2; subterfuge_6; 1; "door"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_edible --> [ 2; subterfuge_7; 1; "edible"; K2_thing; NULL; ];
Array A_enterable --> [ 2; subterfuge_8; 1; "enterable"; K6_supporter; K5_container; NULL; ];
Array A_light --> [ 2; subterfuge_9; 1; "lighted"; K2_thing; K1_room; NULL; ];
Array A_lockable --> [ 2; subterfuge_10; 1; "lockable"; K4_door; K5_container; NULL; ];
Array A_locked --> [ 2; subterfuge_11; 1; "locked"; K4_door; K5_container; NULL; ];
Array A_moved --> [ 2; subterfuge_12; 1; "handled"; K2_thing; NULL; ];
Array A_on --> [ 2; subterfuge_13; 1; "switched on"; K13_device; NULL; ];
Array A_open --> [ 2; subterfuge_14; 1; "open"; K4_door; K5_container; NULL; ];
Array A_openable --> [ 2; subterfuge_15; 1; "openable"; K4_door; K5_container; NULL; ];
Array A_scenery --> [ 2; subterfuge_16; 1; "scenery"; K2_thing; K3_direction; NULL; ];
Array A_static --> [ 2; subterfuge_17; 1; "fixed in place"; K2_thing; NULL; ];
Array A_supporter --> [ 2; subterfuge_18; 1; "supporter"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_switchable --> [ 2; subterfuge_19; 1; "switchable"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_talkable --> [ 2; subterfuge_20; 1; "<nameless>"; NULL; ];
Array A_transparent --> [ 2; subterfuge_21; 1; "transparent"; K6_supporter; K8_person; K5_container; NULL; ];
Array A_visited --> [ 2; subterfuge_22; 1; "visited"; K1_room; NULL; ];
Array A_worn --> [ 2; subterfuge_23; 1; "<nameless>"; NULL; ];
Array A_male --> [ 2; subterfuge_24; 1; "<nameless>"; NULL; ];
Array A_female --> [ 2; subterfuge_25; 1; "female"; K8_person; NULL; ];
Array A_neuter --> [ 2; subterfuge_26; 1; "neuter"; K8_person; NULL; ];
Array A_pluralname --> [ 2; subterfuge_27; 1; "plural-named"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_ambigpluralname --> [ 2; subterfuge_28; 1; "ambiguously plural"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_proper --> [ 2; subterfuge_29; 1; "proper-named"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_remove_proper --> [ 2; subterfuge_30; 1; "<nameless>"; NULL; ];
Array A_privately_named --> [ 2; subterfuge_31; 1; "privately-named"; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_mentioned --> [ 2; subterfuge_32; 1; "mentioned"; K2_thing; NULL; ];
Array A_pushable --> [ 2; subterfuge_33; 1; "pushable between rooms"; K2_thing; NULL; ];
Array A_mark_as_room --> [ 2; subterfuge_34; 1; "mark_as_room"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_mark_as_thing --> [ 2; subterfuge_35; 1; "mark_as_thing"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_workflag --> [ 2; subterfuge_36; 1; "marked for listing"; K2_thing; K3_direction; NULL; ];
Array A_workflag2 --> [ 2; subterfuge_37; 1; "<nameless>"; NULL; ];
Array A_add_to_scope --> [ 1; subterfuge_38; 0; "<nameless>"; NULL; ];
Array A_article --> [ 1; subterfuge_39; 0; "indefinite article"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_capacity --> [ 1; subterfuge_40; 0; "carrying capacity"; K6_supporter; K8_person; K5_container; NULL; ];
Array A_component_child --> [ 1; subterfuge_41; 0; "component_child"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_component_parent --> [ 1; subterfuge_42; 0; "component_parent"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_component_sibling --> [ 1; subterfuge_43; 0; "component_sibling"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_description --> [ 1; subterfuge_44; 0; "description"; K1_room; K2_thing; NULL; ];
Array A_door_dir --> [ 1; subterfuge_45; 0; "door_dir"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_door_to --> [ 1; subterfuge_46; 0; "leading-through destination"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; K4_door; NULL; ];
Array A_found_in --> [ 1; subterfuge_47; 0; "<nameless>"; NULL; ];
Array A_initial --> [ 1; subterfuge_48; 0; "initial appearance"; K2_thing; NULL; ];
Array A_list_together --> [ 1; subterfuge_49; 0; "list grouping key"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_map_region --> [ 1; subterfuge_50; 0; "map region"; K1_room; NULL; ];
Array A_parse_name --> [ 1; subterfuge_51; 0; "parse_name"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_plural --> [ 1; subterfuge_52; 0; "printed plural name"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_regional_found_in --> [ 1; subterfuge_53; 0; "regional_found_in"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_room_index --> [ 1; subterfuge_54; 0; "room_index"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_short_name --> [ 1; subterfuge_55; 0; "printed name"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_saved_short_name --> [ 1; subterfuge_56; 0; "saved_short_name"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_vector --> [ 1; subterfuge_57; 0; "vector"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_with_key --> [ 1; subterfuge_58; 0; "matching key"; K2_thing; K4_door; K5_container; NULL; ];
Array A_KD_Count --> [ 1; subterfuge_59; 0; "KD_Count"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK1_Count --> [ 1; subterfuge_60; 0; "room"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK2_Count --> [ 1; subterfuge_61; 0; "thing"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK4_Count --> [ 1; subterfuge_62; 0; "door"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK5_Count --> [ 1; subterfuge_63; 0; "container"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK6_Count --> [ 1; subterfuge_64; 0; "supporter"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK8_Count --> [ 1; subterfuge_65; 0; "person"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK3_Count --> [ 1; subterfuge_66; 0; "direction"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK1_link --> [ 1; subterfuge_67; 0; "<nameless>"; NULL; ];
Array A_IK2_link --> [ 1; subterfuge_68; 0; "<nameless>"; NULL; ];
Array A_IK5_link --> [ 1; subterfuge_69; 0; "<nameless>"; NULL; ];
Array A_IK6_link --> [ 1; subterfuge_70; 0; "<nameless>"; NULL; ];
Array A_IK8_link --> [ 1; subterfuge_71; 0; "<nameless>"; NULL; ];
Array A_articles --> [ 1; subterfuge_72; 0; "<nameless>"; NULL; ];
Array A_grammar --> [ 1; subterfuge_73; 0; "<nameless>"; NULL; ];
Array A_inside_description --> [ 1; subterfuge_74; 0; "<nameless>"; NULL; ];
Array A_short_name_indef --> [ 1; subterfuge_75; 0; "<nameless>"; NULL; ];
Array A_cap_short_name --> [ 1; subterfuge_76; 0; "object"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_before --> [ 1; subterfuge_77; 0; "before"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_action_bitmap --> [ 1; subterfuge_78; 0; "action_bitmap"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_name --> [ 1; subterfuge_79; 0; "name"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_P_variable_initial_value --> [ 1; subterfuge_80; 0; "variable initial value"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_P_specification --> [ 1; subterfuge_81; 0; "specification"; NULL; ];
Array A_P_indefinite_appearance_text --> [ 1; subterfuge_82; 0; "indefinite appearance text"; NULL; ];
Array A_P_adaptive_text_viewpoint --> [ 1; subterfuge_83; 0; "adaptive text viewpoint"; NULL; ];
Array A_P_opposite --> [ 1; subterfuge_84; 0; "opposite"; K3_direction; NULL; ];
Array A_P_recurring --> [ 1; subterfuge_85; 1; "recurring"; NULL; ];
Array A_K1_room_Next --> [ 1; subterfuge_86; 0; "room"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K2_thing_Next --> [ 1; subterfuge_87; 0; "thing"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K3_direction_Next --> [ 1; subterfuge_88; 0; "direction"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K4_door_Next --> [ 1; subterfuge_89; 0; "door"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K5_container_Next --> [ 1; subterfuge_90; 0; "container"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K6_supporter_Next --> [ 1; subterfuge_91; 0; "supporter"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK7_Count --> [ 1; subterfuge_92; 0; "backdrop"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K7_backdrop_Next --> [ 1; subterfuge_93; 0; "backdrop"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K8_person_Next --> [ 1; subterfuge_94; 0; "person"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK9_Count --> [ 1; subterfuge_95; 0; "region"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K9_region_Next --> [ 1; subterfuge_96; 0; "region"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_IK10_Count --> [ 1; subterfuge_97; 0; "man"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K10_man_Next --> [ 1; subterfuge_98; 0; "man"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K11_woman_Count --> [ 1; subterfuge_99; 0; "woman"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K11_woman_Next --> [ 1; subterfuge_100; 0; "woman"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K12_animal_Count --> [ 1; subterfuge_101; 0; "animal"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K12_animal_Next --> [ 1; subterfuge_102; 0; "animal"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K13_device_Count --> [ 1; subterfuge_103; 0; "device"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K13_device_Next --> [ 1; subterfuge_104; 0; "device"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K14_vehicle_Count --> [ 1; subterfuge_105; 0; "vehicle"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K14_vehicle_Next --> [ 1; subterfuge_106; 0; "vehicle"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K15_player_s_holdall_Count --> [ 1; subterfuge_107; 0; "player's holdall"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K15_player_s_holdall_Next --> [ 1; subterfuge_108; 0; "player's holdall"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K16_little_girl_Count --> [ 1; subterfuge_109; 0; "little girl"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array A_K16_little_girl_Next --> [ 1; subterfuge_110; 0; "little girl"; K0_kind; K1_room; K2_thing; K9_region; K3_direction; NULL; ];
Array bc_U1 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U2 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U3 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U4 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U5 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array ActionHappened --> [ 0; 0; 0; 0; 0; 0; 0; 0; ];
Array ActionCoding --> [ ##Inv; ##Take; ##Remove; ##Drop; ##PutOn; ##Insert; ##Eat; ##Go; ##Enter; ##Exit; ##GetOff; ##Look; ##Examine; ##LookUnder; ##Search; ##Consult; ##Lock; ##Unlock; ##SwitchOn; ##SwitchOff; ##Open; ##Close; ##Wear; ##Disrobe; ##Give; ##Show; ##WakeOther; ##ThrowAt; ##Attack; ##Kiss; ##Answer; ##Tell; ##Ask; ##AskFor; ##Wait; ##Touch; ##Wave; ##Pull; ##Push; ##Turn; ##PushDir; ##Squeeze; ##Yes; ##No; ##Burn; ##Wake; ##Think; ##Smell; ##Listen; ##Taste; ##Cut; ##Jump; ##Tie; ##Drink; ##Sorry; ##Swing; ##Rub; ##SetTo; ##WaveHands; ##Buy; ##Climb; ##Sleep; ##Quit; ##Save; ##Restore; ##Restart; ##Verify; ##ScriptOn; ##ScriptOff; ##Version; ##Score; ##LMode3; ##LMode2; ##LMode1; ##NotifyOn; ##NotifyOff; ##Pronouns; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array ActionData table [ ##Inv; 0; OBJECT_TY; OBJECT_TY; 0; 20000; ##Take; 9; OBJECT_TY; OBJECT_TY; 0; 20001; ##Remove; 27; OBJECT_TY; OBJECT_TY; 0; 20002; ##Drop; 9; OBJECT_TY; OBJECT_TY; 0; 20003; ##PutOn; 27; OBJECT_TY; OBJECT_TY; 0; 20004; ##Insert; 27; OBJECT_TY; OBJECT_TY; 0; 20005; ##Eat; 9; OBJECT_TY; OBJECT_TY; 0; 20006; ##Go; 8; OBJECT_TY; OBJECT_TY; call_U501; 20007; ##Enter; 9; OBJECT_TY; OBJECT_TY; 0; 20008; ##Exit; 0; OBJECT_TY; OBJECT_TY; call_U508; 20009; ##GetOff; 9; OBJECT_TY; OBJECT_TY; 0; 20010; ##Look; 0; OBJECT_TY; OBJECT_TY; call_U515; 20011; ##Examine; 12; OBJECT_TY; OBJECT_TY; call_U519; 20012; ##LookUnder; 12; OBJECT_TY; OBJECT_TY; 0; 20013; ##Search; 13; OBJECT_TY; OBJECT_TY; 0; 20014; ##Consult; 25; OBJECT_TY; UNDERSTANDING_TY; 0; 20015; ##Lock; 155; OBJECT_TY; OBJECT_TY; 0; 20016; ##Unlock; 155; OBJECT_TY; OBJECT_TY; 0; 20017; ##SwitchOn; 9; OBJECT_TY; OBJECT_TY; 0; 20018; ##SwitchOff; 9; OBJECT_TY; OBJECT_TY; 0; 20019; ##Open; 9; OBJECT_TY; OBJECT_TY; 0; 20020; ##Close; 9; OBJECT_TY; OBJECT_TY; 0; 20021; ##Wear; 73; OBJECT_TY; OBJECT_TY; 0; 20022; ##Disrobe; 9; OBJECT_TY; OBJECT_TY; 0; 20023; ##Give; 91; OBJECT_TY; OBJECT_TY; 0; 20024; ##Show; 89; OBJECT_TY; OBJECT_TY; 0; 20025; ##WakeOther; 9; OBJECT_TY; OBJECT_TY; 0; 20026; ##ThrowAt; 89; OBJECT_TY; OBJECT_TY; 0; 20027; ##Attack; 9; OBJECT_TY; OBJECT_TY; 0; 20028; ##Kiss; 9; OBJECT_TY; OBJECT_TY; 0; 20029; ##Answer; 25; OBJECT_TY; UNDERSTANDING_TY; 0; 20030; ##Tell; 25; OBJECT_TY; UNDERSTANDING_TY; 0; 20031; ##Ask; 25; OBJECT_TY; UNDERSTANDING_TY; 0; 20032; ##AskFor; 27; OBJECT_TY; OBJECT_TY; 0; 20033; ##Wait; 0; OBJECT_TY; OBJECT_TY; 0; 20034; ##Touch; 9; OBJECT_TY; OBJECT_TY; 0; 20035; ##Wave; 9; OBJECT_TY; OBJECT_TY; 0; 20036; ##Pull; 9; OBJECT_TY; OBJECT_TY; 0; 20037; ##Push; 9; OBJECT_TY; OBJECT_TY; 0; 20038; ##Turn; 9; OBJECT_TY; OBJECT_TY; 0; 20039; ##PushDir; 25; OBJECT_TY; OBJECT_TY; 0; 20040; ##Squeeze; 9; OBJECT_TY; OBJECT_TY; 0; 20041; ##Yes; 0; OBJECT_TY; OBJECT_TY; 0; 20042; ##No; 0; OBJECT_TY; OBJECT_TY; 0; 20043; ##Burn; 9; OBJECT_TY; OBJECT_TY; 0; 20044; ##Wake; 0; OBJECT_TY; OBJECT_TY; 0; 20045; ##Think; 0; OBJECT_TY; OBJECT_TY; 0; 20046; ##Smell; 9; OBJECT_TY; OBJECT_TY; 0; 20047; ##Listen; 9; OBJECT_TY; OBJECT_TY; 0; 20048; ##Taste; 9; OBJECT_TY; OBJECT_TY; 0; 20049; ##Cut; 9; OBJECT_TY; OBJECT_TY; 0; 20050; ##Jump; 0; OBJECT_TY; OBJECT_TY; 0; 20051; ##Tie; 27; OBJECT_TY; OBJECT_TY; 0; 20052; ##Drink; 9; OBJECT_TY; OBJECT_TY; 0; 20053; ##Sorry; 0; OBJECT_TY; OBJECT_TY; 0; 20054; ##Swing; 9; OBJECT_TY; OBJECT_TY; 0; 20055; ##Rub; 9; OBJECT_TY; OBJECT_TY; 0; 20056; ##SetTo; 25; OBJECT_TY; UNDERSTANDING_TY; 0; 20057; ##WaveHands; 0; OBJECT_TY; OBJECT_TY; 0; 20058; ##Buy; 9; OBJECT_TY; OBJECT_TY; 0; 20059; ##Climb; 9; OBJECT_TY; OBJECT_TY; 0; 20060; ##Sleep; 0; OBJECT_TY; OBJECT_TY; 0; 20061; ##Quit; 32; OBJECT_TY; OBJECT_TY; 0; 20062; ##Save; 32; OBJECT_TY; OBJECT_TY; 0; 20063; ##Restore; 32; OBJECT_TY; OBJECT_TY; 0; 20064; ##Restart; 32; OBJECT_TY; OBJECT_TY; 0; 20065; ##Verify; 32; OBJECT_TY; OBJECT_TY; 0; 20066; ##ScriptOn; 32; OBJECT_TY; OBJECT_TY; 0; 20067; ##ScriptOff; 32; OBJECT_TY; OBJECT_TY; 0; 20068; ##Version; 32; OBJECT_TY; OBJECT_TY; 0; 20069; ##Score; 32; OBJECT_TY; OBJECT_TY; 0; 20070; ##LMode3; 32; OBJECT_TY; OBJECT_TY; 0; 20071; ##LMode2; 32; OBJECT_TY; OBJECT_TY; 0; 20072; ##LMode1; 32; OBJECT_TY; OBJECT_TY; 0; 20073; ##NotifyOn; 32; OBJECT_TY; OBJECT_TY; 0; 20074; ##NotifyOff; 32; OBJECT_TY; OBJECT_TY; 0; 20075; ##Pronouns; 32; OBJECT_TY; OBJECT_TY; 0; 20076; 0; 0; 0; 0; 0; 20077; 0; 0; 0; 0; 0; 20078; 0; 0; 0; 0; 0; 20079; 0; 0; 0; 0; 0; 20080; 0; 0; 0; 0; 0; 20081; 0; 0; 0; 0; 0; 20082; 0; 0; 0; 0; 0; 20083; 0; 0; 0; 0; 0; 20084; 0; 0; 0; 0; 0; 20085; 0; 0; 0; 0; 0; 20086; 0; 0; 0; 0; 0; 20087; 0; 0; 0; 0; 0; 20088; 0; 0; 0; 0; 0; 20089; 0; 0; 0; 0; 0; 20090; 0; 0; 0; 0; 0; 20091; 0; 0; 0; 0; 0; 20092; 0; 0; 0; 0; 0; 20093; 0; 0; 0; 0; 0; 20094; 0; 0; 0; 0; 0; 20095; 0; 0; 0; 0; 0; 20096; 0; 0; 0; 0; 0; 20097; 0; 0; 0; 0; 0; 20098; 0; 0; 0; 0; 0; 20099; 0; ];
Array Activity_after_rulebooks --> [ rulebook_id_U5; rulebook_id_U8; rulebook_id_U11; rulebook_id_U41; rulebook_id_U44; rulebook_id_U47; rulebook_id_U50; rulebook_id_U53; rulebook_id_U56; rulebook_id_U59; rulebook_id_U62; rulebook_id_U65; rulebook_id_U68; rulebook_id_U71; rulebook_id_U74; rulebook_id_U77; rulebook_id_U80; rulebook_id_U83; rulebook_id_U86; rulebook_id_U89; rulebook_id_U92; rulebook_id_U95; rulebook_id_U98; rulebook_id_U101; rulebook_id_U104; rulebook_id_U107; rulebook_id_U110; rulebook_id_U113; rulebook_id_U116; rulebook_id_U119; rulebook_id_U122; rulebook_id_U125; rulebook_id_U128; rulebook_id_U131; ];
Array Activity_atb_rulebooks -> [ 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 1; 0; 1; 1; 1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array Activity_before_rulebooks --> [ rulebook_id_U3; rulebook_id_U6; rulebook_id_U9; rulebook_id_U39; rulebook_id_U42; rulebook_id_U45; rulebook_id_U48; rulebook_id_U51; rulebook_id_U54; rulebook_id_U57; rulebook_id_U60; rulebook_id_U63; rulebook_id_U66; rulebook_id_U69; rulebook_id_U72; rulebook_id_U75; rulebook_id_U78; rulebook_id_U81; rulebook_id_U84; rulebook_id_U87; rulebook_id_U90; rulebook_id_U93; rulebook_id_U96; rulebook_id_U99; rulebook_id_U102; rulebook_id_U105; rulebook_id_U108; rulebook_id_U111; rulebook_id_U114; rulebook_id_U117; rulebook_id_U120; rulebook_id_U123; rulebook_id_U126; rulebook_id_U129; ];
Array Activity_for_rulebooks --> [ rulebook_id_U4; rulebook_id_U7; rulebook_id_U10; rulebook_id_U40; rulebook_id_U43; rulebook_id_U46; rulebook_id_U49; rulebook_id_U52; rulebook_id_U55; rulebook_id_U58; rulebook_id_U61; rulebook_id_U64; rulebook_id_U67; rulebook_id_U70; rulebook_id_U73; rulebook_id_U76; rulebook_id_U79; rulebook_id_U82; rulebook_id_U85; rulebook_id_U88; rulebook_id_U91; rulebook_id_U94; rulebook_id_U97; rulebook_id_U100; rulebook_id_U103; rulebook_id_U106; rulebook_id_U109; rulebook_id_U112; rulebook_id_U115; rulebook_id_U118; rulebook_id_U121; rulebook_id_U124; rulebook_id_U127; rulebook_id_U130; ];
Array activity_var_creators --> [ 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array TimedEventsTable table [ 0; 0; ];
Array TimedEventTimesTable table [ 0; 0; ];
Array PastActionsI6Routines --> [ 0; 0; ];
Array TableOfVerbs --> [ call_U132; call_U133; call_U134; call_U135; call_U136; call_U137; call_U138; call_U139; call_U140; call_U141; call_U142; call_U143; call_U144; call_U145; call_U146; call_U147; call_U148; call_U149; call_U150; call_U1844; call_U1845; call_U1846; call_U1847; call_U1848; call_U1849; call_U1850; call_U1851; call_U1852; call_U1853; call_U1854; call_U1855; call_U1856; call_U1857; call_U1858; call_U1859; call_U1860; call_U1861; call_U1862; call_U1863; call_U1864; call_U1865; call_U1866; call_U1867; call_U1868; call_U1869; call_U1870; call_U1871; call_U1872; call_U1873; call_U1874; call_U1875; call_U1876; call_U1877; call_U1878; call_U1879; call_U1880; call_U1881; call_U1882; call_U1883; call_U1884; call_U1885; call_U1886; call_U1887; call_U1888; call_U1889; call_U1890; call_U1891; call_U1892; call_U1893; call_U1894; call_U1895; call_U1896; call_U1897; call_U1898; call_U1899; call_U1900; call_U1901; call_U1902; call_U1903; call_U1904; call_U1905; call_U1906; call_U1907; call_U1908; call_U1909; call_U1910; call_U1911; call_U1912; call_U1913; call_U1914; call_U203; call_U204; call_U205; call_U206; call_U207; call_U208; call_U1942; call_U1943; call_U1944; call_U1945; call_U1946; call_U1947; 0; ];
Array KindHierarchy --> [ K0_kind; 0; K1_room; 0; K2_thing; 0; K3_direction; 0; K4_door; 2; K5_container; 2; K6_supporter; 2; K7_backdrop; 2; K8_person; 2; K9_region; 0; K10_man; 8; K11_woman; 8; K12_animal; 8; K13_device; 2; K14_vehicle; 5; K15_player_s_holdall; 5; K16_little_girl; 8; ];
Array ResourceIDsOfFigures --> [ 0; 1; 0; ];
Array ResourceIDsOfSounds --> [ 0; 0; ];
Array TableOfExternalFiles --> [ 0; 0; ];
Array RulebookNames --> [ "Startup rulebook"; "Shutdown rulebook"; "before starting the virtual machine rulebook"; "for starting the virtual machine rulebook"; "after starting the virtual machine rulebook"; "before printing the name rulebook"; "for printing the name rulebook"; "after printing the name rulebook"; "before printing the plural name rulebook"; "for printing the plural name rulebook"; "after printing the plural name rulebook"; "Turn sequence rulebook"; "Scene changing rulebook"; "When play begins rulebook"; "When play ends rulebook"; "When scene begins rulebook"; "When scene ends rulebook"; "Every turn rulebook"; "Action-processing rulebook"; "Setting action variables rulebook"; "specific action-processing rulebook"; "player's action awareness rulebook"; "Accessibility rulebook"; "Reaching inside rulebook"; "Reaching outside rulebook"; "Visibility rulebook"; "Persuasion rulebook"; "Unsuccessful attempt by rulebook"; "Before rulebook"; "Instead rulebook"; "Check rulebook"; "Carry out rulebook"; "After rulebook"; "Report rulebook"; "does the player mean rulebook"; "multiple action processing rulebook"; "when Entire Game begins rulebook"; "when Entire Game ends rulebook"; "before issuing the response text rulebook"; "for issuing the response text rulebook"; "after issuing the response text rulebook"; "before printing a number rulebook"; "for printing a number rulebook"; "after printing a number rulebook"; "before printing room description details rulebook"; "for printing room description details rulebook"; "after printing room description details rulebook"; "before printing inventory details rulebook"; "for printing inventory details rulebook"; "after printing inventory details rulebook"; "before listing contents rulebook"; "for listing contents rulebook"; "after listing contents rulebook"; "before grouping together rulebook"; "for grouping together rulebook"; "after grouping together rulebook"; "before writing a paragraph about rulebook"; "for writing a paragraph about rulebook"; "after writing a paragraph about rulebook"; "before listing nondescript items rulebook"; "for listing nondescript items rulebook"; "after listing nondescript items rulebook"; "before printing the name of a dark room rulebook"; "for printing the name of a dark room rulebook"; "after printing the name of a dark room rulebook"; "before printing the description of a dark room rulebook"; "for printing the description of a dark room rulebook"; "after printing the description of a dark room rulebook"; "before printing the announcement of darkness rulebook"; "for printing the announcement of darkness rulebook"; "after printing the announcement of darkness rulebook"; "before printing the announcement of light rulebook"; "for printing the announcement of light rulebook"; "after printing the announcement of light rulebook"; "before printing a refusal to act in the dark rulebook"; "for printing a refusal to act in the dark rulebook"; "after printing a refusal to act in the dark rulebook"; "before constructing the status line rulebook"; "for constructing the status line rulebook"; "after constructing the status line rulebook"; "before printing the banner text rulebook"; "for printing the banner text rulebook"; "after printing the banner text rulebook"; "before reading a command rulebook"; "for reading a command rulebook"; "after reading a command rulebook"; "before deciding the scope rulebook"; "for deciding the scope rulebook"; "after deciding the scope rulebook"; "before deciding the concealed possessions rulebook"; "for deciding the concealed possessions rulebook"; "after deciding the concealed possessions rulebook"; "before deciding whether all includes rulebook"; "for deciding whether all includes rulebook"; "after deciding whether all includes rulebook"; "before clarifying the parser's choice rulebook"; "for clarifying the parser's choice rulebook"; "after clarifying the parser's choice rulebook"; "before asking which do you mean rulebook"; "for asking which do you mean rulebook"; "after asking which do you mean rulebook"; "before printing a parser error rulebook"; "for printing a parser error rulebook"; "after printing a parser error rulebook"; "before supplying a missing noun rulebook"; "for supplying a missing noun rulebook"; "after supplying a missing noun rulebook"; "before supplying a missing second noun rulebook"; "for supplying a missing second noun rulebook"; "after supplying a missing second noun rulebook"; "before implicitly taking rulebook"; "for implicitly taking rulebook"; "after implicitly taking rulebook"; "before amusing a victorious player rulebook"; "for amusing a victorious player rulebook"; "after amusing a victorious player rulebook"; "before printing the player's obituary rulebook"; "for printing the player's obituary rulebook"; "after printing the player's obituary rulebook"; "before handling the final question rulebook"; "for handling the final question rulebook"; "after handling the final question rulebook"; "before printing the locale description rulebook"; "for printing the locale description rulebook"; "after printing the locale description rulebook"; "before choosing notable locale objects rulebook"; "for choosing notable locale objects rulebook"; "after choosing notable locale objects rulebook"; "before printing a locale paragraph about rulebook"; "for printing a locale paragraph about rulebook"; "after printing a locale paragraph about rulebook"; "check taking inventory rulebook"; "carry out taking inventory rulebook"; "report taking inventory rulebook"; "check taking rulebook"; "carry out taking rulebook"; "report taking rulebook"; "check removing it from rulebook"; "carry out removing it from rulebook"; "report removing it from rulebook"; "check dropping rulebook"; "carry out dropping rulebook"; "report dropping rulebook"; "check putting it on rulebook"; "carry out putting it on rulebook"; "report putting it on rulebook"; "check inserting it into rulebook"; "carry out inserting it into rulebook"; "report inserting it into rulebook"; "check eating rulebook"; "carry out eating rulebook"; "report eating rulebook"; "check going rulebook"; "carry out going rulebook"; "report going rulebook"; "check entering rulebook"; "carry out entering rulebook"; "report entering rulebook"; "check exiting rulebook"; "carry out exiting rulebook"; "report exiting rulebook"; "check getting off rulebook"; "carry out getting off rulebook"; "report getting off rulebook"; "check looking rulebook"; "carry out looking rulebook"; "report looking rulebook"; "check examining rulebook"; "carry out examining rulebook"; "report examining rulebook"; "check looking under rulebook"; "carry out looking under rulebook"; "report looking under rulebook"; "check searching rulebook"; "carry out searching rulebook"; "report searching rulebook"; "check consulting it about rulebook"; "carry out consulting it about rulebook"; "report consulting it about rulebook"; "check locking it with rulebook"; "carry out locking it with rulebook"; "report locking it with rulebook"; "check unlocking it with rulebook"; "carry out unlocking it with rulebook"; "report unlocking it with rulebook"; "check switching on rulebook"; "carry out switching on rulebook"; "report switching on rulebook"; "check switching off rulebook"; "carry out switching off rulebook"; "report switching off rulebook"; "check opening rulebook"; "carry out opening rulebook"; "report opening rulebook"; "check closing rulebook"; "carry out closing rulebook"; "report closing rulebook"; "check wearing rulebook"; "carry out wearing rulebook"; "report wearing rulebook"; "check taking off rulebook"; "carry out taking off rulebook"; "report taking off rulebook"; "check giving it to rulebook"; "carry out giving it to rulebook"; "report giving it to rulebook"; "check showing it to rulebook"; "carry out showing it to rulebook"; "report showing it to rulebook"; "check waking rulebook"; "carry out waking rulebook"; "report waking rulebook"; "check throwing it at rulebook"; "carry out throwing it at rulebook"; "report throwing it at rulebook"; "check attacking rulebook"; "carry out attacking rulebook"; "report attacking rulebook"; "check kissing rulebook"; "carry out kissing rulebook"; "report kissing rulebook"; "check answering it that rulebook"; "carry out answering it that rulebook"; "report answering it that rulebook"; "check telling it about rulebook"; "carry out telling it about rulebook"; "report telling it about rulebook"; "check asking it about rulebook"; "carry out asking it about rulebook"; "report asking it about rulebook"; "check asking it for rulebook"; "carry out asking it for rulebook"; "report asking it for rulebook"; "check waiting rulebook"; "carry out waiting rulebook"; "report waiting rulebook"; "check touching rulebook"; "carry out touching rulebook"; "report touching rulebook"; "check waving rulebook"; "carry out waving rulebook"; "report waving rulebook"; "check pulling rulebook"; "carry out pulling rulebook"; "report pulling rulebook"; "check pushing rulebook"; "carry out pushing rulebook"; "report pushing rulebook"; "check turning rulebook"; "carry out turning rulebook"; "report turning rulebook"; "check pushing it to rulebook"; "carry out pushing it to rulebook"; "report pushing it to rulebook"; "check squeezing rulebook"; "carry out squeezing rulebook"; "report squeezing rulebook"; "check saying yes rulebook"; "carry out saying yes rulebook"; "report saying yes rulebook"; "check saying no rulebook"; "carry out saying no rulebook"; "report saying no rulebook"; "check burning rulebook"; "carry out burning rulebook"; "report burning rulebook"; "check waking up rulebook"; "carry out waking up rulebook"; "report waking up rulebook"; "check thinking rulebook"; "carry out thinking rulebook"; "report thinking rulebook"; "check smelling rulebook"; "carry out smelling rulebook"; "report smelling rulebook"; "check listening to rulebook"; "carry out listening to rulebook"; "report listening to rulebook"; "check tasting rulebook"; "carry out tasting rulebook"; "report tasting rulebook"; "check cutting rulebook"; "carry out cutting rulebook"; "report cutting rulebook"; "check jumping rulebook"; "carry out jumping rulebook"; "report jumping rulebook"; "check tying it to rulebook"; "carry out tying it to rulebook"; "report tying it to rulebook"; "check drinking rulebook"; "carry out drinking rulebook"; "report drinking rulebook"; "check saying sorry rulebook"; "carry out saying sorry rulebook"; "report saying sorry rulebook"; "check swinging rulebook"; "carry out swinging rulebook"; "report swinging rulebook"; "check rubbing rulebook"; "carry out rubbing rulebook"; "report rubbing rulebook"; "check setting it to rulebook"; "carry out setting it to rulebook"; "report setting it to rulebook"; "check waving hands rulebook"; "carry out waving hands rulebook"; "report waving hands rulebook"; "check buying rulebook"; "carry out buying rulebook"; "report buying rulebook"; "check climbing rulebook"; "carry out climbing rulebook"; "report climbing rulebook"; "check sleeping rulebook"; "carry out sleeping rulebook"; "report sleeping rulebook"; "check quitting the game rulebook"; "carry out quitting the game rulebook"; "report quitting the game rulebook"; "check saving the game rulebook"; "carry out saving the game rulebook"; "report saving the game rulebook"; "check restoring the game rulebook"; "carry out restoring the game rulebook"; "report restoring the game rulebook"; "check restarting the game rulebook"; "carry out restarting the game rulebook"; "report restarting the game rulebook"; "check verifying the story file rulebook"; "carry out verifying the story file rulebook"; "report verifying the story file rulebook"; "check switching the story transcript on rulebook"; "carry out switching the story transcript on rulebook"; "report switching the story transcript on rulebook"; "check switching the story transcript off rulebook"; "carry out switching the story transcript off rulebook"; "report switching the story transcript off rulebook"; "check requesting the story file version rulebook"; "carry out requesting the story file version rulebook"; "report requesting the story file version rulebook"; "check requesting the score rulebook"; "carry out requesting the score rulebook"; "report requesting the score rulebook"; "check preferring abbreviated room descriptions rulebook"; "carry out preferring abbreviated room descriptions rulebook"; "report preferring abbreviated room descriptions rulebook"; "check preferring unabbreviated room descriptions rulebook"; "carry out preferring unabbreviated room descriptions rulebook"; "report preferring unabbreviated room descriptions rulebook"; "check preferring sometimes abbreviated room descriptions rulebook"; "carry out preferring sometimes abbreviated room descriptions rulebook"; "report preferring sometimes abbreviated room descriptions rulebook"; "check switching score notification on rulebook"; "carry out switching score notification on rulebook"; "report switching score notification on rulebook"; "check switching score notification off rulebook"; "carry out switching score notification off rulebook"; "report switching score notification off rulebook"; "check requesting the pronoun meanings rulebook"; "carry out requesting the pronoun meanings rulebook"; "report requesting the pronoun meanings rulebook"; ];
Array rulebook_var_creators --> [ 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; call_U363; 0; call_U366; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array rulebooks_array --> [ call_U112; call_U113; call_U114; call_U115; call_U116; call_U117; call_U118; call_U119; call_U120; call_U121; call_U122; call_U355; call_U356; call_U357; call_U358; call_U359; call_U360; call_U361; call_U362; call_U364; call_U365; call_U367; call_U368; call_U369; call_U370; call_U371; call_U372; call_U373; call_U374; call_U375; call_U376; call_U377; call_U378; call_U379; call_U380; call_U381; call_U382; call_U383; call_U384; call_U385; call_U386; call_U387; call_U388; call_U389; call_U390; call_U391; call_U392; call_U393; call_U394; call_U395; call_U396; call_U397; call_U398; call_U399; call_U400; call_U401; call_U402; call_U403; call_U404; call_U405; call_U406; call_U407; call_U408; call_U409; call_U410; call_U411; call_U412; call_U413; call_U414; call_U415; call_U416; call_U417; call_U418; call_U419; call_U420; call_U421; call_U422; call_U423; call_U424; call_U425; call_U426; call_U427; call_U428; call_U429; call_U430; call_U431; call_U432; call_U433; call_U434; call_U435; call_U436; call_U437; call_U438; call_U439; call_U440; call_U441; call_U442; call_U443; call_U444; call_U445; call_U446; call_U447; call_U448; call_U449; call_U450; call_U451; call_U452; call_U453; call_U454; call_U455; call_U456; call_U457; call_U458; call_U459; call_U460; call_U461; call_U462; call_U463; call_U464; call_U465; call_U466; call_U467; call_U468; call_U469; call_U470; call_U471; call_U472; call_U473; call_U474; call_U475; call_U476; call_U477; call_U478; call_U479; call_U480; call_U481; call_U482; call_U483; call_U484; call_U485; call_U486; call_U487; call_U488; call_U489; call_U490; call_U491; call_U492; call_U493; call_U494; call_U495; call_U496; call_U497; call_U498; call_U499; call_U500; call_U502; call_U503; call_U504; call_U505; call_U506; call_U507; call_U509; call_U510; call_U511; call_U512; call_U513; call_U514; call_U516; call_U517; call_U518; call_U520; call_U521; call_U522; call_U523; call_U524; call_U525; call_U526; call_U527; call_U528; call_U529; call_U530; call_U531; call_U532; call_U533; call_U534; call_U535; call_U536; call_U537; call_U538; call_U539; call_U540; call_U541; call_U542; call_U543; call_U544; call_U545; call_U546; call_U547; call_U548; call_U549; call_U550; call_U551; call_U552; call_U553; call_U554; call_U555; call_U556; call_U557; call_U558; call_U559; call_U560; call_U561; call_U562; call_U563; call_U564; call_U565; call_U566; call_U567; call_U568; call_U569; call_U570; call_U571; call_U572; call_U573; call_U574; call_U575; call_U576; call_U577; call_U578; call_U579; call_U580; call_U581; call_U582; call_U583; call_U584; call_U585; call_U586; call_U587; call_U588; call_U589; call_U590; call_U591; call_U592; call_U593; call_U594; call_U595; call_U596; call_U597; call_U598; call_U599; call_U600; call_U601; call_U602; call_U603; call_U604; call_U605; call_U606; call_U607; call_U608; call_U609; call_U610; call_U611; call_U612; call_U613; call_U614; call_U615; call_U616; call_U617; call_U618; call_U619; call_U620; call_U621; call_U622; call_U623; call_U624; call_U625; call_U626; call_U627; call_U628; call_U629; call_U630; call_U631; call_U632; call_U633; call_U634; call_U635; call_U636; call_U637; call_U638; call_U639; call_U640; call_U641; call_U642; call_U643; call_U644; call_U645; call_U646; call_U647; call_U648; call_U649; call_U650; call_U651; call_U652; call_U653; call_U654; call_U655; call_U656; call_U657; call_U658; call_U659; call_U660; call_U661; call_U662; call_U663; call_U664; call_U665; call_U666; call_U667; call_U668; call_U669; call_U670; call_U671; call_U672; call_U673; call_U674; call_U675; call_U676; call_U677; call_U678; call_U679; call_U680; call_U681; call_U682; call_U683; call_U684; call_U685; call_U686; call_U687; call_U688; call_U689; call_U690; call_U691; call_U692; call_U693; call_U694; call_U695; call_U696; call_U697; call_U698; call_U699; call_U700; call_U701; call_U702; call_U703; call_U704; call_U705; call_U706; call_U707; call_U708; call_U709; call_U710; call_U711; 0; ];
Array ResponseTexts --> [ ts_array_U1; ts_array_U2; ts_array_U3; ts_array_U4; ts_array_U5; ts_array_U6; ts_array_U7; ts_array_U8; ts_array_U9; ts_array_U10; ts_array_U11; ts_array_U12; ts_array_U13; ts_array_U14; ts_array_U15; ts_array_U16; ts_array_U17; ts_array_U18; ts_array_U19; ts_array_U20; ts_array_U21; ts_array_U22; ts_array_U23; ts_array_U24; ts_array_U25; ts_array_U26; ts_array_U27; ts_array_U28; ts_array_U29; ts_array_U30; ts_array_U31; ts_array_U32; ts_array_U33; ts_array_U34; ts_array_U35; ts_array_U36; ts_array_U37; ts_array_U38; ts_array_U39; ts_array_U40; ts_array_U41; ts_array_U42; ts_array_U43; ts_array_U44; ts_array_U45; ts_array_U46; ts_array_U47; ts_array_U48; ts_array_U49; ts_array_U50; ts_array_U51; ts_array_U52; ts_array_U53; ts_array_U54; ts_array_U55; ts_array_U56; ts_array_U57; ts_array_U58; ts_array_U59; ts_array_U60; ts_array_U61; ts_array_U62; ts_array_U63; ts_array_U64; ts_array_U65; ts_array_U66; ts_array_U67; ts_array_U68; ts_array_U69; ts_array_U70; ts_array_U71; ts_array_U72; ts_array_U73; ts_array_U74; ts_array_U75; ts_array_U76; ts_array_U77; ts_array_U78; ts_array_U79; ts_array_U80; ts_array_U81; ts_array_U82; ts_array_U83; ts_array_U84; ts_array_U85; ts_array_U86; ts_array_U87; ts_array_U88; ts_array_U89; ts_array_U90; ts_array_U91; ts_array_U92; ts_array_U93; ts_array_U94; ts_array_U95; ts_array_U96; ts_array_U97; ts_array_U98; ts_array_U99; ts_array_U100; ts_array_U101; ts_array_U102; ts_array_U103; ts_array_U104; ts_array_U105; ts_array_U106; ts_array_U107; ts_array_U108; ts_array_U109; ts_array_U110; ts_array_U111; ts_array_U112; ts_array_U113; ts_array_U114; ts_array_U115; ts_array_U116; ts_array_U117; ts_array_U118; ts_array_U119; ts_array_U120; ts_array_U121; ts_array_U122; ts_array_U123; ts_array_U124; ts_array_U125; ts_array_U126; ts_array_U127; ts_array_U128; ts_array_U129; ts_array_U130; ts_array_U131; ts_array_U132; ts_array_U133; ts_array_U134; ts_array_U135; ts_array_U136; ts_array_U137; ts_array_U138; ts_array_U139; ts_array_U140; ts_array_U141; ts_array_U142; ts_array_U143; ts_array_U144; ts_array_U145; ts_array_U146; ts_array_U147; ts_array_U148; ts_array_U149; ts_array_U150; ts_array_U151; ts_array_U152; ts_array_U153; ts_array_U154; ts_array_U155; ts_array_U156; ts_array_U157; ts_array_U158; ts_array_U159; ts_array_U160; ts_array_U161; ts_array_U162; ts_array_U163; ts_array_U164; ts_array_U165; ts_array_U166; ts_array_U167; ts_array_U168; ts_array_U169; ts_array_U170; ts_array_U171; ts_array_U172; ts_array_U173; ts_array_U174; ts_array_U175; ts_array_U176; ts_array_U177; ts_array_U178; ts_array_U179; ts_array_U180; ts_array_U181; ts_array_U182; ts_array_U183; ts_array_U184; ts_array_U185; ts_array_U186; ts_array_U187; ts_array_U188; ts_array_U189; ts_array_U190; ts_array_U191; ts_array_U192; ts_array_U193; ts_array_U194; ts_array_U195; ts_array_U196; ts_array_U197; ts_array_U198; ts_array_U199; ts_array_U200; ts_array_U201; ts_array_U202; ts_array_U203; ts_array_U204; ts_array_U205; ts_array_U206; ts_array_U207; ts_array_U208; ts_array_U209; ts_array_U210; ts_array_U211; ts_array_U212; ts_array_U213; ts_array_U214; ts_array_U215; ts_array_U216; ts_array_U217; ts_array_U218; ts_array_U219; ts_array_U220; ts_array_U221; ts_array_U222; ts_array_U223; ts_array_U224; ts_array_U225; ts_array_U226; ts_array_U227; ts_array_U228; ts_array_U229; ts_array_U230; ts_array_U231; ts_array_U232; ts_array_U233; ts_array_U234; ts_array_U235; ts_array_U236; ts_array_U237; ts_array_U238; ts_array_U239; ts_array_U240; ts_array_U241; ts_array_U242; ts_array_U243; ts_array_U244; ts_array_U245; ts_array_U246; ts_array_U247; ts_array_U248; ts_array_U249; ts_array_U250; ts_array_U251; ts_array_U252; ts_array_U253; ts_array_U254; ts_array_U255; ts_array_U256; ts_array_U257; ts_array_U258; ts_array_U259; ts_array_U260; ts_array_U261; ts_array_U262; ts_array_U263; ts_array_U264; ts_array_U265; ts_array_U266; ts_array_U267; ts_array_U268; ts_array_U269; ts_array_U270; ts_array_U271; ts_array_U272; ts_array_U273; ts_array_U274; ts_array_U275; ts_array_U276; ts_array_U277; ts_array_U278; ts_array_U279; ts_array_U280; ts_array_U281; ts_array_U282; ts_array_U283; ts_array_U284; ts_array_U285; ts_array_U286; ts_array_U287; ts_array_U288; ts_array_U289; ts_array_U290; ts_array_U291; ts_array_U292; ts_array_U293; ts_array_U294; ts_array_U295; ts_array_U296; ts_array_U297; ts_array_U298; ts_array_U299; ts_array_U300; ts_array_U301; ts_array_U302; ts_array_U303; ts_array_U304; ts_array_U305; ts_array_U306; ts_array_U307; ts_array_U308; ts_array_U309; ts_array_U310; ts_array_U311; ts_array_U312; ts_array_U313; ts_array_U314; ts_array_U315; ts_array_U316; ts_array_U317; ts_array_U318; ts_array_U319; ts_array_U320; ts_array_U321; ts_array_U322; ts_array_U323; ts_array_U324; ts_array_U325; ts_array_U326; ts_array_U327; ts_array_U328; ts_array_U329; ts_array_U330; ts_array_U331; ts_array_U332; ts_array_U333; ts_array_U334; ts_array_U335; ts_array_U336; ts_array_U337; ts_array_U338; ts_array_U339; ts_array_U340; ts_array_U341; ts_array_U342; ts_array_U343; ts_array_U344; ts_array_U345; ts_array_U346; ts_array_U347; ts_array_U348; ts_array_U349; ts_array_U350; ts_array_U351; ts_array_U352; ts_array_U353; ts_array_U354; ts_array_U355; ts_array_U356; ts_array_U357; ts_array_U358; ts_array_U359; ts_array_U360; ts_array_U361; ts_array_U362; ts_array_U363; ts_array_U364; ts_array_U365; ts_array_U366; ts_array_U367; ts_array_U368; ts_array_U369; ts_array_U370; ts_array_U371; ts_array_U372; ts_array_U373; ts_array_U374; ts_array_U375; ts_array_U376; ts_array_U377; ts_array_U378; ts_array_U379; ts_array_U380; ts_array_U381; ts_array_U382; ts_array_U383; ts_array_U384; ts_array_U385; ts_array_U386; ts_array_U387; ts_array_U388; ts_array_U389; ts_array_U390; ts_array_U391; ts_array_U392; ts_array_U393; 0; 0; ];
Array ResponseDivisions --> [ "Standard Rules"; 1; 393; 0; 0; 0; ];
Array TableOfTables --> [ TheEmptyTable; table_data_U1; table_data_U2; 0; 0; ];
Array TB_Blanks -> [ 0; 0; 0; 4; 27; 255; 3; 0; 0; ];
Array closure_data_U1 --> [ DK3_phrase_real_number____re; call_U128; "rsqr function"; ];
Array closure_data_U2 --> [ DK3_phrase_real_number____re; call_U129; "arcsinh function"; ];
Array closure_data_U3 --> [ DK3_phrase_real_number____re; call_U130; "arccosh function"; ];
Array closure_data_U4 --> [ DK3_phrase_real_number____re; call_U131; "arctanh function"; ];
Array closure_data_U5 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Abs; "abs function"; ];
Array closure_data_U6 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Root; "root function"; ];
Array closure_data_U7 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Ceiling; "ceiling function"; ];
Array closure_data_U8 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Floor; "floor function"; ];
Array closure_data_U9 --> [ DK4_phrase_real_number____nu; REAL_NUMBER_TY_to_NUMBER_TY; "int function"; ];
Array closure_data_U10 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Log; "log function"; ];
Array closure_data_U11 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Exp; "exp function"; ];
Array closure_data_U12 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Sin; "sin function"; ];
Array closure_data_U13 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Cos; "cos function"; ];
Array closure_data_U14 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Tan; "tan function"; ];
Array closure_data_U15 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Arcsin; "arcsin function"; ];
Array closure_data_U16 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Arccos; "arccos function"; ];
Array closure_data_U17 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Arctan; "arctan function"; ];
Array closure_data_U18 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Sinh; "sinh function"; ];
Array closure_data_U19 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Cosh; "cosh function"; ];
Array closure_data_U20 --> [ DK3_phrase_real_number____re; REAL_NUMBER_TY_Tanh; "tanh function"; ];
Array inline_U1 --> [ 0; 0; 0; 0; 0; ];
Array bc_U6 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U1; ];
Array bc_U7 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U2; ];
Array bc_U8 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U3; ];
Array bc_U9 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U2 --> [ 0; 0; 0; 0; 0; ];
Array bc_U10 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U4; ];
Array bc_U11 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U5; ];
Array bc_U12 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U6; ];
Array bc_U13 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U3 --> [ 0; 0; 0; 0; 0; ];
Array bc_U14 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U7; ];
Array bc_U15 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U8; ];
Array bc_U16 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U9; ];
Array bc_U17 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U4 --> [ 0; 0; 0; 0; 0; ];
Array bc_U18 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U10; ];
Array bc_U19 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U11; ];
Array bc_U20 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U12; ];
Array bc_U21 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U5 --> [ 0; 0; 0; 0; 0; ];
Array bc_U22 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U13; ];
Array bc_U23 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U14; ];
Array bc_U24 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U15; ];
Array bc_U25 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U6 --> [ 0; 0; 0; 0; 0; ];
Array bc_U26 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U16; ];
Array bc_U27 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U17; ];
Array bc_U28 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U18; ];
Array bc_U29 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U7 --> [ 0; 0; 0; 0; 0; ];
Array bc_U30 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U19; ];
Array bc_U31 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U20; ];
Array bc_U32 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U21; ];
Array bc_U33 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U8 --> [ 0; 0; 0; 0; 0; ];
Array bc_U34 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U22; ];
Array bc_U35 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U23; ];
Array bc_U36 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U24; ];
Array bc_U37 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U9 --> [ 0; 0; 0; 0; 0; ];
Array bc_U38 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U25; ];
Array bc_U39 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U26; ];
Array bc_U40 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U27; ];
Array bc_U41 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U10 --> [ 0; 0; 0; 0; 0; ];
Array bc_U42 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U28; ];
Array bc_U43 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U29; ];
Array bc_U44 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U30; ];
Array bc_U45 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U11 --> [ 0; 0; 0; 0; 0; ];
Array bc_U46 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U31; ];
Array bc_U47 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U32; ];
Array bc_U48 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U33; ];
Array bc_U49 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U12 --> [ 0; 0; 0; 0; 0; ];
Array bc_U50 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U34; ];
Array bc_U51 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U35; ];
Array bc_U52 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U36; ];
Array bc_U53 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U13 --> [ 0; 0; 0; 0; 0; ];
Array bc_U54 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U37; ];
Array bc_U55 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U38; ];
Array bc_U56 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U39; ];
Array bc_U57 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U40; ];
Array bc_U58 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U59 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U41; ];
Array bc_U60 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U61 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U62 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array Rel_Record1 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "leading-through relation"; abilities_U1; A_door_to; DK10_relation_of_rooms_to_doo; call_U350; "Leading-through relates one room ( called the leading-through destination ) to various doors"; ];
Array Rel_Record2 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "lock-fitting relation"; abilities_U2; A_with_key; DK8_relation_of_things; call_U354; "Lock-fitting relates one thing ( called the matching key ) to various things"; ];
Array as_block_constant_U1 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U712; ];
Array ts_array_U1 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U713; ];
Array as_block_constant_U2 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U714; ];
Array ts_array_U2 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U715; ];
Array as_block_constant_U3 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U716; ];
Array ts_array_U3 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U717; ];
Array as_block_constant_U4 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U718; ];
Array ts_array_U4 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U719; ];
Array as_block_constant_U5 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U720; ];
Array ts_array_U5 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U721; ];
Array as_block_constant_U6 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U722; ];
Array ts_array_U6 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U723; ];
Array as_block_constant_U7 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U724; ];
Array ts_array_U7 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U725; ];
Array as_block_constant_U8 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U726; ];
Array ts_array_U8 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U727; ];
Array as_block_constant_U9 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U728; ];
Array ts_array_U9 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U729; ];
Array as_block_constant_U10 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U730; ];
Array ts_array_U10 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U731; ];
Array as_block_constant_U11 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U732; ];
Array ts_array_U11 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U733; ];
Array as_block_constant_U12 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U734; ];
Array ts_array_U12 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U735; ];
Array as_block_constant_U13 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U736; ];
Array ts_array_U13 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U737; ];
Array as_block_constant_U14 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U738; ];
Array ts_array_U14 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U739; ];
Array as_block_constant_U15 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U740; ];
Array ts_array_U15 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U741; ];
Array as_block_constant_U16 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U742; ];
Array ts_array_U16 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U743; ];
Array as_block_constant_U17 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U744; ];
Array ts_array_U17 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U745; ];
Array as_block_constant_U18 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U746; ];
Array ts_array_U18 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U747; ];
Array as_block_constant_U19 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U748; ];
Array ts_array_U19 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U749; ];
Array as_block_constant_U20 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U750; ];
Array ts_array_U20 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U751; ];
Array as_block_constant_U21 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U752; ];
Array ts_array_U21 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U753; ];
Array as_block_constant_U22 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U754; ];
Array ts_array_U22 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U755; ];
Array as_block_constant_U23 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U756; ];
Array ts_array_U23 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U757; ];
Array as_block_constant_U24 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U758; ];
Array ts_array_U24 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U759; ];
Array as_block_constant_U25 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U760; ];
Array ts_array_U25 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U761; ];
Array as_block_constant_U26 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U762; ];
Array ts_array_U26 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U763; ];
Array as_block_constant_U27 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U764; ];
Array ts_array_U27 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U765; ];
Array as_block_constant_U28 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U766; ];
Array ts_array_U28 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U767; ];
Array as_block_constant_U29 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U768; ];
Array ts_array_U29 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U769; ];
Array as_block_constant_U30 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U770; ];
Array ts_array_U30 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U771; ];
Array as_block_constant_U31 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U772; ];
Array ts_array_U31 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U773; ];
Array as_block_constant_U32 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U774; ];
Array ts_array_U32 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U775; ];
Array as_block_constant_U33 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U776; ];
Array ts_array_U33 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U777; ];
Array as_block_constant_U34 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U778; ];
Array ts_array_U34 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U779; ];
Array as_block_constant_U35 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U780; ];
Array ts_array_U35 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U781; ];
Array as_block_constant_U36 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U782; ];
Array ts_array_U36 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U783; ];
Array as_block_constant_U37 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U784; ];
Array ts_array_U37 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U785; ];
Array as_block_constant_U38 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U786; ];
Array ts_array_U38 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U787; ];
Array as_block_constant_U39 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U788; ];
Array ts_array_U39 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U789; ];
Array as_block_constant_U40 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U790; ];
Array ts_array_U40 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U791; ];
Array as_block_constant_U41 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U792; ];
Array ts_array_U41 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U793; ];
Array as_block_constant_U42 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U794; ];
Array ts_array_U42 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U795; ];
Array as_block_constant_U43 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U796; ];
Array ts_array_U43 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U797; ];
Array as_block_constant_U44 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U798; ];
Array ts_array_U44 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U799; ];
Array as_block_constant_U45 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U800; ];
Array ts_array_U45 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U801; ];
Array as_block_constant_U46 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U802; ];
Array ts_array_U46 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U803; ];
Array as_block_constant_U47 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U804; ];
Array ts_array_U47 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U805; ];
Array as_block_constant_U48 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U806; ];
Array ts_array_U48 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U807; ];
Array as_block_constant_U49 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U808; ];
Array ts_array_U49 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U809; ];
Array as_block_constant_U50 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U810; ];
Array ts_array_U50 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U811; ];
Array as_block_constant_U51 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U812; ];
Array ts_array_U51 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U813; ];
Array as_block_constant_U52 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U814; ];
Array ts_array_U52 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U815; ];
Array as_block_constant_U53 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U816; ];
Array ts_array_U53 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U817; ];
Array as_block_constant_U54 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U818; ];
Array ts_array_U54 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U819; ];
Array as_block_constant_U55 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U820; ];
Array ts_array_U55 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U821; ];
Array as_block_constant_U56 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U822; ];
Array ts_array_U56 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U823; ];
Array as_block_constant_U57 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U824; ];
Array ts_array_U57 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U825; ];
Array as_block_constant_U58 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U826; ];
Array ts_array_U58 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U827; ];
Array as_block_constant_U59 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U828; ];
Array ts_array_U59 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U829; ];
Array as_block_constant_U60 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U830; ];
Array ts_array_U60 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U831; ];
Array as_block_constant_U61 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U832; ];
Array ts_array_U61 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U833; ];
Array as_block_constant_U62 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U834; ];
Array ts_array_U62 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U835; ];
Array as_block_constant_U63 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U836; ];
Array ts_array_U63 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U837; ];
Array as_block_constant_U64 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U838; ];
Array ts_array_U64 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U839; ];
Array as_block_constant_U65 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U840; ];
Array ts_array_U65 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U841; ];
Array as_block_constant_U66 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U842; ];
Array ts_array_U66 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U843; ];
Array as_block_constant_U67 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U844; ];
Array ts_array_U67 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U845; ];
Array as_block_constant_U68 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U846; ];
Array ts_array_U68 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U847; ];
Array as_block_constant_U69 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U848; ];
Array ts_array_U69 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U849; ];
Array as_block_constant_U70 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U850; ];
Array ts_array_U70 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U851; ];
Array as_block_constant_U71 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U852; ];
Array ts_array_U71 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U853; ];
Array as_block_constant_U72 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U854; ];
Array ts_array_U72 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U855; ];
Array as_block_constant_U73 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U856; ];
Array ts_array_U73 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U857; ];
Array as_block_constant_U74 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U858; ];
Array ts_array_U74 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U859; ];
Array as_block_constant_U75 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U860; ];
Array ts_array_U75 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U861; ];
Array as_block_constant_U76 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U862; ];
Array ts_array_U76 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U863; ];
Array as_block_constant_U77 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U864; ];
Array ts_array_U77 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U865; ];
Array as_block_constant_U78 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U866; ];
Array ts_array_U78 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U867; ];
Array as_block_constant_U79 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U868; ];
Array ts_array_U79 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U869; ];
Array as_block_constant_U80 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U870; ];
Array ts_array_U80 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U871; ];
Array as_block_constant_U81 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U872; ];
Array ts_array_U81 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U873; ];
Array as_block_constant_U82 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U874; ];
Array ts_array_U82 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U875; ];
Array as_block_constant_U83 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U876; ];
Array ts_array_U83 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U877; ];
Array as_block_constant_U84 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U878; ];
Array ts_array_U84 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U879; ];
Array as_block_constant_U85 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U880; ];
Array ts_array_U85 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U881; ];
Array as_block_constant_U86 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U882; ];
Array ts_array_U86 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U883; ];
Array as_block_constant_U87 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U884; ];
Array ts_array_U87 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U885; ];
Array as_block_constant_U88 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U886; ];
Array ts_array_U88 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U887; ];
Array as_block_constant_U89 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U888; ];
Array ts_array_U89 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U889; ];
Array as_block_constant_U90 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U890; ];
Array ts_array_U90 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U891; ];
Array as_block_constant_U91 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U892; ];
Array ts_array_U91 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U893; ];
Array as_block_constant_U92 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U894; ];
Array ts_array_U92 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U895; ];
Array as_block_constant_U93 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U896; ];
Array ts_array_U93 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U897; ];
Array as_block_constant_U94 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U898; ];
Array ts_array_U94 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U899; ];
Array as_block_constant_U95 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U900; ];
Array ts_array_U95 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U901; ];
Array as_block_constant_U96 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U902; ];
Array ts_array_U96 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U903; ];
Array as_block_constant_U97 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U904; ];
Array ts_array_U97 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U905; ];
Array as_block_constant_U98 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U906; ];
Array ts_array_U98 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U907; ];
Array as_block_constant_U99 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U908; ];
Array ts_array_U99 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U909; ];
Array as_block_constant_U100 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U910; ];
Array ts_array_U100 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U911; ];
Array as_block_constant_U101 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U912; ];
Array ts_array_U101 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U913; ];
Array as_block_constant_U102 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U914; ];
Array ts_array_U102 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U915; ];
Array as_block_constant_U103 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U916; ];
Array ts_array_U103 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U917; ];
Array as_block_constant_U104 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U918; ];
Array ts_array_U104 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U919; ];
Array as_block_constant_U105 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U920; ];
Array ts_array_U105 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U921; ];
Array as_block_constant_U106 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U922; ];
Array ts_array_U106 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U923; ];
Array as_block_constant_U107 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U924; ];
Array ts_array_U107 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U925; ];
Array as_block_constant_U108 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U926; ];
Array ts_array_U108 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U927; ];
Array as_block_constant_U109 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U928; ];
Array ts_array_U109 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U929; ];
Array as_block_constant_U110 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U930; ];
Array ts_array_U110 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U931; ];
Array as_block_constant_U111 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U932; ];
Array ts_array_U111 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U933; ];
Array as_block_constant_U112 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U934; ];
Array ts_array_U112 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U935; ];
Array as_block_constant_U113 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U936; ];
Array ts_array_U113 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U937; ];
Array as_block_constant_U114 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U938; ];
Array ts_array_U114 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U939; ];
Array as_block_constant_U115 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U940; ];
Array ts_array_U115 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U941; ];
Array as_block_constant_U116 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U942; ];
Array ts_array_U116 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U943; ];
Array as_block_constant_U117 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U944; ];
Array ts_array_U117 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U945; ];
Array as_block_constant_U118 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U946; ];
Array ts_array_U118 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U947; ];
Array as_block_constant_U119 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U948; ];
Array ts_array_U119 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U949; ];
Array as_block_constant_U120 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U950; ];
Array ts_array_U120 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U951; ];
Array as_block_constant_U121 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U952; ];
Array ts_array_U121 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U953; ];
Array as_block_constant_U122 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U954; ];
Array ts_array_U122 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U955; ];
Array as_block_constant_U123 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U956; ];
Array ts_array_U123 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U957; ];
Array as_block_constant_U124 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U958; ];
Array ts_array_U124 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U959; ];
Array as_block_constant_U125 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U960; ];
Array ts_array_U125 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U961; ];
Array as_block_constant_U126 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U962; ];
Array ts_array_U126 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U963; ];
Array as_block_constant_U127 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U964; ];
Array ts_array_U127 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U965; ];
Array as_block_constant_U128 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U966; ];
Array ts_array_U128 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U967; ];
Array as_block_constant_U129 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U968; ];
Array ts_array_U129 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U969; ];
Array as_block_constant_U130 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U970; ];
Array ts_array_U130 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U971; ];
Array as_block_constant_U131 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U972; ];
Array ts_array_U131 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U973; ];
Array as_block_constant_U132 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U974; ];
Array ts_array_U132 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U975; ];
Array as_block_constant_U133 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U976; ];
Array ts_array_U133 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U977; ];
Array as_block_constant_U134 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U978; ];
Array ts_array_U134 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U979; ];
Array as_block_constant_U135 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U995; ];
Array ts_array_U135 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U996; ];
Array bc_U63 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array as_block_constant_U136 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1025; ];
Array ts_array_U136 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1026; ];
Array as_block_constant_U137 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1028; ];
Array ts_array_U137 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1029; ];
Array as_block_constant_U138 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1031; ];
Array ts_array_U138 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1032; ];
Array as_block_constant_U139 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1033; ];
Array ts_array_U139 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1034; ];
Array as_block_constant_U140 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1036; ];
Array ts_array_U140 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1037; ];
Array as_block_constant_U141 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1047; ];
Array ts_array_U141 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1048; ];
Array as_block_constant_U142 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1049; ];
Array ts_array_U142 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1050; ];
Array as_block_constant_U143 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1051; ];
Array ts_array_U143 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1052; ];
Array as_block_constant_U144 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1053; ];
Array ts_array_U144 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1054; ];
Array as_block_constant_U145 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1055; ];
Array ts_array_U145 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1056; ];
Array as_block_constant_U146 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1057; ];
Array ts_array_U146 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1058; ];
Array bc_U64 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array as_block_constant_U147 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1068; ];
Array ts_array_U147 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1069; ];
Array bc_U65 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array as_block_constant_U148 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1075; ];
Array ts_array_U148 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1076; ];
Array as_block_constant_U149 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1080; ];
Array ts_array_U149 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1081; ];
Array as_block_constant_U150 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1083; ];
Array ts_array_U150 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1084; ];
Array as_block_constant_U151 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1086; ];
Array ts_array_U151 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1087; ];
Array as_block_constant_U152 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1089; ];
Array ts_array_U152 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1090; ];
Array as_block_constant_U153 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1092; ];
Array ts_array_U153 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1093; ];
Array as_block_constant_U154 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1095; ];
Array ts_array_U154 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1096; ];
Array as_block_constant_U155 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1098; ];
Array ts_array_U155 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1099; ];
Array as_block_constant_U156 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1101; ];
Array ts_array_U156 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1102; ];
Array as_block_constant_U157 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1104; ];
Array ts_array_U157 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1105; ];
Array as_block_constant_U158 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1107; ];
Array ts_array_U158 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1108; ];
Array as_block_constant_U159 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1110; ];
Array ts_array_U159 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1111; ];
Array as_block_constant_U160 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1113; ];
Array ts_array_U160 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1114; ];
Array as_block_constant_U161 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1116; ];
Array ts_array_U161 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1117; ];
Array as_block_constant_U162 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1119; ];
Array ts_array_U162 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1120; ];
Array as_block_constant_U163 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1125; ];
Array ts_array_U163 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1126; ];
Array as_block_constant_U164 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1129; ];
Array ts_array_U164 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1130; ];
Array as_block_constant_U165 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1133; ];
Array ts_array_U165 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1134; ];
Array as_block_constant_U166 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1135; ];
Array ts_array_U166 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1136; ];
Array as_block_constant_U167 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1138; ];
Array ts_array_U167 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1139; ];
Array as_block_constant_U168 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1141; ];
Array ts_array_U168 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1142; ];
Array as_block_constant_U169 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1145; ];
Array ts_array_U169 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1146; ];
Array as_block_constant_U170 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1148; ];
Array ts_array_U170 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1149; ];
Array as_block_constant_U171 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1151; ];
Array ts_array_U171 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1152; ];
Array as_block_constant_U172 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1154; ];
Array ts_array_U172 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1155; ];
Array as_block_constant_U173 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1157; ];
Array ts_array_U173 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1158; ];
Array as_block_constant_U174 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1162; ];
Array ts_array_U174 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1163; ];
Array as_block_constant_U175 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1164; ];
Array ts_array_U175 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1165; ];
Array as_block_constant_U176 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1168; ];
Array ts_array_U176 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1169; ];
Array as_block_constant_U177 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1170; ];
Array ts_array_U177 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1171; ];
Array as_block_constant_U178 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1175; ];
Array ts_array_U178 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1176; ];
Array as_block_constant_U179 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1178; ];
Array ts_array_U179 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1179; ];
Array as_block_constant_U180 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1181; ];
Array ts_array_U180 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1182; ];
Array as_block_constant_U181 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1185; ];
Array ts_array_U181 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1186; ];
Array as_block_constant_U182 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1189; ];
Array ts_array_U182 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1190; ];
Array as_block_constant_U183 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1192; ];
Array ts_array_U183 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1193; ];
Array as_block_constant_U184 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1196; ];
Array ts_array_U184 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1197; ];
Array as_block_constant_U185 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1199; ];
Array ts_array_U185 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1200; ];
Array as_block_constant_U186 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1203; ];
Array ts_array_U186 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1204; ];
Array as_block_constant_U187 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1206; ];
Array ts_array_U187 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1207; ];
Array as_block_constant_U188 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1209; ];
Array ts_array_U188 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1210; ];
Array as_block_constant_U189 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1213; ];
Array ts_array_U189 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1214; ];
Array as_block_constant_U190 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1217; ];
Array ts_array_U190 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1218; ];
Array as_block_constant_U191 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1220; ];
Array ts_array_U191 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1221; ];
Array as_block_constant_U192 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1223; ];
Array ts_array_U192 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1224; ];
Array as_block_constant_U193 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1226; ];
Array ts_array_U193 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1227; ];
Array as_block_constant_U194 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1230; ];
Array ts_array_U194 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1231; ];
Array as_block_constant_U195 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1235; ];
Array ts_array_U195 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1236; ];
Array as_block_constant_U196 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1237; ];
Array ts_array_U196 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1238; ];
Array as_block_constant_U197 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1241; ];
Array ts_array_U197 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1242; ];
Array as_block_constant_U198 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1244; ];
Array ts_array_U198 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1245; ];
Array as_block_constant_U199 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1246; ];
Array ts_array_U199 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1247; ];
Array as_block_constant_U200 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1249; ];
Array ts_array_U200 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1250; ];
Array as_block_constant_U201 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1252; ];
Array ts_array_U201 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1253; ];
Array as_block_constant_U202 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1256; ];
Array ts_array_U202 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1257; ];
Array as_block_constant_U203 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1258; ];
Array ts_array_U203 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1259; ];
Array as_block_constant_U204 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1264; ];
Array ts_array_U204 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1265; ];
Array as_block_constant_U205 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1266; ];
Array ts_array_U205 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1267; ];
Array as_block_constant_U206 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1268; ];
Array ts_array_U206 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1269; ];
Array as_block_constant_U207 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1270; ];
Array ts_array_U207 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1271; ];
Array as_block_constant_U208 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1272; ];
Array ts_array_U208 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1273; ];
Array as_block_constant_U209 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1274; ];
Array ts_array_U209 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1275; ];
Array as_block_constant_U210 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1276; ];
Array ts_array_U210 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1277; ];
Array as_block_constant_U211 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1278; ];
Array ts_array_U211 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1279; ];
Array as_block_constant_U212 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1280; ];
Array ts_array_U212 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1281; ];
Array as_block_constant_U213 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1282; ];
Array ts_array_U213 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1283; ];
Array as_block_constant_U214 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1284; ];
Array ts_array_U214 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1285; ];
Array as_block_constant_U215 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1286; ];
Array ts_array_U215 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1287; ];
Array as_block_constant_U216 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1288; ];
Array ts_array_U216 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1289; ];
Array as_block_constant_U217 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1290; ];
Array ts_array_U217 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1291; ];
Array as_block_constant_U218 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1292; ];
Array ts_array_U218 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1293; ];
Array as_block_constant_U219 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1294; ];
Array ts_array_U219 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1295; ];
Array as_block_constant_U220 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1296; ];
Array ts_array_U220 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1297; ];
Array as_block_constant_U221 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1298; ];
Array ts_array_U221 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1299; ];
Array as_block_constant_U222 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1300; ];
Array ts_array_U222 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1301; ];
Array as_block_constant_U223 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1307; ];
Array ts_array_U223 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1308; ];
Array as_block_constant_U224 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1309; ];
Array ts_array_U224 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1310; ];
Array as_block_constant_U225 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1312; ];
Array ts_array_U225 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1313; ];
Array as_block_constant_U226 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1314; ];
Array ts_array_U226 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1315; ];
Array as_block_constant_U227 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1316; ];
Array ts_array_U227 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1317; ];
Array as_block_constant_U228 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1318; ];
Array ts_array_U228 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1319; ];
Array as_block_constant_U229 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1321; ];
Array ts_array_U229 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1322; ];
Array as_block_constant_U230 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1326; ];
Array ts_array_U230 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1327; ];
Array as_block_constant_U231 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1328; ];
Array ts_array_U231 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1329; ];
Array as_block_constant_U232 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1331; ];
Array ts_array_U232 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1332; ];
Array as_block_constant_U233 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1334; ];
Array ts_array_U233 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1335; ];
Array as_block_constant_U234 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1336; ];
Array ts_array_U234 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1337; ];
Array as_block_constant_U235 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1338; ];
Array ts_array_U235 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1339; ];
Array as_block_constant_U236 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1340; ];
Array ts_array_U236 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1341; ];
Array as_block_constant_U237 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1342; ];
Array ts_array_U237 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1343; ];
Array as_block_constant_U238 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1346; ];
Array ts_array_U238 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1347; ];
Array as_block_constant_U239 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1348; ];
Array ts_array_U239 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1349; ];
Array as_block_constant_U240 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1350; ];
Array ts_array_U240 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1351; ];
Array as_block_constant_U241 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1352; ];
Array ts_array_U241 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1353; ];
Array as_block_constant_U242 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1358; ];
Array ts_array_U242 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1359; ];
Array as_block_constant_U243 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1361; ];
Array ts_array_U243 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1362; ];
Array as_block_constant_U244 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1366; ];
Array ts_array_U244 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1367; ];
Array as_block_constant_U245 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1368; ];
Array ts_array_U245 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1369; ];
Array as_block_constant_U246 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1370; ];
Array ts_array_U246 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1371; ];
Array as_block_constant_U247 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1374; ];
Array ts_array_U247 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1375; ];
Array as_block_constant_U248 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1378; ];
Array ts_array_U248 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1379; ];
Array as_block_constant_U249 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1385; ];
Array ts_array_U249 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1386; ];
Array as_block_constant_U250 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1387; ];
Array ts_array_U250 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1388; ];
Array as_block_constant_U251 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1389; ];
Array ts_array_U251 --> [ CONSTANT_PERISHABLE_TEXT_STORAGE; call_U1390; ];
Array as_block_constant_U252 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1392; ];
Array ts_array_U252 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1393; ];
Array as_block_constant_U253 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1397; ];
Array ts_array_U253 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1398; ];
Array bc_U66 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array as_block_constant_U254 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1401; ];
Array ts_array_U254 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1402; ];
Array as_block_constant_U255 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1406; ];
Array ts_array_U255 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1407; ];
Array as_block_constant_U256 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1408; ];
Array ts_array_U256 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1409; ];
Array as_block_constant_U257 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1413; ];
Array ts_array_U257 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1414; ];
Array as_block_constant_U258 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1416; ];
Array ts_array_U258 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1417; ];
Array as_block_constant_U259 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1419; ];
Array ts_array_U259 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1420; ];
Array as_block_constant_U260 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1422; ];
Array ts_array_U260 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1423; ];
Array as_block_constant_U261 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1425; ];
Array ts_array_U261 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1426; ];
Array as_block_constant_U262 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1428; ];
Array ts_array_U262 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1429; ];
Array as_block_constant_U263 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1431; ];
Array ts_array_U263 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1432; ];
Array as_block_constant_U264 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1434; ];
Array ts_array_U264 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1435; ];
Array as_block_constant_U265 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1438; ];
Array ts_array_U265 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1439; ];
Array as_block_constant_U266 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1440; ];
Array ts_array_U266 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1441; ];
Array as_block_constant_U267 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1444; ];
Array ts_array_U267 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1445; ];
Array as_block_constant_U268 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1446; ];
Array ts_array_U268 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1447; ];
Array as_block_constant_U269 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1449; ];
Array ts_array_U269 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1450; ];
Array as_block_constant_U270 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1452; ];
Array ts_array_U270 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1453; ];
Array as_block_constant_U271 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1454; ];
Array ts_array_U271 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1455; ];
Array as_block_constant_U272 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1457; ];
Array ts_array_U272 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1458; ];
Array as_block_constant_U273 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1460; ];
Array ts_array_U273 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1461; ];
Array as_block_constant_U274 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1463; ];
Array ts_array_U274 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1464; ];
Array as_block_constant_U275 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1466; ];
Array ts_array_U275 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1467; ];
Array as_block_constant_U276 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1470; ];
Array ts_array_U276 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1471; ];
Array as_block_constant_U277 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1472; ];
Array ts_array_U277 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1473; ];
Array as_block_constant_U278 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1475; ];
Array ts_array_U278 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1476; ];
Array as_block_constant_U279 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1478; ];
Array ts_array_U279 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1479; ];
Array as_block_constant_U280 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1481; ];
Array ts_array_U280 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1482; ];
Array as_block_constant_U281 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1485; ];
Array ts_array_U281 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1486; ];
Array as_block_constant_U282 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1487; ];
Array ts_array_U282 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1488; ];
Array as_block_constant_U283 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1490; ];
Array ts_array_U283 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1491; ];
Array as_block_constant_U284 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1493; ];
Array ts_array_U284 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1494; ];
Array as_block_constant_U285 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1497; ];
Array ts_array_U285 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1498; ];
Array as_block_constant_U286 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1500; ];
Array ts_array_U286 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1501; ];
Array as_block_constant_U287 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1503; ];
Array ts_array_U287 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1504; ];
Array as_block_constant_U288 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1507; ];
Array ts_array_U288 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1508; ];
Array as_block_constant_U289 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1510; ];
Array ts_array_U289 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1511; ];
Array as_block_constant_U290 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1513; ];
Array ts_array_U290 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1514; ];
Array as_block_constant_U291 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1516; ];
Array ts_array_U291 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1517; ];
Array as_block_constant_U292 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1520; ];
Array ts_array_U292 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1521; ];
Array as_block_constant_U293 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1523; ];
Array ts_array_U293 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1524; ];
Array as_block_constant_U294 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1525; ];
Array ts_array_U294 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1526; ];
Array as_block_constant_U295 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1527; ];
Array ts_array_U295 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1528; ];
Array as_block_constant_U296 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1530; ];
Array ts_array_U296 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1531; ];
Array as_block_constant_U297 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1533; ];
Array ts_array_U297 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1534; ];
Array as_block_constant_U298 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1537; ];
Array ts_array_U298 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1538; ];
Array as_block_constant_U299 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1539; ];
Array ts_array_U299 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1540; ];
Array as_block_constant_U300 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1541; ];
Array ts_array_U300 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1542; ];
Array as_block_constant_U301 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1544; ];
Array ts_array_U301 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1545; ];
Array as_block_constant_U302 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1547; ];
Array ts_array_U302 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1548; ];
Array as_block_constant_U303 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1550; ];
Array ts_array_U303 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1551; ];
Array as_block_constant_U304 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1554; ];
Array ts_array_U304 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1555; ];
Array as_block_constant_U305 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1556; ];
Array ts_array_U305 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1557; ];
Array as_block_constant_U306 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1560; ];
Array ts_array_U306 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1561; ];
Array as_block_constant_U307 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1564; ];
Array ts_array_U307 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1565; ];
Array as_block_constant_U308 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1568; ];
Array ts_array_U308 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1569; ];
Array as_block_constant_U309 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1570; ];
Array ts_array_U309 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1571; ];
Array as_block_constant_U310 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1573; ];
Array ts_array_U310 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1574; ];
Array as_block_constant_U311 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1576; ];
Array ts_array_U311 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1577; ];
Array as_block_constant_U312 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1579; ];
Array ts_array_U312 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1580; ];
Array as_block_constant_U313 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1582; ];
Array ts_array_U313 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1583; ];
Array as_block_constant_U314 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1585; ];
Array ts_array_U314 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1586; ];
Array as_block_constant_U315 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1589; ];
Array ts_array_U315 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1590; ];
Array as_block_constant_U316 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1593; ];
Array ts_array_U316 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1594; ];
Array as_block_constant_U317 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1595; ];
Array ts_array_U317 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1596; ];
Array as_block_constant_U318 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1597; ];
Array ts_array_U318 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1598; ];
Array as_block_constant_U319 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1600; ];
Array ts_array_U319 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1601; ];
Array as_block_constant_U320 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1604; ];
Array ts_array_U320 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1605; ];
Array as_block_constant_U321 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1607; ];
Array ts_array_U321 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1608; ];
Array as_block_constant_U322 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1610; ];
Array ts_array_U322 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1611; ];
Array as_block_constant_U323 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1613; ];
Array ts_array_U323 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1614; ];
Array as_block_constant_U324 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1616; ];
Array ts_array_U324 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1617; ];
Array as_block_constant_U325 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1619; ];
Array ts_array_U325 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1620; ];
Array as_block_constant_U326 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1622; ];
Array ts_array_U326 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1623; ];
Array as_block_constant_U327 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1625; ];
Array ts_array_U327 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1626; ];
Array as_block_constant_U328 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1628; ];
Array ts_array_U328 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1629; ];
Array as_block_constant_U329 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1631; ];
Array ts_array_U329 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1632; ];
Array as_block_constant_U330 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1634; ];
Array ts_array_U330 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1635; ];
Array as_block_constant_U331 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1637; ];
Array ts_array_U331 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1638; ];
Array as_block_constant_U332 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1642; ];
Array ts_array_U332 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1643; ];
Array as_block_constant_U333 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1644; ];
Array ts_array_U333 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1645; ];
Array as_block_constant_U334 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1647; ];
Array ts_array_U334 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1648; ];
Array as_block_constant_U335 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1649; ];
Array ts_array_U335 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1650; ];
Array as_block_constant_U336 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1652; ];
Array ts_array_U336 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1653; ];
Array as_block_constant_U337 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1654; ];
Array ts_array_U337 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1655; ];
Array as_block_constant_U338 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1656; ];
Array ts_array_U338 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1657; ];
Array as_block_constant_U339 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1659; ];
Array ts_array_U339 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1660; ];
Array as_block_constant_U340 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1661; ];
Array ts_array_U340 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1662; ];
Array as_block_constant_U341 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1664; ];
Array ts_array_U341 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1665; ];
Array as_block_constant_U342 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1667; ];
Array ts_array_U342 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1668; ];
Array as_block_constant_U343 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1669; ];
Array ts_array_U343 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1670; ];
Array as_block_constant_U344 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1672; ];
Array ts_array_U344 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1673; ];
Array as_block_constant_U345 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1675; ];
Array ts_array_U345 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1676; ];
Array as_block_constant_U346 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1678; ];
Array ts_array_U346 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1679; ];
Array as_block_constant_U347 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1681; ];
Array ts_array_U347 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1682; ];
Array as_block_constant_U348 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1683; ];
Array ts_array_U348 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1684; ];
Array as_block_constant_U349 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1686; ];
Array ts_array_U349 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1687; ];
Array as_block_constant_U350 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1689; ];
Array ts_array_U350 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1690; ];
Array as_block_constant_U351 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1692; ];
Array ts_array_U351 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1693; ];
Array as_block_constant_U352 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1695; ];
Array ts_array_U352 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1696; ];
Array as_block_constant_U353 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1697; ];
Array ts_array_U353 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1698; ];
Array as_block_constant_U354 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1700; ];
Array ts_array_U354 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1701; ];
Array as_block_constant_U355 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1703; ];
Array ts_array_U355 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1704; ];
Array as_block_constant_U356 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1706; ];
Array ts_array_U356 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1707; ];
Array as_block_constant_U357 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1709; ];
Array ts_array_U357 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1710; ];
Array as_block_constant_U358 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1711; ];
Array ts_array_U358 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1712; ];
Array as_block_constant_U359 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1714; ];
Array ts_array_U359 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1715; ];
Array as_block_constant_U360 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1717; ];
Array ts_array_U360 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1718; ];
Array as_block_constant_U361 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1720; ];
Array ts_array_U361 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1721; ];
Array as_block_constant_U362 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1723; ];
Array ts_array_U362 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1724; ];
Array as_block_constant_U363 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1727; ];
Array ts_array_U363 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1728; ];
Array as_block_constant_U364 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1730; ];
Array ts_array_U364 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1731; ];
Array as_block_constant_U365 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1733; ];
Array ts_array_U365 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1734; ];
Array as_block_constant_U366 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1735; ];
Array ts_array_U366 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1736; ];
Array as_block_constant_U367 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1738; ];
Array ts_array_U367 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1739; ];
Array as_block_constant_U368 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1741; ];
Array ts_array_U368 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1742; ];
Array as_block_constant_U369 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1744; ];
Array ts_array_U369 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1745; ];
Array as_block_constant_U370 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1747; ];
Array ts_array_U370 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1748; ];
Array as_block_constant_U371 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1750; ];
Array ts_array_U371 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1751; ];
Array as_block_constant_U372 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1753; ];
Array ts_array_U372 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1754; ];
Array as_block_constant_U373 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1755; ];
Array ts_array_U373 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1756; ];
Array as_block_constant_U374 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1758; ];
Array ts_array_U374 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1759; ];
Array as_block_constant_U375 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1760; ];
Array ts_array_U375 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1761; ];
Array as_block_constant_U376 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1763; ];
Array ts_array_U376 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1764; ];
Array as_block_constant_U377 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1765; ];
Array ts_array_U377 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1766; ];
Array as_block_constant_U378 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1768; ];
Array ts_array_U378 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1769; ];
Array as_block_constant_U379 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1771; ];
Array ts_array_U379 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1772; ];
Array as_block_constant_U380 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1773; ];
Array ts_array_U380 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1774; ];
Array as_block_constant_U381 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1776; ];
Array ts_array_U381 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1777; ];
Array as_block_constant_U382 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1779; ];
Array ts_array_U382 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1780; ];
Array as_block_constant_U383 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1782; ];
Array ts_array_U383 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1783; ];
Array as_block_constant_U384 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1785; ];
Array ts_array_U384 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1786; ];
Array as_block_constant_U385 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1788; ];
Array ts_array_U385 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1789; ];
Array as_block_constant_U386 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1791; ];
Array ts_array_U386 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1792; ];
Array as_block_constant_U387 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1793; ];
Array ts_array_U387 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1794; ];
Array as_block_constant_U388 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1796; ];
Array ts_array_U388 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1797; ];
Array as_block_constant_U389 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1799; ];
Array ts_array_U389 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1800; ];
Array as_block_constant_U390 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1801; ];
Array ts_array_U390 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1802; ];
Array as_block_constant_U391 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1804; ];
Array ts_array_U391 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1805; ];
Array as_block_constant_U392 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1807; ];
Array ts_array_U392 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1808; ];
Array as_block_constant_U393 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1810; ];
Array ts_array_U393 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1811; ];
Array bc_U67 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U68 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U69 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U70 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U71 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U14 --> [ 0; 0; 0; 0; 0; ];
Array bc_U72 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U73 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U74 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U75 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U76 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U77 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U78 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U42; ];
Array bc_U79 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U80 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U81 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U82 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U43; ];
Array bc_U83 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U84 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U85 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U86 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U87 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U88 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U44; ];
Array bc_U89 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U90 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U91 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U92 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U93 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U94 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U45; ];
Array bc_U95 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U96 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U97 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U98 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U99 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U100 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U46; ];
Array bc_U101 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U102 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U103 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U104 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U105 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U106 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U47; ];
Array bc_U107 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U108 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U109 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U110 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U111 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U112 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U48; ];
Array bc_U113 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U114 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U115 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U116 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U49; ];
Array bc_U117 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U118 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U119 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U120 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U121 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U122 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U50; ];
Array bc_U123 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U124 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U125 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U126 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U127 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U128 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U51; ];
Array bc_U129 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U130 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U131 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U132 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U133 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U134 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U52; ];
Array bc_U135 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U136 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U137 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U138 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U139 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U140 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U53; ];
Array bc_U141 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U142 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U143 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U144 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U145 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U146 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U54; ];
Array bc_U147 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U148 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U149 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U150 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U151 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array DK1_rule --> [ RULE_TY; 2; ACTION_NAME_TY; VOID_TY; ];
Array DK2_activity_on_objects --> [ ACTIVITY_TY; 1; OBJECT_TY; ];
Array DK3_phrase_real_number____re --> [ PHRASE_TY; 2; REAL_NUMBER_TY; ];
Array DK4_phrase_real_number____nu --> [ PHRASE_TY; 2; NUMBER_TY; ];
Array DK10_relation_of_rooms_to_doo --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array bc_U152 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U55; ];
Array bc_U153 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U56; ];
Array bc_U154 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U57; ];
Array bc_U155 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U58; ];
Array bc_U156 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array column_data_U1 table [ column_bits_U1; column_blanks_U1; bc_U157; bc_U158; bc_U159; bc_U160; bc_U161; ];
Array bc_U157 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U59; ];
Array bc_U158 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U60; ];
Array bc_U159 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U61; ];
Array bc_U160 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U62; ];
Array bc_U161 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U63; ];
Array column_data_U2 table [ column_bits_U2; column_blanks_U2; 0; 0; 1; 0; 0; ];
Array column_data_U3 table [ column_bits_U3; column_blanks_U3; Consult_Grammar1; Consult_Grammar2; Consult_Grammar3; Consult_Grammar4; Consult_Grammar5; ];
Array column_data_U4 table [ column_bits_U4; column_blanks_U4; IMMEDIATELY_RESTART_VM_R; IMMEDIATELY_RESTORE_SAVED_R; TABLE_NOVALUE; IMMEDIATELY_QUIT_R; IMMEDIATELY_UNDO_R; ];
Array column_data_U5 table [ column_bits_U5; column_blanks_U5; TABLE_NOVALUE; TABLE_NOVALUE; V29_amusing_a_victorious_play; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U1 table [ column_data_U1; column_data_U2; column_data_U3; column_data_U4; column_data_U5; ];
Array column_data_U6 table [ column_bits_U6; NULL; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array column_data_U7 table [ column_bits_U7; column_blanks_U6; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; TABLE_NOVALUE; ];
Array table_data_U2 table [ column_data_U6; column_data_U7; ];
Array bc_U162 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U64; ];
Array bc_U163 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U65; ];
Array bc_U164 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U165 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U166 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U167 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U66; ];
Array bc_U168 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U169 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U170 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U171 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U172 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U67; ];
Array bc_U173 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U174 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U175 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U176 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U177 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U68; ];
Array bc_U178 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U179 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U180 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U181 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U182 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U69; ];
Array bc_U183 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U184 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U185 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U186 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U187 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U70; ];
Array bc_U188 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U189 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U190 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U191 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U192 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U71; ];
Array bc_U193 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U194 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U195 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U196 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U197 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U72; ];
Array bc_U198 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U199 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U200 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U201 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U202 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U73; ];
Array bc_U203 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U204 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U205 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U206 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U15 --> [ 0; 0; 0; 0; 0; ];
Array bc_U207 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U74; ];
Array bc_U208 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U209 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U210 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U211 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U212 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U16 --> [ 0; 0; 0; 0; 0; ];
Array bc_U213 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U75; ];
Array bc_U214 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U76; ];
Array bc_U215 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U216 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U217 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U218 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U17 --> [ 0; 0; 0; 0; 0; ];
Array bc_U219 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U77; ];
Array bc_U220 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U78; ];
Array bc_U221 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U222 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U223 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U224 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U18 --> [ 0; 0; 0; 0; 0; ];
Array bc_U225 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U79; ];
Array bc_U226 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U80; ];
Array bc_U227 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U228 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U229 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U230 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U19 --> [ 0; 0; 0; 0; 0; ];
Array bc_U231 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U81; ];
Array bc_U232 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U82; ];
Array bc_U233 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U234 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U235 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U236 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U20 --> [ 0; 0; 0; 0; 0; ];
Array bc_U237 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U83; ];
Array ts_array_U394 --> [ CONSTANT_PACKED_TEXT_STORAGE; call_U1915; ];
Array bc_U238 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U239 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U84; ];
Array bc_U240 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U241 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U21 --> [ 0; 0; 0; 0; 0; ];
Array bc_U242 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U85; ];
Array bc_U243 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U244 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U245 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U246 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U247 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array inline_U22 --> [ 0; 0; 0; 0; 0; ];
Array bc_U248 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U86; ];
Array bc_U249 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U250 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U251 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U87; ];
Array bc_U252 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U253 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U254 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U88; ];
Array bc_U255 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U256 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U257 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U258 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array bc_U259 --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array DK5_relation_of_values --> [ RELATION_TY; 2; VALUE_TY; VALUE_TY; ];
Array DK6_relation_of_objects --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array DK7_relation_of_supporters_t --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array DK8_relation_of_things --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array DK9_relation_of_people_to_th --> [ RELATION_TY; 2; OBJECT_TY; OBJECT_TY; ];
Array Rel_Record3 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "equality relation"; abilities_U3; 0; DK5_relation_of_values; call_U1948; "is"; ];
Array Rel_Record4 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "meaning relation"; abilities_U4; 0; DK6_relation_of_objects; call_U1949; "means"; ];
Array Rel_Record5 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "possession relation"; abilities_U5; 0; DK6_relation_of_objects; call_U1950; "has"; ];
Array Rel_Record6 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "universal relation"; abilities_U6; 0; DK6_relation_of_objects; call_U1951; "relates"; ];
Array Rel_Record7 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "provision relation"; abilities_U7; 0; DK6_relation_of_objects; call_U1952; "provides"; ];
Array Rel_Record8 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "containment relation"; abilities_U8; 0; DK6_relation_of_objects; call_U1953; "contains"; ];
Array Rel_Record9 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "support relation"; abilities_U9; 0; DK7_relation_of_supporters_t; call_U1954; "supports"; ];
Array Rel_Record10 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "incorporation relation"; abilities_U10; 0; DK8_relation_of_things; call_U1955; "incorporates"; ];
Array Rel_Record11 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "enclosure relation"; abilities_U11; 0; DK6_relation_of_objects; call_U1956; "encloses"; ];
Array Rel_Record12 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "carrying relation"; abilities_U12; 0; DK9_relation_of_people_to_th; call_U1957; "carries"; ];
Array Rel_Record13 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "holding relation"; abilities_U13; 0; DK9_relation_of_people_to_th; call_U1958; "holds"; ];
Array Rel_Record14 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "wearing relation"; abilities_U14; 0; DK9_relation_of_people_to_th; call_U1959; "wears"; ];
Array Rel_Record15 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "visibility relation"; abilities_U15; 0; DK8_relation_of_things; call_U1960; "can-see"; ];
Array Rel_Record16 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "touchability relation"; abilities_U16; 0; DK8_relation_of_things; call_U1961; "can-touch"; ];
Array Rel_Record17 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "concealment relation"; abilities_U17; 0; DK8_relation_of_things; call_U1962; "conceals"; ];
Array Rel_Record18 --> [ 0; 101515264; RELATION_TY; MAX_POSITIVE_NUMBER; NULL; NULL; "never-holding relation"; abilities_U18; 0; DK5_relation_of_values; call_U1963; "is"; ];
Array bc_U260 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U89; ];
Array bc_U261 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U90; ];
Array bc_U262 --> [ CONSTANT_PACKED_TEXT_STORAGE; text_U91; ];
Array UUID_ARRAY -> [ 45; 'U'; 'U'; 'I'; 'D'; ':'; '/'; '/'; '8'; 'C'; '1'; '8'; '5'; 'B'; '5'; 'A'; '-'; 'C'; '2'; '2'; '8'; '-'; '4'; '6'; 'B'; '7'; '-'; 'B'; 'A'; '4'; '9'; '-'; 'F'; '0'; '5'; '7'; 'E'; '8'; '0'; '9'; '3'; 'E'; '2'; '8'; '/'; '/'; ];
Array InitialSituation --> [ selfobj; 0; I_kitchen_U1; 540; 0; ];
Array Map_Storage --> [ I_hallway_U1; 0; 0; I_living_room_U1; 0; 0; 0; I_living_room_U1; 0; I_basement_U1; 0; I_patio_U1; I_girl_s_room_U1; 0; 0; I_kitchen_U1; 0; I_pantry_U1; I_bathroom_U1; I_big_room_U1; 0; 0; 0; 0; 0; 0; 0; I_hallway_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_hallway_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_hallway_U1; 0; 0; 0; 0; 0; I_hallway_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_kitchen_U1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; I_kitchen_U1; 0; I_kitchen_U1; 0; 0; 0; 0; 0; I_kitchen_U1; 0; 0; 0; 0; 0; ];
Array name_array1 --> [ 'north'; 'directions//p'; 'n//'; ];
Array name_array2 --> [ 'northeast'; 'directions//p'; 'ne'; ];
Array name_array3 --> [ 'northwest'; 'directions//p'; 'nw'; ];
Array name_array4 --> [ 'south'; 'directions//p'; 's//'; ];
Array name_array5 --> [ 'southeast'; 'directions//p'; 'se'; ];
Array name_array6 --> [ 'southwest'; 'directions//p'; 'sw'; ];
Array name_array7 --> [ 'east'; 'directions//p'; 'e//'; ];
Array name_array8 --> [ 'west'; 'directions//p'; 'w//'; ];
Array name_array9 --> [ 'up'; 'directions//p'; 'u//'; ];
Array name_array10 --> [ 'down'; 'directions//p'; 'd//'; ];
Array name_array11 --> [ 'inside'; 'directions//p'; 'in'; ];
Array name_array12 --> [ 'outside'; 'directions//p'; 'out'; ];
Array name_array13 --> [ 'kitchen'; 'rooms//p'; ];
Array name_array14 --> [ 'hallway'; 'rooms//p'; ];
Array name_array15 --> [ 'girl^s'; 'room'; 'rooms//p'; ];
Array name_array16 --> [ 'big'; 'room'; 'rooms//p'; ];
Array name_array17 --> [ 'bathroom'; 'rooms//p'; ];
Array name_array18 --> [ 'pantry'; 'rooms//p'; ];
Array name_array19 --> [ 'basement'; 'rooms//p'; ];
Array name_array20 --> [ 'patio'; 'rooms//p'; ];
Array name_array21 --> [ 'living'; 'room'; 'rooms//p'; ];
Array name_array22 --> [ 'makeup'; 'table'; 'things//p'; ];
Array name_array23 --> [ 'stories'; 'things//p'; ];
Array name_array24 --> [ 'magic'; 'bottle'; 'things//p'; ];
Array name_array25 --> [ 'blue'; 'chalk'; 'things//p'; ];
Array name_array26 --> [ 'stool'; 'things//p'; ];
Array name_array27 --> [ 'simi'; 'little//p'; 'girls//p'; ];
Array name_array28 --> [ 'milky'; 'things//p'; ];
Array name_array29 --> [ 'savleen'; 'little//p'; 'girls//p'; ];
Array LocalParking --> [ 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; ];
Array PowersOfTwo_TB --> [ 2048; 1024; 512; 256; 128; 64; 32; 16; 8; 4; 2; 1; ];
Array IncreasingPowersOfTwo_TB --> [ 1; 2; 4; 8; 16; 32; 64; 128; 256; 512; 1024; 2048; 4096; 8192; 16384; 32768; ];
Array EMPTY_TEXT_VALUE --> [ CONSTANT_PACKED_TEXT_STORAGE; EMPTY_TEXT_PACKED; ];
Array TheEmptyTable --> [ 0; 0; ];
Array blockv_stack --> 2048; ! blank with extent 2048
Array Protect_I7_Arrays --> [ 16339; 12345; ];
Array I7_SOO_SHUF -> 32; ! blank with extent 32
Array gg_event --> 4; ! blank with extent 4
Array gg_arguments buffer 28; ! blank with extent 28
Array buffer buffer 260; ! blank with extent 260
Array buffer2 buffer 260; ! blank with extent 260
Array buffer3 buffer 260; ! blank with extent 260
Array parse --> 61; ! blank with extent 61
Array parse2 --> 61; ! blank with extent 61
Array gg_tokenbuf -> 9; ! blank with extent 9
Array AnyToStrArr -> 67; ! blank with extent 67
Array PowersOfTen --> [ 1; 10; 100; 1000; 10000; 100000; 1000000; 10000000; 100000000; 1000000000; ];
Array CheckTableEntryIsBlank_LU -> [ 1; 2; 4; 8; 16; 32; 64; 128; ];
Array CheckTableEntryIsNonBlank_LU -> [ 254; 253; 251; 247; 239; 223; 191; 127; ];
Array MStack --> 160; ! blank with extent 160
Array latest_rule_result --> 3; ! blank with extent 3
Array Flex_Heap -> 32788; ! blank with extent 32788
Array TEXT_TY_Buffers --> 2058; ! blank with extent 2058
Array CharCasingChart0 --> [ 97; 26; -32; 170; 1; UNIC_NCT; 181; 1; 743; 186; 1; UNIC_NCT; 223; 1; UNIC_NCT; 224; 23; -32; 248; 7; -32; 255; 1; 121; 257; -47; -1; 305; 1; -232; 307; -5; -1; 312; 1; UNIC_NCT; 314; -15; -1; 329; 1; UNIC_NCT; 331; -45; -1; 378; -5; -1; 383; 1; -300; 384; 1; UNIC_NCT; 387; -3; -1; 392; 1; -1; 396; 1; -1; 397; 1; UNIC_NCT; 402; 1; -1; 405; 1; 97; 409; 1; -1; 410; 2; UNIC_NCT; 414; 1; 130; 417; -5; -1; 424; 1; -1; 426; 2; UNIC_NCT; 429; 1; -1; 432; 1; -1; 436; -3; -1; 441; 1; -1; 442; 1; UNIC_NCT; 445; 1; -1; 446; 1; UNIC_NCT; 447; 1; 56; 454; 1; -2; 457; 1; -2; 460; 1; -2; 462; -15; -1; 477; 1; -79; 479; -17; -1; 496; 1; UNIC_NCT; 499; 1; -2; 501; 1; -1; 505; -39; -1; 545; 1; UNIC_NCT; 547; -17; -1; 564; 3; UNIC_NCT; 592; 3; UNIC_NCT; 595; 1; -210; 596; 1; -206; 597; 1; UNIC_NCT; 598; 2; -205; 600; 1; UNIC_NCT; 601; 1; -202; 602; 1; UNIC_NCT; 603; 1; -203; 604; 4; UNIC_NCT; 608; 1; -205; 609; 2; UNIC_NCT; 611; 1; -207; 612; 4; UNIC_NCT; 616; 1; -209; 617; 1; -211; 618; 5; UNIC_NCT; 623; 1; -211; 624; 2; UNIC_NCT; 626; 1; -213; 627; 2; UNIC_NCT; 629; 1; -214; 630; 10; UNIC_NCT; 640; 1; -218; 641; 2; UNIC_NCT; 643; 1; -218; 644; 4; UNIC_NCT; 648; 1; -218; 649; 1; UNIC_NCT; 650; 2; -217; 652; 6; UNIC_NCT; 658; 1; -219; 659; 29; UNIC_NCT; 912; 1; UNIC_NCT; 940; 1; -38; 941; 3; -37; 944; 1; UNIC_NCT; 945; 17; -32; 962; 1; -31; 963; 9; -32; 972; 1; -64; 973; 2; -63; 976; 1; -62; 977; 1; -57; 981; 1; -47; 982; 1; -54; 983; 1; UNIC_NCT; 985; -23; -1; 1008; 1; -86; 1009; 1; -80; 1010; 1; 7; 1011; 1; UNIC_NCT; 1013; 1; -96; 1016; 1; -1; 1019; 1; -1; 1072; 32; -32; 1104; 16; -80; 1121; -33; -1; 1163; -53; -1; 1218; -13; -1; 1233; -37; -1; 1273; 1; -1; 1281; -15; -1; 1377; 38; -48; 1415; 1; UNIC_NCT; 7424; 44; UNIC_NCT; 7522; 10; UNIC_NCT; 7681; -149; -1; 7830; 5; UNIC_NCT; 7835; 1; -59; 7841; -89; -1; 7936; 8; 8; 7952; 6; 8; 7968; 8; 8; 7984; 8; 8; 8000; 6; 8; 8016; 1; UNIC_NCT; 8017; 1; 8; 8018; 1; UNIC_NCT; 8019; 1; 8; 8020; 1; UNIC_NCT; 8021; 1; 8; 8022; 1; UNIC_NCT; 8023; 1; 8; 8032; 8; 8; 8048; 2; 74; 8050; 4; 86; 8054; 2; 100; 8056; 2; 128; 8058; 2; 112; 8060; 2; 126; 8064; 8; 8; 8080; 8; 8; 8096; 8; 8; 8112; 2; 8; 8114; 1; UNIC_NCT; 8115; 1; 9; 8116; -3; UNIC_NCT; 8119; 1; UNIC_NCT; 8126; 1; -7205; 8130; 1; UNIC_NCT; 8131; 1; 9; 8132; -3; UNIC_NCT; 8135; 1; UNIC_NCT; 8144; 2; 8; 8146; 2; UNIC_NCT; 8150; 2; UNIC_NCT; 8160; 2; 8; 8162; 3; UNIC_NCT; 8165; 1; 7; 8166; 2; UNIC_NCT; 8178; 1; UNIC_NCT; 8179; 1; 9; 8180; -3; UNIC_NCT; 8183; 1; UNIC_NCT; 8305; 1; UNIC_NCT; 8319; 1; UNIC_NCT; 8458; 1; UNIC_NCT; 8462; 2; UNIC_NCT; 8467; 1; UNIC_NCT; 8495; 1; UNIC_NCT; 8500; 1; UNIC_NCT; 8505; 1; UNIC_NCT; 8509; 1; UNIC_NCT; 8518; 4; UNIC_NCT; 64256; 7; UNIC_NCT; 64275; 5; UNIC_NCT; 65345; 26; -32; 0; ];
Array CharCasingChart1 --> [ 65; 26; 32; 192; 23; 32; 216; 7; 32; 256; -47; 1; 304; 1; -199; 306; -5; 1; 313; -15; 1; 330; -45; 1; 376; 1; -121; 377; -5; 1; 385; 1; 210; 386; -3; 1; 390; 1; 206; 391; 1; 1; 393; 2; 205; 395; 1; 1; 398; 1; 79; 399; 1; 202; 400; 1; 203; 401; 1; 1; 403; 1; 205; 404; 1; 207; 406; 1; 211; 407; 1; 209; 408; 1; 1; 412; 1; 211; 413; 1; 213; 415; 1; 214; 416; -5; 1; 422; 1; 218; 423; 1; 1; 425; 1; 218; 428; 1; 1; 430; 1; 218; 431; 1; 1; 433; 2; 217; 435; -3; 1; 439; 1; 219; 440; 1; 1; 444; 1; 1; 452; 1; 2; 455; 1; 2; 458; 1; 2; 461; -15; 1; 478; -17; 1; 497; 1; 2; 500; 1; 1; 502; 1; -97; 503; 1; -56; 504; -39; 1; 544; 1; -130; 546; -17; 1; 902; 1; 38; 904; 3; 37; 908; 1; 64; 910; 2; 63; 913; 17; 32; 931; 9; 32; 978; 3; UNIC_NCT; 984; -23; 1; 1012; 1; -60; 1015; 1; 1; 1017; 1; -7; 1018; 1; 1; 1024; 16; 80; 1040; 32; 32; 1120; -33; 1; 1162; -53; 1; 1216; 1; UNIC_NCT; 1217; -13; 1; 1232; -37; 1; 1272; 1; 1; 1280; -15; 1; 1329; 38; 48; 4256; 38; UNIC_NCT; 7680; -149; 1; 7840; -89; 1; 7944; 8; -8; 7960; 6; -8; 7976; 8; -8; 7992; 8; -8; 8008; 6; -8; 8025; -7; -8; 8040; 8; -8; 8120; 2; -8; 8122; 2; -74; 8136; 4; -86; 8152; 2; -8; 8154; 2; -100; 8168; 2; -8; 8170; 2; -112; 8172; 1; -7; 8184; 2; -128; 8186; 2; -126; 8450; 1; UNIC_NCT; 8455; 1; UNIC_NCT; 8459; 3; UNIC_NCT; 8464; 3; UNIC_NCT; 8469; 1; UNIC_NCT; 8473; 5; UNIC_NCT; 8484; 1; UNIC_NCT; 8486; 1; -7517; 8488; 1; UNIC_NCT; 8490; 1; -8383; 8491; 1; -8262; 8492; 2; UNIC_NCT; 8496; 2; UNIC_NCT; 8499; 1; UNIC_NCT; 8510; 2; UNIC_NCT; 8517; 1; UNIC_NCT; 65313; 26; 32; 0; ];
Array RE_PACKET_space --> 448; ! blank with extent 448
Array RE_Subexpressions --> 11; ! blank with extent 11
Array Allocated_Match_Vars --> 10; ! blank with extent 10
Array Subexp_Posns --> 20; ! blank with extent 20
Array RTP_Buffer --> [ -1; 0; 0; 0; 0; 0; 0; ];
Array LanguagePronouns table [ 'it'; 568; NULL; 'him'; 2048; NULL; 'her'; 1024; NULL; 'them'; 455; NULL; ];
Array LanguageDescriptors table [ 'my'; 4095; POSSESS_PK; 0; 'this'; 4095; POSSESS_PK; 0; 'these'; 455; POSSESS_PK; 0; 'that'; 4095; POSSESS_PK; 1; 'those'; 455; POSSESS_PK; 1; 'his'; 4095; POSSESS_PK; 'him'; 'her'; 4095; POSSESS_PK; 'her'; 'their'; 4095; POSSESS_PK; 'them'; 'its'; 4095; POSSESS_PK; 'it'; 'the'; 4095; DEFART_PK; NULL; 'a//'; 3640; INDEFART_PK; NULL; 'an'; 3640; INDEFART_PK; NULL; 'some'; 455; INDEFART_PK; NULL; 'lit'; 4095; LIGHTED_PK; NULL; 'lighted'; 4095; LIGHTED_PK; NULL; 'unlit'; 4095; UNLIGHTED_PK; NULL; ];
Array LanguageNumbers table [ 'one'; 1; 'two'; 2; 'three'; 3; 'four'; 4; 'five'; 5; 'six'; 6; 'seven'; 7; 'eight'; 8; 'nine'; 9; 'ten'; 10; 'eleven'; 11; 'twelve'; 12; 'thirteen'; 13; 'fourteen'; 14; 'fifteen'; 15; 'sixteen'; 16; 'seventeen'; 17; 'eighteen'; 18; 'nineteen'; 19; 'twenty'; 20; 'twenty-one'; 21; 'twenty-two'; 22; 'twenty-three'; 23; 'twenty-four'; 24; 'twenty-five'; 25; 'twenty-six'; 26; 'twenty-seven'; 27; 'twenty-eight'; 28; 'twenty-nine'; 29; 'thirty'; 30; ];
Array LanguageArticles --> [ "The "; "the "; "a "; "The "; "the "; "an "; "The "; "the "; "some "; "The "; "the "; "some "; ];
Array LanguageGNAsToArticles --> [ 0; 0; 0; 1; 1; 1; 0; 0; 0; 1; 1; 1; ];
Array scene_started --> 3; ! blank with extent 3
Array scene_ended --> 3; ! blank with extent 3
Array scene_status --> 3; ! blank with extent 3
Array scene_endings --> 3; ! blank with extent 3
Array scene_latest_ending --> 3; ! blank with extent 3
Array multiple_object --> 100; ! blank with extent 100
Array parser_results --> 16; ! blank with extent 16
Array requisition_stack --> 90; ! blank with extent 90
Array LWI_Storage --> [ 1; -1; Computed_Constant_Value_4_U2; ];
Array Details_of_Specific_Action --> 5; ! blank with extent 5
Array activities_stack --> 20; ! blank with extent 20
Array activity_parameters_stack --> 20; ! blank with extent 20
Array ResourceUsageFlags -> 6; ! blank with extent 6
Array T_SL_Score_Moves --> [ CONSTANT_PACKED_TEXT_STORAGE; SL_Score_Moves; ];
Array T_SL_Location --> [ CONSTANT_PACKED_TEXT_STORAGE; SL_Location; ];
Array StorageForShortName buffer 250; ! blank with extent 250
Array DoorRoutingViable -> 1; ! blank with extent 1
Array FWMatrix --> 81; ! blank with extent 81
Array test_stack --> 128; ! blank with extent 128
Array TimesActionHasHappened --> 1; ! blank with extent 1
Array TurnsActionHasBeenHappening --> 1; ! blank with extent 1
Array LastTurnActionHappenedOn --> 1; ! blank with extent 1
Array ActionCurrentlyHappeningFlag -> 1; ! blank with extent 1
Array past_chronological_record --> 1; ! blank with extent 1
Array present_chronological_record --> 1; ! blank with extent 1
Array SAT_Tmp --> 7; ! blank with extent 7
Array pattern --> 32; ! blank with extent 32
Array pattern2 --> 32; ! blank with extent 32
Array line_ttype --> 32; ! blank with extent 32
Array line_tdata --> 32; ! blank with extent 32
Array line_token --> 32; ! blank with extent 32
Array oops_workspace -> 64; ! blank with extent 64
Array match_list --> 100; ! blank with extent 100
Array match_classes --> 100; ! blank with extent 100
Array match_scores --> 100; ! blank with extent 100
Array alt_match_list --> 101; ! blank with extent 101
Array KOVP_0 table [ 0; 0; 1; ];
Array KOVP_1 table [ 0; 0; bc_U62; ];
Array KOVP_2 table [ 0; 0; I_first_person_plural_U1; I_first_person_singular_U1; I_first_person_singular_U1; I_first_person_singular_U1; I_first_person_singular_U1; I_first_person_singular_U1; ];
Array value_ranges --> 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
Array value_property_holders --> 0 0 VPH_2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 VPH_25 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
Class K0_kind
    has ~pluralname
    has ~proper
    with short_name bc_U1
    with plural bc_U2
    with article bc_U3
    has ~ambigpluralname
    with list_together bc_U4
;
Class K1_room
  class K0_kind
    with description bc_U67
    with map_region 0
    has ~privately_named
    has light
    has ~visited
    with short_name bc_U68
    with plural bc_U69
    with article bc_U70
    with list_together bc_U71
;
Class K2_thing
  class K0_kind
    has ~privately_named
    has ~light
    has ~edible
    has ~static
    has ~concealed
    has ~workflag
    has mentioned
    with component_parent 0
    with component_child 0
    with component_sibling 0
    with action_bitmap 0 0 0 0 0
    has ~scenery
    has ~clothing
    has ~pushable
    has ~moved
    with description bc_U72
    with initial bc_U73
    with with_key 0
    with short_name bc_U74
    with plural bc_U75
    with article bc_U76
    with list_together bc_U77
;
Class K6_supporter
  class K2_thing
    with plural bc_U94
    with capacity 100
    has static
    has transparent
    has ~enterable
    with description bc_U95
    with initial bc_U96
    with short_name bc_U97
    with article bc_U98
    with list_together bc_U99
;
Class K8_person
  class K2_thing
    with plural bc_U106
    with capacity 100
    has transparent
    has ~female
    has ~neuter
    with description bc_U107
    with initial bc_U108
    with short_name bc_U109
    with article bc_U110
    with list_together bc_U111
;
Class K10_man
  class K8_person
    with plural bc_U116
    has ~female
    has ~neuter
    with description bc_U117
    with initial bc_U118
    with short_name bc_U119
    with article bc_U120
    with list_together bc_U121
;
Class K11_woman
  class K8_person
    with plural bc_U122
    has female
    has ~neuter
    with description bc_U123
    with initial bc_U124
    with short_name bc_U125
    with article bc_U126
    with list_together bc_U127
;
Class K12_animal
  class K8_person
    with plural bc_U128
    with description bc_U129
    with initial bc_U130
    with short_name bc_U131
    with article bc_U132
    with list_together bc_U133
;
Class K16_little_girl
  class K8_person
    with plural bc_U254
    has female
    with description bc_U255
    with initial bc_U256
    with short_name bc_U257
    with article bc_U258
    with list_together bc_U259
;
Class K4_door
  class K2_thing
    with plural bc_U82
    has static
    has ~pushable
    has ~open
    has openable
    has ~lockable
    has ~locked
    with door_to 0
    with with_key 0
    with description bc_U83
    with initial bc_U84
    with short_name bc_U85
    with article bc_U86
    with list_together bc_U87
;
Class K5_container
  class K2_thing
    with plural bc_U88
    with capacity 100
    has ~transparent
    has open
    has ~openable
    has ~lockable
    has ~locked
    has ~enterable
    with with_key 0
    with description bc_U89
    with initial bc_U90
    with short_name bc_U91
    with article bc_U92
    with list_together bc_U93
;
Class K14_vehicle
  class K5_container
    with plural bc_U140
    has static
    has enterable
    with description bc_U141
    with initial bc_U142
    with short_name bc_U143
    with article bc_U144
    with list_together bc_U145
;
Class K15_player_s_holdall
  class K5_container
    with plural bc_U146
    has ~static
    has openable
    with description bc_U147
    with initial bc_U148
    with short_name bc_U149
    with article bc_U150
    with list_together bc_U151
;
Class K7_backdrop
  class K2_thing
    with plural bc_U100
    has static
    has scenery
    has ~pushable
    with description bc_U101
    with initial bc_U102
    with short_name bc_U103
    with article bc_U104
    with list_together bc_U105
;
Class K13_device
  class K2_thing
    with plural bc_U134
    has ~on
    with description bc_U135
    with initial bc_U136
    with short_name bc_U137
    with article bc_U138
    with list_together bc_U139
;
Class K9_region
  class K0_kind
    with plural bc_U112
    has ~privately_named
    with short_name bc_U113
    with article bc_U114
    with list_together bc_U115
;
Class K3_direction
  class K0_kind
    with plural bc_U78
    has ~privately_named
    has scenery
    has ~workflag
    with P_opposite I_north_U1
    with short_name bc_U79
    with article bc_U80
    with list_together bc_U81
;
Object Compass "(Compass object)"
    has concealed
;
Object thedark "(thedark object)"
    has concealed
;
Object VPH_25    with P_recurring KOVP_0
    with description KOVP_1
;
Object VPH_2    with P_adaptive_text_viewpoint KOVP_2
;
K3_direction I_north_U1 Compass    with short_name bc_U6
    with article bc_U7
    with P_opposite I_south_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 0
    with K3_direction_Next I_northeast_U1
    with action_bitmap 0 0 0 0 0
    with parse_name parse_name1
    with name 'north' 'directions//p' 'n//'
    with plural bc_U8
    with list_together bc_U9
;
K3_direction I_northeast_U1 Compass    with short_name bc_U10
    with article bc_U11
    with P_opposite I_southwest_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 1
    with K3_direction_Next I_northwest_U1
    with action_bitmap 0 0 0 0 0
    with parse_name parse_name2
    with name 'northeast' 'directions//p' 'ne'
    with plural bc_U12
    with list_together bc_U13
;
K3_direction I_northwest_U1 Compass    with short_name bc_U14
    with article bc_U15
    with P_opposite I_southeast_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 2
    with K3_direction_Next I_south_U1
    with action_bitmap 0 0 0 0 0
    with parse_name parse_name3
    with name 'northwest' 'directions//p' 'nw'
    with plural bc_U16
    with list_together bc_U17
;
K3_direction I_south_U1 Compass    with short_name bc_U18
    with article bc_U19
    with P_opposite I_north_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 3
    with K3_direction_Next I_southeast_U1
    with action_bitmap 0 0 0 0 0
    with parse_name parse_name4
    with name 'south' 'directions//p' 's//'
    with plural bc_U20
    with list_together bc_U21
;
K3_direction I_southeast_U1 Compass    with short_name bc_U22
    with article bc_U23
    with P_opposite I_northwest_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 4
    with K3_direction_Next I_southwest_U1
    with action_bitmap 0 0 0 0 0
    with parse_name parse_name5
    with name 'southeast' 'directions//p' 'se'
    with plural bc_U24
    with list_together bc_U25
;
K3_direction I_southwest_U1 Compass    with short_name bc_U26
    with article bc_U27
    with P_opposite I_northeast_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 5
    with K3_direction_Next I_east_U1
    with action_bitmap 0 0 0 0 0
    with parse_name parse_name6
    with name 'southwest' 'directions//p' 'sw'
    with plural bc_U28
    with list_together bc_U29
;
K3_direction I_east_U1 Compass    with short_name bc_U30
    with article bc_U31
    with P_opposite I_west_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 6
    with K3_direction_Next I_west_U1
    with action_bitmap 0 0 0 0 0
    with parse_name parse_name7
    with name 'east' 'directions//p' 'e//'
    with plural bc_U32
    with list_together bc_U33
;
K3_direction I_west_U1 Compass    with short_name bc_U34
    with article bc_U35
    with P_opposite I_east_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 7
    with K3_direction_Next I_up_U1
    with action_bitmap 0 0 0 0 0
    with parse_name parse_name8
    with name 'west' 'directions//p' 'w//'
    with plural bc_U36
    with list_together bc_U37
;
K3_direction I_up_U1 Compass    with short_name bc_U38
    with article bc_U39
    with P_opposite I_down_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 8
    with K3_direction_Next I_down_U1
    with action_bitmap 0 0 0 0 0
    with parse_name parse_name9
    with name 'up' 'directions//p' 'u//'
    with plural bc_U40
    with list_together bc_U41
;
K3_direction I_down_U1 Compass    with short_name bc_U42
    with article bc_U43
    with P_opposite I_up_U1
    with vector 0
    with KD_Count 3
    with IK3_Count 9
    with K3_direction_Next in_obj
    with action_bitmap 0 0 0 0 0
    with parse_name parse_name10
    with name 'down' 'directions//p' 'd//'
    with plural bc_U44
    with list_together bc_U45
;
K3_direction in_obj Compass    with short_name bc_U46
    with article bc_U47
    with P_opposite out_obj
    with vector 0
    with KD_Count 3
    with IK3_Count 10
    with K3_direction_Next out_obj
    with action_bitmap 0 0 0 0 0
    with parse_name parse_name11
    with name 'inside' 'directions//p' 'in'
    with plural bc_U48
    with list_together bc_U49
;
K3_direction out_obj Compass    with short_name bc_U50
    with article bc_U51
    with P_opposite in_obj
    with vector 0
    with KD_Count 3
    with IK3_Count 11
    with K3_direction_Next 0
    with action_bitmap 0 0 0 0 0
    with parse_name parse_name12
    with name 'outside' 'directions//p' 'out'
    with plural bc_U52
    with list_together bc_U53
;
K8_person selfobj    with short_name bc_U54
    with description bc_U55
    has proper
    has privately_named
    has concealed
    with vector 0
    with cap_short_name bc_U56
    has mark_as_thing
    has animate
    with before NULL
    with saved_short_name bc_U57
    with KD_Count 8
    with IK2_Count 0
    with K2_thing_Next I_stories_U1
    with IK8_Count 0
    with K8_person_Next I_simi_U1
    with action_bitmap 0 0 0 0 0
    with parse_name parse_name13
    with initial bc_U58
    with plural bc_U59
    with article bc_U60
    with list_together bc_U61
;
K1_room I_kitchen_U1    with short_name bc_U162
    with description bc_U163
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 0
    with K1_room_Next I_hallway_U1
    with name 'kitchen' 'rooms//p'
    with plural bc_U164
    with article bc_U165
    with list_together bc_U166
;
K2_thing -> I_stories_U1    with short_name bc_U213
    with description bc_U214
    has pluralname
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 2
    with K2_thing_Next I_magic_bottle_U1
    with action_bitmap 0 0 0 0 0
    with name 'stories' 'things//p'
    with initial bc_U215
    with plural bc_U216
    with article bc_U217
    with list_together bc_U218
;
K2_thing -> I_magic_bottle_U1    with short_name bc_U219
    with description bc_U220
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 3
    with K2_thing_Next I_blue_chalk_U1
    with action_bitmap 0 0 0 0 0
    with name 'magic' 'bottle' 'things//p'
    with initial bc_U221
    with plural bc_U222
    with article bc_U223
    with list_together bc_U224
;
K2_thing -> I_blue_chalk_U1    with short_name bc_U225
    with description bc_U226
    has pluralname
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 4
    with K2_thing_Next I_stool_U1
    with action_bitmap 0 0 0 0 0
    with name 'blue' 'chalk' 'things//p'
    with initial bc_U227
    with plural bc_U228
    with article bc_U229
    with list_together bc_U230
;
K2_thing -> I_stool_U1    with short_name bc_U231
    with description bc_U232
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 5
    with K2_thing_Next I_simi_U1
    with action_bitmap 0 0 0 0 0
    with name 'stool' 'things//p'
    with initial bc_U233
    with plural bc_U234
    with article bc_U235
    with list_together bc_U236
;
K16_little_girl -> I_simi_U1    with short_name bc_U237
    with description ts_array_U394
    has proper
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 16
    with IK2_Count 6
    with K2_thing_Next I_milky_U1
    with IK8_Count 1
    with K8_person_Next I_savleen_U1
    with K16_little_girl_Count 0
    with K16_little_girl_Next I_savleen_U1
    with action_bitmap 0 0 0 0 0
    with name 'simi' 'little//p' 'girls//p'
    with initial bc_U238
    with plural bc_U239
    with article bc_U240
    with list_together bc_U241
;
K2_thing -> -> I_milky_U1    with short_name bc_U242
    has ~static
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 7
    with K2_thing_Next I_savleen_U1
    with action_bitmap 0 0 0 0 0
    with name 'milky' 'things//p'
    with description bc_U243
    with initial bc_U244
    with plural bc_U245
    with article bc_U246
    with list_together bc_U247
;
K16_little_girl -> I_savleen_U1    with short_name bc_U248
    has proper
    with vector 0
    has mark_as_thing
    has animate
    with before NULL
    with KD_Count 16
    with IK2_Count 8
    with K2_thing_Next I_makeup_table_U1
    with IK8_Count 2
    with K8_person_Next 0
    with K16_little_girl_Count 1
    with K16_little_girl_Next 0
    with action_bitmap 0 0 0 0 0
    with name 'savleen' 'little//p' 'girls//p'
    with description bc_U249
    with initial bc_U250
    with plural bc_U251
    with article bc_U252
    with list_together bc_U253
;
K1_room I_hallway_U1    with short_name bc_U167
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 1
    with K1_room_Next I_girl_s_room_U1
    with name 'hallway' 'rooms//p'
    with description bc_U168
    with plural bc_U169
    with article bc_U170
    with list_together bc_U171
;
K1_room I_girl_s_room_U1    with short_name bc_U172
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 2
    with K1_room_Next I_big_room_U1
    with name 'girl^s' 'room' 'rooms//p'
    with description bc_U173
    with plural bc_U174
    with article bc_U175
    with list_together bc_U176
;
K1_room I_big_room_U1    with short_name bc_U177
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 3
    with K1_room_Next I_bathroom_U1
    with name 'big' 'room' 'rooms//p'
    with description bc_U178
    with plural bc_U179
    with article bc_U180
    with list_together bc_U181
;
K1_room I_bathroom_U1    with short_name bc_U182
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 4
    with K1_room_Next I_pantry_U1
    with name 'bathroom' 'rooms//p'
    with description bc_U183
    with plural bc_U184
    with article bc_U185
    with list_together bc_U186
;
K1_room I_pantry_U1    with short_name bc_U187
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 5
    with K1_room_Next I_basement_U1
    with name 'pantry' 'rooms//p'
    with description bc_U188
    with plural bc_U189
    with article bc_U190
    with list_together bc_U191
;
K1_room I_basement_U1    with short_name bc_U192
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 6
    with K1_room_Next I_patio_U1
    with name 'basement' 'rooms//p'
    with description bc_U193
    with plural bc_U194
    with article bc_U195
    with list_together bc_U196
;
K1_room I_patio_U1    with short_name bc_U197
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 7
    with K1_room_Next I_living_room_U1
    with name 'patio' 'rooms//p'
    with description bc_U198
    with plural bc_U199
    with article bc_U200
    with list_together bc_U201
;
K1_room I_living_room_U1    with short_name bc_U202
    with vector 0
    with room_index -1
    has mark_as_room
    with KD_Count 1
    with IK1_Count 8
    with K1_room_Next 0
    with name 'living' 'room' 'rooms//p'
    with description bc_U203
    with plural bc_U204
    with article bc_U205
    with list_together bc_U206
;
K2_thing -> I_makeup_table_U1    with short_name bc_U207
    with vector 0
    has mark_as_thing
    with KD_Count 2
    with IK2_Count 1
    with K2_thing_Next 0
    with action_bitmap 0 0 0 0 0
    with name 'makeup' 'table' 'things//p'
    with description bc_U208
    with initial bc_U209
    with plural bc_U210
    with article bc_U211
    with list_together bc_U212
;
#ifndef cap_short_name; Constant cap_short_name = 0; #endif;
#ifndef before; Constant before = 0; #endif;
#ifndef action_bitmap; Constant action_bitmap = 0; #endif;
#ifndef name; Constant name = 0; #endif;
#ifndef P_variable_initial_value; Constant P_variable_initial_value = 0; #endif;
#ifndef P_specification; Constant P_specification = 0; #endif;
#ifndef P_indefinite_appearance_text; Constant P_indefinite_appearance_text = 0; #endif;
#ifndef P_adaptive_text_viewpoint; Constant P_adaptive_text_viewpoint = 0; #endif;
#ifndef P_opposite; Constant P_opposite = 0; #endif;
#ifndef P_recurring; Constant P_recurring = 0; #endif;
#ifndef K1_room_Next; Constant K1_room_Next = 0; #endif;
#ifndef K2_thing_Next; Constant K2_thing_Next = 0; #endif;
#ifndef K3_direction_Next; Constant K3_direction_Next = 0; #endif;
#ifndef K4_door_Next; Constant K4_door_Next = 0; #endif;
#ifndef K5_container_Next; Constant K5_container_Next = 0; #endif;
#ifndef K6_supporter_Next; Constant K6_supporter_Next = 0; #endif;
#ifndef IK7_Count; Constant IK7_Count = 0; #endif;
#ifndef K7_backdrop_Next; Constant K7_backdrop_Next = 0; #endif;
#ifndef K8_person_Next; Constant K8_person_Next = 0; #endif;
#ifndef IK9_Count; Constant IK9_Count = 0; #endif;
#ifndef K9_region_Next; Constant K9_region_Next = 0; #endif;
#ifndef IK10_Count; Constant IK10_Count = 0; #endif;
#ifndef K10_man_Next; Constant K10_man_Next = 0; #endif;
#ifndef K11_woman_Count; Constant K11_woman_Count = 0; #endif;
#ifndef K11_woman_Next; Constant K11_woman_Next = 0; #endif;
#ifndef K12_animal_Count; Constant K12_animal_Count = 0; #endif;
#ifndef K12_animal_Next; Constant K12_animal_Next = 0; #endif;
#ifndef K13_device_Count; Constant K13_device_Count = 0; #endif;
#ifndef K13_device_Next; Constant K13_device_Next = 0; #endif;
#ifndef K14_vehicle_Count; Constant K14_vehicle_Count = 0; #endif;
#ifndef K14_vehicle_Next; Constant K14_vehicle_Next = 0; #endif;
#ifndef K15_player_s_holdall_Count; Constant K15_player_s_holdall_Count = 0; #endif;
#ifndef K15_player_s_holdall_Next; Constant K15_player_s_holdall_Next = 0; #endif;
#ifndef K16_little_girl_Count; Constant K16_little_girl_Count = 0; #endif;
#ifndef K16_little_girl_Next; Constant K16_little_girl_Next = 0; #endif;
#Ifdef TARGET_ZCODE;
Global max_z_object;
#Ifdef Z__Region;
[ OC__Cl obj cla j a n objflag;
    @jl obj 1 ?NotObj;
    @jg obj max_z_object ?NotObj;
    @inc objflag;
    #Ifdef K1_room;
    @je cla K1_room ?~NotRoom;
    @test_attr obj mark_as_room ?rtrue;
    @rfalse;
    .NotRoom;
    #Endif;
    #Ifdef K2_thing;
    @je cla K2_thing ?~NotObj;
    @test_attr obj mark_as_thing ?rtrue;
    @rfalse;
    #Endif;
    .NotObj;

    @je cla Object Class ?ObjOrClass;
    @je cla Routine String ?RoutOrStr;

    @jin cla 1 ?~Mistake;

    @jz objflag ?rfalse;
    @get_prop_addr obj 2 -> a;
    @jz a ?rfalse;
    @get_prop_len a -> n;

    @div n 2 -> n;
    .Loop;
    @loadw a j -> sp;
    @je sp cla ?rtrue;
    @inc j;
    @jl j n ?Loop;
    @rfalse;

    .ObjOrClass;
    @jz objflag ?rfalse;
    @je cla Object ?JustObj;

    ! So now cla is Class
    @jg obj String ?~rtrue;
    @jin obj Class ?rtrue;
    @rfalse;

    .JustObj;
    ! So now cla is Object
    @jg obj String ?~rfalse;
    @jin obj Class ?rfalse;
    @rtrue;

    .RoutOrStr;
    @jz objflag ?~rfalse;
    @call_2s Z__Region obj -> sp;
    @inc sp;
    @je sp cla ?rtrue;
    @rfalse;

    .Mistake;
    RT__Err("apply 'ofclass' for", cla, -1);
    rfalse;
];
#Endif;
#Endif;
[ call_U1 sk;
    rfalse;
];
[ call_U2 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if (t_0) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "printed name: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_short_name), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_short_name));
                    print (char) 34;
                }
                print "^";
                print "printed plural name: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_plural), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_plural));
                    print (char) 34;
                }
                print "^";
                print "indefinite article: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_article), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_article));
                    print (char) 34;
                }
                print "^";
                print "list grouping key: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_list_together), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_list_together));
                    print (char) 34;
                }
                print "^";
            }
        } else {
            if (t_0) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_pluralname)) && ((t_0 has pluralname)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "plural-named";
                }
                if (((AllowInShowme(A_pluralname)) && ((~~((t_0 has pluralname)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "singular-named";
                }
                if (((AllowInShowme(A_proper)) && ((t_0 has proper)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "proper-named";
                }
                if (((AllowInShowme(A_proper)) && ((~~((t_0 has proper)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "improper-named";
                }
                if (((AllowInShowme(A_ambigpluralname)) && ((t_0 has ambigpluralname)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "ambiguously plural";
                }
            }
        }
        return na;
    #endif;
];
[ call_U3 sk;
    return I_entire_game_U1;
];
[ PrintSceneName value;
    switch (value) {
        I_entire_game_U1:
            print "Entire Game";
            ;
        default:
            print "<illegal scene>";
            ;
    }
];
[ call_U4 x;
    return x;
];
[ call_U5 x;
    return x;
];
[ call_U6 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(1);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U7 sk;
    rfalse;
];
[ DECIMAL_TOKEN_INNER original_wn;
    return GPR_FAIL;
];
[ call_U9 sk;
    rfalse;
];
[ call_U11 sk;
    rfalse;
];
[ TRUTH_STATE_TOKEN_INNER original_wn;
    return GPR_FAIL;
];
[ call_U12 sk;
    return BlkValueCreate(sk);
];
[ call_U13 sk;
    return 101;
];
[ call_U14 sk;
    return 32;
];
[ call_U15 sk;
    rfalse;
];
[ call_U16 sk;
    rfalse;
];
[ call_U17 sk;
    rfalse;
];
[ call_U18 sk;
    return TheEmptyTable;
];
[ call_U19 sk;
    rfalse;
];
[ RulebookOutcomePrintingRule nro;
    if ((nro == 0)) {
        print "(no outcome)";
    } else {
        print (string) nro;
        rfalse;
    }
];
[ call_U20 sk;
    return outcome_allow_startup_U1;
];
[ call_U21 sk;
    rfalse;
];
[ PrintExternalFileName value;
    switch (value) {
        default:
            print "<illegal external file>";
            ;
    }
];
[ call_U22 x;
    return x;
];
[ call_U23 x;
    return x;
];
[ call_U24 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(0);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U25 sk;
    rfalse;
];
[ call_U26 sk;
    return BlkValueCreate(sk);
];
[ call_U27 sk;
    return ##Wait;
];
[ call_U28 sk;
    return 540;
];
[ TIME_TOKEN_INNER original_wn;
    return GPR_FAIL;
];
[ call_U30 sk;
    return I_figure_of_cover_U1;
];
[ PrintFigureName value;
    switch (value) {
        I_figure_of_cover_U1:
            print "Figure of cover";
            ;
        default:
            print "<illegal figure name>";
            ;
    }
];
[ call_U31 x;
    return x;
];
[ call_U32 x;
    return x;
];
[ call_U33 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(1);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U34 sk;
    rfalse;
];
[ PrintSoundName value;
    switch (value) {
        default:
            print "<illegal sound name>";
            ;
    }
];
[ call_U35 x;
    return x;
];
[ call_U36 x;
    return x;
];
[ call_U37 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(0);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U38 sk;
    return DefaultTopic;
];
[ call_U39 sk;
    return BlkValueCreate(sk);
];
[ call_U40 sk;
    rfalse;
];
[ call_U41 sk;
    rfalse;
];
[ DB_Action_Details act n s for_say;
    switch (act) {
        ##Inv:
            InvDbg(n, s, for_say);
            ;
        ##Take:
            TakeDbg(n, s, for_say);
            ;
        ##Remove:
            RemoveDbg(n, s, for_say);
            ;
        ##Drop:
            DropDbg(n, s, for_say);
            ;
        ##PutOn:
            PutOnDbg(n, s, for_say);
            ;
        ##Insert:
            InsertDbg(n, s, for_say);
            ;
        ##Eat:
            EatDbg(n, s, for_say);
            ;
        ##Go:
            GoDbg(n, s, for_say);
            ;
        ##Enter:
            EnterDbg(n, s, for_say);
            ;
        ##Exit:
            ExitDbg(n, s, for_say);
            ;
        ##GetOff:
            GetOffDbg(n, s, for_say);
            ;
        ##Look:
            LookDbg(n, s, for_say);
            ;
        ##Examine:
            ExamineDbg(n, s, for_say);
            ;
        ##LookUnder:
            LookUnderDbg(n, s, for_say);
            ;
        ##Search:
            SearchDbg(n, s, for_say);
            ;
        ##Consult:
            ConsultDbg(n, s, for_say);
            ;
        ##Lock:
            LockDbg(n, s, for_say);
            ;
        ##Unlock:
            UnlockDbg(n, s, for_say);
            ;
        ##SwitchOn:
            SwitchOnDbg(n, s, for_say);
            ;
        ##SwitchOff:
            SwitchOffDbg(n, s, for_say);
            ;
        ##Open:
            OpenDbg(n, s, for_say);
            ;
        ##Close:
            CloseDbg(n, s, for_say);
            ;
        ##Wear:
            WearDbg(n, s, for_say);
            ;
        ##Disrobe:
            DisrobeDbg(n, s, for_say);
            ;
        ##Give:
            GiveDbg(n, s, for_say);
            ;
        ##Show:
            ShowDbg(n, s, for_say);
            ;
        ##WakeOther:
            WakeOtherDbg(n, s, for_say);
            ;
        ##ThrowAt:
            ThrowAtDbg(n, s, for_say);
            ;
        ##Attack:
            AttackDbg(n, s, for_say);
            ;
        ##Kiss:
            KissDbg(n, s, for_say);
            ;
        ##Answer:
            AnswerDbg(n, s, for_say);
            ;
        ##Tell:
            TellDbg(n, s, for_say);
            ;
        ##Ask:
            AskDbg(n, s, for_say);
            ;
        ##AskFor:
            AskForDbg(n, s, for_say);
            ;
        ##Wait:
            WaitDbg(n, s, for_say);
            ;
        ##Touch:
            TouchDbg(n, s, for_say);
            ;
        ##Wave:
            WaveDbg(n, s, for_say);
            ;
        ##Pull:
            PullDbg(n, s, for_say);
            ;
        ##Push:
            PushDbg(n, s, for_say);
            ;
        ##Turn:
            TurnDbg(n, s, for_say);
            ;
        ##PushDir:
            PushDirDbg(n, s, for_say);
            ;
        ##Squeeze:
            SqueezeDbg(n, s, for_say);
            ;
        ##Yes:
            YesDbg(n, s, for_say);
            ;
        ##No:
            NoDbg(n, s, for_say);
            ;
        ##Burn:
            BurnDbg(n, s, for_say);
            ;
        ##Wake:
            WakeDbg(n, s, for_say);
            ;
        ##Think:
            ThinkDbg(n, s, for_say);
            ;
        ##Smell:
            SmellDbg(n, s, for_say);
            ;
        ##Listen:
            ListenDbg(n, s, for_say);
            ;
        ##Taste:
            TasteDbg(n, s, for_say);
            ;
        ##Cut:
            CutDbg(n, s, for_say);
            ;
        ##Jump:
            JumpDbg(n, s, for_say);
            ;
        ##Tie:
            TieDbg(n, s, for_say);
            ;
        ##Drink:
            DrinkDbg(n, s, for_say);
            ;
        ##Sorry:
            SorryDbg(n, s, for_say);
            ;
        ##Swing:
            SwingDbg(n, s, for_say);
            ;
        ##Rub:
            RubDbg(n, s, for_say);
            ;
        ##SetTo:
            SetToDbg(n, s, for_say);
            ;
        ##WaveHands:
            WaveHandsDbg(n, s, for_say);
            ;
        ##Buy:
            BuyDbg(n, s, for_say);
            ;
        ##Climb:
            ClimbDbg(n, s, for_say);
            ;
        ##Sleep:
            SleepDbg(n, s, for_say);
            ;
        ##Quit:
            QuitDbg(n, s, for_say);
            ;
        ##Save:
            SaveDbg(n, s, for_say);
            ;
        ##Restore:
            RestoreDbg(n, s, for_say);
            ;
        ##Restart:
            RestartDbg(n, s, for_say);
            ;
        ##Verify:
            VerifyDbg(n, s, for_say);
            ;
        ##ScriptOn:
            ScriptOnDbg(n, s, for_say);
            ;
        ##ScriptOff:
            ScriptOffDbg(n, s, for_say);
            ;
        ##Version:
            VersionDbg(n, s, for_say);
            ;
        ##Score:
            ScoreDbg(n, s, for_say);
            ;
        ##LMode3:
            LMode3Dbg(n, s, for_say);
            ;
        ##LMode2:
            LMode2Dbg(n, s, for_say);
            ;
        ##LMode1:
            LMode1Dbg(n, s, for_say);
            ;
        ##NotifyOn:
            NotifyOnDbg(n, s, for_say);
            ;
        ##NotifyOff:
            NotifyOffDbg(n, s, for_say);
            ;
        ##Pronouns:
            PronounsDbg(n, s, for_say);
            ;
    }
];
[ TestSinglePastState past_flag pt turn_end wanted old new trips consecutives;
    rfalse;
];
[ ShowExtensionVersions;
];
[ ShowFullExtensionVersions;
    print "Basic Inform version 1 by Graham Nelson^";
    print "English Language version 1 by Graham Nelson^";
    print "Standard Rules version 6 by Graham Nelson^";
];
[ ShowOneExtension id;
    if ((id == 1)) {
        print "Basic Inform version 1 by Graham Nelson";
    }
    if ((id == 2)) {
        print "English Language version 1 by Graham Nelson";
    }
    if ((id == 3)) {
        print "Standard Rules version 6 by Graham Nelson";
    }
];
[ ShowMeInstanceDetails which na t_0;
    return na;
];
[ DefaultValueOfKOV sk k;
    (k = KindAtomic(sk));
    switch (k) {
        WEAK_ID_47:
            return call_U123(sk);
            ;
        WEAK_ID_52:
            return call_U1812(sk);
            ;
        WEAK_ID_53:
            return call_U1814(sk);
            ;
        WEAK_ID_54:
            return call_U1816(sk);
            ;
        WEAK_ID_55:
            return call_U1818(sk);
            ;
        WEAK_ID_56:
            return call_U1820(sk);
            ;
        WEAK_ID_57:
            return call_U1822(sk);
            ;
        WEAK_ID_58:
            return call_U1824(sk);
            ;
        WEAK_ID_59:
            return call_U1825(sk);
            ;
        WEAK_ID_60:
            return call_U1827(sk);
            ;
        WEAK_ID_61:
            return call_U1828(sk);
            ;
        WEAK_ID_62:
            return call_U1829(sk);
            ;
        WEAK_ID_63:
            return call_U1830(sk);
            ;
        WEAK_ID_64:
            return call_U1831(sk);
            ;
        WEAK_ID_65:
            return call_U1833(sk);
            ;
        WEAK_ID_66:
            return call_U1834(sk);
            ;
        WEAK_ID_67:
            return call_U1835(sk);
            ;
        WEAK_ID_48:
            return call_U151(sk);
            ;
        WEAK_ID_49:
            return call_U155(sk);
            ;
        WEAK_ID_50:
            return call_U159(sk);
            ;
        WEAK_ID_51:
            return call_U163(sk);
            ;
        WEAK_ID_68:
            return call_U1916(sk);
            ;
        OBJECT_TY:
            return call_U1(sk);
            ;
        SCENE_TY:
            return call_U3(sk);
            ;
        NUMBER_TY:
            return call_U7(sk);
            ;
        REAL_NUMBER_TY:
            return call_U9(sk);
            ;
        TRUTH_STATE_TY:
            return call_U11(sk);
            ;
        TEXT_TY:
            return call_U12(sk);
            ;
        SNIPPET_TY:
            return call_U13(sk);
            ;
        UNICODE_CHARACTER_TY:
            return call_U14(sk);
            ;
        USE_OPTION_TY:
            return call_U15(sk);
            ;
        RESPONSE_TY:
            return call_U16(sk);
            ;
        VERB_TY:
            return call_U17(sk);
            ;
        TABLE_TY:
            return call_U18(sk);
            ;
        EQUATION_TY:
            return call_U19(sk);
            ;
        RULEBOOK_OUTCOME_TY:
            return call_U20(sk);
            ;
        EXTERNAL_FILE_TY:
            return call_U21(sk);
            ;
        DESCRIPTION_OF_ACTION_TY:
            return call_U25(sk);
            ;
        STORED_ACTION_TY:
            return call_U26(sk);
            ;
        ACTION_NAME_TY:
            return call_U27(sk);
            ;
        TIME_TY:
            return call_U28(sk);
            ;
        FIGURE_NAME_TY:
            return call_U30(sk);
            ;
        SOUND_NAME_TY:
            return call_U34(sk);
            ;
        UNDERSTANDING_TY:
            return call_U38(sk);
            ;
        LIST_OF_TY:
            return call_U39(sk);
            ;
        NIL_TY:
            return call_U40(sk);
            ;
        VOID_TY:
            return call_U41(sk);
            ;
    }
    rfalse;
];
[ DefaultValueFinder k;
    rfalse;
];
[ PrintKindValuePair k v;
    (k = KindAtomic(k));
    switch (k) {
        WEAK_ID_47:
            E1(v);
            ;
        WEAK_ID_67:
            E6(v);
            ;
        WEAK_ID_48:
            E2(v);
            ;
        WEAK_ID_49:
            E3(v);
            ;
        WEAK_ID_50:
            E4(v);
            ;
        WEAK_ID_51:
            E5(v);
            ;
        OBJECT_TY:
            PrintShortName(v);
            ;
        SCENE_TY:
            PrintSceneName(v);
            ;
        NUMBER_TY:
            DecimalNumber(v);
            ;
        REAL_NUMBER_TY:
            REAL_NUMBER_TY_Say(v);
            ;
        TRUTH_STATE_TY:
            DA_TruthState(v);
            ;
        TEXT_TY:
            TEXT_TY_Say(v);
            ;
        SNIPPET_TY:
            PrintSnippet(v);
            ;
        UNICODE_CHARACTER_TY:
            DecimalNumber(v);
            ;
        USE_OPTION_TY:
            PrintUseOption(v);
            ;
        RESPONSE_TY:
            PrintResponse(v);
            ;
        VERB_TY:
            PrintVerbAsValue(v);
            ;
        TABLE_TY:
            PrintTableName(v);
            ;
        EQUATION_TY:
            DA_Number(v);
            ;
        RULEBOOK_OUTCOME_TY:
            RulebookOutcomePrintingRule(v);
            ;
        EXTERNAL_FILE_TY:
            PrintExternalFileName(v);
            ;
        DESCRIPTION_OF_ACTION_TY:
            DecimalNumber(v);
            ;
        STORED_ACTION_TY:
            STORED_ACTION_TY_Say(v);
            ;
        ACTION_NAME_TY:
            SayActionName(v);
            ;
        TIME_TY:
            PrintTimeOfDay(v);
            ;
        FIGURE_NAME_TY:
            PrintFigureName(v);
            ;
        SOUND_NAME_TY:
            PrintSoundName(v);
            ;
        UNDERSTANDING_TY:
            DecimalNumber(v);
            ;
        LIST_OF_TY:
            LIST_OF_TY_Say(v);
            ;
        VALUE_TY:
            DecimalNumber(v);
            ;
        STORED_VALUE_TY:
            DecimalNumber(v);
            ;
        SAYABLE_VALUE_TY:
            DecimalNumber(v);
            ;
        UNDERSTANDABLE_VALUE_TY:
            DecimalNumber(v);
            ;
        ARITHMETIC_VALUE_TY:
            DecimalNumber(v);
            ;
        REAL_ARITHMETIC_VALUE_TY:
            DecimalNumber(v);
            ;
        ENUMERATED_VALUE_TY:
            DecimalNumber(v);
            ;
        POINTER_VALUE_TY:
            DecimalNumber(v);
            ;
        PHRASE_TY:
            SayPhraseName(v);
            ;
        VARIABLE_TY:
            DecimalNumber(v);
            ;
        RELATION_TY:
            RELATION_TY_Say(v);
            ;
        RULE_TY:
            RulePrintingRule(v);
            ;
        RULEBOOK_TY:
            RulePrintingRule(v);
            ;
        ACTIVITY_TY:
            DecimalNumber(v);
            ;
        DESCRIPTION_OF_TY:
            DecimalNumber(v);
            ;
        PROPERTY_TY:
            PROPERTY_TY_Say(v);
            ;
        TABLE_COLUMN_TY:
            DecimalNumber(v);
            ;
        COMBINATION_TY:
            COMBINATION_TY_Say(v);
            ;
        NIL_TY:
            DecimalNumber(v);
            ;
        UNKNOWN_TY:
            DecimalNumber(v);
            ;
        VOID_TY:
            DecimalNumber(v);
            ;
        TUPLE_ENTRY_TY:
            DecimalNumber(v);
            ;
        default:
            print v;
            ;
    }
];
[ KOVComparisonFunction k;
    (k = KindAtomic(k));
    switch (k) {
        OBJECT_TY:
            return UnsignedCompare;
            ;
        SCENE_TY:
            return UnsignedCompare;
            ;
        REAL_NUMBER_TY:
            return REAL_NUMBER_TY_Compare;
            ;
        TRUTH_STATE_TY:
            return UnsignedCompare;
            ;
        TEXT_TY:
            return BlkValueCompare;
            ;
        SNIPPET_TY:
            return UnsignedCompare;
            ;
        UNICODE_CHARACTER_TY:
            return UnsignedCompare;
            ;
        USE_OPTION_TY:
            return UnsignedCompare;
            ;
        RESPONSE_TY:
            return UnsignedCompare;
            ;
        VERB_TY:
            return UnsignedCompare;
            ;
        TABLE_TY:
            return UnsignedCompare;
            ;
        EQUATION_TY:
            return UnsignedCompare;
            ;
        RULEBOOK_OUTCOME_TY:
            return UnsignedCompare;
            ;
        EXTERNAL_FILE_TY:
            return UnsignedCompare;
            ;
        DESCRIPTION_OF_ACTION_TY:
            return UnsignedCompare;
            ;
        STORED_ACTION_TY:
            return BlkValueCompare;
            ;
        ACTION_NAME_TY:
            return UnsignedCompare;
            ;
        FIGURE_NAME_TY:
            return UnsignedCompare;
            ;
        SOUND_NAME_TY:
            return UnsignedCompare;
            ;
        UNDERSTANDING_TY:
            return UnsignedCompare;
            ;
        LIST_OF_TY:
            return BlkValueCompare;
            ;
        PHRASE_TY:
            return UnsignedCompare;
            ;
        VARIABLE_TY:
            return UnsignedCompare;
            ;
        RELATION_TY:
            return BlkValueCompare;
            ;
        RULE_TY:
            return UnsignedCompare;
            ;
        RULEBOOK_TY:
            return UnsignedCompare;
            ;
        ACTIVITY_TY:
            return UnsignedCompare;
            ;
        DESCRIPTION_OF_TY:
            return UnsignedCompare;
            ;
        PROPERTY_TY:
            return UnsignedCompare;
            ;
        TABLE_COLUMN_TY:
            return UnsignedCompare;
            ;
        COMBINATION_TY:
            return BlkValueCompare;
            ;
        NIL_TY:
            return UnsignedCompare;
            ;
        VOID_TY:
            return UnsignedCompare;
            ;
        TUPLE_ENTRY_TY:
            return UnsignedCompare;
            ;
    }
    rfalse;
];
[ KOVDomainSize k;
    (k = KindAtomic(k));
    switch (k) {
        WEAK_ID_47:
            return 6;
            ;
        WEAK_ID_67:
            return 25;
            ;
        WEAK_ID_48:
            return 5;
            ;
        WEAK_ID_49:
            return 6;
            ;
        WEAK_ID_50:
            return 2;
            ;
        WEAK_ID_51:
            return 3;
            ;
        SCENE_TY:
            rtrue;
            ;
        FIGURE_NAME_TY:
            rtrue;
            ;
    }
    rfalse;
];
[ KOVIsBlockValue k;
    (k = KindAtomic(k));
    switch (k) {
        TEXT_TY:
            rtrue;
            ;
        STORED_ACTION_TY:
            rtrue;
            ;
        LIST_OF_TY:
            rtrue;
            ;
        RELATION_TY:
            rtrue;
            ;
        COMBINATION_TY:
            rtrue;
            ;
    }
    rfalse;
];
[ I7_Kind_Name k;
    if ((k == K1_room)) {
        print "room";
    }
    if ((k == K2_thing)) {
        print "thing";
    }
    if ((k == K3_direction)) {
        print "direction";
    }
    if ((k == K4_door)) {
        print "door";
    }
    if ((k == K5_container)) {
        print "container";
    }
    if ((k == K6_supporter)) {
        print "supporter";
    }
    if ((k == K7_backdrop)) {
        print "backdrop";
    }
    if ((k == K8_person)) {
        print "person";
    }
    if ((k == K9_region)) {
        print "region";
    }
    if ((k == K10_man)) {
        print "man";
    }
    if ((k == K11_woman)) {
        print "woman";
    }
    if ((k == K12_animal)) {
        print "animal";
    }
    if ((k == K13_device)) {
        print "device";
    }
    if ((k == K14_vehicle)) {
        print "vehicle";
    }
    if ((k == K15_player_s_holdall)) {
        print "player's holdall";
    }
    if ((k == K16_little_girl)) {
        print "little girl";
    }
];
[ KOVSupportFunction k fail;
    (k = KindAtomic(k));
    switch (k) {
        TEXT_TY:
            return TEXT_TY_Support;
            ;
        STORED_ACTION_TY:
            return STORED_ACTION_TY_Support;
            ;
        LIST_OF_TY:
            return LIST_OF_TY_Support;
            ;
        RELATION_TY:
            return RELATION_TY_Support;
            ;
        COMBINATION_TY:
            return COMBINATION_TY_Support;
            ;
    }
    if (fail) {
        BlkValueError(fail);
    }
    rfalse;
];
[ ShowMeKindDetails which na t_0;
    (na = call_U1813(which, na, t_0));
    (na = call_U1815(which, na, t_0));
    (na = call_U1817(which, na, t_0));
    (na = call_U1819(which, na, t_0));
    (na = call_U1821(which, na, t_0));
    (na = call_U1823(which, na, t_0));
    (na = call_U1826(which, na, t_0));
    (na = call_U1832(which, na, t_0));
    (na = call_U2(which, na, t_0));
    return na;
];
[ CreateDynamicRelations;
];
[ IterateRelations callback;
    (callback)(Rel_Record1);
    (callback)(Rel_Record2);
    (callback)(Rel_Record3);
    (callback)(Rel_Record4);
    (callback)(Rel_Record5);
    (callback)(Rel_Record6);
    (callback)(Rel_Record7);
    (callback)(Rel_Record8);
    (callback)(Rel_Record9);
    (callback)(Rel_Record10);
    (callback)(Rel_Record11);
    (callback)(Rel_Record12);
    (callback)(Rel_Record13);
    (callback)(Rel_Record14);
    (callback)(Rel_Record15);
    (callback)(Rel_Record16);
    (callback)(Rel_Record17);
    (callback)(Rel_Record18);
];
[ RProperty obj cl pr;
    if ((obj ofclass cl)) {
        return _final_propertyvalue(OBJECT_TY, obj, pr);
    }
    rfalse;
];
[ MStack_GetRBVarCreator rb;
    return (rulebook_var_creators-->(rb));
];
[ RulePrintingRule R;
    if ((((R >= 0)) && ((R < 362)))) {
        print (string) (RulebookNames-->(R));
    } else {
        if ((R == FINAL_CODE_STARTUP_R)) {
            print "final code startup rule";
            rtrue;
        }
        if ((R == STANDARD_NAME_PRINTING_R)) {
            print "standard name printing rule";
            rtrue;
        }
        if ((R == STANDARD_PLURAL_NAME_PRINTING_R)) {
            print "standard printing the plural name rule";
            rtrue;
        }
        if ((R == ADJUST_LIGHT_R)) {
            print "adjust light rule";
            rtrue;
        }
        if ((R == GENERATE_ACTION_R)) {
            print "generate action rule";
            rtrue;
        }
        if ((R == BASIC_ACCESSIBILITY_R)) {
            print "basic accessibility rule";
            rtrue;
        }
        if ((R == BASIC_VISIBILITY_R)) {
            print "basic visibility rule";
            rtrue;
        }
        if ((R == REQUESTED_ACTIONS_REQUIRE_R)) {
            print "requested actions require persuasion rule";
            rtrue;
        }
        if ((R == CARRY_OUT_REQUESTED_ACTIONS_R)) {
            print "carry out requested actions rule";
            rtrue;
        }
        if ((R == ACCESS_THROUGH_BARRIERS_R)) {
            print "access through barriers rule";
            rtrue;
        }
        if ((R == CANT_REACH_INSIDE_CLOSED_R)) {
            print "can't reach inside closed containers rule";
            rtrue;
        }
        if ((R == CANT_REACH_INSIDE_ROOMS_R)) {
            print "can't reach inside rooms rule";
            rtrue;
        }
        if ((R == CANT_REACH_OUTSIDE_CLOSED_R)) {
            print "can't reach outside closed containers rule";
            rtrue;
        }
        if ((R == LIST_WRITER_INTERNAL_R)) {
            print "list writer internal rule";
            rtrue;
        }
        if ((R == ACTION_PROCESSING_INTERNAL_R)) {
            print "action processing internal rule";
            rtrue;
        }
        if ((R == PARSER_ERROR_INTERNAL_R)) {
            print "parser error internal rule";
            rtrue;
        }
        if ((R == PARSER_N_ERROR_INTERNAL_R)) {
            print "parser nothing error internal rule";
            rtrue;
        }
        if ((R == DARKNESS_NAME_INTERNAL_R)) {
            print "darkness name internal rule";
            rtrue;
        }
        if ((R == PARSER_COMMAND_INTERNAL_R)) {
            print "parser command internal rule";
            rtrue;
        }
        if ((R == PARSER_CLARIF_INTERNAL_R)) {
            print "parser clarification internal rule";
            rtrue;
        }
        if ((R == YES_OR_NO_QUESTION_INTERNAL_R)) {
            print "yes or no question internal rule";
            rtrue;
        }
        if ((R == PRINT_PROTAGONIST_INTERNAL_R)) {
            print "print protagonist internal rule";
            rtrue;
        }
        if ((R == STANDARD_IMPLICIT_TAKING_R)) {
            print "standard implicit taking rule";
            rtrue;
        }
        if ((R == PRINT_OBITUARY_HEADLINE_R)) {
            print "print obituary headline rule";
            rtrue;
        }
        if ((R == IMMEDIATELY_UNDO_R)) {
            print "immediately undo rule";
            rtrue;
        }
        if ((R == QUIT_THE_GAME_R)) {
            print "quit the game rule";
            rtrue;
        }
        if ((R == SAVE_THE_GAME_R)) {
            print "save the game rule";
            rtrue;
        }
        if ((R == RESTORE_THE_GAME_R)) {
            print "restore the game rule";
            rtrue;
        }
        if ((R == RESTART_THE_GAME_R)) {
            print "restart the game rule";
            rtrue;
        }
        if ((R == VERIFY_THE_STORY_FILE_R)) {
            print "verify the story file rule";
            rtrue;
        }
        if ((R == SWITCH_TRANSCRIPT_ON_R)) {
            print "switch the story transcript on rule";
            rtrue;
        }
        if ((R == SWITCH_TRANSCRIPT_OFF_R)) {
            print "switch the story transcript off rule";
            rtrue;
        }
        if ((R == ANNOUNCE_SCORE_R)) {
            print "announce the score rule";
            rtrue;
        }
        if ((R == REP_PREFER_ABBREVIATED_R)) {
            print "standard report preferring abbreviated room descriptions rule";
            rtrue;
        }
        if ((R == REP_PREFER_UNABBREVIATED_R)) {
            print "standard report preferring unabbreviated room descriptions rule";
            rtrue;
        }
        if ((R == REP_PREFER_SOMETIMES_ABBR_R)) {
            print "standard report preferring sometimes abbreviated room descriptions rule";
            rtrue;
        }
        if ((R == REP_SWITCH_NOTIFY_ON_R)) {
            print "standard report switching score notification on rule";
            rtrue;
        }
        if ((R == REP_SWITCH_NOTIFY_OFF_R)) {
            print "standard report switching score notification off rule";
            rtrue;
        }
        if ((R == ANNOUNCE_PRONOUN_MEANINGS_R)) {
            print "announce the pronoun meanings rule";
            rtrue;
        }
        if ((R == call_U980)) {
            print "declare everything initially unmentioned rule";
            rtrue;
        }
        if ((R == call_U982)) {
            print "start in the correct scenes rule";
            rtrue;
        }
        if ((R == call_U983)) {
            print "when play begins stage rule";
            rtrue;
        }
        if ((R == call_U984)) {
            print "fix baseline scoring rule";
            rtrue;
        }
        if ((R == call_U985)) {
            print "display banner rule";
            rtrue;
        }
        if ((R == call_U986)) {
            print "initial room description rule";
            rtrue;
        }
        if ((R == call_U987)) {
            print "every turn stage rule";
            rtrue;
        }
        if ((R == call_U988)) {
            print "A first turn sequence rule";
            rtrue;
        }
        if ((R == call_U989)) {
            print "A last turn sequence rule";
            rtrue;
        }
        if ((R == call_U990)) {
            print "notify score changes rule";
            rtrue;
        }
        if ((R == call_U991)) {
            print "when play ends stage rule";
            rtrue;
        }
        if ((R == call_U992)) {
            print "print player's obituary rule";
            rtrue;
        }
        if ((R == call_U993)) {
            print "set pronouns from items from multiple object lists rule";
            rtrue;
        }
        if ((R == call_U994)) {
            print "announce items from multiple object lists rule";
            rtrue;
        }
        if ((R == call_U997)) {
            print "before stage rule";
            rtrue;
        }
        if ((R == call_U998)) {
            print "instead stage rule";
            rtrue;
        }
        if ((R == call_U999)) {
            print "end action-processing in success rule";
            rtrue;
        }
        if ((R == call_U1000)) {
            print "investigate player's awareness before action rule";
            rtrue;
        }
        if ((R == call_U1001)) {
            print "check stage rule";
            rtrue;
        }
        if ((R == call_U1002)) {
            print "carry out stage rule";
            rtrue;
        }
        if ((R == call_U1003)) {
            print "after stage rule";
            rtrue;
        }
        if ((R == call_U1004)) {
            print "investigate player's awareness after action rule";
            rtrue;
        }
        if ((R == call_U1005)) {
            print "report stage rule";
            rtrue;
        }
        if ((R == call_U1006)) {
            print "last specific action-processing rule";
            rtrue;
        }
        if ((R == call_U1007)) {
            print "player aware of his own actions rule";
            rtrue;
        }
        if ((R == call_U1008)) {
            print "player aware of actions by visible actors rule";
            rtrue;
        }
        if ((R == call_U1009)) {
            print "player aware of actions on visible nouns rule";
            rtrue;
        }
        if ((R == call_U1010)) {
            print "player aware of actions on visible second nouns rule";
            rtrue;
        }
        if ((R == call_U1011)) {
            print "can't act in the dark rule";
            rtrue;
        }
        if ((R == call_U1012)) {
            print "very unlikely to mean taking what's already carried rule";
            rtrue;
        }
        if ((R == call_U1013)) {
            print "scene description text rule";
            rtrue;
        }
        if ((R == call_U1014)) {
            print "make named things mentioned rule";
            rtrue;
        }
        if ((R == call_U1015)) {
            print "standard printing a number of something rule";
            rtrue;
        }
        if ((R == call_U1016)) {
            print "look around once light available rule";
            rtrue;
        }
        if ((R == call_U1017)) {
            print "exclude scenery from take all rule";
            rtrue;
        }
        if ((R == call_U1018)) {
            print "exclude people from take all rule";
            rtrue;
        }
        if ((R == call_U1019)) {
            print "exclude fixed in place things from take all rule";
            rtrue;
        }
        if ((R == call_U1020)) {
            print "exclude indirect possessions from take all rule";
            rtrue;
        }
        if ((R == call_U1021)) {
            print "exclude people from drop all rule";
            rtrue;
        }
        if ((R == call_U1022)) {
            print "ambient odour rule";
            rtrue;
        }
        if ((R == call_U1023)) {
            print "ambient sound rule";
            rtrue;
        }
        if ((R == call_U1024)) {
            print "block vaguely going rule";
            rtrue;
        }
        if ((R == call_U1027)) {
            print "print the final prompt rule";
            rtrue;
        }
        if ((R == call_U1030)) {
            print "print the final question rule";
            rtrue;
        }
        if ((R == call_U1035)) {
            print "standard respond to final question rule";
            rtrue;
        }
        if ((R == call_U1038)) {
            print "initialise locale description rule";
            rtrue;
        }
        if ((R == call_U1039)) {
            print "find notable locale objects rule";
            rtrue;
        }
        if ((R == call_U1040)) {
            print "interesting locale paragraphs rule";
            rtrue;
        }
        if ((R == call_U1041)) {
            print "you-can-also-see rule";
            rtrue;
        }
        if ((R == call_U1059)) {
            print "standard notable locale objects rule";
            rtrue;
        }
        if ((R == call_U1060)) {
            print "don't mention player's supporter in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1061)) {
            print "don't mention scenery in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1062)) {
            print "don't mention undescribed items in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1063)) {
            print "set pronouns from items in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1064)) {
            print "offer items to writing a paragraph about rule";
            rtrue;
        }
        if ((R == call_U1065)) {
            print "use initial appearance in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1070)) {
            print "initial appearance on supporters rule";
            rtrue;
        }
        if ((R == call_U1072)) {
            print "describe what's on scenery supporters in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1077)) {
            print "describe what's on mentioned supporters in room descriptions rule";
            rtrue;
        }
        if ((R == call_U1082)) {
            print "print empty inventory rule";
            rtrue;
        }
        if ((R == call_U1085)) {
            print "print standard inventory rule";
            rtrue;
        }
        if ((R == call_U1088)) {
            print "report other people taking inventory rule";
            rtrue;
        }
        if ((R == call_U1091)) {
            print "can't take yourself rule";
            rtrue;
        }
        if ((R == call_U1094)) {
            print "can't take other people rule";
            rtrue;
        }
        if ((R == call_U1097)) {
            print "can't take component parts rule";
            rtrue;
        }
        if ((R == call_U1100)) {
            print "can't take people's possessions rule";
            rtrue;
        }
        if ((R == call_U1103)) {
            print "can't take items out of play rule";
            rtrue;
        }
        if ((R == call_U1106)) {
            print "can't take what you're inside rule";
            rtrue;
        }
        if ((R == call_U1109)) {
            print "can't take what's already taken rule";
            rtrue;
        }
        if ((R == call_U1112)) {
            print "can't take scenery rule";
            rtrue;
        }
        if ((R == call_U1115)) {
            print "can only take things rule";
            rtrue;
        }
        if ((R == call_U1118)) {
            print "can't take what's fixed in place rule";
            rtrue;
        }
        if ((R == call_U1121)) {
            print "use player's holdall to avoid exceeding carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1127)) {
            print "can't exceed carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1131)) {
            print "standard taking rule";
            rtrue;
        }
        if ((R == call_U1132)) {
            print "standard report taking rule";
            rtrue;
        }
        if ((R == call_U1137)) {
            print "can't remove what's not inside rule";
            rtrue;
        }
        if ((R == call_U1140)) {
            print "can't remove from people rule";
            rtrue;
        }
        if ((R == call_U1143)) {
            print "convert remove to take rule";
            rtrue;
        }
        if ((R == call_U1144)) {
            print "can't drop yourself rule";
            rtrue;
        }
        if ((R == call_U1147)) {
            print "can't drop body parts rule";
            rtrue;
        }
        if ((R == call_U1150)) {
            print "can't drop what's already dropped rule";
            rtrue;
        }
        if ((R == call_U1153)) {
            print "can't drop what's not held rule";
            rtrue;
        }
        if ((R == call_U1156)) {
            print "can't drop clothes being worn rule";
            rtrue;
        }
        if ((R == call_U1159)) {
            print "can't drop if this exceeds carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1166)) {
            print "standard dropping rule";
            rtrue;
        }
        if ((R == call_U1167)) {
            print "standard report dropping rule";
            rtrue;
        }
        if ((R == call_U1172)) {
            print "convert put to drop where possible rule";
            rtrue;
        }
        if ((R == call_U1173)) {
            print "can't put what's not held rule";
            rtrue;
        }
        if ((R == call_U1174)) {
            print "can't put something on itself rule";
            rtrue;
        }
        if ((R == call_U1177)) {
            print "can't put onto what's not a supporter rule";
            rtrue;
        }
        if ((R == call_U1180)) {
            print "can't put clothes being worn rule";
            rtrue;
        }
        if ((R == call_U1183)) {
            print "can't put if this exceeds carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1187)) {
            print "standard putting rule";
            rtrue;
        }
        if ((R == call_U1188)) {
            print "concise report putting rule";
            rtrue;
        }
        if ((R == call_U1191)) {
            print "standard report putting rule";
            rtrue;
        }
        if ((R == call_U1194)) {
            print "convert insert to drop where possible rule";
            rtrue;
        }
        if ((R == call_U1195)) {
            print "can't insert what's already inserted rule";
            rtrue;
        }
        if ((R == call_U1198)) {
            print "can't insert something into itself rule";
            rtrue;
        }
        if ((R == call_U1201)) {
            print "can't insert what's not held rule";
            rtrue;
        }
        if ((R == call_U1202)) {
            print "can't insert into closed containers rule";
            rtrue;
        }
        if ((R == call_U1205)) {
            print "can't insert into what's not a container rule";
            rtrue;
        }
        if ((R == call_U1208)) {
            print "can't insert clothes being worn rule";
            rtrue;
        }
        if ((R == call_U1211)) {
            print "can't insert if this exceeds carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1215)) {
            print "standard inserting rule";
            rtrue;
        }
        if ((R == call_U1216)) {
            print "concise report inserting rule";
            rtrue;
        }
        if ((R == call_U1219)) {
            print "standard report inserting rule";
            rtrue;
        }
        if ((R == call_U1222)) {
            print "can't eat unless edible rule";
            rtrue;
        }
        if ((R == call_U1225)) {
            print "can't eat clothing without removing it first rule";
            rtrue;
        }
        if ((R == call_U1228)) {
            print "can't eat other people's food rule";
            rtrue;
        }
        if ((R == call_U1232)) {
            print "can't eat portable food without carrying it rule";
            rtrue;
        }
        if ((R == call_U1233)) {
            print "standard eating rule";
            rtrue;
        }
        if ((R == call_U1234)) {
            print "standard report eating rule";
            rtrue;
        }
        if ((R == call_U1239)) {
            print "standard set going variables rule";
            rtrue;
        }
        if ((R == call_U1240)) {
            print "stand up before going rule";
            rtrue;
        }
        if ((R == call_U1243)) {
            print "can't travel in what's not a vehicle rule";
            rtrue;
        }
        if ((R == call_U1248)) {
            print "can't go through undescribed doors rule";
            rtrue;
        }
        if ((R == call_U1251)) {
            print "can't go through closed doors rule";
            rtrue;
        }
        if ((R == call_U1254)) {
            print "determine map connection rule";
            rtrue;
        }
        if ((R == call_U1255)) {
            print "can't go that way rule";
            rtrue;
        }
        if ((R == call_U1260)) {
            print "move player and vehicle rule";
            rtrue;
        }
        if ((R == call_U1261)) {
            print "move floating objects rule";
            rtrue;
        }
        if ((R == call_U1262)) {
            print "check light in new location rule";
            rtrue;
        }
        if ((R == call_U1263)) {
            print "describe room gone into rule";
            rtrue;
        }
        if ((R == call_U1302)) {
            print "find what to enter rule";
            rtrue;
        }
        if ((R == call_U1304)) {
            print "convert enter door into go rule";
            rtrue;
        }
        if ((R == call_U1305)) {
            print "convert enter compass direction into go rule";
            rtrue;
        }
        if ((R == call_U1306)) {
            print "can't enter what's already entered rule";
            rtrue;
        }
        if ((R == call_U1311)) {
            print "can't enter what's not enterable rule";
            rtrue;
        }
        if ((R == call_U1320)) {
            print "can't enter closed containers rule";
            rtrue;
        }
        if ((R == call_U1323)) {
            print "can't enter if this exceeds carrying capacity rule";
            rtrue;
        }
        if ((R == call_U1330)) {
            print "can't enter something carried rule";
            rtrue;
        }
        if ((R == call_U1333)) {
            print "implicitly pass through other barriers rule";
            rtrue;
        }
        if ((R == call_U1344)) {
            print "standard entering rule";
            rtrue;
        }
        if ((R == call_U1345)) {
            print "standard report entering rule";
            rtrue;
        }
        if ((R == call_U1354)) {
            print "describe contents entered into rule";
            rtrue;
        }
        if ((R == call_U1355)) {
            print "standard set exiting variables rule";
            rtrue;
        }
        if ((R == call_U1356)) {
            print "convert exit into go out rule";
            rtrue;
        }
        if ((R == call_U1357)) {
            print "can't exit when not inside anything rule";
            rtrue;
        }
        if ((R == call_U1360)) {
            print "can't exit closed containers rule";
            rtrue;
        }
        if ((R == call_U1363)) {
            print "convert exit into get off rule";
            rtrue;
        }
        if ((R == call_U1364)) {
            print "standard exiting rule";
            rtrue;
        }
        if ((R == call_U1365)) {
            print "standard report exiting rule";
            rtrue;
        }
        if ((R == call_U1372)) {
            print "describe room emerged into rule";
            rtrue;
        }
        if ((R == call_U1373)) {
            print "can't get off things rule";
            rtrue;
        }
        if ((R == call_U1376)) {
            print "standard getting off rule";
            rtrue;
        }
        if ((R == call_U1377)) {
            print "standard report getting off rule";
            rtrue;
        }
        if ((R == call_U1380)) {
            print "describe room stood up into rule";
            rtrue;
        }
        if ((R == call_U1381)) {
            print "determine visibility ceiling rule";
            rtrue;
        }
        if ((R == call_U1382)) {
            print "declare everything unmentioned rule";
            rtrue;
        }
        if ((R == call_U1384)) {
            print "room description heading rule";
            rtrue;
        }
        if ((R == call_U1391)) {
            print "room description body text rule";
            rtrue;
        }
        if ((R == call_U1394)) {
            print "room description paragraphs about objects rule";
            rtrue;
        }
        if ((R == call_U1395)) {
            print "check new arrival rule";
            rtrue;
        }
        if ((R == call_U1396)) {
            print "other people looking rule";
            rtrue;
        }
        if ((R == call_U1399)) {
            print "standard examining rule";
            rtrue;
        }
        if ((R == call_U1400)) {
            print "examine directions rule";
            rtrue;
        }
        if ((R == call_U1403)) {
            print "examine containers rule";
            rtrue;
        }
        if ((R == call_U1410)) {
            print "examine supporters rule";
            rtrue;
        }
        if ((R == call_U1415)) {
            print "examine devices rule";
            rtrue;
        }
        if ((R == call_U1418)) {
            print "examine undescribed things rule";
            rtrue;
        }
        if ((R == call_U1421)) {
            print "report other people examining rule";
            rtrue;
        }
        if ((R == call_U1424)) {
            print "standard looking under rule";
            rtrue;
        }
        if ((R == call_U1427)) {
            print "report other people looking under rule";
            rtrue;
        }
        if ((R == call_U1430)) {
            print "can't search unless container or supporter rule";
            rtrue;
        }
        if ((R == call_U1433)) {
            print "can't search closed opaque containers rule";
            rtrue;
        }
        if ((R == call_U1436)) {
            print "standard search containers rule";
            rtrue;
        }
        if ((R == call_U1442)) {
            print "standard search supporters rule";
            rtrue;
        }
        if ((R == call_U1448)) {
            print "report other people searching rule";
            rtrue;
        }
        if ((R == call_U1451)) {
            print "block consulting rule";
            rtrue;
        }
        if ((R == call_U1456)) {
            print "can't lock without a lock rule";
            rtrue;
        }
        if ((R == call_U1459)) {
            print "can't lock what's already locked rule";
            rtrue;
        }
        if ((R == call_U1462)) {
            print "can't lock what's open rule";
            rtrue;
        }
        if ((R == call_U1465)) {
            print "can't lock without the correct key rule";
            rtrue;
        }
        if ((R == call_U1468)) {
            print "standard locking rule";
            rtrue;
        }
        if ((R == call_U1469)) {
            print "standard report locking rule";
            rtrue;
        }
        if ((R == call_U1474)) {
            print "can't unlock without a lock rule";
            rtrue;
        }
        if ((R == call_U1477)) {
            print "can't unlock what's already unlocked rule";
            rtrue;
        }
        if ((R == call_U1480)) {
            print "can't unlock without the correct key rule";
            rtrue;
        }
        if ((R == call_U1483)) {
            print "standard unlocking rule";
            rtrue;
        }
        if ((R == call_U1484)) {
            print "standard report unlocking rule";
            rtrue;
        }
        if ((R == call_U1489)) {
            print "can't switch on unless switchable rule";
            rtrue;
        }
        if ((R == call_U1492)) {
            print "can't switch on what's already on rule";
            rtrue;
        }
        if ((R == call_U1495)) {
            print "standard switching on rule";
            rtrue;
        }
        if ((R == call_U1496)) {
            print "standard report switching on rule";
            rtrue;
        }
        if ((R == call_U1499)) {
            print "can't switch off unless switchable rule";
            rtrue;
        }
        if ((R == call_U1502)) {
            print "can't switch off what's already off rule";
            rtrue;
        }
        if ((R == call_U1505)) {
            print "standard switching off rule";
            rtrue;
        }
        if ((R == call_U1506)) {
            print "standard report switching off rule";
            rtrue;
        }
        if ((R == call_U1509)) {
            print "can't open unless openable rule";
            rtrue;
        }
        if ((R == call_U1512)) {
            print "can't open what's locked rule";
            rtrue;
        }
        if ((R == call_U1515)) {
            print "can't open what's already open rule";
            rtrue;
        }
        if ((R == call_U1518)) {
            print "standard opening rule";
            rtrue;
        }
        if ((R == call_U1519)) {
            print "reveal any newly visible interior rule";
            rtrue;
        }
        if ((R == call_U1522)) {
            print "standard report opening rule";
            rtrue;
        }
        if ((R == call_U1529)) {
            print "can't close unless openable rule";
            rtrue;
        }
        if ((R == call_U1532)) {
            print "can't close what's already closed rule";
            rtrue;
        }
        if ((R == call_U1535)) {
            print "standard closing rule";
            rtrue;
        }
        if ((R == call_U1536)) {
            print "standard report closing rule";
            rtrue;
        }
        if ((R == call_U1543)) {
            print "can't wear what's not clothing rule";
            rtrue;
        }
        if ((R == call_U1546)) {
            print "can't wear what's not held rule";
            rtrue;
        }
        if ((R == call_U1549)) {
            print "can't wear what's already worn rule";
            rtrue;
        }
        if ((R == call_U1552)) {
            print "standard wearing rule";
            rtrue;
        }
        if ((R == call_U1553)) {
            print "standard report wearing rule";
            rtrue;
        }
        if ((R == call_U1558)) {
            print "Does the player mean taking off something worn";
            rtrue;
        }
        if ((R == call_U1559)) {
            print "can't take off what's not worn rule";
            rtrue;
        }
        if ((R == call_U1562)) {
            print "can't exceed carrying capacity when taking off rule";
            rtrue;
        }
        if ((R == call_U1566)) {
            print "standard taking off rule";
            rtrue;
        }
        if ((R == call_U1567)) {
            print "standard report taking off rule";
            rtrue;
        }
        if ((R == call_U1572)) {
            print "can't give what you haven't got rule";
            rtrue;
        }
        if ((R == call_U1575)) {
            print "can't give to yourself rule";
            rtrue;
        }
        if ((R == call_U1578)) {
            print "can't give to a non-person rule";
            rtrue;
        }
        if ((R == call_U1581)) {
            print "can't give clothes being worn rule";
            rtrue;
        }
        if ((R == call_U1584)) {
            print "block giving rule";
            rtrue;
        }
        if ((R == call_U1587)) {
            print "can't exceed carrying capacity when giving rule";
            rtrue;
        }
        if ((R == call_U1591)) {
            print "standard giving rule";
            rtrue;
        }
        if ((R == call_U1592)) {
            print "standard report giving rule";
            rtrue;
        }
        if ((R == call_U1599)) {
            print "can't show what you haven't got rule";
            rtrue;
        }
        if ((R == call_U1602)) {
            print "convert show to yourself to examine rule";
            rtrue;
        }
        if ((R == call_U1603)) {
            print "block showing rule";
            rtrue;
        }
        if ((R == call_U1606)) {
            print "block waking rule";
            rtrue;
        }
        if ((R == call_U1609)) {
            print "implicitly remove thrown clothing rule";
            rtrue;
        }
        if ((R == call_U1612)) {
            print "futile to throw things at inanimate objects rule";
            rtrue;
        }
        if ((R == call_U1615)) {
            print "block throwing at rule";
            rtrue;
        }
        if ((R == call_U1618)) {
            print "block attacking rule";
            rtrue;
        }
        if ((R == call_U1621)) {
            print "kissing yourself rule";
            rtrue;
        }
        if ((R == call_U1624)) {
            print "block kissing rule";
            rtrue;
        }
        if ((R == call_U1627)) {
            print "block answering rule";
            rtrue;
        }
        if ((R == call_U1630)) {
            print "telling yourself rule";
            rtrue;
        }
        if ((R == call_U1633)) {
            print "block telling rule";
            rtrue;
        }
        if ((R == call_U1636)) {
            print "block asking rule";
            rtrue;
        }
        if ((R == call_U1639)) {
            print "asking yourself for something rule";
            rtrue;
        }
        if ((R == call_U1640)) {
            print "translate asking for to giving rule";
            rtrue;
        }
        if ((R == call_U1641)) {
            print "standard report waiting rule";
            rtrue;
        }
        if ((R == call_U1646)) {
            print "report touching yourself rule";
            rtrue;
        }
        if ((R == call_U1651)) {
            print "report touching other people rule";
            rtrue;
        }
        if ((R == call_U1658)) {
            print "report touching things rule";
            rtrue;
        }
        if ((R == call_U1663)) {
            print "can't wave what's not held rule";
            rtrue;
        }
        if ((R == call_U1666)) {
            print "report waving things rule";
            rtrue;
        }
        if ((R == call_U1671)) {
            print "can't pull what's fixed in place rule";
            rtrue;
        }
        if ((R == call_U1674)) {
            print "can't pull scenery rule";
            rtrue;
        }
        if ((R == call_U1677)) {
            print "can't pull people rule";
            rtrue;
        }
        if ((R == call_U1680)) {
            print "report pulling rule";
            rtrue;
        }
        if ((R == call_U1685)) {
            print "can't push what's fixed in place rule";
            rtrue;
        }
        if ((R == call_U1688)) {
            print "can't push scenery rule";
            rtrue;
        }
        if ((R == call_U1691)) {
            print "can't push people rule";
            rtrue;
        }
        if ((R == call_U1694)) {
            print "report pushing rule";
            rtrue;
        }
        if ((R == call_U1699)) {
            print "can't turn what's fixed in place rule";
            rtrue;
        }
        if ((R == call_U1702)) {
            print "can't turn scenery rule";
            rtrue;
        }
        if ((R == call_U1705)) {
            print "can't turn people rule";
            rtrue;
        }
        if ((R == call_U1708)) {
            print "report turning rule";
            rtrue;
        }
        if ((R == call_U1713)) {
            print "can't push unpushable things rule";
            rtrue;
        }
        if ((R == call_U1716)) {
            print "can't push to non-directions rule";
            rtrue;
        }
        if ((R == call_U1719)) {
            print "can't push vertically rule";
            rtrue;
        }
        if ((R == call_U1722)) {
            print "can't push from within rule";
            rtrue;
        }
        if ((R == call_U1725)) {
            print "standard pushing in directions rule";
            rtrue;
        }
        if ((R == call_U1726)) {
            print "block pushing in directions rule";
            rtrue;
        }
        if ((R == call_U1729)) {
            print "innuendo about squeezing people rule";
            rtrue;
        }
        if ((R == call_U1732)) {
            print "report squeezing rule";
            rtrue;
        }
        if ((R == call_U1737)) {
            print "block saying yes rule";
            rtrue;
        }
        if ((R == call_U1740)) {
            print "block saying no rule";
            rtrue;
        }
        if ((R == call_U1743)) {
            print "block burning rule";
            rtrue;
        }
        if ((R == call_U1746)) {
            print "block waking up rule";
            rtrue;
        }
        if ((R == call_U1749)) {
            print "block thinking rule";
            rtrue;
        }
        if ((R == call_U1752)) {
            print "report smelling rule";
            rtrue;
        }
        if ((R == call_U1757)) {
            print "report listening rule";
            rtrue;
        }
        if ((R == call_U1762)) {
            print "report tasting rule";
            rtrue;
        }
        if ((R == call_U1767)) {
            print "block cutting rule";
            rtrue;
        }
        if ((R == call_U1770)) {
            print "report jumping rule";
            rtrue;
        }
        if ((R == call_U1775)) {
            print "block tying rule";
            rtrue;
        }
        if ((R == call_U1778)) {
            print "block drinking rule";
            rtrue;
        }
        if ((R == call_U1781)) {
            print "block saying sorry rule";
            rtrue;
        }
        if ((R == call_U1784)) {
            print "block swinging rule";
            rtrue;
        }
        if ((R == call_U1787)) {
            print "can't rub another person rule";
            rtrue;
        }
        if ((R == call_U1790)) {
            print "report rubbing rule";
            rtrue;
        }
        if ((R == call_U1795)) {
            print "block setting it to rule";
            rtrue;
        }
        if ((R == call_U1798)) {
            print "report waving hands rule";
            rtrue;
        }
        if ((R == call_U1803)) {
            print "block buying rule";
            rtrue;
        }
        if ((R == call_U1806)) {
            print "block climbing rule";
            rtrue;
        }
        if ((R == call_U1809)) {
            print "block sleeping rule";
            rtrue;
        }
        if ((R == LITTLE_USED_DO_NOTHING_R)) {
            print "little-used do nothing rule";
            rtrue;
        }
        if ((R == VIRTUAL_MACHINE_STARTUP_R)) {
            print "virtual machine startup rule";
            rtrue;
        }
        if ((R == INITIALISE_MEMORY_R)) {
            print "initialise memory rule";
            rtrue;
        }
        if ((R == SEED_RANDOM_NUMBER_GENERATOR_R)) {
            print "seed random number generator rule";
            rtrue;
        }
        if ((R == UPDATE_CHRONOLOGICAL_RECORDS_R)) {
            print "update chronological records rule";
            rtrue;
        }
        if ((R == POSITION_PLAYER_IN_MODEL_R)) {
            print "position player in model world rule";
            rtrue;
        }
        if ((R == ADVANCE_TIME_R)) {
            print "advance time rule";
            rtrue;
        }
        if ((R == NOTE_OBJECT_ACQUISITIONS_R)) {
            print "note object acquisitions rule";
            rtrue;
        }
        if ((R == PARSE_COMMAND_R)) {
            print "parse command rule";
            rtrue;
        }
        if ((R == TIMED_EVENTS_R)) {
            print "timed events rule";
            rtrue;
        }
        if ((R == RESURRECT_PLAYER_IF_ASKED_R)) {
            print "resurrect player if asked rule";
            rtrue;
        }
        if ((R == ASK_FINAL_QUESTION_R)) {
            print "ask the final question rule";
            rtrue;
        }
        if ((R == SCENE_CHANGE_MACHINERY_R)) {
            print "scene change machinery rule";
            rtrue;
        }
        if ((R == CARRYING_REQUIREMENTS_R)) {
            print "carrying requirements rule";
            rtrue;
        }
        if ((R == DESCEND_TO_SPECIFIC_ACTION_R)) {
            print "descend to specific action-processing rule";
            rtrue;
        }
        if ((R == WORK_OUT_DETAILS_OF_SPECIFIC_R)) {
            print "work out details of specific action rule";
            rtrue;
        }
        if ((R == STANDARD_RESPONSE_ISSUING_R)) {
            print "standard issuing the response text rule";
            rtrue;
        }
        if ((R == STANDARD_CONTENTS_LISTING_R)) {
            print "standard contents listing rule";
            rtrue;
        }
        if ((R == PRINT_FINAL_SCORE_R)) {
            print "print final score rule";
            rtrue;
        }
        if ((R == DISPLAY_FINAL_STATUS_LINE_R)) {
            print "display final status line rule";
            rtrue;
        }
        if ((R == IMMEDIATELY_RESTART_VM_R)) {
            print "immediately restart the VM rule";
            rtrue;
        }
        if ((R == IMMEDIATELY_RESTORE_SAVED_R)) {
            print "immediately restore saved game rule";
            rtrue;
        }
        if ((R == IMMEDIATELY_QUIT_R)) {
            print "immediately quit rule";
            rtrue;
        }
        if ((R == READ_FINAL_ANSWER_R)) {
            print "read the final answer rule";
            rtrue;
        }
        if ((R == ANNOUNCE_STORY_FILE_VERSION_R)) {
            print "announce the story file version rule";
            rtrue;
        }
        if ((R == PREFER_ABBREVIATED_R)) {
            print "prefer abbreviated room descriptions rule";
            rtrue;
        }
        if ((R == PREFER_UNABBREVIATED_R)) {
            print "prefer unabbreviated room descriptions rule";
            rtrue;
        }
        if ((R == PREFER_SOMETIMES_ABBREVIATED_R)) {
            print "prefer sometimes abbreviated room descriptions rule";
            rtrue;
        }
        if ((R == SWITCH_SCORE_NOTIFY_ON_R)) {
            print "switch score notification on rule";
            rtrue;
        }
        if ((R == SWITCH_SCORE_NOTIFY_OFF_R)) {
            print "switch score notification off rule";
            rtrue;
        }
        if ((R == call_U1941)) {
            print "Instead of eating Simi";
            rtrue;
        }
        print "(nameless rule at address ";
        print R;
        print ")";
    }
];
[ PrintResponse R;
    if ((R == 1)) {
        RulePrintingRule(ADJUST_LIGHT_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 2)) {
        RulePrintingRule(GENERATE_ACTION_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 3)) {
        RulePrintingRule(GENERATE_ACTION_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 4)) {
        RulePrintingRule(BASIC_ACCESSIBILITY_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 5)) {
        RulePrintingRule(BASIC_VISIBILITY_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 6)) {
        RulePrintingRule(REQUESTED_ACTIONS_REQUIRE_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 7)) {
        RulePrintingRule(CARRY_OUT_REQUESTED_ACTIONS_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 8)) {
        RulePrintingRule(ACCESS_THROUGH_BARRIERS_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 9)) {
        RulePrintingRule(CANT_REACH_INSIDE_CLOSED_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 10)) {
        RulePrintingRule(CANT_REACH_INSIDE_ROOMS_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 11)) {
        RulePrintingRule(CANT_REACH_OUTSIDE_CLOSED_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 12)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 13)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 14)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 15)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 16)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 17)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 18)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 71;
        print ")";
    }
    if ((R == 19)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 72;
        print ")";
    }
    if ((R == 20)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 73;
        print ")";
    }
    if ((R == 21)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 74;
        print ")";
    }
    if ((R == 22)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 75;
        print ")";
    }
    if ((R == 23)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 76;
        print ")";
    }
    if ((R == 24)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 77;
        print ")";
    }
    if ((R == 25)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 78;
        print ")";
    }
    if ((R == 26)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 79;
        print ")";
    }
    if ((R == 27)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 80;
        print ")";
    }
    if ((R == 28)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 81;
        print ")";
    }
    if ((R == 29)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 82;
        print ")";
    }
    if ((R == 30)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 83;
        print ")";
    }
    if ((R == 31)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 84;
        print ")";
    }
    if ((R == 32)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 85;
        print ")";
    }
    if ((R == 33)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 86;
        print ")";
    }
    if ((R == 34)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 87;
        print ")";
    }
    if ((R == 35)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 88;
        print ")";
    }
    if ((R == 36)) {
        RulePrintingRule(LIST_WRITER_INTERNAL_R);
        print " response (";
        print (char) 89;
        print ")";
    }
    if ((R == 37)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 38)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 39)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 40)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 41)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 42)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 43)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 71;
        print ")";
    }
    if ((R == 44)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 72;
        print ")";
    }
    if ((R == 45)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 73;
        print ")";
    }
    if ((R == 46)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 74;
        print ")";
    }
    if ((R == 47)) {
        RulePrintingRule(ACTION_PROCESSING_INTERNAL_R);
        print " response (";
        print (char) 75;
        print ")";
    }
    if ((R == 48)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 49)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 50)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 51)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 52)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 53)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 54)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 71;
        print ")";
    }
    if ((R == 55)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 72;
        print ")";
    }
    if ((R == 56)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 73;
        print ")";
    }
    if ((R == 57)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 74;
        print ")";
    }
    if ((R == 58)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 75;
        print ")";
    }
    if ((R == 59)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 76;
        print ")";
    }
    if ((R == 60)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 77;
        print ")";
    }
    if ((R == 61)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 78;
        print ")";
    }
    if ((R == 62)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 79;
        print ")";
    }
    if ((R == 63)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 80;
        print ")";
    }
    if ((R == 64)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 81;
        print ")";
    }
    if ((R == 65)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 82;
        print ")";
    }
    if ((R == 66)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 83;
        print ")";
    }
    if ((R == 67)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 84;
        print ")";
    }
    if ((R == 68)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 85;
        print ")";
    }
    if ((R == 69)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 86;
        print ")";
    }
    if ((R == 70)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 87;
        print ")";
    }
    if ((R == 71)) {
        RulePrintingRule(PARSER_ERROR_INTERNAL_R);
        print " response (";
        print (char) 88;
        print ")";
    }
    if ((R == 72)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 73)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 74)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 75)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 76)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 77)) {
        RulePrintingRule(PARSER_N_ERROR_INTERNAL_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 78)) {
        RulePrintingRule(DARKNESS_NAME_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 79)) {
        RulePrintingRule(PARSER_COMMAND_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 80)) {
        RulePrintingRule(PARSER_COMMAND_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 81)) {
        RulePrintingRule(PARSER_COMMAND_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 82)) {
        RulePrintingRule(PARSER_COMMAND_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 83)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 84)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 85)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 86)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 87)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 88)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 89)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 71;
        print ")";
    }
    if ((R == 90)) {
        RulePrintingRule(PARSER_CLARIF_INTERNAL_R);
        print " response (";
        print (char) 72;
        print ")";
    }
    if ((R == 91)) {
        RulePrintingRule(YES_OR_NO_QUESTION_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 92)) {
        RulePrintingRule(PRINT_PROTAGONIST_INTERNAL_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 93)) {
        RulePrintingRule(PRINT_PROTAGONIST_INTERNAL_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 94)) {
        RulePrintingRule(PRINT_PROTAGONIST_INTERNAL_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 95)) {
        RulePrintingRule(STANDARD_IMPLICIT_TAKING_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 96)) {
        RulePrintingRule(STANDARD_IMPLICIT_TAKING_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 97)) {
        RulePrintingRule(PRINT_OBITUARY_HEADLINE_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 98)) {
        RulePrintingRule(PRINT_OBITUARY_HEADLINE_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 99)) {
        RulePrintingRule(PRINT_OBITUARY_HEADLINE_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 100)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 101)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 102)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 103)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 104)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 105)) {
        RulePrintingRule(IMMEDIATELY_UNDO_R);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 106)) {
        RulePrintingRule(QUIT_THE_GAME_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 107)) {
        RulePrintingRule(SAVE_THE_GAME_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 108)) {
        RulePrintingRule(SAVE_THE_GAME_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 109)) {
        RulePrintingRule(RESTORE_THE_GAME_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 110)) {
        RulePrintingRule(RESTORE_THE_GAME_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 111)) {
        RulePrintingRule(RESTART_THE_GAME_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 112)) {
        RulePrintingRule(RESTART_THE_GAME_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 113)) {
        RulePrintingRule(VERIFY_THE_STORY_FILE_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 114)) {
        RulePrintingRule(VERIFY_THE_STORY_FILE_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 115)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_ON_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 116)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_ON_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 117)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_ON_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 118)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_OFF_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 119)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_OFF_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 120)) {
        RulePrintingRule(SWITCH_TRANSCRIPT_OFF_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 121)) {
        RulePrintingRule(ANNOUNCE_SCORE_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 122)) {
        RulePrintingRule(ANNOUNCE_SCORE_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 123)) {
        RulePrintingRule(ANNOUNCE_SCORE_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 124)) {
        RulePrintingRule(ANNOUNCE_SCORE_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 125)) {
        RulePrintingRule(ANNOUNCE_SCORE_R);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 126)) {
        RulePrintingRule(REP_PREFER_ABBREVIATED_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 127)) {
        RulePrintingRule(REP_PREFER_UNABBREVIATED_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 128)) {
        RulePrintingRule(REP_PREFER_SOMETIMES_ABBR_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 129)) {
        RulePrintingRule(REP_SWITCH_NOTIFY_ON_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 130)) {
        RulePrintingRule(REP_SWITCH_NOTIFY_OFF_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 131)) {
        RulePrintingRule(ANNOUNCE_PRONOUN_MEANINGS_R);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 132)) {
        RulePrintingRule(ANNOUNCE_PRONOUN_MEANINGS_R);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 133)) {
        RulePrintingRule(ANNOUNCE_PRONOUN_MEANINGS_R);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 134)) {
        RulePrintingRule(ANNOUNCE_PRONOUN_MEANINGS_R);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 135)) {
        RulePrintingRule(call_U994);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 136)) {
        RulePrintingRule(call_U1024);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 137)) {
        RulePrintingRule(call_U1027);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 138)) {
        RulePrintingRule(call_U1030);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 139)) {
        RulePrintingRule(call_U1030);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 140)) {
        RulePrintingRule(call_U1035);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 141)) {
        RulePrintingRule(call_U1041);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 142)) {
        RulePrintingRule(call_U1041);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 143)) {
        RulePrintingRule(call_U1041);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 144)) {
        RulePrintingRule(call_U1041);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 145)) {
        RulePrintingRule(call_U1041);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 146)) {
        RulePrintingRule(call_U1041);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 147)) {
        RulePrintingRule(call_U1065);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 148)) {
        RulePrintingRule(call_U1072);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 149)) {
        RulePrintingRule(call_U1077);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 150)) {
        RulePrintingRule(call_U1082);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 151)) {
        RulePrintingRule(call_U1085);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 152)) {
        RulePrintingRule(call_U1088);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 153)) {
        RulePrintingRule(call_U1091);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 154)) {
        RulePrintingRule(call_U1094);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 155)) {
        RulePrintingRule(call_U1097);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 156)) {
        RulePrintingRule(call_U1100);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 157)) {
        RulePrintingRule(call_U1103);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 158)) {
        RulePrintingRule(call_U1106);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 159)) {
        RulePrintingRule(call_U1109);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 160)) {
        RulePrintingRule(call_U1112);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 161)) {
        RulePrintingRule(call_U1115);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 162)) {
        RulePrintingRule(call_U1118);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 163)) {
        RulePrintingRule(call_U1121);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 164)) {
        RulePrintingRule(call_U1127);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 165)) {
        RulePrintingRule(call_U1132);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 166)) {
        RulePrintingRule(call_U1132);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 167)) {
        RulePrintingRule(call_U1137);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 168)) {
        RulePrintingRule(call_U1140);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 169)) {
        RulePrintingRule(call_U1144);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 170)) {
        RulePrintingRule(call_U1147);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 171)) {
        RulePrintingRule(call_U1150);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 172)) {
        RulePrintingRule(call_U1153);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 173)) {
        RulePrintingRule(call_U1156);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 174)) {
        RulePrintingRule(call_U1159);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 175)) {
        RulePrintingRule(call_U1159);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 176)) {
        RulePrintingRule(call_U1167);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 177)) {
        RulePrintingRule(call_U1167);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 178)) {
        RulePrintingRule(call_U1174);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 179)) {
        RulePrintingRule(call_U1177);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 180)) {
        RulePrintingRule(call_U1180);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 181)) {
        RulePrintingRule(call_U1183);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 182)) {
        RulePrintingRule(call_U1188);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 183)) {
        RulePrintingRule(call_U1191);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 184)) {
        RulePrintingRule(call_U1195);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 185)) {
        RulePrintingRule(call_U1198);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 186)) {
        RulePrintingRule(call_U1202);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 187)) {
        RulePrintingRule(call_U1205);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 188)) {
        RulePrintingRule(call_U1208);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 189)) {
        RulePrintingRule(call_U1211);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 190)) {
        RulePrintingRule(call_U1216);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 191)) {
        RulePrintingRule(call_U1219);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 192)) {
        RulePrintingRule(call_U1222);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 193)) {
        RulePrintingRule(call_U1225);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 194)) {
        RulePrintingRule(call_U1228);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 195)) {
        RulePrintingRule(call_U1234);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 196)) {
        RulePrintingRule(call_U1234);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 197)) {
        RulePrintingRule(call_U1240);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 198)) {
        RulePrintingRule(call_U1243);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 199)) {
        RulePrintingRule(call_U1243);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 200)) {
        RulePrintingRule(call_U1248);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 201)) {
        RulePrintingRule(call_U1251);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 202)) {
        RulePrintingRule(call_U1255);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 203)) {
        RulePrintingRule(call_U1255);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 204)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 205)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 206)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 207)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 208)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 209)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 70;
        print ")";
    }
    if ((R == 210)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 71;
        print ")";
    }
    if ((R == 211)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 72;
        print ")";
    }
    if ((R == 212)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 73;
        print ")";
    }
    if ((R == 213)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 74;
        print ")";
    }
    if ((R == 214)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 75;
        print ")";
    }
    if ((R == 215)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 76;
        print ")";
    }
    if ((R == 216)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 77;
        print ")";
    }
    if ((R == 217)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 78;
        print ")";
    }
    if ((R == 218)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 79;
        print ")";
    }
    if ((R == 219)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 80;
        print ")";
    }
    if ((R == 220)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 81;
        print ")";
    }
    if ((R == 221)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 82;
        print ")";
    }
    if ((R == 222)) {
        RulePrintingRule(call_U1263);
        print " response (";
        print (char) 83;
        print ")";
    }
    if ((R == 223)) {
        RulePrintingRule(call_U1306);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 224)) {
        RulePrintingRule(call_U1306);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 225)) {
        RulePrintingRule(call_U1311);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 226)) {
        RulePrintingRule(call_U1311);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 227)) {
        RulePrintingRule(call_U1311);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 228)) {
        RulePrintingRule(call_U1311);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 229)) {
        RulePrintingRule(call_U1320);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 230)) {
        RulePrintingRule(call_U1323);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 231)) {
        RulePrintingRule(call_U1323);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 232)) {
        RulePrintingRule(call_U1330);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 233)) {
        RulePrintingRule(call_U1333);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 234)) {
        RulePrintingRule(call_U1333);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 235)) {
        RulePrintingRule(call_U1333);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 236)) {
        RulePrintingRule(call_U1333);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 237)) {
        RulePrintingRule(call_U1333);
        print " response (";
        print (char) 69;
        print ")";
    }
    if ((R == 238)) {
        RulePrintingRule(call_U1345);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 239)) {
        RulePrintingRule(call_U1345);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 240)) {
        RulePrintingRule(call_U1345);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 241)) {
        RulePrintingRule(call_U1345);
        print " response (";
        print (char) 68;
        print ")";
    }
    if ((R == 242)) {
        RulePrintingRule(call_U1357);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 243)) {
        RulePrintingRule(call_U1360);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 244)) {
        RulePrintingRule(call_U1365);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 245)) {
        RulePrintingRule(call_U1365);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 246)) {
        RulePrintingRule(call_U1365);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 247)) {
        RulePrintingRule(call_U1373);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 248)) {
        RulePrintingRule(call_U1377);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 249)) {
        RulePrintingRule(call_U1384);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 250)) {
        RulePrintingRule(call_U1384);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 251)) {
        RulePrintingRule(call_U1384);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 252)) {
        RulePrintingRule(call_U1391);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 253)) {
        RulePrintingRule(call_U1396);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 254)) {
        RulePrintingRule(call_U1400);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 255)) {
        RulePrintingRule(call_U1403);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 256)) {
        RulePrintingRule(call_U1403);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 257)) {
        RulePrintingRule(call_U1410);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 258)) {
        RulePrintingRule(call_U1415);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 259)) {
        RulePrintingRule(call_U1418);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 260)) {
        RulePrintingRule(call_U1421);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 261)) {
        RulePrintingRule(call_U1424);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 262)) {
        RulePrintingRule(call_U1427);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 263)) {
        RulePrintingRule(call_U1430);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 264)) {
        RulePrintingRule(call_U1433);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 265)) {
        RulePrintingRule(call_U1436);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 266)) {
        RulePrintingRule(call_U1436);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 267)) {
        RulePrintingRule(call_U1442);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 268)) {
        RulePrintingRule(call_U1442);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 269)) {
        RulePrintingRule(call_U1448);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 270)) {
        RulePrintingRule(call_U1451);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 271)) {
        RulePrintingRule(call_U1451);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 272)) {
        RulePrintingRule(call_U1456);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 273)) {
        RulePrintingRule(call_U1459);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 274)) {
        RulePrintingRule(call_U1462);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 275)) {
        RulePrintingRule(call_U1465);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 276)) {
        RulePrintingRule(call_U1469);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 277)) {
        RulePrintingRule(call_U1469);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 278)) {
        RulePrintingRule(call_U1474);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 279)) {
        RulePrintingRule(call_U1477);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 280)) {
        RulePrintingRule(call_U1480);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 281)) {
        RulePrintingRule(call_U1484);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 282)) {
        RulePrintingRule(call_U1484);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 283)) {
        RulePrintingRule(call_U1489);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 284)) {
        RulePrintingRule(call_U1492);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 285)) {
        RulePrintingRule(call_U1496);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 286)) {
        RulePrintingRule(call_U1499);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 287)) {
        RulePrintingRule(call_U1502);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 288)) {
        RulePrintingRule(call_U1506);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 289)) {
        RulePrintingRule(call_U1509);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 290)) {
        RulePrintingRule(call_U1512);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 291)) {
        RulePrintingRule(call_U1515);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 292)) {
        RulePrintingRule(call_U1519);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 293)) {
        RulePrintingRule(call_U1522);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 294)) {
        RulePrintingRule(call_U1522);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 295)) {
        RulePrintingRule(call_U1522);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 296)) {
        RulePrintingRule(call_U1529);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 297)) {
        RulePrintingRule(call_U1532);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 298)) {
        RulePrintingRule(call_U1536);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 299)) {
        RulePrintingRule(call_U1536);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 300)) {
        RulePrintingRule(call_U1536);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 301)) {
        RulePrintingRule(call_U1543);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 302)) {
        RulePrintingRule(call_U1546);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 303)) {
        RulePrintingRule(call_U1549);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 304)) {
        RulePrintingRule(call_U1553);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 305)) {
        RulePrintingRule(call_U1553);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 306)) {
        RulePrintingRule(call_U1559);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 307)) {
        RulePrintingRule(call_U1562);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 308)) {
        RulePrintingRule(call_U1567);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 309)) {
        RulePrintingRule(call_U1567);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 310)) {
        RulePrintingRule(call_U1572);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 311)) {
        RulePrintingRule(call_U1575);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 312)) {
        RulePrintingRule(call_U1578);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 313)) {
        RulePrintingRule(call_U1581);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 314)) {
        RulePrintingRule(call_U1584);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 315)) {
        RulePrintingRule(call_U1587);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 316)) {
        RulePrintingRule(call_U1592);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 317)) {
        RulePrintingRule(call_U1592);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 318)) {
        RulePrintingRule(call_U1592);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 319)) {
        RulePrintingRule(call_U1599);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 320)) {
        RulePrintingRule(call_U1603);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 321)) {
        RulePrintingRule(call_U1606);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 322)) {
        RulePrintingRule(call_U1609);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 323)) {
        RulePrintingRule(call_U1612);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 324)) {
        RulePrintingRule(call_U1615);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 325)) {
        RulePrintingRule(call_U1618);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 326)) {
        RulePrintingRule(call_U1621);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 327)) {
        RulePrintingRule(call_U1624);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 328)) {
        RulePrintingRule(call_U1627);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 329)) {
        RulePrintingRule(call_U1630);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 330)) {
        RulePrintingRule(call_U1633);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 331)) {
        RulePrintingRule(call_U1636);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 332)) {
        RulePrintingRule(call_U1641);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 333)) {
        RulePrintingRule(call_U1641);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 334)) {
        RulePrintingRule(call_U1646);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 335)) {
        RulePrintingRule(call_U1646);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 336)) {
        RulePrintingRule(call_U1651);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 337)) {
        RulePrintingRule(call_U1651);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 338)) {
        RulePrintingRule(call_U1651);
        print " response (";
        print (char) 67;
        print ")";
    }
    if ((R == 339)) {
        RulePrintingRule(call_U1658);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 340)) {
        RulePrintingRule(call_U1658);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 341)) {
        RulePrintingRule(call_U1663);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 342)) {
        RulePrintingRule(call_U1666);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 343)) {
        RulePrintingRule(call_U1666);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 344)) {
        RulePrintingRule(call_U1671);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 345)) {
        RulePrintingRule(call_U1674);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 346)) {
        RulePrintingRule(call_U1677);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 347)) {
        RulePrintingRule(call_U1680);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 348)) {
        RulePrintingRule(call_U1680);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 349)) {
        RulePrintingRule(call_U1685);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 350)) {
        RulePrintingRule(call_U1688);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 351)) {
        RulePrintingRule(call_U1691);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 352)) {
        RulePrintingRule(call_U1694);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 353)) {
        RulePrintingRule(call_U1694);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 354)) {
        RulePrintingRule(call_U1699);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 355)) {
        RulePrintingRule(call_U1702);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 356)) {
        RulePrintingRule(call_U1705);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 357)) {
        RulePrintingRule(call_U1708);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 358)) {
        RulePrintingRule(call_U1708);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 359)) {
        RulePrintingRule(call_U1713);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 360)) {
        RulePrintingRule(call_U1716);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 361)) {
        RulePrintingRule(call_U1719);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 362)) {
        RulePrintingRule(call_U1722);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 363)) {
        RulePrintingRule(call_U1726);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 364)) {
        RulePrintingRule(call_U1729);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 365)) {
        RulePrintingRule(call_U1732);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 366)) {
        RulePrintingRule(call_U1732);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 367)) {
        RulePrintingRule(call_U1737);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 368)) {
        RulePrintingRule(call_U1740);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 369)) {
        RulePrintingRule(call_U1743);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 370)) {
        RulePrintingRule(call_U1746);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 371)) {
        RulePrintingRule(call_U1749);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 372)) {
        RulePrintingRule(call_U1752);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 373)) {
        RulePrintingRule(call_U1752);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 374)) {
        RulePrintingRule(call_U1757);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 375)) {
        RulePrintingRule(call_U1757);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 376)) {
        RulePrintingRule(call_U1762);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 377)) {
        RulePrintingRule(call_U1762);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 378)) {
        RulePrintingRule(call_U1767);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 379)) {
        RulePrintingRule(call_U1770);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 380)) {
        RulePrintingRule(call_U1770);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 381)) {
        RulePrintingRule(call_U1775);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 382)) {
        RulePrintingRule(call_U1778);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 383)) {
        RulePrintingRule(call_U1781);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 384)) {
        RulePrintingRule(call_U1784);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 385)) {
        RulePrintingRule(call_U1787);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 386)) {
        RulePrintingRule(call_U1790);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 387)) {
        RulePrintingRule(call_U1790);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 388)) {
        RulePrintingRule(call_U1795);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 389)) {
        RulePrintingRule(call_U1798);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 390)) {
        RulePrintingRule(call_U1798);
        print " response (";
        print (char) 66;
        print ")";
    }
    if ((R == 391)) {
        RulePrintingRule(call_U1803);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 392)) {
        RulePrintingRule(call_U1806);
        print " response (";
        print (char) 65;
        print ")";
    }
    if ((R == 393)) {
        RulePrintingRule(call_U1809);
        print " response (";
        print (char) 65;
        print ")";
    }
];
[ ShowSceneStatus;
    call_U346();
];
[ DetectSceneChange chs;
    .Again;
    if (call_U345()) {
        jump CScene;
    }
    rfalse;
    .CScene;
    if ((chs > 20)) {
        print ">--> The scene change machinery is stuck.^";
        rtrue;
    }
    ++(chs);
    jump Again;
];
[ PrintTableName T;
    switch (T) {
        TheEmptyTable:
            print "(the empty table)";
            rtrue;
            ;
        table_data_U1:
            print "Table of Final Question Options";
            rtrue;
            ;
        table_data_U2:
            print "Table of Locale Priorities";
            rtrue;
            ;
        default:
            print "** No such table **";
            rtrue;
            ;
    }
];
[ TC_KOV tc unk;
    switch (tc) {
        100:
            return TEXT_TY;
            ;
        101:
            return TRUTH_STATE_TY;
            ;
        102:
            return UNDERSTANDING_TY;
            ;
        103:
            return DK1_rule;
            ;
        104:
            return DK2_activity_on_objects;
            ;
        105:
            return OBJECT_TY;
            ;
        106:
            return NUMBER_TY;
            ;
    }
    return unk;
];
[ TestScriptSub;
    print ">--> No test scripts exist for this game.^";
];
[ TestUseOption UO;
    if ((UO == 14)) {
        rtrue;
    }
    if ((UO == 15)) {
        rtrue;
    }
    if ((UO == 16)) {
        rtrue;
    }
    if ((UO == 27)) {
        rtrue;
    }
    rfalse;
];
[ PrintUseOption UO;
    switch (UO) {
        0:
            print "ineffectual option";
            ;
        1:
            print "american dialect option";
            ;
        2:
            print "serial comma option";
            ;
        3:
            print "memory economy option";
            ;
        4:
            print "engineering notation option";
            ;
        5:
            print "unabbreviated object names option";
            ;
        6:
            print "predictable randomisation option";
            ;
        7:
            print "fast route-finding option";
            ;
        8:
            print "slow route-finding option";
            ;
        9:
            print "numbered rules option";
            ;
        10:
            print "telemetry recordings option";
            ;
        11:
            print "no deprecated features option";
            ;
        12:
            print "gn testing version option";
            ;
        13:
            print "authorial modesty option";
            ;
        14:
            print "dynamic memory allocation option [8192]";
            ;
        15:
            print "maximum text length option [1024]";
            ;
        16:
            print "index figure thumbnails option [50]";
            ;
        17:
            print "command line echoing option";
            ;
        18:
            print "full-length room descriptions option";
            ;
        19:
            print "abbreviated room descriptions option";
            ;
        20:
            print "scoring option";
            ;
        21:
            print "no scoring option";
            ;
        22:
            print "manual pronouns option";
            ;
        23:
            print "undo prevention option";
            ;
        24:
            print "verbose room descriptions option";
            ;
        25:
            print "brief room descriptions option";
            ;
        26:
            print "superbrief room descriptions option";
            ;
        27:
            print "maximum things understood at once option [100]";
            ;
    }
];
[ call_U42 t_0;
    if (1) {
        return (IntegerRemainder(t_0, 2) == 0);
    }
    rfalse;
];
[ call_U43 t_0;
    if (1) {
        return (~~((IntegerRemainder(t_0, 2) == 0)));
    }
    rfalse;
];
[ call_U44 t_0;
    if (1) {
        return (t_0 > 0);
    }
    rfalse;
];
[ call_U45 t_0;
    if (1) {
        return ((REAL_NUMBER_TY_Compare)(t_0,NUMBER_TY_to_REAL_NUMBER_TY(0)) > 0);
    }
    rfalse;
];
[ call_U46 t_0;
    if (1) {
        return (t_0 < 0);
    }
    rfalse;
];
[ call_U47 t_0;
    if (1) {
        return ((REAL_NUMBER_TY_Compare)(t_0,NUMBER_TY_to_REAL_NUMBER_TY(0)) < 0);
    }
    rfalse;
];
[ call_U48 t_0;
    if (1) {
        return TEXT_TY_Empty(t_0);
    }
    rfalse;
];
[ call_U49 t_0;
    if (1) {
        return (TableFilledRows(t_0) == 0);
    }
    rfalse;
];
[ call_U50 t_0;
    if (1) {
        return RulebookEmpty(t_0);
    }
    rfalse;
];
[ call_U51 t_0;
    if (1) {
        return ActivityEmpty(t_0);
    }
    rfalse;
];
[ call_U52 t_0;
    if (1) {
        return LIST_OF_TY_Empty(t_0);
    }
    rfalse;
];
[ call_U53 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, (-(1)));
    }
    rfalse;
];
[ call_U54 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, 1);
    }
    rfalse;
];
[ call_U55 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, 0);
    }
    rfalse;
];
[ call_U56 t_0;
    if (1) {
        return (~~(TEXT_TY_Empty(t_0)));
    }
    rfalse;
];
[ call_U57 t_0;
    if (1) {
        return (~~((TableFilledRows(t_0) == 0)));
    }
    rfalse;
];
[ call_U58 t_0;
    if (1) {
        return (~~(RulebookEmpty(t_0)));
    }
    rfalse;
];
[ call_U59 t_0;
    if (1) {
        return (~~(ActivityEmpty(t_0)));
    }
    rfalse;
];
[ call_U60 t_0;
    if (1) {
        return (~~(LIST_OF_TY_Empty(t_0)));
    }
    rfalse;
];
[ call_U61 t_0;
    if (1) {
        return (~~(RELATION_TY_Empty(t_0, (-(1)))));
    }
    rfalse;
];
[ call_U62 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, 0);
    }
    rfalse;
];
[ call_U63 t_0;
    if (1) {
        return RELATION_TY_Empty(t_0, 1);
    }
    rfalse;
];
[ call_U64 t_0;
    if (1) {
        return TEXT_TY_IsSubstituted(t_0);
    }
    rfalse;
];
[ call_U65 t_0;
    if (1) {
        return (~~(TEXT_TY_IsSubstituted(t_0)));
    }
    rfalse;
];
[ call_U66 t_0;
    if (1) {
        return (TableBlankRows(t_0) == 0);
    }
    rfalse;
];
[ call_U67 t_0;
    if (1) {
        return (~~((TableBlankRows(t_0) == 0)));
    }
    rfalse;
];
[ call_U68 t_0;
    if (1) {
        return TestActivity(t_0);
    }
    rfalse;
];
[ call_U69 t_0;
    if (1) {
        return TestUseOption(t_0);
    }
    rfalse;
];
[ call_U70 t_0;
    if (1) {
        return (~~(TestUseOption(t_0)));
    }
    rfalse;
];
[ call_U71 t_0;
    if (1) {
        return VerbIsModal(t_0);
    }
    rfalse;
];
[ call_U72 t_0;
    if (1) {
        return (~~(VerbIsModal(t_0)));
    }
    rfalse;
];
[ call_U73 t_0;
    if (1) {
        return VerbIsMeaningful(t_0);
    }
    rfalse;
];
[ call_U74 t_0;
    if (1) {
        return (~~(VerbIsMeaningful(t_0)));
    }
    rfalse;
];
[ call_U75 t_0;
    if (1) {
        return RELATION_TY_EquivalenceAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U76 t_0;
    if (1) {
        return RELATION_TY_EquivalenceAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U77 t_0;
    if (1) {
        return RELATION_TY_EquivalenceAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U78 t_0;
    if (1) {
        return RELATION_TY_SymmetricAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U79 t_0;
    if (1) {
        return RELATION_TY_SymmetricAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U80 t_0;
    if (1) {
        return RELATION_TY_SymmetricAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U81 t_0;
    if (1) {
        return RELATION_TY_OToOAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U82 t_0;
    if (1) {
        return RELATION_TY_OToOAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U83 t_0;
    if (1) {
        return RELATION_TY_OToOAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U84 t_0;
    if (1) {
        return RELATION_TY_OToVAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U85 t_0;
    if (1) {
        return RELATION_TY_OToVAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U86 t_0;
    if (1) {
        return RELATION_TY_OToVAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U87 t_0;
    if (1) {
        return RELATION_TY_VToOAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U88 t_0;
    if (1) {
        return RELATION_TY_VToOAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U89 t_0;
    if (1) {
        return RELATION_TY_VToOAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U90 t_0;
    if (1) {
        return RELATION_TY_VToVAdjective(t_0, (-(1)));
    }
    rfalse;
];
[ call_U91 t_0;
    if (1) {
        return RELATION_TY_VToVAdjective(t_0, 1);
    }
    rfalse;
];
[ call_U92 t_0;
    if (1) {
        return RELATION_TY_VToVAdjective(t_0, 0);
    }
    rfalse;
];
[ call_U93 t_0;
    if (1) {
        return ((((REAL_NUMBER_TY_Compare)(t_0,2139095040) == 0)) || (((REAL_NUMBER_TY_Compare)(t_0,-8388608) == 0)));
    }
    rfalse;
];
[ call_U94 t_0;
    if (1) {
        return (~~(((((REAL_NUMBER_TY_Compare)(t_0,2139095040) == 0)) || (((REAL_NUMBER_TY_Compare)(t_0,-8388608) == 0)))));
    }
    rfalse;
];
[ call_U95 t_0;
    if (1) {
        return REAL_NUMBER_TY_Nan(t_0);
    }
    rfalse;
];
[ call_U96 t_0;
    if (1) {
        return (~~(REAL_NUMBER_TY_Nan(t_0)));
    }
    rfalse;
];
[ call_U97 t_0;
    if (t_0) {
        return (t_0 has pluralname);
    }
    rfalse;
];
[ call_U98 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pluralname, 1);
    }
    rfalse;
];
[ call_U99 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pluralname, 0);
    }
    rfalse;
];
[ call_U100 t_0;
    if (t_0) {
        return ((t_0 has pluralname) == 0);
    }
    rfalse;
];
[ call_U101 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pluralname, 0);
    }
    rfalse;
];
[ call_U102 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pluralname, 1);
    }
    rfalse;
];
[ call_U103 t_0;
    if (t_0) {
        return (t_0 has proper);
    }
    rfalse;
];
[ call_U104 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_proper, 1);
    }
    rfalse;
];
[ call_U105 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_proper, 0);
    }
    rfalse;
];
[ call_U106 t_0;
    if (t_0) {
        return ((t_0 has proper) == 0);
    }
    rfalse;
];
[ call_U107 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_proper, 0);
    }
    rfalse;
];
[ call_U108 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_proper, 1);
    }
    rfalse;
];
[ call_U109 t_0;
    if (t_0) {
        return (t_0 has ambigpluralname);
    }
    rfalse;
];
[ call_U110 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_ambigpluralname, 1);
    }
    rfalse;
];
[ call_U111 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_ambigpluralname, 0);
    }
    rfalse;
];
[ ADJDEFN1 t_0;
    rfalse;
];
[ ADJDEFN2 t_0;
    rfalse;
];
[ ADJDEFN3 t_0;
    rfalse;
];
[ ADJDEFN4 t_0;
    rfalse;
];
[ ADJDEFN5 t_0;
    rfalse;
];
[ ADJDEFN6 t_0;
    rfalse;
];
[ ADJDEFN7 t_0;
    rfalse;
];
[ ADJDEFN8 t_0;
    rfalse;
];
[ ADJDEFN9 t_0;
    rfalse;
];
[ ADJDEFN10 t_0;
    rfalse;
];
[ ADJDEFN11 t_0;
    rfalse;
];
[ ADJDEFN12 t_0;
    rfalse;
];
[ ADJDEFN13 t_0;
    rfalse;
];
[ ADJDEFN14 t_0;
    rfalse;
];
[ ADJDEFN15 t_0;
    rfalse;
];
[ ADJDEFN16 t_0;
    rfalse;
];
[ ADJDEFN17 t_0;
    rfalse;
];
[ ADJDEFN18 t_0;
    rfalse;
];
[ ADJDEFN19 t_0;
    rfalse;
];
[ ADJDEFN20 t_0;
    rfalse;
];
[ ADJDEFN21 t_0;
    rfalse;
];
[ ADJDEFN22 t_0;
    rfalse;
];
[ ADJDEFN23 t_0;
    rfalse;
];
[ ADJDEFN24 t_0;
    rfalse;
];
[ ADJDEFN25 t_0;
    rfalse;
];
[ call_U112 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if (debug_rules) {
        DB_Rule(INITIALISE_MEMORY_R, 0, 0);
    }
    (rv = (INITIALISE_MEMORY_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return INITIALISE_MEMORY_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(VIRTUAL_MACHINE_STARTUP_R, 0, 0);
    }
    (rv = (VIRTUAL_MACHINE_STARTUP_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return VIRTUAL_MACHINE_STARTUP_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(SEED_RANDOM_NUMBER_GENERATOR_R, 0, 0);
    }
    (rv = (SEED_RANDOM_NUMBER_GENERATOR_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SEED_RANDOM_NUMBER_GENERATOR_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(UPDATE_CHRONOLOGICAL_RECORDS_R, 0, 0);
    }
    (rv = (UPDATE_CHRONOLOGICAL_RECORDS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return UPDATE_CHRONOLOGICAL_RECORDS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U980)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U980;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(POSITION_PLAYER_IN_MODEL_R, 0, 0);
    }
    (rv = (POSITION_PLAYER_IN_MODEL_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return POSITION_PLAYER_IN_MODEL_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U982)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U982;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U983)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U983;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U984)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U984;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U985)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U985;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U986)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U986;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U113 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U991)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U991;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(RESURRECT_PLAYER_IF_ASKED_R, 0, 0);
    }
    (rv = (RESURRECT_PLAYER_IF_ASKED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return RESURRECT_PLAYER_IF_ASKED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U992)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U992;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(ASK_FINAL_QUESTION_R, 0, 0);
    }
    (rv = (ASK_FINAL_QUESTION_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ASK_FINAL_QUESTION_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U115 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(FINAL_CODE_STARTUP_R, 0, 0);
    }
    (rv = (FINAL_CODE_STARTUP_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return FINAL_CODE_STARTUP_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U117 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1014)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1014;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U118 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_NAME_PRINTING_R, 0, 0);
    }
    (rv = (STANDARD_NAME_PRINTING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_NAME_PRINTING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U121 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_PLURAL_NAME_PRINTING_R, 0, 0);
    }
    (rv = (STANDARD_PLURAL_NAME_PRINTING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_PLURAL_NAME_PRINTING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U123 sk;
    return I_english_language_U1;
];
[ E1 value;
    switch (value) {
        I_english_language_U1:
            print "English language";
            ;
        I_french_language_U1:
            print "French language";
            ;
        I_german_language_U1:
            print "German language";
            ;
        I_italian_language_U1:
            print "Italian language";
            ;
        I_spanish_language_U1:
            print "Spanish language";
            ;
        I_swedish_language_U1:
            print "Swedish language";
            ;
        default:
            print "<illegal natural language>";
            ;
    }
];
[ call_U124 x;
    return ((x%6) + 1);
];
[ call_U125 x;
    return (((x + 4)%6) + 1);
];
[ call_U126 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(6);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U127;
    rfalse;
];
[ call_U128 t_0 tmp_0;
    (tmp_0 = REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2)));
    return tmp_0;
    rfalse;
];
[ call_U129 t_0 tmp_0;
    (tmp_0 = (REAL_NUMBER_TY_Log)(REAL_NUMBER_TY_Plus(t_0, (REAL_NUMBER_TY_Root)(REAL_NUMBER_TY_Plus(REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2)), NUMBER_TY_to_REAL_NUMBER_TY(1))))));
    return tmp_0;
    rfalse;
];
[ call_U130 t_0 tmp_0;
    (tmp_0 = (REAL_NUMBER_TY_Log)(REAL_NUMBER_TY_Plus(t_0, (REAL_NUMBER_TY_Root)(REAL_NUMBER_TY_Minus(REAL_NUMBER_TY_Pow(t_0, NUMBER_TY_to_REAL_NUMBER_TY(2)), NUMBER_TY_to_REAL_NUMBER_TY(1))))));
    return tmp_0;
    rfalse;
];
[ call_U131 t_0 tmp_0;
    (tmp_0 = REAL_NUMBER_TY_Times(1056964608, REAL_NUMBER_TY_Minus((REAL_NUMBER_TY_Log)(REAL_NUMBER_TY_Plus(NUMBER_TY_to_REAL_NUMBER_TY(1), t_0)), (REAL_NUMBER_TY_Log)(REAL_NUMBER_TY_Minus(NUMBER_TY_to_REAL_NUMBER_TY(1), t_0)))));
    return tmp_0;
    rfalse;
];
[ ConjugateVerb4 fn vp t modal_to;
    switch (fn) {
        1:
            print "have";
            ;
        2:
            print "had";
            ;
        3:
            print "having";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record5;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "has";
                    } else {
                        print "have";
                    }
                    ;
                2:
                    print "had";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has had";
                    } else {
                        print "have had";
                    }
                    ;
                4:
                    print "had had";
                    ;
                5:
                    print "will have";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not have";
                    } else {
                        print "do not have";
                    }
                    ;
                2:
                    print "did not have";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not had";
                    } else {
                        print "have not had";
                    }
                    ;
                4:
                    print "had not had";
                    ;
                5:
                    print "will not have";
                    ;
            }
            ;
    }
];
[ call_U132 fn vp t modal_to;
    (t = ConjugateVerb4(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record5;
    }
];
[ ConjugateVerb8 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to";
            ;
        2:
            print "been able to";
            ;
        3:
            print "being able to";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "has been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "has not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U133 fn vp t modal_to;
    (t = ConjugateVerb8(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb2 fn vp t modal_to;
    switch (fn) {
        1:
            print "mean";
            ;
        2:
            print "meant";
            ;
        3:
            print "meaning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "means";
                    } else {
                        print "mean";
                    }
                    ;
                2:
                    print "meant";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has meant";
                    } else {
                        print "have meant";
                    }
                    ;
                4:
                    print "had meant";
                    ;
                5:
                    print "will mean";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not mean";
                    } else {
                        print "do not mean";
                    }
                    ;
                2:
                    print "did not mean";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not meant";
                    } else {
                        print "have not meant";
                    }
                    ;
                4:
                    print "had not meant";
                    ;
                5:
                    print "will not mean";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb3 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb4 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb5 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb6 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb7 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb8 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb9 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb10 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb11 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb12 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb13 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb14 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb15 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb61 fn vp t modal_to;
    switch (fn) {
        1:
            print "imply";
            ;
        2:
            print "implied";
            ;
        3:
            print "implying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record4;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "implies";
                    } else {
                        print "imply";
                    }
                    ;
                2:
                    print "implied";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has implied";
                    } else {
                        print "have implied";
                    }
                    ;
                4:
                    print "had implied";
                    ;
                5:
                    print "will imply";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not imply";
                    } else {
                        print "do not imply";
                    }
                    ;
                2:
                    print "did not imply";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not implied";
                    } else {
                        print "have not implied";
                    }
                    ;
                4:
                    print "had not implied";
                    ;
                5:
                    print "will not imply";
                    ;
            }
            ;
    }
];
[ call_U134 fn vp t modal_to;
    (t = ConjugateVerb61(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb16 fn vp t modal_to;
    switch (fn) {
        1:
            print "imply";
            ;
        2:
            print "implied";
            ;
        3:
            print "implying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "implies";
                    } else {
                        print "imply";
                    }
                    ;
                2:
                    print "implied";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has implied";
                    } else {
                        print "have implied";
                    }
                    ;
                4:
                    print "had implied";
                    ;
                5:
                    print "will imply";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not imply";
                    } else {
                        print "do not imply";
                    }
                    ;
                2:
                    print "did not imply";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not implied";
                    } else {
                        print "have not implied";
                    }
                    ;
                4:
                    print "had not implied";
                    ;
                5:
                    print "will not imply";
                    ;
            }
            ;
    }
];
[ ConjugateVerb62 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to be";
            ;
        2:
            print "been able to be";
            ;
        3:
            print "being able to be";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    print "can be";
                    ;
                2:
                    print "could be";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been able to be";
                    } else {
                        print "have been able to be";
                    }
                    ;
                4:
                    print "had been able to be";
                    ;
                5:
                    print "will be able to be";
                    ;
                6:
                    print "be";
                    ;
                7:
                    print "be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    print "cannot be";
                    ;
                2:
                    print "could not be";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been able to be";
                    } else {
                        print "have not been able to be";
                    }
                    ;
                4:
                    print "had not been able to be";
                    ;
                5:
                    print "will not be able to be";
                    ;
                6:
                    print "be";
                    ;
                7:
                    print "be";
                    ;
            }
            ;
    }
];
[ call_U135 fn vp t modal_to;
    (t = ConjugateVerb62(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb63 fn vp t modal_to;
    switch (fn) {
        1:
            print "specify";
            ;
        2:
            print "specified";
            ;
        3:
            print "specifying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "specifies";
                    } else {
                        print "specify";
                    }
                    ;
                2:
                    print "specified";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has specified";
                    } else {
                        print "have specified";
                    }
                    ;
                4:
                    print "had specified";
                    ;
                5:
                    print "will specify";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not specify";
                    } else {
                        print "do not specify";
                    }
                    ;
                2:
                    print "did not specify";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not specified";
                    } else {
                        print "have not specified";
                    }
                    ;
                4:
                    print "had not specified";
                    ;
                5:
                    print "will not specify";
                    ;
            }
            ;
    }
];
[ call_U136 fn vp t modal_to;
    (t = ConjugateVerb63(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb64 fn vp t modal_to;
    switch (fn) {
        1:
            print "relate";
            ;
        2:
            print "related";
            ;
        3:
            print "relating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record6;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "relates";
                    } else {
                        print "relate";
                    }
                    ;
                2:
                    print "related";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has related";
                    } else {
                        print "have related";
                    }
                    ;
                4:
                    print "had related";
                    ;
                5:
                    print "will relate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not relate";
                    } else {
                        print "do not relate";
                    }
                    ;
                2:
                    print "did not relate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not related";
                    } else {
                        print "have not related";
                    }
                    ;
                4:
                    print "had not related";
                    ;
                5:
                    print "will not relate";
                    ;
            }
            ;
    }
];
[ call_U137 fn vp t modal_to;
    (t = ConjugateVerb64(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb17 fn vp t modal_to;
    switch (fn) {
        1:
            print "relate";
            ;
        2:
            print "related";
            ;
        3:
            print "relating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "relates";
                    } else {
                        print "relate";
                    }
                    ;
                2:
                    print "related";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has related";
                    } else {
                        print "have related";
                    }
                    ;
                4:
                    print "had related";
                    ;
                5:
                    print "will relate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not relate";
                    } else {
                        print "do not relate";
                    }
                    ;
                2:
                    print "did not relate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not related";
                    } else {
                        print "have not related";
                    }
                    ;
                4:
                    print "had not related";
                    ;
                5:
                    print "will not relate";
                    ;
            }
            ;
    }
];
[ ConjugateVerb65 fn vp t modal_to;
    switch (fn) {
        1:
            print "substitute";
            ;
        2:
            print "substituted";
            ;
        3:
            print "substituting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "substitutes";
                    } else {
                        print "substitute";
                    }
                    ;
                2:
                    print "substituted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has substituted";
                    } else {
                        print "have substituted";
                    }
                    ;
                4:
                    print "had substituted";
                    ;
                5:
                    print "will substitute";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not substitute";
                    } else {
                        print "do not substitute";
                    }
                    ;
                2:
                    print "did not substitute";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not substituted";
                    } else {
                        print "have not substituted";
                    }
                    ;
                4:
                    print "had not substituted";
                    ;
                5:
                    print "will not substitute";
                    ;
            }
            ;
    }
];
[ call_U138 fn vp t modal_to;
    (t = ConjugateVerb65(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U139 fn vp t modal_to;
    (t = ConjugateVerb65(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " for";
];
[ ConjugateModalVerb18 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb19 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb20 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb21 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ ConjugateVerb66 fn vp t modal_to;
    switch (fn) {
        1:
            print "translate";
            ;
        2:
            print "translated";
            ;
        3:
            print "translating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "translates";
                    } else {
                        print "translate";
                    }
                    ;
                2:
                    print "translated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has translated";
                    } else {
                        print "have translated";
                    }
                    ;
                4:
                    print "had translated";
                    ;
                5:
                    print "will translate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not translate";
                    } else {
                        print "do not translate";
                    }
                    ;
                2:
                    print "did not translate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not translated";
                    } else {
                        print "have not translated";
                    }
                    ;
                4:
                    print "had not translated";
                    ;
                5:
                    print "will not translate";
                    ;
            }
            ;
    }
];
[ call_U140 fn vp t modal_to;
    (t = ConjugateVerb66(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U141 fn vp t modal_to;
    (t = ConjugateVerb66(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " into";
];
[ call_U142 fn vp t modal_to;
    (t = ConjugateVerb66(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " as";
];
[ ConjugateModalVerb22 fn vp t modal_to;
    switch (fn) {
        1:
            print "translate";
            ;
        2:
            print "translated";
            ;
        3:
            print "translating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "translates";
                    } else {
                        print "translate";
                    }
                    ;
                2:
                    print "translated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has translated";
                    } else {
                        print "have translated";
                    }
                    ;
                4:
                    print "had translated";
                    ;
                5:
                    print "will translate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not translate";
                    } else {
                        print "do not translate";
                    }
                    ;
                2:
                    print "did not translate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not translated";
                    } else {
                        print "have not translated";
                    }
                    ;
                4:
                    print "had not translated";
                    ;
                5:
                    print "will not translate";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb23 fn vp t modal_to;
    switch (fn) {
        1:
            print "translate";
            ;
        2:
            print "translated";
            ;
        3:
            print "translating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "translates";
                    } else {
                        print "translate";
                    }
                    ;
                2:
                    print "translated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has translated";
                    } else {
                        print "have translated";
                    }
                    ;
                4:
                    print "had translated";
                    ;
                5:
                    print "will translate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not translate";
                    } else {
                        print "do not translate";
                    }
                    ;
                2:
                    print "did not translate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not translated";
                    } else {
                        print "have not translated";
                    }
                    ;
                4:
                    print "had not translated";
                    ;
                5:
                    print "will not translate";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb24 fn vp t modal_to;
    switch (fn) {
        1:
            print "translate";
            ;
        2:
            print "translated";
            ;
        3:
            print "translating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "translates";
                    } else {
                        print "translate";
                    }
                    ;
                2:
                    print "translated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has translated";
                    } else {
                        print "have translated";
                    }
                    ;
                4:
                    print "had translated";
                    ;
                5:
                    print "will translate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not translate";
                    } else {
                        print "do not translate";
                    }
                    ;
                2:
                    print "did not translate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not translated";
                    } else {
                        print "have not translated";
                    }
                    ;
                4:
                    print "had not translated";
                    ;
                5:
                    print "will not translate";
                    ;
            }
            ;
    }
];
[ ConjugateVerb67 fn vp t modal_to;
    switch (fn) {
        1:
            print "provide";
            ;
        2:
            print "provided";
            ;
        3:
            print "providing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record7;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "provides";
                    } else {
                        print "provide";
                    }
                    ;
                2:
                    print "provided";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has provided";
                    } else {
                        print "have provided";
                    }
                    ;
                4:
                    print "had provided";
                    ;
                5:
                    print "will provide";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not provide";
                    } else {
                        print "do not provide";
                    }
                    ;
                2:
                    print "did not provide";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not provided";
                    } else {
                        print "have not provided";
                    }
                    ;
                4:
                    print "had not provided";
                    ;
                5:
                    print "will not provide";
                    ;
            }
            ;
    }
];
[ call_U143 fn vp t modal_to;
    (t = ConjugateVerb67(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record7;
    }
];
[ ConjugateVerb68 fn vp t modal_to;
    switch (fn) {
        1:
            print "use";
            ;
        2:
            print "used";
            ;
        3:
            print "using";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "uses";
                    } else {
                        print "use";
                    }
                    ;
                2:
                    print "used";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has used";
                    } else {
                        print "have used";
                    }
                    ;
                4:
                    print "had used";
                    ;
                5:
                    print "will use";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not use";
                    } else {
                        print "do not use";
                    }
                    ;
                2:
                    print "did not use";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not used";
                    } else {
                        print "have not used";
                    }
                    ;
                4:
                    print "had not used";
                    ;
                5:
                    print "will not use";
                    ;
            }
            ;
    }
];
[ call_U144 fn vp t modal_to;
    (t = ConjugateVerb68(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb69 fn vp t modal_to;
    switch (fn) {
        1:
            print "include";
            ;
        2:
            print "included";
            ;
        3:
            print "including";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "includes";
                    } else {
                        print "include";
                    }
                    ;
                2:
                    print "included";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has included";
                    } else {
                        print "have included";
                    }
                    ;
                4:
                    print "had included";
                    ;
                5:
                    print "will include";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not include";
                    } else {
                        print "do not include";
                    }
                    ;
                2:
                    print "did not include";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not included";
                    } else {
                        print "have not included";
                    }
                    ;
                4:
                    print "had not included";
                    ;
                5:
                    print "will not include";
                    ;
            }
            ;
    }
];
[ call_U145 fn vp t modal_to;
    (t = ConjugateVerb69(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U146 fn vp t modal_to;
    (t = ConjugateVerb69(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb70 fn vp t modal_to;
    switch (fn) {
        1:
            print "omit";
            ;
        2:
            print "omitted";
            ;
        3:
            print "omitting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "omits";
                    } else {
                        print "omit";
                    }
                    ;
                2:
                    print "omitted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has omitted";
                    } else {
                        print "have omitted";
                    }
                    ;
                4:
                    print "had omitted";
                    ;
                5:
                    print "will omit";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not omit";
                    } else {
                        print "do not omit";
                    }
                    ;
                2:
                    print "did not omit";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not omitted";
                    } else {
                        print "have not omitted";
                    }
                    ;
                4:
                    print "had not omitted";
                    ;
                5:
                    print "will not omit";
                    ;
            }
            ;
    }
];
[ call_U147 fn vp t modal_to;
    (t = ConjugateVerb70(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U148 fn vp t modal_to;
    (t = ConjugateVerb70(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb71 fn vp t modal_to;
    switch (fn) {
        1:
            print "test";
            ;
        2:
            print "tested";
            ;
        3:
            print "testing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "tests";
                    } else {
                        print "test";
                    }
                    ;
                2:
                    print "tested";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has tested";
                    } else {
                        print "have tested";
                    }
                    ;
                4:
                    print "had tested";
                    ;
                5:
                    print "will test";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not test";
                    } else {
                        print "do not test";
                    }
                    ;
                2:
                    print "did not test";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not tested";
                    } else {
                        print "have not tested";
                    }
                    ;
                4:
                    print "had not tested";
                    ;
                5:
                    print "will not test";
                    ;
            }
            ;
    }
];
[ call_U149 fn vp t modal_to;
    (t = ConjugateVerb71(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U150 fn vp t modal_to;
    (t = ConjugateVerb71(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb25 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb26 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb27 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb28 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ call_U151 sk;
    return I_present_tense_U1;
];
[ E2 value;
    switch (value) {
        I_present_tense_U1:
            print "present tense";
            ;
        I_past_tense_U1:
            print "past tense";
            ;
        I_perfect_tense_U1:
            print "perfect tense";
            ;
        I_past_perfect_tense_U1:
            print "past perfect tense";
            ;
        I_future_tense_U1:
            print "future tense";
            ;
        default:
            print "<illegal grammatical tense>";
            ;
    }
];
[ call_U152 x;
    return ((x%5) + 1);
];
[ call_U153 x;
    return (((x + 3)%5) + 1);
];
[ call_U154 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(5);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U155 sk;
    return I_first_person_singular_U1;
];
[ E3 value;
    switch (value) {
        I_first_person_singular_U1:
            print "first person singular";
            ;
        I_second_person_singular_U1:
            print "second person singular";
            ;
        I_third_person_singular_U1:
            print "third person singular";
            ;
        I_first_person_plural_U1:
            print "first person plural";
            ;
        I_second_person_plural_U1:
            print "second person plural";
            ;
        I_third_person_plural_U1:
            print "third person plural";
            ;
        default:
            print "<illegal narrative viewpoint>";
            ;
    }
];
[ call_U156 x;
    return ((x%6) + 1);
];
[ call_U157 x;
    return (((x + 4)%6) + 1);
];
[ call_U158 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(6);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U159 sk;
    return I_nominative_U1;
];
[ E4 value;
    switch (value) {
        I_nominative_U1:
            print "nominative";
            ;
        I_accusative_U1:
            print "accusative";
            ;
        default:
            print "<illegal grammatical case>";
            ;
    }
];
[ call_U160 x;
    return ((x%2) + 1);
];
[ call_U161 x;
    return ((x%2) + 1);
];
[ call_U162 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(2);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U163 sk;
    return I_neuter_gender_U1;
];
[ E5 value;
    switch (value) {
        I_neuter_gender_U1:
            print "neuter gender";
            ;
        I_masculine_gender_U1:
            print "masculine gender";
            ;
        I_feminine_gender_U1:
            print "feminine gender";
            ;
        default:
            print "<illegal grammatical gender>";
            ;
    }
];
[ call_U164 x;
    return ((x%3) + 1);
];
[ call_U165 x;
    return (((x + 1)%3) + 1);
];
[ call_U166 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(3);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ call_U167;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "I";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "you";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U327(player)) {
            (say__p = 1);
            ParaContent();
            print "he";
        } else {
            (say__p = 1);
            ParaContent();
            print "she";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "we";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "you";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "they";
    }
    rfalse;
];
[ call_U168;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "me";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "you";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U327(player)) {
            (say__p = 1);
            ParaContent();
            print "him";
        } else {
            (say__p = 1);
            ParaContent();
            print "her";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "us";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "you";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "them";
    }
    rfalse;
];
[ call_U169;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "mine";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "yours";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U327(player)) {
            (say__p = 1);
            ParaContent();
            print "his";
        } else {
            (say__p = 1);
            ParaContent();
            print "hers";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "ours";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "yours";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "theirs";
    }
    rfalse;
];
[ call_U170;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "myself";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "yourself";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U327(player)) {
            (say__p = 1);
            ParaContent();
            print "himself";
        } else {
            (say__p = 1);
            ParaContent();
            print "herself";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "ourselves";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "yourselves";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "themselves";
    }
    rfalse;
];
[ call_U171;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "my";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "your";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U327(player)) {
            (say__p = 1);
            ParaContent();
            print "his";
        } else {
            (say__p = 1);
            ParaContent();
            print "her";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "our";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "your";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "their";
    }
    rfalse;
];
[ call_U172;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "I";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "You";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U327(player)) {
            (say__p = 1);
            ParaContent();
            print "He";
        } else {
            (say__p = 1);
            ParaContent();
            print "She";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "We";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "You";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "They";
    }
    rfalse;
];
[ call_U173;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Me";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "You";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U327(player)) {
            (say__p = 1);
            ParaContent();
            print "Him";
        } else {
            (say__p = 1);
            ParaContent();
            print "Her";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Us";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "You";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Them";
    }
    rfalse;
];
[ call_U174;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Mine";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Yours";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U327(player)) {
            (say__p = 1);
            ParaContent();
            print "His";
        } else {
            (say__p = 1);
            ParaContent();
            print "Hers";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Ours";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Yours";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Theirs";
    }
    rfalse;
];
[ call_U175;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Myself";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Yourself";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U327(player)) {
            (say__p = 1);
            ParaContent();
            print "Himself";
        } else {
            (say__p = 1);
            ParaContent();
            print "Herself";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Ourselves";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Yourselves";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Themselves";
    }
    rfalse;
];
[ call_U176;
    (prior_named_noun = player);
    if ((story_viewpoint == I_first_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "My";
    }
    if ((story_viewpoint == I_second_person_singular_U1)) {
        (say__p = 1);
        ParaContent();
        print "Your";
    }
    if ((story_viewpoint == I_third_person_singular_U1)) {
        if (call_U327(player)) {
            (say__p = 1);
            ParaContent();
            print "His";
        } else {
            (say__p = 1);
            ParaContent();
            print "Her";
        }
    }
    if ((story_viewpoint == I_first_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Our";
    }
    if ((story_viewpoint == I_second_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Your";
    }
    if ((story_viewpoint == I_third_person_plural_U1)) {
        (say__p = 1);
        ParaContent();
        print "Their";
    }
    rfalse;
];
[ call_U177;
    (say__p = 1);
    ParaContent();
    call_U179(I_accusative_U1);
    rfalse;
];
[ call_U178;
    (say__p = 1);
    ParaContent();
    call_U180(I_nominative_U1);
    rfalse;
];
[ call_U179 t_0 tmp_0;
    if ((t_0 == I_nominative_U1)) {
        (tmp_0 = prior_named_noun);
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            print "those";
        } else {
            if ((tmp_0 == player)) {
                (say__p = 1);
                ParaContent();
                call_U167();
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "he";
                } else {
                    if ((((((tmp_0 ofclass K8_person)) && (call_U324(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                        (say__p = 1);
                        ParaContent();
                        print "she";
                    } else {
                        (say__p = 1);
                        ParaContent();
                        print "that";
                    }
                }
            }
        }
    } else {
        (tmp_0 = prior_named_noun);
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            print "those";
        } else {
            if ((tmp_0 == player)) {
                (say__p = 1);
                ParaContent();
                call_U167();
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "him";
                } else {
                    if ((((((tmp_0 ofclass K8_person)) && (call_U324(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                        (say__p = 1);
                        ParaContent();
                        print "her";
                    } else {
                        (say__p = 1);
                        ParaContent();
                        print "that";
                    }
                }
            }
        }
    }
    rfalse;
];
[ call_U180 t_0 tmp_0;
    if ((t_0 == I_nominative_U1)) {
        (tmp_0 = prior_named_noun);
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            print "Those";
        } else {
            if ((tmp_0 == player)) {
                (say__p = 1);
                ParaContent();
                call_U172();
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "He";
                } else {
                    if ((((((tmp_0 ofclass K8_person)) && (call_U324(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                        (say__p = 1);
                        ParaContent();
                        print "She";
                    } else {
                        (say__p = 1);
                        ParaContent();
                        print "That";
                    }
                }
            }
        }
    } else {
        (tmp_0 = prior_named_noun);
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            print "Those";
        } else {
            if ((tmp_0 == player)) {
                (say__p = 1);
                ParaContent();
                call_U172();
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "Him";
                } else {
                    if ((((((tmp_0 ofclass K8_person)) && (call_U324(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                        (say__p = 1);
                        ParaContent();
                        print "Her";
                    } else {
                        (say__p = 1);
                        ParaContent();
                        print "That";
                    }
                }
            }
        }
    }
    rfalse;
];
[ call_U181 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "they";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U167();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "he";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U324(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "she";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "it";
                }
            }
        }
    }
    rfalse;
];
[ call_U182 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "They";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U172();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "He";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U324(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "She";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "It";
                }
            }
        }
    }
    rfalse;
];
[ call_U183 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "their";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U171();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "his";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U324(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "her";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "its";
                }
            }
        }
    }
    rfalse;
];
[ call_U184 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "Their";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U176();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "His";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U324(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "Her";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "Its";
                }
            }
        }
    }
    rfalse;
];
[ call_U185 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "them";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U168();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "him";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U324(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "her";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "it";
                }
            }
        }
    }
    rfalse;
];
[ call_U186 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "Them";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U173();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "Him";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U324(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "Her";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "It";
                }
            }
        }
    }
    rfalse;
];
[ call_U187 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "theirs";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U169();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "his";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U324(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "hers";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "its";
                }
            }
        }
    }
    rfalse;
];
[ call_U188 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "Theirs";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U174();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "His";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U324(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "Hers";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "Its";
                }
            }
        }
    }
    rfalse;
];
[ call_U189 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "themselves";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U170();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "himself";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U324(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "herself";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "itself";
                }
            }
        }
    }
    rfalse;
];
[ call_U190 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "Themselves";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U175();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "Himself";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U324(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "Herself";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "Itself";
                }
            }
        }
    }
    rfalse;
];
[ call_U191 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "they";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U167();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "he";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U324(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "she";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "that";
                }
            }
        }
    }
    (say__p = 1);
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U192 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
        (say__p = 1);
        ParaContent();
        print "They";
    } else {
        if ((tmp_0 == player)) {
            (say__p = 1);
            ParaContent();
            call_U172();
        } else {
            if ((((((tmp_0 ofclass K8_person)) && (call_U327(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                (say__p = 1);
                ParaContent();
                print "He";
            } else {
                if ((((((tmp_0 ofclass K8_person)) && (call_U324(tmp_0)))) && ((~~(call_U330(tmp_0)))))) {
                    (say__p = 1);
                    ParaContent();
                    print "She";
                } else {
                    (say__p = 1);
                    ParaContent();
                    print "That";
                }
            }
        }
    }
    (say__p = 1);
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U193;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "It";
    rfalse;
];
[ call_U194;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "There";
    rfalse;
];
[ call_U195;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "it";
    rfalse;
];
[ call_U196;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "there";
    rfalse;
];
[ call_U197;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "It";
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U198;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "There";
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U199;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "it";
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U200;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(0);
    ParaContent();
    print "there";
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rfalse;
];
[ call_U201 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((tmp_0 == player)) {
        (say__p = 1);
        ParaContent();
        call_U171();
    } else {
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            DefArt(tmp_0);
            ParaContent();
            print "'";
        } else {
            (say__p = 1);
            ParaContent();
            DefArt(tmp_0);
            ParaContent();
            print "'";
            ParaContent();
            print "s";
        }
    }
    rfalse;
];
[ call_U202 tmp_0;
    (tmp_0 = prior_named_noun);
    if ((tmp_0 == player)) {
        (say__p = 1);
        ParaContent();
        call_U176();
    } else {
        if ((((prior_named_list >= 2)) || (((prior_named_noun) && ((prior_named_noun has pluralname)))))) {
            (say__p = 1);
            ParaContent();
            CDefArt(tmp_0);
            ParaContent();
            print "'";
        } else {
            (say__p = 1);
            ParaContent();
            CDefArt(tmp_0);
            ParaContent();
            print "'";
            ParaContent();
            print "s";
        }
    }
    rfalse;
];
[ ConjugateVerb2 fn vp t modal_to;
    switch (fn) {
        1:
            print "can't";
            ;
        2:
            print "can'ted";
            ;
        3:
            print "can'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "can't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "hasn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "haven't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "hadn't been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb5 fn vp t modal_to;
    switch (fn) {
        1:
            print "aren't";
            ;
        2:
            print "aren'ted";
            ;
        3:
            print "aren'ting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "aren't";
                            ;
                        2:
                            print "aren't";
                            ;
                        5:
                            print "aren't";
                            ;
                        3:
                            print "isn't";
                            ;
                        6:
                            print "aren't";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "wasn't";
                            ;
                        4:
                            print "weren't";
                            ;
                        2:
                            print "weren't";
                            ;
                        5:
                            print "weren't";
                            ;
                        3:
                            print "wasn't";
                            ;
                        6:
                            print "weren't";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "hasn't been";
                    } else {
                        print "haven't been";
                    }
                    ;
                4:
                    print "hadn't been";
                    ;
                5:
                    print "won't be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb7 fn vp t modal_to;
    switch (fn) {
        1:
            print "'re";
            ;
        2:
            print " been";
            ;
        3:
            print " being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "'m";
                            ;
                        4:
                            print "'re";
                            ;
                        2:
                            print "'re";
                            ;
                        5:
                            print "'re";
                            ;
                        3:
                            print "'s";
                            ;
                        6:
                            print "'re";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print " was";
                            ;
                        4:
                            print " were";
                            ;
                        2:
                            print " were";
                            ;
                        5:
                            print " were";
                            ;
                        3:
                            print " was";
                            ;
                        6:
                            print " were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "'s been";
                    } else {
                        print "'ve been";
                    }
                    ;
                4:
                    print "'d been";
                    ;
                5:
                    print "'ll be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "'m not";
                            ;
                        4:
                            print "'re not";
                            ;
                        2:
                            print "'re not";
                            ;
                        5:
                            print "'re not";
                            ;
                        3:
                            print "'s not";
                            ;
                        6:
                            print "'re not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print " wasn't";
                            ;
                        4:
                            print " weren't";
                            ;
                        2:
                            print " weren't";
                            ;
                        5:
                            print " weren't";
                            ;
                        3:
                            print " wasn't";
                            ;
                        6:
                            print " weren't";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "'s not been";
                    } else {
                        print "'ve not been";
                    }
                    ;
                4:
                    print "'d not been";
                    ;
                5:
                    print "'ll not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb10 fn vp t modal_to;
    switch (fn) {
        1:
            print "would";
            ;
        2:
            print "woulded";
            ;
        3:
            print "woulding";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "would";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "would not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "would not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U203 fn vp t modal_to;
    (t = ConjugateVerb10(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb15 fn vp t modal_to;
    switch (fn) {
        1:
            print "haven't";
            ;
        2:
            print "haven'ted";
            ;
        3:
            print "haven'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "hasn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb19 fn vp t modal_to;
    switch (fn) {
        1:
            print "might";
            ;
        2:
            print "mighted";
            ;
        3:
            print "mighting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "might";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "might not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "might not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U204 fn vp t modal_to;
    (t = ConjugateVerb19(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb29 fn vp t modal_to;
    switch (fn) {
        1:
            print "don't";
            ;
        2:
            print "don'ted";
            ;
        3:
            print "don'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "doesn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "don't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "didn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateModalVerb29 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to";
            ;
        2:
            print "been able to";
            ;
        3:
            print "being able to";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "can";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "has been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "have been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "had been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "will be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "cannot";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "has not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "have not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "had not been able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "will not be able to";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ ConjugateVerb72 fn vp t modal_to;
    switch (fn) {
        1:
            print "could";
            ;
        2:
            print "coulded";
            ;
        3:
            print "coulding";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "could not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "could not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U205 fn vp t modal_to;
    (t = ConjugateVerb72(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb73 fn vp t modal_to;
    switch (fn) {
        1:
            print "may";
            ;
        2:
            print "mayed";
            ;
        3:
            print "maying";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "may";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "may not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "may not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U206 fn vp t modal_to;
    (t = ConjugateVerb73(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb74 fn vp t modal_to;
    switch (fn) {
        1:
            print "must";
            ;
        2:
            print "musted";
            ;
        3:
            print "musting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "must";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "must not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "must not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U207 fn vp t modal_to;
    (t = ConjugateVerb74(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb75 fn vp t modal_to;
    switch (fn) {
        1:
            print "should";
            ;
        2:
            print "shoulded";
            ;
        3:
            print "shoulding";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "should";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "should not have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "should not";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
    }
];
[ call_U208 fn vp t modal_to;
    (t = ConjugateVerb75(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb76 fn vp t modal_to;
    switch (fn) {
        1:
            print "'ve";
            ;
        2:
            print " had";
            ;
        3:
            print " having";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "'s";
                    } else {
                        print "'ve";
                    }
                    ;
                2:
                    print " had";
                    ;
                3:
                    if ((vp == 3)) {
                        print "'s had";
                    } else {
                        print "'ve had";
                    }
                    ;
                4:
                    print "'d had";
                    ;
                5:
                    print "'ll have";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "'s not";
                    } else {
                        print "'ve not";
                    }
                    ;
                2:
                    print " hadn't";
                    ;
                3:
                    if ((vp == 3)) {
                        print "'s not had";
                    } else {
                        print "'ve not had";
                    }
                    ;
                4:
                    print "'d not had";
                    ;
                5:
                    print "'ll not have";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb30 fn vp t modal_to;
    switch (fn) {
        1:
            print "haven't";
            ;
        2:
            print "haven'ted";
            ;
        3:
            print "haven'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "hasn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "haven't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "hadn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb77 fn vp t modal_to;
    switch (fn) {
        1:
            print "mustn't";
            ;
        2:
            print "mustn'ted";
            ;
        3:
            print "mustn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mustn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mustn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb78 fn vp t modal_to;
    switch (fn) {
        1:
            print "mightn't";
            ;
        2:
            print "mightn'ted";
            ;
        3:
            print "mightn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mightn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mightn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb79 fn vp t modal_to;
    switch (fn) {
        1:
            print "mayn't";
            ;
        2:
            print "mayn'ted";
            ;
        3:
            print "mayn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "mayn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "mayn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb80 fn vp t modal_to;
    switch (fn) {
        1:
            print "wouldn't";
            ;
        2:
            print "wouldn'ted";
            ;
        3:
            print "wouldn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb81 fn vp t modal_to;
    switch (fn) {
        1:
            print "couldn't";
            ;
        2:
            print "couldn'ted";
            ;
        3:
            print "couldn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "couldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "couldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb82 fn vp t modal_to;
    switch (fn) {
        1:
            print "shouldn't";
            ;
        2:
            print "shouldn'ted";
            ;
        3:
            print "shouldn'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "shouldn't have";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "shouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ ConjugateVerb83 fn vp t modal_to;
    switch (fn) {
        1:
            print "won't";
            ;
        2:
            print "won'ted";
            ;
        3:
            print "won'ting";
            ;
        CV_MODAL:
            rtrue;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                3:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                4:
                    switch (vp) {
                        1:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        4:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        2:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        5:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        3:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                        6:
                            print "wouldn't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(2);
                            }
                            ;
                    }
                    ;
                5:
                    switch (vp) {
                        1:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        4:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        2:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        5:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        3:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                        6:
                            print "won't";
                            if (modal_to) {
                                print " ";
                                (modal_to)(1);
                            }
                            ;
                    }
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
            }
            ;
    }
];
[ call_U209 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (player == WearerOf(t_0));
    }
    rfalse;
];
[ call_U210 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (player == CarrierOf(t_0));
    }
    rfalse;
];
[ call_U211 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (player == HolderOf(t_0));
    }
    rfalse;
];
[ call_U212 t_0;
    if ((t_0 ofclass K2_thing)) {
        return TestVisibility(player, t_0);
    }
    rfalse;
];
[ call_U213 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(TestVisibility(player, t_0)));
    }
    rfalse;
];
[ call_U214 t_0;
    if ((t_0 ofclass K2_thing)) {
        return TestTouchability(player, t_0);
    }
    rfalse;
];
[ call_U215 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(TestTouchability(player, t_0)));
    }
    rfalse;
];
[ call_U216 t_0;
    if ((t_0 ofclass K2_thing)) {
        return TestConcealment(HolderOf(t_0), t_0);
    }
    rfalse;
];
[ call_U217 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(TestConcealment(HolderOf(t_0), t_0)));
    }
    rfalse;
];
[ call_U218 t_0;
    if ((t_0 ofclass K2_thing)) {
        return OnStage(t_0, (-(1)));
    }
    rfalse;
];
[ call_U219 t_0;
    if ((t_0 ofclass K2_thing)) {
        return OnStage(t_0, 1);
    }
    rfalse;
];
[ call_U220 t_0;
    if ((t_0 ofclass K2_thing)) {
        return OnStage(t_0, 0);
    }
    rfalse;
];
[ call_U221 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(OnStage(t_0, (-(1)))));
    }
    rfalse;
];
[ call_U222 t_0;
    if ((t_0 ofclass K2_thing)) {
        return OnStage(t_0, 0);
    }
    rfalse;
];
[ call_U223 t_0;
    if ((t_0 ofclass K2_thing)) {
        return OnStage(t_0, 1);
    }
    rfalse;
];
[ call_U224 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (~~(call_U218(t_0)));
    }
    rfalse;
];
[ call_U225 t_0;
    if (1) {
        return ((scene_status-->((t_0 - 1))) == 1);
    }
    rfalse;
];
[ call_U226 t_0;
    if ((t_0 ofclass K1_room)) {
        return TestAdjacency(real_location, t_0);
    }
    rfalse;
];
[ call_U227 t_0;
    if ((t_0 ofclass K2_thing)) {
        return (((~~(call_U264(t_0)))) && ((((~~(call_U288(t_0)))) && ((~~(call_U276(t_0)))))));
    }
    rfalse;
];
[ call_U228 t_0;
    if (t_0) {
        return (t_0 has privately_named);
    }
    rfalse;
];
[ call_U229 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_privately_named, 1);
    }
    rfalse;
];
[ call_U230 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_privately_named, 0);
    }
    rfalse;
];
[ call_U231 t_0;
    if (t_0) {
        return ((t_0 has privately_named) == 0);
    }
    rfalse;
];
[ call_U232 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_privately_named, 0);
    }
    rfalse;
];
[ call_U233 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_privately_named, 1);
    }
    rfalse;
];
[ call_U234 t_0;
    if (t_0) {
        return (t_0 has light);
    }
    rfalse;
];
[ call_U235 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 1);
    }
    rfalse;
];
[ call_U236 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 0);
    }
    rfalse;
];
[ call_U237 t_0;
    if (t_0) {
        return ((t_0 has light) == 0);
    }
    rfalse;
];
[ call_U238 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 0);
    }
    rfalse;
];
[ call_U239 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 1);
    }
    rfalse;
];
[ call_U240 t_0;
    if (t_0) {
        return (t_0 has visited);
    }
    rfalse;
];
[ call_U241 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_visited, 1);
    }
    rfalse;
];
[ call_U242 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_visited, 0);
    }
    rfalse;
];
[ call_U243 t_0;
    if (t_0) {
        return ((t_0 has visited) == 0);
    }
    rfalse;
];
[ call_U244 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_visited, 0);
    }
    rfalse;
];
[ call_U245 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_visited, 1);
    }
    rfalse;
];
[ call_U246 t_0;
    if (t_0) {
        return (t_0 has light);
    }
    rfalse;
];
[ call_U247 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 1);
    }
    rfalse;
];
[ call_U248 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 0);
    }
    rfalse;
];
[ call_U249 t_0;
    if (t_0) {
        return ((t_0 has light) == 0);
    }
    rfalse;
];
[ call_U250 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 0);
    }
    rfalse;
];
[ call_U251 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_light, 1);
    }
    rfalse;
];
[ call_U252 t_0;
    if (t_0) {
        return (t_0 has edible);
    }
    rfalse;
];
[ call_U253 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_edible, 1);
    }
    rfalse;
];
[ call_U254 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_edible, 0);
    }
    rfalse;
];
[ call_U255 t_0;
    if (t_0) {
        return ((t_0 has edible) == 0);
    }
    rfalse;
];
[ call_U256 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_edible, 0);
    }
    rfalse;
];
[ call_U257 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_edible, 1);
    }
    rfalse;
];
[ call_U258 t_0;
    if (t_0) {
        return (t_0 has static);
    }
    rfalse;
];
[ call_U259 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_static, 1);
    }
    rfalse;
];
[ call_U260 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_static, 0);
    }
    rfalse;
];
[ call_U261 t_0;
    if (t_0) {
        return ((t_0 has static) == 0);
    }
    rfalse;
];
[ call_U262 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_static, 0);
    }
    rfalse;
];
[ call_U263 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_static, 1);
    }
    rfalse;
];
[ call_U264 t_0;
    if (t_0) {
        return (t_0 has scenery);
    }
    rfalse;
];
[ call_U265 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_scenery, 1);
    }
    rfalse;
];
[ call_U266 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_scenery, 0);
    }
    rfalse;
];
[ call_U267 t_0;
    if (t_0) {
        return (t_0 has clothing);
    }
    rfalse;
];
[ call_U268 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_clothing, 1);
    }
    rfalse;
];
[ call_U269 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_clothing, 0);
    }
    rfalse;
];
[ call_U270 t_0;
    if (t_0) {
        return (t_0 has pushable);
    }
    rfalse;
];
[ call_U271 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pushable, 1);
    }
    rfalse;
];
[ call_U272 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_pushable, 0);
    }
    rfalse;
];
[ call_U273 t_0;
    if (t_0) {
        return (t_0 has moved);
    }
    rfalse;
];
[ call_U274 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_moved, 1);
    }
    rfalse;
];
[ call_U275 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_moved, 0);
    }
    rfalse;
];
[ call_U276 t_0;
    if (t_0) {
        return (t_0 has concealed);
    }
    rfalse;
];
[ call_U277 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_concealed, 1);
    }
    rfalse;
];
[ call_U278 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_concealed, 0);
    }
    rfalse;
];
[ call_U279 t_0;
    if (t_0) {
        return ((t_0 has concealed) == 0);
    }
    rfalse;
];
[ call_U280 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_concealed, 0);
    }
    rfalse;
];
[ call_U281 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_concealed, 1);
    }
    rfalse;
];
[ call_U282 t_0;
    if (t_0) {
        return (t_0 has workflag);
    }
    rfalse;
];
[ call_U283 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_workflag, 1);
    }
    rfalse;
];
[ call_U284 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_workflag, 0);
    }
    rfalse;
];
[ call_U285 t_0;
    if (t_0) {
        return ((t_0 has workflag) == 0);
    }
    rfalse;
];
[ call_U286 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_workflag, 0);
    }
    rfalse;
];
[ call_U287 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_workflag, 1);
    }
    rfalse;
];
[ call_U288 t_0;
    if (t_0) {
        return (t_0 has mentioned);
    }
    rfalse;
];
[ call_U289 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mentioned, 1);
    }
    rfalse;
];
[ call_U290 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mentioned, 0);
    }
    rfalse;
];
[ call_U291 t_0;
    if (t_0) {
        return ((t_0 has mentioned) == 0);
    }
    rfalse;
];
[ call_U292 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mentioned, 0);
    }
    rfalse;
];
[ call_U293 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mentioned, 1);
    }
    rfalse;
];
[ call_U294 t_0;
    if (t_0) {
        return (t_0 has enterable);
    }
    rfalse;
];
[ call_U295 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_enterable, 1);
    }
    rfalse;
];
[ call_U296 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_enterable, 0);
    }
    rfalse;
];
[ call_U297 t_0;
    if (t_0) {
        return (t_0 has transparent);
    }
    rfalse;
];
[ call_U298 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_transparent, 1);
    }
    rfalse;
];
[ call_U299 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_transparent, 0);
    }
    rfalse;
];
[ call_U300 t_0;
    if (t_0) {
        return ((t_0 has transparent) == 0);
    }
    rfalse;
];
[ call_U301 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_transparent, 0);
    }
    rfalse;
];
[ call_U302 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_transparent, 1);
    }
    rfalse;
];
[ call_U303 t_0;
    if (t_0) {
        return (t_0 has open);
    }
    rfalse;
];
[ call_U304 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_open, 1);
    }
    rfalse;
];
[ call_U305 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_open, 0);
    }
    rfalse;
];
[ call_U306 t_0;
    if (t_0) {
        return ((t_0 has open) == 0);
    }
    rfalse;
];
[ call_U307 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_open, 0);
    }
    rfalse;
];
[ call_U308 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_open, 1);
    }
    rfalse;
];
[ call_U309 t_0;
    if (t_0) {
        return (t_0 has openable);
    }
    rfalse;
];
[ call_U310 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_openable, 1);
    }
    rfalse;
];
[ call_U311 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_openable, 0);
    }
    rfalse;
];
[ call_U312 t_0;
    if (t_0) {
        return ((t_0 has openable) == 0);
    }
    rfalse;
];
[ call_U313 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_openable, 0);
    }
    rfalse;
];
[ call_U314 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_openable, 1);
    }
    rfalse;
];
[ call_U315 t_0;
    if (t_0) {
        return (t_0 has lockable);
    }
    rfalse;
];
[ call_U316 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_lockable, 1);
    }
    rfalse;
];
[ call_U317 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_lockable, 0);
    }
    rfalse;
];
[ call_U318 t_0;
    if (t_0) {
        return (t_0 has locked);
    }
    rfalse;
];
[ call_U319 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_locked, 1);
    }
    rfalse;
];
[ call_U320 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_locked, 0);
    }
    rfalse;
];
[ call_U321 t_0;
    if (t_0) {
        return ((t_0 has locked) == 0);
    }
    rfalse;
];
[ call_U322 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_locked, 0);
    }
    rfalse;
];
[ call_U323 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_locked, 1);
    }
    rfalse;
];
[ call_U324 t_0;
    if (t_0) {
        return (t_0 has female);
    }
    rfalse;
];
[ call_U325 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_female, 1);
    }
    rfalse;
];
[ call_U326 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_female, 0);
    }
    rfalse;
];
[ call_U327 t_0;
    if (t_0) {
        return ((t_0 has female) == 0);
    }
    rfalse;
];
[ call_U328 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_female, 0);
    }
    rfalse;
];
[ call_U329 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_female, 1);
    }
    rfalse;
];
[ call_U330 t_0;
    if (t_0) {
        return (t_0 has neuter);
    }
    rfalse;
];
[ call_U331 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_neuter, 1);
    }
    rfalse;
];
[ call_U332 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_neuter, 0);
    }
    rfalse;
];
[ call_U333 t_0;
    if (t_0) {
        return (t_0 has on);
    }
    rfalse;
];
[ call_U334 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_on, 1);
    }
    rfalse;
];
[ call_U335 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_on, 0);
    }
    rfalse;
];
[ call_U336 t_0;
    if (t_0) {
        return ((t_0 has on) == 0);
    }
    rfalse;
];
[ call_U337 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_on, 0);
    }
    rfalse;
];
[ call_U338 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_on, 1);
    }
    rfalse;
];
[ call_U339 t_0;
    if (1) {
        return _final_propertyvalue(SCENE_TY, t_0, A_P_recurring);
    }
    rfalse;
];
[ call_U340 t_0;
    if (1) {
        return WriteGProperty(SCENE_TY, t_0, A_P_recurring, 1);
    }
    rfalse;
];
[ call_U341 t_0;
    if (1) {
        return WriteGProperty(SCENE_TY, t_0, A_P_recurring, 0);
    }
    rfalse;
];
[ call_U342 t_0;
    if (1) {
        return (_final_propertyvalue(SCENE_TY, t_0, A_P_recurring) == 0);
    }
    rfalse;
];
[ call_U343 t_0;
    if (1) {
        return WriteGProperty(SCENE_TY, t_0, A_P_recurring, 0);
    }
    rfalse;
];
[ call_U344 t_0;
    if (1) {
        return WriteGProperty(SCENE_TY, t_0, A_P_recurring, 1);
    }
    rfalse;
];
[ ADJDEFN26 t_0;
    rfalse;
];
[ ADJDEFN27 t_0;
    rfalse;
];
[ ADJDEFN28 t_0;
    rfalse;
];
[ ADJDEFN29 t_0;
    rfalse;
];
[ ADJDEFN30 t_0;
    rfalse;
];
[ ADJDEFN31 t_0;
    rfalse;
];
[ ADJDEFN32 t_0;
    rfalse;
];
[ ADJDEFN33 t_0;
    rfalse;
];
[ ADJDEFN34 t_0;
    rfalse;
];
[ ADJDEFN35 t_0;
    rfalse;
];
[ ADJDEFN36 t_0;
    rfalse;
];
[ call_U345 ch;
    if (((scene_status-->(0)) == 1)) {
        if ((deadflag ~= 0)) {
            (ch = 1);
            if (debug_scenes) {
                print "[Scene 'Entire Game' ends]^";
            }
            if (GProperty(SCENE_TY, 1, A_P_recurring)) {
                ((scene_status-->(0)) = 0);
            } else {
                ((scene_status-->(0)) = 2);
            }
            FollowRulebook(rulebook_id_U38);
            FollowRulebook(WHEN_SCENE_ENDS_RB, 1);
            ((scene_ended-->(0)) = the_time);
            ((scene_endings-->(0)) = (((scene_endings-->(0)))|(2)));
            ((scene_latest_ending-->(0)) = 1);
            rtrue;
        }
    }
    if (((scene_status-->(0)) == 0)) {
        if ((deadflag == 0)) {
            (ch = 1);
            if (debug_scenes) {
                print "[Scene 'Entire Game' begins]^";
            }
            ((scene_status-->(0)) = 1);
            FollowRulebook(WHEN_SCENE_BEGINS_RB, 1);
            FollowRulebook(rulebook_id_U37);
            ((scene_started-->(0)) = the_time);
            ((scene_endings-->(0)) = (((scene_endings-->(0)))|(1)));
            ((scene_latest_ending-->(0)) = 0);
            rtrue;
        }
    }
    rfalse;
];
[ call_U346;
    #ifdef DEBUG;
        if (((scene_status-->(0)) == 1)) {
            print "Scene 'Entire Game' playing (for ";
            print (the_time - (scene_started-->(0)));
            print " mins now)^";
        } else {
            if (((scene_latest_ending-->(0)) > 0)) {
                print "Scene 'Entire Game' ended";
                print "^";
            }
        }
    #endif;
];
[ call_U347 X;
    if ((X ofclass K4_door)) {
        return (X.door_to);
    }
    rfalse;
];
[ call_U348 L R;
    if ((((L ofclass K1_room)) && ((R ofclass K4_door)))) {
        ((R.door_to) = L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record1);
];
[ call_U349 L R;
    if ((((L ofclass K1_room)) && ((R ofclass K4_door)))) {
        Relation_NowN1toV(R, A_door_to, L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record1);
];
[ call_U350 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == call_U347(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                    if ((call_U350)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = 0):0:) {
                    if ((call_U350)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                if ((call_U350)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = 0):0:) {
                if ((call_U350)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                    for ((Z3 = 0):0:) {
                        if ((call_U350)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K1_room_First):Z1:(Z1 = (Z1.K1_room_Next))) {
                        for ((Z3 = 0):0:) {
                            if ((call_U350)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            call_U348(X, Y);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            call_U349(X, Y);
            rtrue;
            ;
        RELS_SHOW:
            (Relation_RShowOtoO)(rr,0);
            rtrue;
            ;
        RELS_EMPTY:
            return (Relation_EmptyOtoO)(rr,0,(X == 1));
            ;
        RELS_ROUTE_FIND:
            return (OtoVRelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y);
            ;
        RELS_ROUTE_FIND_COUNT:
            return RelFollowVector((OtoVRelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y), X, Y);
            ;
    }
    rfalse;
];
[ call_U351 X;
    if ((X ofclass K2_thing)) {
        return (X.with_key);
    }
    rfalse;
];
[ call_U352 L R;
    if ((((L ofclass K2_thing)) && ((R ofclass K2_thing)))) {
        ((R.with_key) = L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record2);
];
[ call_U353 L R;
    if ((((L ofclass K2_thing)) && ((R ofclass K2_thing)))) {
        Relation_NowN1toV(R, A_with_key, L);
        rtrue;
    }
    RunTimeProblem(RTP_RELKINDVIOLATION, L, R, Rel_Record2);
];
[ call_U354 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == call_U351(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U354)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U354)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U354)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U354)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U354)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U354)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            call_U352(X, Y);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            call_U353(X, Y);
            rtrue;
            ;
        RELS_SHOW:
            (Relation_RShowOtoO)(rr,0);
            rtrue;
            ;
        RELS_EMPTY:
            return (Relation_EmptyOtoO)(rr,0,(X == 1));
            ;
        RELS_ROUTE_FIND:
            return (OtoVRelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y);
            ;
        RELS_ROUTE_FIND_COUNT:
            return RelFollowVector((OtoVRelRouteTo)(RlnGetF(rr, RR_STORAGE),X,Y), X, Y);
            ;
    }
    rfalse;
];
[ call_U355 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if (debug_rules) {
        DB_Rule(PARSE_COMMAND_R, 0, 0);
    }
    (rv = (PARSE_COMMAND_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PARSE_COMMAND_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U980)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U980;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(GENERATE_ACTION_R, 0, 0);
    }
    (rv = (GENERATE_ACTION_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return GENERATE_ACTION_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U988)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U988;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U987)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U987;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(TIMED_EVENTS_R, 0, 0);
    }
    (rv = (TIMED_EVENTS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return TIMED_EVENTS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(ADVANCE_TIME_R, 0, 0);
    }
    (rv = (ADVANCE_TIME_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ADVANCE_TIME_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(UPDATE_CHRONOLOGICAL_RECORDS_R, 0, 0);
    }
    (rv = (UPDATE_CHRONOLOGICAL_RECORDS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return UPDATE_CHRONOLOGICAL_RECORDS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U989)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U989;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(ADJUST_LIGHT_R, 0, 0);
    }
    (rv = (ADJUST_LIGHT_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ADJUST_LIGHT_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(NOTE_OBJECT_ACQUISITIONS_R, 0, 0);
    }
    (rv = (NOTE_OBJECT_ACQUISITIONS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return NOTE_OBJECT_ACQUISITIONS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U990)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U990;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U356 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SCENE_CHANGE_MACHINERY_R, 0, 0);
    }
    (rv = (SCENE_CHANGE_MACHINERY_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SCENE_CHANGE_MACHINERY_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U359 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1013)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1013;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U362 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U994)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U994;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U993)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U993;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U997)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U997;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(BASIC_VISIBILITY_R, 0, 0);
    }
    (rv = (BASIC_VISIBILITY_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return BASIC_VISIBILITY_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(BASIC_ACCESSIBILITY_R, 0, 0);
    }
    (rv = (BASIC_ACCESSIBILITY_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return BASIC_ACCESSIBILITY_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(CARRYING_REQUIREMENTS_R, 0, 0);
    }
    (rv = (CARRYING_REQUIREMENTS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return CARRYING_REQUIREMENTS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U998)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U998;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(REQUESTED_ACTIONS_REQUIRE_R, 0, 0);
    }
    (rv = (REQUESTED_ACTIONS_REQUIRE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REQUESTED_ACTIONS_REQUIRE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(CARRY_OUT_REQUESTED_ACTIONS_R, 0, 0);
    }
    (rv = (CARRY_OUT_REQUESTED_ACTIONS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return CARRY_OUT_REQUESTED_ACTIONS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    if (debug_rules) {
        DB_Rule(DESCEND_TO_SPECIFIC_ACTION_R, 0, 0);
    }
    (rv = (DESCEND_TO_SPECIFIC_ACTION_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return DESCEND_TO_SPECIFIC_ACTION_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U999)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U999;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U363 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = selfobj);
        (pos)++;
    } else {
        (pos)++;
    }
    rtrue;
];
[ call_U364 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if ((action == ##Go)) {
        (rv = (call_U1239)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1239;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Exit)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1355)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1355;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Look)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1381)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1381;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    rfalse;
];
[ call_U365 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if (debug_rules) {
        DB_Rule(WORK_OUT_DETAILS_OF_SPECIFIC_R, 0, 0);
    }
    (rv = (WORK_OUT_DETAILS_OF_SPECIFIC_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return WORK_OUT_DETAILS_OF_SPECIFIC_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1000)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1000;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1001)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1001;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1002)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1002;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1003)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1003;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1004)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1004;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1005)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1005;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1006)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1006;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U366 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
    }
    return 6;
];
[ call_U367 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1007)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1007;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1008)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1008;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1009)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1009;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1010)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1010;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U368 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(ACCESS_THROUGH_BARRIERS_R, 0, 0);
    }
    (rv = (ACCESS_THROUGH_BARRIERS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ACCESS_THROUGH_BARRIERS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U369 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(CANT_REACH_INSIDE_ROOMS_R, 0, 0);
    }
    (rv = (CANT_REACH_INSIDE_ROOMS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return CANT_REACH_INSIDE_ROOMS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(CANT_REACH_INSIDE_CLOSED_R, 0, 0);
    }
    (rv = (CANT_REACH_INSIDE_CLOSED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return CANT_REACH_INSIDE_CLOSED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U370 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(CANT_REACH_OUTSIDE_CLOSED_R, 0, 0);
    }
    (rv = (CANT_REACH_OUTSIDE_CLOSED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return CANT_REACH_OUTSIDE_CLOSED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U371 forbid_breaks rv;
    (rv = (call_U1011)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1011;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U375 forbid_breaks rv;
    if ((action == ##Eat)) {
        (rv = (call_U1941)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1941;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    rfalse;
];
[ call_U380 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    if ((action == ##Take)) {
        (rv = (call_U1012)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1012;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    if ((action == ##Disrobe)) {
        if ((original_deadflag ~= deadflag)) {
            rfalse;
        }
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
        (rv = (call_U1558)());
        if (rv) {
            if ((rv == 2)) {
                return reason_the_action_failed;
            }
            return call_U1558;
        }
        ((latest_rule_result-->(0)) = 0);
    } else {
        if (say__p) {
            RulebookParBreak(forbid_breaks);
        }
    }
    rfalse;
];
[ call_U385 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_RESPONSE_ISSUING_R, 0, 0);
    }
    (rv = (STANDARD_RESPONSE_ISSUING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_RESPONSE_ISSUING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U388 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1015)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1015;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U397 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_CONTENTS_LISTING_R, 0, 0);
    }
    (rv = (STANDARD_CONTENTS_LISTING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_CONTENTS_LISTING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U418 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1016)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1016;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U439 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1021)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1021;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1017)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1017;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1019)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1019;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1018)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1018;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1020)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1020;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U451 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1022)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1022;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1023)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1023;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1024)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1024;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1302)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1302;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U457 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(STANDARD_IMPLICIT_TAKING_R, 0, 0);
    }
    (rv = (STANDARD_IMPLICIT_TAKING_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return STANDARD_IMPLICIT_TAKING_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U463 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(PRINT_OBITUARY_HEADLINE_R, 0, 0);
    }
    (rv = (PRINT_OBITUARY_HEADLINE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PRINT_OBITUARY_HEADLINE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(PRINT_FINAL_SCORE_R, 0, 0);
    }
    (rv = (PRINT_FINAL_SCORE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PRINT_FINAL_SCORE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(DISPLAY_FINAL_STATUS_LINE_R, 0, 0);
    }
    (rv = (DISPLAY_FINAL_STATUS_LINE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return DISPLAY_FINAL_STATUS_LINE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U465 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1030)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1030;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1027)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1027;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    if (debug_rules) {
        DB_Rule(READ_FINAL_ANSWER_R, 0, 0);
    }
    (rv = (READ_FINAL_ANSWER_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return READ_FINAL_ANSWER_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U466 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1035)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1035;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U468 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1038)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1038;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1039)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1039;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U469 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1040)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1040;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1041)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1041;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U472 forbid_breaks rv p;
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1059)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1059;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U475 forbid_breaks rv original_deadflag p;
    (original_deadflag = deadflag);
    (p = parameter_value);
    (parameter_value = p);
    (rv = (call_U1070)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1070;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1060)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1060;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1061)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1061;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1062)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1062;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1063)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1063;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1064)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1064;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1065)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1065;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1072)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1072;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (parameter_value = p);
    (rv = (call_U1077)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1077;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U478 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1082)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1082;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1085)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1085;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U479 forbid_breaks rv;
    (rv = (call_U1088)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1088;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ InvSub;
    return GenericVerbSub(rulebook_id_U132, rulebook_id_U133, rulebook_id_U134);
];
[ InvDbg n s for_say;
    print "taking inventory";
];
[ call_U480 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1091)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1091;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1094)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1094;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1097)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1097;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1100)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1100;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1103)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1103;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1106)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1106;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1109)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1109;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1112)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1112;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1115)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1115;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1118)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1118;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1121)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1121;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1127)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1127;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U481 forbid_breaks rv;
    (rv = (call_U1131)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1131;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U482 forbid_breaks rv;
    (rv = (call_U1132)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1132;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TakeSub;
    return GenericVerbSub(rulebook_id_U135, rulebook_id_U136, rulebook_id_U137);
];
[ TakeDbg n s for_say;
    print "taking";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U483 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1097)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1097;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1137)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1137;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1140)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1140;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1143)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1143;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ RemoveSub;
    return GenericVerbSub(rulebook_id_U138, rulebook_id_U139, rulebook_id_U140);
];
[ RemoveDbg n s for_say;
    print "removing";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "from";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U486 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1147)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1147;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1144)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1144;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1150)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1150;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1153)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1153;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1156)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1156;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1159)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1159;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U487 forbid_breaks rv;
    (rv = (call_U1166)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1166;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U488 forbid_breaks rv;
    (rv = (call_U1167)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1167;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ DropSub;
    return GenericVerbSub(rulebook_id_U141, rulebook_id_U142, rulebook_id_U143);
];
[ DropDbg n s for_say;
    print "dropping";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U489 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1172)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1172;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1173)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1173;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1174)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1174;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1177)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1177;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1180)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1180;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1183)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1183;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U490 forbid_breaks rv;
    (rv = (call_U1187)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1187;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U491 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1188)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1188;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1191)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1191;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ PutOnSub;
    return GenericVerbSub(rulebook_id_U144, rulebook_id_U145, rulebook_id_U146);
];
[ PutOnDbg n s for_say;
    print "putting";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "on";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U492 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1194)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1194;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1195)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1195;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1198)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1198;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1201)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1201;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1202)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1202;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1205)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1205;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1208)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1208;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1211)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1211;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U493 forbid_breaks rv;
    (rv = (call_U1215)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1215;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U494 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1216)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1216;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1219)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1219;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ InsertSub;
    return GenericVerbSub(rulebook_id_U147, rulebook_id_U148, rulebook_id_U149);
];
[ InsertDbg n s for_say;
    print "inserting";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "into";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U495 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1222)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1222;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1225)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1225;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1228)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1228;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1232)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1232;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U496 forbid_breaks rv;
    (rv = (call_U1233)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1233;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U497 forbid_breaks rv;
    (rv = (call_U1234)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1234;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ EatSub;
    return GenericVerbSub(rulebook_id_U150, rulebook_id_U151, rulebook_id_U152);
];
[ EatDbg n s for_say;
    print "eating";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U498 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1240)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1240;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1243)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1243;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1248)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1248;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1251)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1251;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1254)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1254;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1255)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1255;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U499 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1260)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1260;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1261)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1261;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1262)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1262;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U500 forbid_breaks rv;
    (rv = (call_U1263)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1263;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U501 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = I_kitchen_U1);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
    }
    return 5;
];
[ GoSub;
    return GenericVerbSub(rulebook_id_U153, rulebook_id_U154, rulebook_id_U155);
];
[ GoDbg n s for_say;
    print "going";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U502 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1304)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1304;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1305)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1305;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1306)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1306;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1311)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1311;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1320)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1320;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1323)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1323;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1330)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1330;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1333)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1333;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U503 forbid_breaks rv;
    (rv = (call_U1344)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1344;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U504 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1345)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1345;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1354)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1354;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ EnterSub;
    return GenericVerbSub(rulebook_id_U156, rulebook_id_U157, rulebook_id_U158);
];
[ EnterDbg n s for_say;
    print "entering";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U505 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1356)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1356;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1357)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1357;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1360)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1360;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1363)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1363;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U506 forbid_breaks rv;
    (rv = (call_U1364)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1364;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U507 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1365)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1365;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1372)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1372;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U508 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
    }
    rtrue;
];
[ ExitSub;
    return GenericVerbSub(rulebook_id_U159, rulebook_id_U160, rulebook_id_U161);
];
[ ExitDbg n s for_say;
    print "exiting";
];
[ call_U509 forbid_breaks rv;
    (rv = (call_U1373)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1373;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U510 forbid_breaks rv;
    (rv = (call_U1376)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1376;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U511 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1377)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1377;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1380)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1380;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ GetOffSub;
    return GenericVerbSub(rulebook_id_U162, rulebook_id_U163, rulebook_id_U164);
];
[ GetOffDbg n s for_say;
    print "getting off";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U513 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1382)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1382;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1384)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1384;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1391)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1391;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1394)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1394;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1395)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1395;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U514 forbid_breaks rv;
    (rv = (call_U1396)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1396;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U515 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = ##Wait);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
        (pos)++;
        (pos)++;
        (pos)++;
    }
    return 4;
];
[ LookSub;
    return GenericVerbSub(rulebook_id_U165, rulebook_id_U166, rulebook_id_U167);
];
[ LookDbg n s for_say;
    print "looking";
];
[ call_U517 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1399)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1399;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1400)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1400;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1403)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1403;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1410)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1410;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1415)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1415;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1418)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1418;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U518 forbid_breaks rv;
    (rv = (call_U1421)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1421;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U519 pos state;
    if ((state == 1)) {
        ((MStack-->(pos)) = 0);
        (pos)++;
    } else {
        (pos)++;
    }
    rtrue;
];
[ ExamineSub;
    return GenericVerbSub(rulebook_id_U168, rulebook_id_U169, rulebook_id_U170);
];
[ ExamineDbg n s for_say;
    print "examining";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U521 forbid_breaks rv;
    (rv = (call_U1424)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1424;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U522 forbid_breaks rv;
    (rv = (call_U1427)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1427;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ LookUnderSub;
    return GenericVerbSub(rulebook_id_U171, rulebook_id_U172, rulebook_id_U173);
];
[ LookUnderDbg n s for_say;
    print "looking under";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U523 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1430)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1430;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1433)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1433;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U525 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1436)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1436;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1442)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1442;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1448)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1448;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SearchSub;
    return GenericVerbSub(rulebook_id_U174, rulebook_id_U175, rulebook_id_U176);
];
[ SearchDbg n s for_say;
    print "searching";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U528 forbid_breaks rv;
    (rv = (call_U1451)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1451;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ConsultSub;
    return GenericVerbSub(rulebook_id_U177, rulebook_id_U178, rulebook_id_U179);
];
[ ConsultDbg n s for_say;
    print "consulting";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "about";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Topic)(((100*consult_from) + consult_words));
    }
];
[ call_U529 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1456)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1456;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1459)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1459;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1462)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1462;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1465)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1465;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U530 forbid_breaks rv;
    (rv = (call_U1468)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1468;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U531 forbid_breaks rv;
    (rv = (call_U1469)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1469;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ LockSub;
    return GenericVerbSub(rulebook_id_U180, rulebook_id_U181, rulebook_id_U182);
];
[ LockDbg n s for_say;
    print "locking";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "with";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U532 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1474)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1474;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1477)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1477;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1480)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1480;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U533 forbid_breaks rv;
    (rv = (call_U1483)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1483;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U534 forbid_breaks rv;
    (rv = (call_U1484)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1484;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ UnlockSub;
    return GenericVerbSub(rulebook_id_U183, rulebook_id_U184, rulebook_id_U185);
];
[ UnlockDbg n s for_say;
    print "unlocking";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "with";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U535 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1489)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1489;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1492)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1492;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U536 forbid_breaks rv;
    (rv = (call_U1495)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1495;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U537 forbid_breaks rv;
    (rv = (call_U1496)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1496;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SwitchOnSub;
    return GenericVerbSub(rulebook_id_U186, rulebook_id_U187, rulebook_id_U188);
];
[ SwitchOnDbg n s for_say;
    print "switching on";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U538 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1499)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1499;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1502)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1502;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U539 forbid_breaks rv;
    (rv = (call_U1505)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1505;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U540 forbid_breaks rv;
    (rv = (call_U1506)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1506;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SwitchOffSub;
    return GenericVerbSub(rulebook_id_U189, rulebook_id_U190, rulebook_id_U191);
];
[ SwitchOffDbg n s for_say;
    print "switching off";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U541 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1509)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1509;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1512)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1512;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1515)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1515;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U542 forbid_breaks rv;
    (rv = (call_U1518)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1518;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U543 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1519)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1519;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1522)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1522;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ OpenSub;
    return GenericVerbSub(rulebook_id_U192, rulebook_id_U193, rulebook_id_U194);
];
[ OpenDbg n s for_say;
    print "opening";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U544 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1529)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1529;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1532)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1532;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U545 forbid_breaks rv;
    (rv = (call_U1535)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1535;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U546 forbid_breaks rv;
    (rv = (call_U1536)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1536;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ CloseSub;
    return GenericVerbSub(rulebook_id_U195, rulebook_id_U196, rulebook_id_U197);
];
[ CloseDbg n s for_say;
    print "closing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U547 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1543)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1543;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1546)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1546;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1549)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1549;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U548 forbid_breaks rv;
    (rv = (call_U1552)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1552;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U549 forbid_breaks rv;
    (rv = (call_U1553)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1553;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WearSub;
    return GenericVerbSub(rulebook_id_U198, rulebook_id_U199, rulebook_id_U200);
];
[ WearDbg n s for_say;
    print "wearing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U550 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1559)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1559;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1562)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1562;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U551 forbid_breaks rv;
    (rv = (call_U1566)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1566;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U552 forbid_breaks rv;
    (rv = (call_U1567)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1567;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ DisrobeSub;
    return GenericVerbSub(rulebook_id_U201, rulebook_id_U202, rulebook_id_U203);
];
[ DisrobeDbg n s for_say;
    print "taking off";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U553 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1572)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1572;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1575)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1575;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1578)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1578;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1581)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1581;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1584)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1584;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1587)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1587;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U554 forbid_breaks rv;
    (rv = (call_U1591)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1591;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U555 forbid_breaks rv;
    (rv = (call_U1592)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1592;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ GiveSub;
    return GenericVerbSub(rulebook_id_U204, rulebook_id_U205, rulebook_id_U206);
];
[ GiveDbg n s for_say;
    print "giving";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U556 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1599)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1599;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1602)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1602;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1603)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1603;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ShowSub;
    return GenericVerbSub(rulebook_id_U207, rulebook_id_U208, rulebook_id_U209);
];
[ ShowDbg n s for_say;
    print "showing";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U559 forbid_breaks rv;
    (rv = (call_U1606)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1606;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WakeOtherSub;
    return GenericVerbSub(rulebook_id_U210, rulebook_id_U211, rulebook_id_U212);
];
[ WakeOtherDbg n s for_say;
    print "waking";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U562 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1609)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1609;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1612)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1612;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1615)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1615;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ThrowAtSub;
    return GenericVerbSub(rulebook_id_U213, rulebook_id_U214, rulebook_id_U215);
];
[ ThrowAtDbg n s for_say;
    print "throwing";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "at";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U565 forbid_breaks rv;
    (rv = (call_U1618)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1618;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ AttackSub;
    return GenericVerbSub(rulebook_id_U216, rulebook_id_U217, rulebook_id_U218);
];
[ AttackDbg n s for_say;
    print "attacking";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U568 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1621)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1621;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1624)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1624;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ KissSub;
    return GenericVerbSub(rulebook_id_U219, rulebook_id_U220, rulebook_id_U221);
];
[ KissDbg n s for_say;
    print "kissing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U573 forbid_breaks rv;
    (rv = (call_U1627)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1627;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ AnswerSub;
    return GenericVerbSub(rulebook_id_U222, rulebook_id_U223, rulebook_id_U224);
];
[ AnswerDbg n s for_say;
    print "answering";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "that";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Topic)(((100*consult_from) + consult_words));
    }
];
[ call_U574 forbid_breaks rv;
    (rv = (call_U1630)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1630;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U576 forbid_breaks rv;
    (rv = (call_U1633)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1633;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TellSub;
    return GenericVerbSub(rulebook_id_U225, rulebook_id_U226, rulebook_id_U227);
];
[ TellDbg n s for_say;
    print "telling";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "about";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Topic)(((100*consult_from) + consult_words));
    }
];
[ call_U579 forbid_breaks rv;
    (rv = (call_U1636)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1636;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ AskSub;
    return GenericVerbSub(rulebook_id_U228, rulebook_id_U229, rulebook_id_U230);
];
[ AskDbg n s for_say;
    print "asking";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "about";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Topic)(((100*consult_from) + consult_words));
    }
];
[ call_U580 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1639)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1639;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1640)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1640;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ AskForSub;
    return GenericVerbSub(rulebook_id_U231, rulebook_id_U232, rulebook_id_U233);
];
[ AskForDbg n s for_say;
    print "asking";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "for";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U585 forbid_breaks rv;
    (rv = (call_U1641)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1641;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WaitSub;
    return GenericVerbSub(rulebook_id_U234, rulebook_id_U235, rulebook_id_U236);
];
[ WaitDbg n s for_say;
    print "waiting";
];
[ call_U588 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1646)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1646;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1651)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1651;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1658)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1658;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TouchSub;
    return GenericVerbSub(rulebook_id_U237, rulebook_id_U238, rulebook_id_U239);
];
[ TouchDbg n s for_say;
    print "touching";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U589 forbid_breaks rv;
    (rv = (call_U1663)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1663;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U591 forbid_breaks rv;
    (rv = (call_U1666)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1666;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WaveSub;
    return GenericVerbSub(rulebook_id_U240, rulebook_id_U241, rulebook_id_U242);
];
[ WaveDbg n s for_say;
    print "waving";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U592 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1671)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1671;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1674)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1674;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1677)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1677;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U594 forbid_breaks rv;
    (rv = (call_U1680)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1680;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ PullSub;
    return GenericVerbSub(rulebook_id_U243, rulebook_id_U244, rulebook_id_U245);
];
[ PullDbg n s for_say;
    print "pulling";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U595 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1685)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1685;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1688)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1688;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1691)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1691;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U597 forbid_breaks rv;
    (rv = (call_U1694)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1694;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ PushSub;
    return GenericVerbSub(rulebook_id_U246, rulebook_id_U247, rulebook_id_U248);
];
[ PushDbg n s for_say;
    print "pushing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U598 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1699)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1699;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1702)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1702;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1705)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1705;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U600 forbid_breaks rv;
    (rv = (call_U1708)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1708;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TurnSub;
    return GenericVerbSub(rulebook_id_U249, rulebook_id_U250, rulebook_id_U251);
];
[ TurnDbg n s for_say;
    print "turning";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U601 forbid_breaks rv original_deadflag;
    (original_deadflag = deadflag);
    (rv = (call_U1713)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1713;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1716)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1716;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1719)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1719;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1722)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1722;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1725)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1725;
    }
    ((latest_rule_result-->(0)) = 0);
    if ((original_deadflag ~= deadflag)) {
        rfalse;
    }
    if (say__p) {
        RulebookParBreak(forbid_breaks);
    }
    (rv = (call_U1726)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1726;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ PushDirSub;
    return GenericVerbSub(rulebook_id_U252, rulebook_id_U253, rulebook_id_U254);
];
[ PushDirDbg n s for_say;
    print "pushing";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U604 forbid_breaks rv;
    (rv = (call_U1729)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1729;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U606 forbid_breaks rv;
    (rv = (call_U1732)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1732;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SqueezeSub;
    return GenericVerbSub(rulebook_id_U255, rulebook_id_U256, rulebook_id_U257);
];
[ SqueezeDbg n s for_say;
    print "squeezing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U607 forbid_breaks rv;
    (rv = (call_U1737)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1737;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ YesSub;
    return GenericVerbSub(rulebook_id_U258, rulebook_id_U259, rulebook_id_U260);
];
[ YesDbg n s for_say;
    print "saying yes";
];
[ call_U610 forbid_breaks rv;
    (rv = (call_U1740)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1740;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ NoSub;
    return GenericVerbSub(rulebook_id_U261, rulebook_id_U262, rulebook_id_U263);
];
[ NoDbg n s for_say;
    print "saying no";
];
[ call_U613 forbid_breaks rv;
    (rv = (call_U1743)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1743;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ BurnSub;
    return GenericVerbSub(rulebook_id_U264, rulebook_id_U265, rulebook_id_U266);
];
[ BurnDbg n s for_say;
    print "burning";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U616 forbid_breaks rv;
    (rv = (call_U1746)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1746;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WakeSub;
    return GenericVerbSub(rulebook_id_U267, rulebook_id_U268, rulebook_id_U269);
];
[ WakeDbg n s for_say;
    print "waking up";
];
[ call_U619 forbid_breaks rv;
    (rv = (call_U1749)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1749;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ThinkSub;
    return GenericVerbSub(rulebook_id_U270, rulebook_id_U271, rulebook_id_U272);
];
[ ThinkDbg n s for_say;
    print "thinking";
];
[ call_U624 forbid_breaks rv;
    (rv = (call_U1752)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1752;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SmellSub;
    return GenericVerbSub(rulebook_id_U273, rulebook_id_U274, rulebook_id_U275);
];
[ SmellDbg n s for_say;
    print "smelling";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U627 forbid_breaks rv;
    (rv = (call_U1757)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1757;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ListenSub;
    return GenericVerbSub(rulebook_id_U276, rulebook_id_U277, rulebook_id_U278);
];
[ ListenDbg n s for_say;
    print "listening to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U630 forbid_breaks rv;
    (rv = (call_U1762)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1762;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TasteSub;
    return GenericVerbSub(rulebook_id_U279, rulebook_id_U280, rulebook_id_U281);
];
[ TasteDbg n s for_say;
    print "tasting";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U631 forbid_breaks rv;
    (rv = (call_U1767)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1767;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ CutSub;
    return GenericVerbSub(rulebook_id_U282, rulebook_id_U283, rulebook_id_U284);
];
[ CutDbg n s for_say;
    print "cutting";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U636 forbid_breaks rv;
    (rv = (call_U1770)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1770;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ JumpSub;
    return GenericVerbSub(rulebook_id_U285, rulebook_id_U286, rulebook_id_U287);
];
[ JumpDbg n s for_say;
    print "jumping";
];
[ call_U637 forbid_breaks rv;
    (rv = (call_U1775)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1775;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ TieSub;
    return GenericVerbSub(rulebook_id_U288, rulebook_id_U289, rulebook_id_U290);
];
[ TieDbg n s for_say;
    print "tying";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(s);
    }
];
[ call_U640 forbid_breaks rv;
    (rv = (call_U1778)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1778;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ DrinkSub;
    return GenericVerbSub(rulebook_id_U291, rulebook_id_U292, rulebook_id_U293);
];
[ DrinkDbg n s for_say;
    print "drinking";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U643 forbid_breaks rv;
    (rv = (call_U1781)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1781;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SorrySub;
    return GenericVerbSub(rulebook_id_U294, rulebook_id_U295, rulebook_id_U296);
];
[ SorryDbg n s for_say;
    print "saying sorry";
];
[ call_U646 forbid_breaks rv;
    (rv = (call_U1784)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1784;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SwingSub;
    return GenericVerbSub(rulebook_id_U297, rulebook_id_U298, rulebook_id_U299);
];
[ SwingDbg n s for_say;
    print "swinging";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U649 forbid_breaks rv;
    (rv = (call_U1787)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1787;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U651 forbid_breaks rv;
    (rv = (call_U1790)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1790;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ RubSub;
    return GenericVerbSub(rulebook_id_U300, rulebook_id_U301, rulebook_id_U302);
];
[ RubDbg n s for_say;
    print "rubbing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U652 forbid_breaks rv;
    (rv = (call_U1795)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1795;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SetToSub;
    return GenericVerbSub(rulebook_id_U303, rulebook_id_U304, rulebook_id_U305);
];
[ SetToDbg n s for_say;
    print "setting";
    print " ";
    if ((for_say == 2)) {
        print "it";
    } else {
        (DA_Name)(n);
    }
    print " ";
    print "to";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Topic)(((100*consult_from) + consult_words));
    }
];
[ call_U657 forbid_breaks rv;
    (rv = (call_U1798)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1798;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ WaveHandsSub;
    return GenericVerbSub(rulebook_id_U306, rulebook_id_U307, rulebook_id_U308);
];
[ WaveHandsDbg n s for_say;
    print "waving hands";
];
[ call_U658 forbid_breaks rv;
    (rv = (call_U1803)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1803;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ BuySub;
    return GenericVerbSub(rulebook_id_U309, rulebook_id_U310, rulebook_id_U311);
];
[ BuyDbg n s for_say;
    print "buying";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U661 forbid_breaks rv;
    (rv = (call_U1806)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1806;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ClimbSub;
    return GenericVerbSub(rulebook_id_U312, rulebook_id_U313, rulebook_id_U314);
];
[ ClimbDbg n s for_say;
    print "climbing";
    if ((for_say ~= 2)) {
        print " ";
        (DA_Name)(n);
    }
];
[ call_U664 forbid_breaks rv;
    (rv = (call_U1809)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return call_U1809;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SleepSub;
    return GenericVerbSub(rulebook_id_U315, rulebook_id_U316, rulebook_id_U317);
];
[ SleepDbg n s for_say;
    print "sleeping";
];
[ call_U668 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(QUIT_THE_GAME_R, 0, 0);
    }
    (rv = (QUIT_THE_GAME_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return QUIT_THE_GAME_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ QuitSub;
    return GenericVerbSub(rulebook_id_U318, rulebook_id_U319, rulebook_id_U320);
];
[ QuitDbg n s for_say;
    print "quitting the game";
];
[ call_U671 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SAVE_THE_GAME_R, 0, 0);
    }
    (rv = (SAVE_THE_GAME_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SAVE_THE_GAME_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ SaveSub;
    return GenericVerbSub(rulebook_id_U321, rulebook_id_U322, rulebook_id_U323);
];
[ SaveDbg n s for_say;
    print "saving the game";
];
[ call_U674 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(RESTORE_THE_GAME_R, 0, 0);
    }
    (rv = (RESTORE_THE_GAME_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return RESTORE_THE_GAME_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ RestoreSub;
    return GenericVerbSub(rulebook_id_U324, rulebook_id_U325, rulebook_id_U326);
];
[ RestoreDbg n s for_say;
    print "restoring the game";
];
[ call_U677 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(RESTART_THE_GAME_R, 0, 0);
    }
    (rv = (RESTART_THE_GAME_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return RESTART_THE_GAME_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ RestartSub;
    return GenericVerbSub(rulebook_id_U327, rulebook_id_U328, rulebook_id_U329);
];
[ RestartDbg n s for_say;
    print "restarting the game";
];
[ call_U680 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(VERIFY_THE_STORY_FILE_R, 0, 0);
    }
    (rv = (VERIFY_THE_STORY_FILE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return VERIFY_THE_STORY_FILE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ VerifySub;
    return GenericVerbSub(rulebook_id_U330, rulebook_id_U331, rulebook_id_U332);
];
[ VerifyDbg n s for_say;
    print "verifying the story file";
];
[ call_U683 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SWITCH_TRANSCRIPT_ON_R, 0, 0);
    }
    (rv = (SWITCH_TRANSCRIPT_ON_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SWITCH_TRANSCRIPT_ON_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ScriptOnSub;
    return GenericVerbSub(rulebook_id_U333, rulebook_id_U334, rulebook_id_U335);
];
[ ScriptOnDbg n s for_say;
    print "switching the story transcript on";
];
[ call_U686 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SWITCH_TRANSCRIPT_OFF_R, 0, 0);
    }
    (rv = (SWITCH_TRANSCRIPT_OFF_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SWITCH_TRANSCRIPT_OFF_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ScriptOffSub;
    return GenericVerbSub(rulebook_id_U336, rulebook_id_U337, rulebook_id_U338);
];
[ ScriptOffDbg n s for_say;
    print "switching the story transcript off";
];
[ call_U689 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(ANNOUNCE_STORY_FILE_VERSION_R, 0, 0);
    }
    (rv = (ANNOUNCE_STORY_FILE_VERSION_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ANNOUNCE_STORY_FILE_VERSION_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ VersionSub;
    return GenericVerbSub(rulebook_id_U339, rulebook_id_U340, rulebook_id_U341);
];
[ VersionDbg n s for_say;
    print "requesting the story file version";
];
[ call_U692 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(ANNOUNCE_SCORE_R, 0, 0);
    }
    (rv = (ANNOUNCE_SCORE_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ANNOUNCE_SCORE_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ ScoreSub;
    return GenericVerbSub(rulebook_id_U342, rulebook_id_U343, rulebook_id_U344);
];
[ ScoreDbg n s for_say;
    print "requesting the score";
];
[ call_U695 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(PREFER_ABBREVIATED_R, 0, 0);
    }
    (rv = (PREFER_ABBREVIATED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PREFER_ABBREVIATED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U696 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(REP_PREFER_ABBREVIATED_R, 0, 0);
    }
    (rv = (REP_PREFER_ABBREVIATED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REP_PREFER_ABBREVIATED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ LMode3Sub;
    return GenericVerbSub(rulebook_id_U345, rulebook_id_U346, rulebook_id_U347);
];
[ LMode3Dbg n s for_say;
    print "preferring abbreviated room descriptions";
];
[ call_U698 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(PREFER_UNABBREVIATED_R, 0, 0);
    }
    (rv = (PREFER_UNABBREVIATED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PREFER_UNABBREVIATED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U699 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(REP_PREFER_UNABBREVIATED_R, 0, 0);
    }
    (rv = (REP_PREFER_UNABBREVIATED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REP_PREFER_UNABBREVIATED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ LMode2Sub;
    return GenericVerbSub(rulebook_id_U348, rulebook_id_U349, rulebook_id_U350);
];
[ LMode2Dbg n s for_say;
    print "preferring unabbreviated room descriptions";
];
[ call_U701 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(PREFER_SOMETIMES_ABBREVIATED_R, 0, 0);
    }
    (rv = (PREFER_SOMETIMES_ABBREVIATED_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return PREFER_SOMETIMES_ABBREVIATED_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U702 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(REP_PREFER_SOMETIMES_ABBR_R, 0, 0);
    }
    (rv = (REP_PREFER_SOMETIMES_ABBR_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REP_PREFER_SOMETIMES_ABBR_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ LMode1Sub;
    return GenericVerbSub(rulebook_id_U351, rulebook_id_U352, rulebook_id_U353);
];
[ LMode1Dbg n s for_say;
    print "preferring sometimes abbreviated room descriptions";
];
[ call_U704 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SWITCH_SCORE_NOTIFY_ON_R, 0, 0);
    }
    (rv = (SWITCH_SCORE_NOTIFY_ON_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SWITCH_SCORE_NOTIFY_ON_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U705 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(REP_SWITCH_NOTIFY_ON_R, 0, 0);
    }
    (rv = (REP_SWITCH_NOTIFY_ON_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REP_SWITCH_NOTIFY_ON_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ NotifyOnSub;
    return GenericVerbSub(rulebook_id_U354, rulebook_id_U355, rulebook_id_U356);
];
[ NotifyOnDbg n s for_say;
    print "switching score notification on";
];
[ call_U707 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(SWITCH_SCORE_NOTIFY_OFF_R, 0, 0);
    }
    (rv = (SWITCH_SCORE_NOTIFY_OFF_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return SWITCH_SCORE_NOTIFY_OFF_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ call_U708 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(REP_SWITCH_NOTIFY_OFF_R, 0, 0);
    }
    (rv = (REP_SWITCH_NOTIFY_OFF_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return REP_SWITCH_NOTIFY_OFF_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ NotifyOffSub;
    return GenericVerbSub(rulebook_id_U357, rulebook_id_U358, rulebook_id_U359);
];
[ NotifyOffDbg n s for_say;
    print "switching score notification off";
];
[ call_U710 forbid_breaks rv;
    if (debug_rules) {
        DB_Rule(ANNOUNCE_PRONOUN_MEANINGS_R, 0, 0);
    }
    (rv = (ANNOUNCE_PRONOUN_MEANINGS_R)());
    if (rv) {
        if ((rv == 2)) {
            return reason_the_action_failed;
        }
        return ANNOUNCE_PRONOUN_MEANINGS_R;
    }
    ((latest_rule_result-->(0)) = 0);
    rfalse;
];
[ PronounsSub;
    return GenericVerbSub(rulebook_id_U360, rulebook_id_U361, rulebook_id_U362);
];
[ PronounsDbg n s for_say;
    print "requesting the pronoun meanings";
];
[ call_U712;
    ResponseViaActivity(response_id_U1);
];
[ call_U713;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[It] [are] [if story tense is present tense]now [end if]pitch dark in^[if story tense is present tense]here[else]there[end if]!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U193();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "now ";
    .L_Say0;
    ParaContent();
    print "pitch dark in ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say1;
    }
    ParaContent();
    print "here";
    jump L_SayX1;
    .L_Say1;
    ParaContent();
    print "there";
    .L_SayX1;
    ParaContent();
    print "!";
    rtrue;
];
[ ADJUST_LIGHT_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U1);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U714;
    ResponseViaActivity(response_id_U2);
];
[ call_U715;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(considering the first sixteen objects only)[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(considering the first sixteen objects only)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U716;
    ResponseViaActivity(response_id_U3);
];
[ call_U717;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nothing to do!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nothing to do!";
    rtrue;
];
[ GENERATE_ACTION_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U2);
            ;
        66:
            (str = as_block_constant_U3);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U718;
    ResponseViaActivity(response_id_U4);
];
[ call_U719;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You must name something more substantial.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You must name something more substantial.";
    rtrue;
];
[ BASIC_ACCESSIBILITY_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U4);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U720;
    ResponseViaActivity(response_id_U5);
];
[ call_U721;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[It] [are] pitch dark, and [we] [can't see] a thing.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U193();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " pitch dark, and ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb3);
    (say__p = 1);
    ParaContent();
    print " a thing.";
    rtrue;
];
[ BASIC_VISIBILITY_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U5);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U722;
    ResponseViaActivity(response_id_U6);
];
[ call_U723;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [have] better things to do.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb4(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " better things to do.";
    rtrue;
];
[ REQUESTED_ACTIONS_REQUIRE_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U6);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U724;
    ResponseViaActivity(response_id_U7);
];
[ call_U725;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [are] unable to do that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unable to do that.";
    rtrue;
];
[ CARRY_OUT_REQUESTED_ACTIONS_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U7);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U726;
    ResponseViaActivity(response_id_U8);
];
[ call_U727;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [aren't] available.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U178();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " available.";
    rtrue;
];
[ ACCESS_THROUGH_BARRIERS_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U8);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U728;
    ResponseViaActivity(response_id_U9);
];
[ call_U729;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [aren't] open.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " open.";
    rtrue;
];
[ CANT_REACH_INSIDE_CLOSED_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U9);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U730;
    ResponseViaActivity(response_id_U10);
];
[ call_U731;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't] reach into [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " reach into ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ CANT_REACH_INSIDE_ROOMS_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U10);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U732;
    ResponseViaActivity(response_id_U11);
];
[ call_U733;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [aren't] open.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " open.";
    rtrue;
];
[ CANT_REACH_OUTSIDE_CLOSED_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U11);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U734;
    ResponseViaActivity(response_id_U12);
];
[ call_U735;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ (~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " (";
    rtrue;
];
[ call_U736;
    ResponseViaActivity(response_id_U13);
];
[ call_U737;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~)~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ")";
    rtrue;
];
[ call_U738;
    ResponseViaActivity(response_id_U14);
];
[ call_U739;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ and ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " and ";
    rtrue;
];
[ call_U740;
    ResponseViaActivity(response_id_U15);
];
[ call_U741;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~providing light~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "providing light";
    rtrue;
];
[ call_U742;
    ResponseViaActivity(response_id_U16);
];
[ call_U743;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~closed~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "closed";
    rtrue;
];
[ call_U744;
    ResponseViaActivity(response_id_U17);
];
[ call_U745;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~empty~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "empty";
    rtrue;
];
[ call_U746;
    ResponseViaActivity(response_id_U18);
];
[ call_U747;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~closed and empty~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "closed and empty";
    rtrue;
];
[ call_U748;
    ResponseViaActivity(response_id_U19);
];
[ call_U749;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~closed and providing light~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "closed and providing light";
    rtrue;
];
[ call_U750;
    ResponseViaActivity(response_id_U20);
];
[ call_U751;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~empty and providing light~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "empty and providing light";
    rtrue;
];
[ call_U752;
    ResponseViaActivity(response_id_U21);
];
[ call_U753;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~closed, empty[if serial comma option is active],[end if] and providing light~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "closed, empty";
    if ((~~(call_U69(use_option_id_U3)))) {
        jump L_Say0;
    }
    ParaContent();
    print ",";
    .L_Say0;
    ParaContent();
    print " and providing light";
    rtrue;
];
[ call_U754;
    ResponseViaActivity(response_id_U22);
];
[ call_U755;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~providing light and being worn~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "providing light and being worn";
    rtrue;
];
[ call_U756;
    ResponseViaActivity(response_id_U23);
];
[ call_U757;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~being worn~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "being worn";
    rtrue;
];
[ call_U758;
    ResponseViaActivity(response_id_U24);
];
[ call_U759;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~open~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "open";
    rtrue;
];
[ call_U760;
    ResponseViaActivity(response_id_U25);
];
[ call_U761;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~open but empty~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "open but empty";
    rtrue;
];
[ call_U762;
    ResponseViaActivity(response_id_U26);
];
[ call_U763;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~closed~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "closed";
    rtrue;
];
[ call_U764;
    ResponseViaActivity(response_id_U27);
];
[ call_U765;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~closed and locked~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "closed and locked";
    rtrue;
];
[ call_U766;
    ResponseViaActivity(response_id_U28);
];
[ call_U767;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~containing~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "containing";
    rtrue;
];
[ call_U768;
    ResponseViaActivity(response_id_U29);
];
[ call_U769;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~on [if the noun is a person]whom[otherwise]which[end if] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "on ";
    if ((~~((noun ofclass K8_person)))) {
        jump L_Say0;
    }
    ParaContent();
    print "whom";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "which";
    .L_SayX0;
    ParaContent();
    print " ";
    rtrue;
];
[ call_U770;
    ResponseViaActivity(response_id_U30);
];
[ call_U771;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~, on top of [if the noun is a person]whom[otherwise]which[end if] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ", on top of ";
    if ((~~((noun ofclass K8_person)))) {
        jump L_Say0;
    }
    ParaContent();
    print "whom";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "which";
    .L_SayX0;
    ParaContent();
    print " ";
    rtrue;
];
[ call_U772;
    ResponseViaActivity(response_id_U31);
];
[ call_U773;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~in [if the noun is a person]whom[otherwise]which[end if] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "in ";
    if ((~~((noun ofclass K8_person)))) {
        jump L_Say0;
    }
    ParaContent();
    print "whom";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "which";
    .L_SayX0;
    ParaContent();
    print " ";
    rtrue;
];
[ call_U774;
    ResponseViaActivity(response_id_U32);
];
[ call_U775;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~, inside [if the noun is a person]whom[otherwise]which[end if] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ", inside ";
    if ((~~((noun ofclass K8_person)))) {
        jump L_Say0;
    }
    ParaContent();
    print "whom";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "which";
    .L_SayX0;
    ParaContent();
    print " ";
    rtrue;
];
[ call_U776;
    ResponseViaActivity(response_id_U33);
];
[ call_U777;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding list writer internals][are]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingLWI();
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rtrue;
];
[ call_U778;
    ResponseViaActivity(response_id_U34);
];
[ call_U779;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding list writer internals][are] nothing~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingLWI();
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing";
    rtrue;
];
[ call_U780;
    ResponseViaActivity(response_id_U35);
];
[ call_U781;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nothing~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nothing";
    rtrue;
];
[ call_U782;
    ResponseViaActivity(response_id_U36);
];
[ call_U783;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~nothing~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "nothing";
    rtrue;
];
[ LIST_WRITER_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U12);
            ;
        66:
            (str = as_block_constant_U13);
            ;
        67:
            (str = as_block_constant_U14);
            ;
        68:
            (str = as_block_constant_U15);
            ;
        69:
            (str = as_block_constant_U16);
            ;
        70:
            (str = as_block_constant_U17);
            ;
        71:
            (str = as_block_constant_U18);
            ;
        72:
            (str = as_block_constant_U19);
            ;
        73:
            (str = as_block_constant_U20);
            ;
        74:
            (str = as_block_constant_U21);
            ;
        75:
            (str = as_block_constant_U22);
            ;
        76:
            (str = as_block_constant_U23);
            ;
        77:
            (str = as_block_constant_U24);
            ;
        78:
            (str = as_block_constant_U25);
            ;
        79:
            (str = as_block_constant_U26);
            ;
        80:
            (str = as_block_constant_U27);
            ;
        81:
            (str = as_block_constant_U28);
            ;
        82:
            (str = as_block_constant_U29);
            ;
        83:
            (str = as_block_constant_U30);
            ;
        84:
            (str = as_block_constant_U31);
            ;
        85:
            (str = as_block_constant_U32);
            ;
        86:
            (str = as_block_constant_U33);
            ;
        87:
            (str = as_block_constant_U34);
            ;
        88:
            (str = as_block_constant_U35);
            ;
        89:
            (str = as_block_constant_U36);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U784;
    ResponseViaActivity(response_id_U37);
];
[ call_U785;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[bracket]That command asks to do something outside of play, so it can^only make sense from you to me. [The noun] cannot be asked to do this.[close^bracket]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "[";
    ParaContent();
    print "That command asks to do something outside of play, so it can only make sense from you to me. ";
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " cannot be asked to do this.";
    ParaContent();
    print "]";
    rtrue;
];
[ call_U786;
    ResponseViaActivity(response_id_U38);
];
[ call_U787;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You must name an object.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You must name an object.";
    rtrue;
];
[ call_U788;
    ResponseViaActivity(response_id_U39);
];
[ call_U789;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You may not name an object.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You may not name an object.";
    rtrue;
];
[ call_U790;
    ResponseViaActivity(response_id_U40);
];
[ call_U791;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You must supply a noun.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You must supply a noun.";
    rtrue;
];
[ call_U792;
    ResponseViaActivity(response_id_U41);
];
[ call_U793;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You may not supply a noun.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You may not supply a noun.";
    rtrue;
];
[ call_U794;
    ResponseViaActivity(response_id_U42);
];
[ call_U795;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You must name a second object.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You must name a second object.";
    rtrue;
];
[ call_U796;
    ResponseViaActivity(response_id_U43);
];
[ call_U797;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You may not name a second object.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You may not name a second object.";
    rtrue;
];
[ call_U798;
    ResponseViaActivity(response_id_U44);
];
[ call_U799;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You must supply a second noun.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You must supply a second noun.";
    rtrue;
];
[ call_U800;
    ResponseViaActivity(response_id_U45);
];
[ call_U801;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You may not supply a second noun.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You may not supply a second noun.";
    rtrue;
];
[ call_U802;
    ResponseViaActivity(response_id_U46);
];
[ call_U803;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(Since something dramatic has happened, your list of commands has been^cut short.)~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(Since something dramatic has happened, your list of commands has been cut short.)";
    rtrue;
];
[ call_U804;
    ResponseViaActivity(response_id_U47);
];
[ call_U805;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I didn't understand that instruction.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I didn't understand that instruction.";
    rtrue;
];
[ ACTION_PROCESSING_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U37);
            ;
        66:
            (str = as_block_constant_U38);
            ;
        67:
            (str = as_block_constant_U39);
            ;
        68:
            (str = as_block_constant_U40);
            ;
        69:
            (str = as_block_constant_U41);
            ;
        70:
            (str = as_block_constant_U42);
            ;
        71:
            (str = as_block_constant_U43);
            ;
        72:
            (str = as_block_constant_U44);
            ;
        73:
            (str = as_block_constant_U45);
            ;
        74:
            (str = as_block_constant_U46);
            ;
        75:
            (str = as_block_constant_U47);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U806;
    ResponseViaActivity(response_id_U48);
];
[ call_U807;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I didn't understand that sentence.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I didn't understand that sentence.";
    rtrue;
];
[ call_U808;
    ResponseViaActivity(response_id_U49);
];
[ call_U809;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I only understood you as far as wanting to ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I only understood you as far as wanting to ";
    rtrue;
];
[ call_U810;
    ResponseViaActivity(response_id_U50);
];
[ call_U811;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I only understood you as far as wanting to (go) ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I only understood you as far as wanting to (go) ";
    rtrue;
];
[ call_U812;
    ResponseViaActivity(response_id_U51);
];
[ call_U813;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I didn't understand that number.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I didn't understand that number.";
    rtrue;
];
[ call_U814;
    ResponseViaActivity(response_id_U52);
];
[ call_U815;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't] see any such thing.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " see any such thing.";
    rtrue;
];
[ call_U816;
    ResponseViaActivity(response_id_U53);
];
[ call_U817;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You seem to have said too little!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You seem to have said too little!";
    rtrue;
];
[ call_U818;
    ResponseViaActivity(response_id_U54);
];
[ call_U819;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [aren't] holding that!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " holding that!";
    rtrue;
];
[ call_U820;
    ResponseViaActivity(response_id_U55);
];
[ call_U821;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You can't use multiple objects with that verb.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You can't use multiple objects with that verb.";
    rtrue;
];
[ call_U822;
    ResponseViaActivity(response_id_U56);
];
[ call_U823;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You can only use multiple objects once on a line.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You can only use multiple objects once on a line.";
    rtrue;
];
[ call_U824;
    ResponseViaActivity(response_id_U57);
];
[ call_U825;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I'm not sure what ['][pronoun i6 dictionary word]['] refers to.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I'm not sure what ";
    ParaContent();
    print "'";
    ParaContent();
    print (address) pronoun_word;
    ParaContent();
    print "'";
    ParaContent();
    print " refers to.";
    rtrue;
];
[ call_U826;
    ResponseViaActivity(response_id_U58);
];
[ call_U827;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't] see ['][pronoun i6 dictionary word]['] ([the noun]) at the moment.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " see ";
    ParaContent();
    print "'";
    ParaContent();
    print (address) pronoun_word;
    ParaContent();
    print "'";
    ParaContent();
    print " (";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ") at the moment.";
    rtrue;
];
[ call_U828;
    ResponseViaActivity(response_id_U59);
];
[ call_U829;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You excepted something not included anyway!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You excepted something not included anyway!";
    rtrue;
];
[ call_U830;
    ResponseViaActivity(response_id_U60);
];
[ call_U831;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You can only do that to something animate.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You can only do that to something animate.";
    rtrue;
];
[ call_U832;
    ResponseViaActivity(response_id_U61);
];
[ call_U833;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~That's not a verb I [if American dialect option is^active]recognize[otherwise]recognise[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "That's not a verb I ";
    if ((~~(call_U69(use_option_id_U2)))) {
        jump L_Say0;
    }
    ParaContent();
    print "recognize";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "recognise";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U834;
    ResponseViaActivity(response_id_U62);
];
[ call_U835;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~That's not something you need to refer to in the course of this game.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "That's not something you need to refer to in the course of this game.";
    rtrue;
];
[ call_U836;
    ResponseViaActivity(response_id_U63);
];
[ call_U837;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I didn't understand the way that finished.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I didn't understand the way that finished.";
    rtrue;
];
[ call_U838;
    ResponseViaActivity(response_id_U64);
];
[ call_U839;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if number understood is 0]None[otherwise]Only [number understood in words][end if]^of those [regarding the number understood][are] available.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((parsed_number == 0)))) {
        jump L_Say0;
    }
    ParaContent();
    print "None";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "Only ";
    ParaContent();
    LanguageNumber((say__n = parsed_number));
    .L_SayX0;
    ParaContent();
    print " of those ";
    ParaContent();
    RegardingNumber(parsed_number);
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " available.";
    rtrue;
];
[ call_U840;
    ResponseViaActivity(response_id_U65);
];
[ call_U841;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~That noun did not make sense in this context.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "That noun did not make sense in this context.";
    rtrue;
];
[ call_U842;
    ResponseViaActivity(response_id_U66);
];
[ call_U843;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~To repeat a command like 'frog, jump', just say 'again', not 'frog, again'.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "To repeat a command like ~frog, jump~, just say ~again~, not ~frog, again~.";
    rtrue;
];
[ call_U844;
    ResponseViaActivity(response_id_U67);
];
[ call_U845;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You can't begin with a comma.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You can't begin with a comma.";
    rtrue;
];
[ call_U846;
    ResponseViaActivity(response_id_U68);
];
[ call_U847;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You seem to want to talk to someone, but I can't see whom.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You seem to want to talk to someone, but I can't see whom.";
    rtrue;
];
[ call_U848;
    ResponseViaActivity(response_id_U69);
];
[ call_U849;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You can't talk to [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You can't talk to ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U850;
    ResponseViaActivity(response_id_U70);
];
[ call_U851;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~To talk to someone, try 'someone, hello' or some such.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "To talk to someone, try ~someone, hello~ or some such.";
    rtrue;
];
[ call_U852;
    ResponseViaActivity(response_id_U71);
];
[ call_U853;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I beg your pardon?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I beg your pardon?";
    rtrue;
];
[ PARSER_ERROR_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U48);
            ;
        66:
            (str = as_block_constant_U49);
            ;
        67:
            (str = as_block_constant_U50);
            ;
        68:
            (str = as_block_constant_U51);
            ;
        69:
            (str = as_block_constant_U52);
            ;
        70:
            (str = as_block_constant_U53);
            ;
        71:
            (str = as_block_constant_U54);
            ;
        72:
            (str = as_block_constant_U55);
            ;
        73:
            (str = as_block_constant_U56);
            ;
        74:
            (str = as_block_constant_U57);
            ;
        75:
            (str = as_block_constant_U58);
            ;
        76:
            (str = as_block_constant_U59);
            ;
        77:
            (str = as_block_constant_U60);
            ;
        78:
            (str = as_block_constant_U61);
            ;
        79:
            (str = as_block_constant_U62);
            ;
        80:
            (str = as_block_constant_U63);
            ;
        81:
            (str = as_block_constant_U64);
            ;
        82:
            (str = as_block_constant_U65);
            ;
        83:
            (str = as_block_constant_U66);
            ;
        84:
            (str = as_block_constant_U67);
            ;
        85:
            (str = as_block_constant_U68);
            ;
        86:
            (str = as_block_constant_U69);
            ;
        87:
            (str = as_block_constant_U70);
            ;
        88:
            (str = as_block_constant_U71);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U854;
    ResponseViaActivity(response_id_U72);
];
[ call_U855;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nothing to do!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nothing to do!";
    rtrue;
];
[ call_U856;
    ResponseViaActivity(response_id_U73);
];
[ call_U857;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [adapt the verb are from the third person plural] none at all available!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U194();
    ParaContent();
    print " ";
    ParaContent();
    (call_U1942)(CV_POS,I_third_person_plural_U1,story_tense);
    ParaContent();
    print " none at all available!";
    rtrue;
];
[ call_U858;
    ResponseViaActivity(response_id_U74);
];
[ call_U859;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [seem] to belong to [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U178();
    ParaContent();
    print " ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to belong to ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U860;
    ResponseViaActivity(response_id_U75);
];
[ call_U861;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [can't] contain things.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U178();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " contain things.";
    rtrue;
];
[ call_U862;
    ResponseViaActivity(response_id_U76);
];
[ call_U863;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [aren't] open.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " open.";
    rtrue;
];
[ call_U864;
    ResponseViaActivity(response_id_U77);
];
[ call_U865;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [are] empty.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " empty.";
    rtrue;
];
[ PARSER_N_ERROR_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U72);
            ;
        66:
            (str = as_block_constant_U73);
            ;
        67:
            (str = as_block_constant_U74);
            ;
        68:
            (str = as_block_constant_U75);
            ;
        69:
            (str = as_block_constant_U76);
            ;
        70:
            (str = as_block_constant_U77);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U866;
    ResponseViaActivity(response_id_U78);
];
[ call_U867;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Darkness~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Darkness";
    rtrue;
];
[ DARKNESS_NAME_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U78);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U868;
    ResponseViaActivity(response_id_U79);
];
[ call_U869;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Sorry, that can't be corrected.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Sorry, that can't be corrected.";
    rtrue;
];
[ call_U870;
    ResponseViaActivity(response_id_U80);
];
[ call_U871;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Think nothing of it.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Think nothing of it.";
    rtrue;
];
[ call_U872;
    ResponseViaActivity(response_id_U81);
];
[ call_U873;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~'Oops' can only correct a single word.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "~Oops~ can only correct a single word.";
    rtrue;
];
[ call_U874;
    ResponseViaActivity(response_id_U82);
];
[ call_U875;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You can hardly repeat that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You can hardly repeat that.";
    rtrue;
];
[ PARSER_COMMAND_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U79);
            ;
        66:
            (str = as_block_constant_U80);
            ;
        67:
            (str = as_block_constant_U81);
            ;
        68:
            (str = as_block_constant_U82);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U876;
    ResponseViaActivity(response_id_U83);
];
[ call_U877;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Who do you mean, ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Who do you mean, ";
    rtrue;
];
[ call_U878;
    ResponseViaActivity(response_id_U84);
];
[ call_U879;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Which do you mean, ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Which do you mean, ";
    rtrue;
];
[ call_U880;
    ResponseViaActivity(response_id_U85);
];
[ call_U881;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Sorry, you can only have one item here. Which exactly?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Sorry, you can only have one item here. Which exactly?";
    rtrue;
];
[ call_U882;
    ResponseViaActivity(response_id_U86);
];
[ call_U883;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Whom do you want [if the noun is not the player][the noun] [end if]to^[parser command so far]?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Whom do you want ";
    if ((~~((~~((noun == player)))))) {
        jump L_Say0;
    }
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    .L_Say0;
    ParaContent();
    print "to ";
    ParaContent();
    PrintCommand();
    ParaContent();
    print "?";
    rtrue;
];
[ call_U884;
    ResponseViaActivity(response_id_U87);
];
[ call_U885;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~What do you want [if the noun is not the player][the noun] [end if]to^[parser command so far]?~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "What do you want ";
    if ((~~((~~((noun == player)))))) {
        jump L_Say0;
    }
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    .L_Say0;
    ParaContent();
    print "to ";
    ParaContent();
    PrintCommand();
    ParaContent();
    print "?";
    rtrue;
];
[ call_U886;
    ResponseViaActivity(response_id_U88);
];
[ call_U887;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~those things~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "those things";
    rtrue;
];
[ call_U888;
    ResponseViaActivity(response_id_U89);
];
[ call_U889;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~that~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "that";
    rtrue;
];
[ call_U890;
    ResponseViaActivity(response_id_U90);
];
[ call_U891;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ or ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " or ";
    rtrue;
];
[ PARSER_CLARIF_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U83);
            ;
        66:
            (str = as_block_constant_U84);
            ;
        67:
            (str = as_block_constant_U85);
            ;
        68:
            (str = as_block_constant_U86);
            ;
        69:
            (str = as_block_constant_U87);
            ;
        70:
            (str = as_block_constant_U88);
            ;
        71:
            (str = as_block_constant_U89);
            ;
        72:
            (str = as_block_constant_U90);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U892;
    ResponseViaActivity(response_id_U91);
];
[ call_U893;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Please answer yes or no.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Please answer yes or no.";
    rtrue;
];
[ YES_OR_NO_QUESTION_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U91);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U894;
    ResponseViaActivity(response_id_U92);
];
[ call_U895;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    rtrue;
];
[ call_U896;
    ResponseViaActivity(response_id_U93);
];
[ call_U897;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[ourselves]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U170();
    rtrue;
];
[ call_U898;
    ResponseViaActivity(response_id_U94);
];
[ call_U899;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[our] former self~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U171();
    ParaContent();
    print " former self";
    rtrue;
];
[ PRINT_PROTAGONIST_INTERNAL_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U92);
            ;
        66:
            (str = as_block_constant_U93);
            ;
        67:
            (str = as_block_constant_U94);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U900;
    ResponseViaActivity(response_id_U95);
];
[ call_U901;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first taking [the noun])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U902;
    ResponseViaActivity(response_id_U96);
];
[ call_U903;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~([the second noun] first taking [the noun])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(";
    ParaContent();
    DefArt(second);
    ParaContent();
    print " first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ STANDARD_IMPLICIT_TAKING_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U95);
            ;
        66:
            (str = as_block_constant_U96);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U904;
    ResponseViaActivity(response_id_U97);
];
[ call_U905;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ You have died ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " You have died ";
    rtrue;
];
[ call_U906;
    ResponseViaActivity(response_id_U98);
];
[ call_U907;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ You have won ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " You have won ";
    rtrue;
];
[ call_U908;
    ResponseViaActivity(response_id_U99);
];
[ call_U909;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ The End ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " The End ";
    rtrue;
];
[ PRINT_OBITUARY_HEADLINE_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U97);
            ;
        66:
            (str = as_block_constant_U98);
            ;
        67:
            (str = as_block_constant_U99);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U910;
    ResponseViaActivity(response_id_U100);
];
[ call_U911;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The use of 'undo' is forbidden in this story.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The use of ~undo~ is forbidden in this story.";
    rtrue;
];
[ call_U912;
    ResponseViaActivity(response_id_U101);
];
[ call_U913;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You can't 'undo' what hasn't been done!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You can't ~undo~ what hasn't been done!";
    rtrue;
];
[ call_U914;
    ResponseViaActivity(response_id_U102);
];
[ call_U915;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Your interpreter does not provide 'undo'. Sorry!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Your interpreter does not provide ~undo~. Sorry!";
    rtrue;
];
[ call_U916;
    ResponseViaActivity(response_id_U103);
];
[ call_U917;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~'Undo' failed. Sorry!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "~Undo~ failed. Sorry!";
    rtrue;
];
[ call_U918;
    ResponseViaActivity(response_id_U104);
];
[ call_U919;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[bracket]Previous turn undone.[close bracket]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "[";
    ParaContent();
    print "Previous turn undone.";
    ParaContent();
    print "]";
    rtrue;
];
[ call_U920;
    ResponseViaActivity(response_id_U105);
];
[ call_U921;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~'Undo' capacity exhausted. Sorry!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "~Undo~ capacity exhausted. Sorry!";
    rtrue;
];
[ IMMEDIATELY_UNDO_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U100);
            ;
        66:
            (str = as_block_constant_U101);
            ;
        67:
            (str = as_block_constant_U102);
            ;
        68:
            (str = as_block_constant_U103);
            ;
        69:
            (str = as_block_constant_U104);
            ;
        70:
            (str = as_block_constant_U105);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U922;
    ResponseViaActivity(response_id_U106);
];
[ call_U923;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Are you sure you want to quit? ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Are you sure you want to quit? ";
    rtrue;
];
[ QUIT_THE_GAME_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U106);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U924;
    ResponseViaActivity(response_id_U107);
];
[ call_U925;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Save failed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Save failed.";
    rtrue;
];
[ call_U926;
    ResponseViaActivity(response_id_U108);
];
[ call_U927;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Ok.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Ok.";
    rtrue;
];
[ SAVE_THE_GAME_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U107);
            ;
        66:
            (str = as_block_constant_U108);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U928;
    ResponseViaActivity(response_id_U109);
];
[ call_U929;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Restore failed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Restore failed.";
    rtrue;
];
[ call_U930;
    ResponseViaActivity(response_id_U110);
];
[ call_U931;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Ok.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Ok.";
    rtrue;
];
[ RESTORE_THE_GAME_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U109);
            ;
        66:
            (str = as_block_constant_U110);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U932;
    ResponseViaActivity(response_id_U111);
];
[ call_U933;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Are you sure you want to restart? ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Are you sure you want to restart? ";
    rtrue;
];
[ call_U934;
    ResponseViaActivity(response_id_U112);
];
[ call_U935;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Failed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Failed.";
    rtrue;
];
[ RESTART_THE_GAME_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U111);
            ;
        66:
            (str = as_block_constant_U112);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U936;
    ResponseViaActivity(response_id_U113);
];
[ call_U937;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The game file has verified as intact.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The game file has verified as intact.";
    rtrue;
];
[ call_U938;
    ResponseViaActivity(response_id_U114);
];
[ call_U939;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The game file did not verify as intact, and may be corrupt.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The game file did not verify as intact, and may be corrupt.";
    rtrue;
];
[ VERIFY_THE_STORY_FILE_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U113);
            ;
        66:
            (str = as_block_constant_U114);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U940;
    ResponseViaActivity(response_id_U115);
];
[ call_U941;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Transcripting is already on.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Transcripting is already on.";
    rtrue;
];
[ call_U942;
    ResponseViaActivity(response_id_U116);
];
[ call_U943;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Start of a transcript of:~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Start of a transcript of:";
    rtrue;
];
[ call_U944;
    ResponseViaActivity(response_id_U117);
];
[ call_U945;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Attempt to begin transcript failed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Attempt to begin transcript failed.";
    rtrue;
];
[ SWITCH_TRANSCRIPT_ON_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U115);
            ;
        66:
            (str = as_block_constant_U116);
            ;
        67:
            (str = as_block_constant_U117);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U946;
    ResponseViaActivity(response_id_U118);
];
[ call_U947;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Transcripting is already off.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Transcripting is already off.";
    rtrue;
];
[ call_U948;
    ResponseViaActivity(response_id_U119);
];
[ call_U949;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[line break]End of transcript.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "^";
    ParaContent();
    print "End of transcript.";
    rtrue;
];
[ call_U950;
    ResponseViaActivity(response_id_U120);
];
[ call_U951;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Attempt to end transcript failed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Attempt to end transcript failed.";
    rtrue;
];
[ SWITCH_TRANSCRIPT_OFF_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U118);
            ;
        66:
            (str = as_block_constant_U119);
            ;
        67:
            (str = as_block_constant_U120);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U952;
    ResponseViaActivity(response_id_U121);
];
[ call_U953;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[if the story has ended]In that game you scored[otherwise]You have so far scored[end if]^[score] out of a possible [maximum score], in [turn count] turn[s]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    if ((~~((deadflag ~= 0)))) {
        jump L_Say0;
    }
    ParaContent();
    print "In that game you scored";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "You have so far scored";
    .L_SayX0;
    ParaContent();
    print " ";
    ParaContent();
    print (say__n = score);
    ParaContent();
    print " out of a possible ";
    ParaContent();
    print (say__n = MAX_SCORE);
    ParaContent();
    print ", in ";
    ParaContent();
    print (say__n = turns);
    ParaContent();
    print " turn";
    ParaContent();
    STextSubstitution();
    rtrue;
];
[ call_U954;
    ResponseViaActivity(response_id_U122);
];
[ call_U955;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~, earning you the rank of ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ", earning you the rank of ";
    rtrue;
];
[ call_U956;
    ResponseViaActivity(response_id_U123);
];
[ call_U957;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no score in this story.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U194();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no score in this story.";
    rtrue;
];
[ call_U958;
    ResponseViaActivity(response_id_U124);
];
[ call_U959;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[bracket]Your score has just gone up by [number understood in words]^point[s].[close bracket]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "[";
    ParaContent();
    print "Your score has just gone up by ";
    ParaContent();
    LanguageNumber((say__n = parsed_number));
    ParaContent();
    print " point";
    ParaContent();
    STextSubstitution();
    ParaContent();
    print ".";
    ParaContent();
    print "]";
    rtrue;
];
[ call_U960;
    ResponseViaActivity(response_id_U125);
];
[ call_U961;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[bracket]Your score has just gone down by [number understood in words]^point[s].[close bracket]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "[";
    ParaContent();
    print "Your score has just gone down by ";
    ParaContent();
    LanguageNumber((say__n = parsed_number));
    ParaContent();
    print " point";
    ParaContent();
    STextSubstitution();
    ParaContent();
    print ".";
    ParaContent();
    print "]";
    rtrue;
];
[ ANNOUNCE_SCORE_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U121);
            ;
        66:
            (str = as_block_constant_U122);
            ;
        67:
            (str = as_block_constant_U123);
            ;
        68:
            (str = as_block_constant_U124);
            ;
        69:
            (str = as_block_constant_U125);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U962;
    ResponseViaActivity(response_id_U126);
];
[ call_U963;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ is now in its 'superbrief' mode, which always gives short descriptions^of locations (even if you haven't been there before).~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " is now in its ~superbrief~ mode, which always gives short descriptions of locations (even if you haven't been there before).";
    rtrue;
];
[ REP_PREFER_ABBREVIATED_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U126);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U964;
    ResponseViaActivity(response_id_U127);
];
[ call_U965;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ is now in its 'verbose' mode, which always gives long descriptions of^locations (even if you've been there before).~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " is now in its ~verbose~ mode, which always gives long descriptions of locations (even if you've been there before).";
    rtrue;
];
[ REP_PREFER_UNABBREVIATED_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U127);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U966;
    ResponseViaActivity(response_id_U128);
];
[ call_U967;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ is now in its 'brief' printing mode, which gives long descriptions^of places never before visited and short descriptions otherwise.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " is now in its ~brief~ printing mode, which gives long descriptions of places never before visited and short descriptions otherwise.";
    rtrue;
];
[ REP_PREFER_SOMETIMES_ABBR_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U128);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U968;
    ResponseViaActivity(response_id_U129);
];
[ call_U969;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Score notification on.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Score notification on.";
    rtrue;
];
[ REP_SWITCH_NOTIFY_ON_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U129);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U970;
    ResponseViaActivity(response_id_U130);
];
[ call_U971;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Score notification off.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Score notification off.";
    rtrue;
];
[ REP_SWITCH_NOTIFY_OFF_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U130);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U972;
    ResponseViaActivity(response_id_U131);
];
[ call_U973;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~At the moment, ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "At the moment, ";
    rtrue;
];
[ call_U974;
    ResponseViaActivity(response_id_U132);
];
[ call_U975;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~means ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "means ";
    rtrue;
];
[ call_U976;
    ResponseViaActivity(response_id_U133);
];
[ call_U977;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~is unset~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "is unset";
    rtrue;
];
[ call_U978;
    ResponseViaActivity(response_id_U134);
];
[ call_U979;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~no pronouns are known to the game.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "no pronouns are known to the game.";
    rtrue;
];
[ ANNOUNCE_PRONOUN_MEANINGS_RM code val val2 s s2 s3 str f;
    if ((((code >= 97)) && ((code <= 122)))) {
        (f = 1);
        (code = (code - 32));
    }
    (s = noun);
    (s2 = second);
    (s3 = parsed_number);
    (noun = val);
    (second = val2);
    (parsed_number = val);
    switch (code) {
        65:
            (str = as_block_constant_U131);
            ;
        66:
            (str = as_block_constant_U132);
            ;
        67:
            (str = as_block_constant_U133);
            ;
        68:
            (str = as_block_constant_U134);
            ;
    }
    if (((str) && ((f == 0)))) {
        TEXT_TY_Say(str);
    }
    (noun = s);
    (second = s2);
    (parsed_number = s3);
    return str;
];
[ call_U980 tmp_0 tmp_1;
    if (debug_rules) {
        DB_Rule(call_U980, 368, 0);
    }
    for (((tmp_0 = (call_U981)(0)),(tmp_1 = (call_U981)(tmp_0))):tmp_0:((tmp_0 = tmp_1),(tmp_1 = (call_U981)(tmp_1)))) {
        call_U290(tmp_0);
    }
    rfalse;
];
[ call_U981 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        return x;
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U982;
    if (debug_rules) {
        DB_Rule(call_U982, 369, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U13));
    rfalse;
];
[ call_U983;
    if (debug_rules) {
        DB_Rule(call_U983, 370, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U14));
    rfalse;
];
[ call_U984;
    if (debug_rules) {
        DB_Rule(call_U984, 371, 0);
    }
    (last_score = score);
    rfalse;
];
[ call_U985;
    if (debug_rules) {
        DB_Rule(call_U985, 372, 0);
    }
    (say__p = 1);
    ParaContent();
    Banner();
    rfalse;
];
[ call_U986;
    if (debug_rules) {
        DB_Rule(call_U986, 373, 0);
    }
    TryAction(0, player, ##Look, 0, 0);
    rfalse;
];
[ call_U987;
    if (debug_rules) {
        DB_Rule(call_U987, 374, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U18));
    rfalse;
];
[ call_U988;
    if (debug_rules) {
        DB_Rule(call_U988, 375, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U13));
    rfalse;
];
[ call_U989;
    if (debug_rules) {
        DB_Rule(call_U989, 376, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U13));
    rfalse;
];
[ call_U990;
    if (debug_rules) {
        DB_Rule(call_U990, 377, 0);
    }
    if ((~~((score == last_score)))) {
        NotifyTheScore();
        (last_score = score);
    }
    rfalse;
];
[ call_U991;
    if (debug_rules) {
        DB_Rule(call_U991, 378, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U15));
    rfalse;
];
[ call_U992;
    if (debug_rules) {
        DB_Rule(call_U992, 379, 0);
    }
    CarryOutActivity(V30_printing_the_player_s_obi);
    rfalse;
];
[ call_U993;
    if (debug_rules) {
        DB_Rule(call_U993, 380, 0);
    }
    if ((~~((multiple_object_item == 0)))) {
        PronounNotice(multiple_object_item);
    }
    rfalse;
];
[ call_U994;
    if (debug_rules) {
        DB_Rule(call_U994, 381, 0);
    }
    if ((~~((multiple_object_item == 0)))) {
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(as_block_constant_U135);
    }
    rfalse;
];
[ call_U995;
    ResponseViaActivity(response_id_U135);
];
[ call_U996;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[current item from the multiple object list]: [run paragraph on]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    PrintShortName(multiple_object_item);
    ParaContent();
    print ": ";
    ParaContent();
    RunParagraphOn();
    rtrue;
];
[ call_U997;
    if (debug_rules) {
        DB_Rule(call_U997, 382, 0);
    }
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U29))) {
        rtrue;
    }
    rfalse;
];
[ call_U998;
    if (debug_rules) {
        DB_Rule(call_U998, 383, 0);
    }
    if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U30))) {
        rtrue;
    }
    rfalse;
];
[ call_U999;
    if (debug_rules) {
        DB_Rule(call_U999, 384, 0);
    }
    RulebookSucceeds();
    rtrue;
    rfalse;
];
[ call_U1000;
    if (debug_rules) {
        DB_Rule(call_U1000, 385, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U22));
    if (RulebookSucceeded()) {
        ((MStack-->(MstVO(rulebook_id_U21, 5))) = 1);
    } else {
        ((MStack-->(MstVO(rulebook_id_U21, 5))) = 0);
    }
    rfalse;
];
[ call_U1001;
    if (debug_rules) {
        DB_Rule(call_U1001, 386, 0);
    }
    if ((temporary_value = FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->(MstVO(rulebook_id_U21, 2))))))) {
        if (RulebookSucceeded()) {
            ActRulebookSucceeds(temporary_value);
        } else {
            ActRulebookFails(temporary_value);
        }
        return 2;
    }
    rfalse;
];
[ call_U1002;
    if (debug_rules) {
        DB_Rule(call_U1002, 387, 0);
    }
    FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->(MstVO(rulebook_id_U21, 3)))));
    rfalse;
];
[ call_U1003;
    if (debug_rules) {
        DB_Rule(call_U1003, 388, 0);
    }
    if (((MStack-->(MstVO(rulebook_id_U21, 0))) == 1)) {
        if (FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U33))) {
            rtrue;
        }
    }
    rfalse;
];
[ call_U1004;
    if (debug_rules) {
        DB_Rule(call_U1004, 389, 0);
    }
    if (((MStack-->(MstVO(rulebook_id_U21, 5))) == 0)) {
        FollowRulebook(RULEBOOK_TY_to_RULE_TY(rulebook_id_U22));
        if (RulebookSucceeded()) {
            ((MStack-->(MstVO(rulebook_id_U21, 5))) = 1);
        }
    }
    rfalse;
];
[ call_U1005;
    if (debug_rules) {
        DB_Rule(call_U1005, 390, 0);
    }
    if (((((MStack-->(MstVO(rulebook_id_U21, 5))) == 1)) && (((MStack-->(MstVO(rulebook_id_U21, 1))) == 0)))) {
        FollowRulebook(RULEBOOK_TY_to_RULE_TY((MStack-->(MstVO(rulebook_id_U21, 4)))));
    }
    rfalse;
];
[ call_U1006;
    if (debug_rules) {
        DB_Rule(call_U1006, 391, 0);
    }
    RulebookSucceeds();
    rtrue;
    rfalse;
];
[ call_U1007;
    if (debug_rules) {
        DB_Rule(call_U1007, 392, 0);
    }
    if ((player == actor)) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U1008;
    if (debug_rules) {
        DB_Rule(call_U1008, 393, 0);
    }
    if ((((~~((player == actor)))) && (TestVisibility(player, actor)))) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U1009;
    if (debug_rules) {
        DB_Rule(call_U1009, 394, 0);
    }
    if ((((noun ofclass K2_thing)) && (TestVisibility(player, noun)))) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U1010;
    if (debug_rules) {
        DB_Rule(call_U1010, 395, 0);
    }
    if ((((second ofclass K2_thing)) && (TestVisibility(player, second)))) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U1011;
    if (debug_rules) {
        DB_Rule(call_U1011, 396, 0);
    }
    if ((location == thedark)) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ call_U1012;
    if ((((action == ##Take)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && ((player == CarrierOf(noun))))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1012, 397, 0);
        }
        RulebookSucceeds(RULEBOOK_OUTCOME_TY, outcome_it_is_very_unlikely_U1);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1012, 397, 2);
        }
    }
    rfalse;
];
[ call_U1013 tmp_0;
    if (((((tmp_0 = parameter_value),((1) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = I_entire_game_U1),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1013, 398, 0);
        }
        if ((~~(((BlkValueCompare)(GProperty(SCENE_TY, tmp_0, A_description),bc_U63) == 0)))) {
            (say__p = 1);
            ParaContent();
            @push self;
            TEXT_TY_Say(GProperty(SCENE_TY, (self = tmp_0), A_description));
            @pull self;
            ParaContent();
            DivideParagraphPoint();
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1013, 398, 2);
        }
    }
    rfalse;
];
[ call_U1014 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1014, 399, 0);
        }
        if (say__comp) {
            rfalse;
        }
        call_U289(tmp_0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1014, 399, 2);
        }
    }
    rfalse;
];
[ call_U1015 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1015, 400, 0);
        }
        (say__p = 1);
        ParaContent();
        LanguageNumber((say__n = listing_size));
        ParaContent();
        print " ";
        CarryOutActivity(V3_printing_the_plural_name, tmp_0);
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1015, 400, 2);
        }
    }
    rfalse;
];
[ call_U1016;
    if (debug_rules) {
        DB_Rule(call_U1016, 401, 0);
    }
    TryAction(0, player, ##Look, 0, 0);
    rfalse;
];
[ call_U1017;
    if (call_U264(parameter_value)) {
        if ((((((action == ##Take)) && ((actor == player)))) || ((((((action == ##Disrobe)) && ((actor == player)))) || ((((action == ##Remove)) && ((actor == player)))))))) {
            if (debug_rules) {
                DB_Rule(call_U1017, 402, 0);
            }
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
            RulebookSucceeds(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U1017, 402, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1017, 402, 2);
        }
    }
    rfalse;
];
[ call_U1018;
    if ((parameter_value ofclass K8_person)) {
        if ((((((action == ##Take)) && ((actor == player)))) || ((((((action == ##Disrobe)) && ((actor == player)))) || ((((action == ##Remove)) && ((actor == player)))))))) {
            if (debug_rules) {
                DB_Rule(call_U1018, 403, 0);
            }
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
            RulebookSucceeds(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U1018, 403, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1018, 403, 2);
        }
    }
    rfalse;
];
[ call_U1019;
    if ((((parameter_value ofclass K2_thing)) && (call_U258(parameter_value)))) {
        if ((((((action == ##Take)) && ((actor == player)))) || ((((((action == ##Disrobe)) && ((actor == player)))) || ((((action == ##Remove)) && ((actor == player)))))))) {
            if (debug_rules) {
                DB_Rule(call_U1019, 404, 0);
            }
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
            RulebookSucceeds(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U1019, 404, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1019, 404, 2);
        }
    }
    rfalse;
];
[ call_U1020;
    if ((((parameter_value ofclass K2_thing)) && (IndirectlyContains(actor, parameter_value)))) {
        if ((((((action == ##Take)) && ((actor == player)))) || ((((action == ##Disrobe)) && ((actor == player)))))) {
            if (debug_rules) {
                DB_Rule(call_U1020, 405, 0);
            }
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
            RulebookSucceeds(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U1020, 405, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1020, 405, 2);
        }
    }
    rfalse;
];
[ call_U1021;
    if ((parameter_value ofclass K8_person)) {
        if ((((((action == ##Drop)) && ((actor == player)))) || ((((((action == ##ThrowAt)) && ((actor == player)))) || ((((((action == ##Insert)) && ((actor == player)))) || ((((action == ##PutOn)) && ((actor == player)))))))))) {
            if (debug_rules) {
                DB_Rule(call_U1021, 406, 0);
            }
            RulebookFails(RULEBOOK_OUTCOME_TY, outcome_it_does_not_U1);
            rtrue;
            RulebookSucceeds(0, 0);
            rtrue;
        } else {
            if ((debug_rules > 1)) {
                DB_Rule(call_U1021, 406, 4);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1021, 406, 2);
        }
    }
    rfalse;
];
[ call_U1022;
    if ((((action == ##Smell)) && ((act_requester == 0)))) {
        if (debug_rules) {
            DB_Rule(call_U1022, 407, 0);
        }
        (noun = TouchabilityCeiling(player));
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1022, 407, 4);
        }
    }
    rfalse;
];
[ call_U1023;
    if ((((action == ##Listen)) && ((act_requester == 0)))) {
        if (debug_rules) {
            DB_Rule(call_U1023, 408, 0);
        }
        (noun = TouchabilityCeiling(player));
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1023, 408, 4);
        }
    }
    rfalse;
];
[ call_U1024;
    if ((((action == ##Go)) && ((act_requester == 0)))) {
        if (debug_rules) {
            DB_Rule(call_U1024, 409, 0);
        }
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(as_block_constant_U136);
        print "^";
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1024, 409, 4);
        }
    }
    rfalse;
];
[ call_U1025;
    ResponseViaActivity(response_id_U136);
];
[ call_U1026;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You'll have to say which compass direction to go in.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You'll have to say which compass direction to go in.";
    rtrue;
];
[ call_U1027;
    if (debug_rules) {
        DB_Rule(call_U1027, 410, 0);
    }
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say(as_block_constant_U137);
    rfalse;
];
[ call_U1028;
    ResponseViaActivity(response_id_U137);
];
[ call_U1029;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~> [run paragraph on]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "> ";
    ParaContent();
    RunParagraphOn();
    rtrue;
];
[ call_U1030 tmp_0 ct_0 ct_1 tmp_1 tmp_2;
    if (debug_rules) {
        DB_Rule(call_U1030, 411, 0);
    }
    (tmp_0 = 0);
    @push ct_0;
    @push ct_1;
    for (((tmp_1 = table_data_U1),((tmp_2 = 1),((ct_0 = tmp_1),(ct_1 = tmp_2)))):(tmp_2 <= TableRows(tmp_1)):((tmp_2)++,((ct_0 = tmp_1),(ct_1 = tmp_2)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            if ((((TableLookUpEntry(ct_0, table_column_id_U2, ct_1) == 0)) || (story_complete))) {
                if (((ExistsTableLookUpEntry(ct_0, table_column_id_U4, ct_1)) || ((~~(call_U51(TableLookUpEntry(ct_0, table_column_id_U5, ct_1))))))) {
                    if (ExistsTableLookUpEntry(ct_0, table_column_id_U1, ct_1)) {
                        (tmp_0 = (tmp_0 + 1));
                    }
                }
            }
        }
    }
    @pull ct_1;
    @pull ct_0;
    if ((tmp_0 < 1)) {
        if (FollowRulebook(IMMEDIATELY_QUIT_R)) {
            rtrue;
        }
    }
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = ct_0),(((LocalParking-->(2)) = ct_1),(((LocalParking-->(3)) = tmp_1),(((LocalParking-->(4)) = tmp_2),as_block_constant_U138))))));
    @push ct_0;
    @push ct_1;
    for (((tmp_1 = table_data_U1),((tmp_2 = 1),((ct_0 = tmp_1),(ct_1 = tmp_2)))):(tmp_2 <= TableRows(tmp_1)):((tmp_2)++,((ct_0 = tmp_1),(ct_1 = tmp_2)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            if ((((TableLookUpEntry(ct_0, table_column_id_U2, ct_1) == 0)) || (story_complete))) {
                if (((ExistsTableLookUpEntry(ct_0, table_column_id_U4, ct_1)) || ((~~(call_U51(TableLookUpEntry(ct_0, table_column_id_U5, ct_1))))))) {
                    if (ExistsTableLookUpEntry(ct_0, table_column_id_U1, ct_1)) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say(TableLookUpEntry(ct_0, table_column_id_U1, ct_1));
                        (tmp_0 = (tmp_0 - 1));
                        if ((tmp_0 == 1)) {
                            if (call_U69(use_option_id_U3)) {
                                (say__p = 1);
                                ParaContent();
                                print ",";
                            }
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = ct_0),(((LocalParking-->(2)) = ct_1),(((LocalParking-->(3)) = tmp_1),(((LocalParking-->(4)) = tmp_2),as_block_constant_U139))))));
                        } else {
                            if ((tmp_0 == 0)) {
                                (say__p = 1);
                                ParaContent();
                                print "?";
                                ParaContent();
                                print "^";
                            } else {
                                (say__p = 1);
                                ParaContent();
                                print ", ";
                            }
                        }
                    }
                }
            }
        }
    }
    @pull ct_1;
    @pull ct_0;
    rfalse;
];
[ call_U1031;
    ResponseViaActivity(response_id_U138);
];
[ call_U1032 tmp_0 tmp_1 tmp_2 ct_0 ct_1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Would you like to ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Would you like to ";
    rtrue;
];
[ call_U1033;
    ResponseViaActivity(response_id_U139);
];
[ call_U1034 tmp_0 tmp_1 tmp_2 ct_0 ct_1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ or ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " or ";
    rtrue;
];
[ call_U1035 ct_0 ct_1 tmp_0 tmp_1;
    if (debug_rules) {
        DB_Rule(call_U1035, 412, 0);
    }
    @push ct_0;
    @push ct_1;
    for (((tmp_0 = table_data_U1),((tmp_1 = 1),((ct_0 = tmp_0),(ct_1 = tmp_1)))):(tmp_1 <= TableRows(tmp_0)):((tmp_1)++,((ct_0 = tmp_0),(ct_1 = tmp_1)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            if ((((TableLookUpEntry(ct_0, table_column_id_U2, ct_1) == 0)) || (story_complete))) {
                if (((ExistsTableLookUpEntry(ct_0, table_column_id_U4, ct_1)) || ((~~(call_U51(TableLookUpEntry(ct_0, table_column_id_U5, ct_1))))))) {
                    if (SnippetMatches(players_command, TableLookUpEntry(ct_0, table_column_id_U3, ct_1))) {
                        if (ExistsTableLookUpEntry(ct_0, table_column_id_U4, ct_1)) {
                            if (FollowRulebook(TableLookUpEntry(ct_0, table_column_id_U4, ct_1))) {
                                rtrue;
                            }
                        } else {
                            CarryOutActivity(TableLookUpEntry(ct_0, table_column_id_U5, ct_1));
                        }
                        RulebookSucceeds();
                        rtrue;
                    }
                }
            }
        }
    }
    @pull ct_1;
    @pull ct_0;
    (say__p = 1);
    ParaContent();
    TEXT_TY_Say((((LocalParking-->(0)) = ct_0),(((LocalParking-->(1)) = ct_1),(((LocalParking-->(2)) = tmp_0),(((LocalParking-->(3)) = tmp_1),as_block_constant_U140)))));
    print "^";
    rfalse;
];
[ call_U1036;
    ResponseViaActivity(response_id_U140);
];
[ call_U1037 tmp_0 tmp_1 ct_0 ct_1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Please give one of the answers above.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Please give one of the answers above.";
    rtrue;
];
[ call_U1038 ct_0 ct_1 tmp_0 tmp_1;
    if (debug_rules) {
        DB_Rule(call_U1038, 415, 0);
    }
    ((Global_Vars-->24) = 0);
    @push ct_0;
    @push ct_1;
    for (((tmp_0 = table_data_U2),((tmp_1 = 1),((ct_0 = tmp_0),(ct_1 = tmp_1)))):(tmp_1 <= TableRows(tmp_0)):((tmp_1)++,((ct_0 = tmp_0),(ct_1 = tmp_1)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            TableBlankOutRow(ct_0, ct_1);
        }
    }
    @pull ct_1;
    @pull ct_0;
    rfalse;
];
[ call_U1039 tmp_0;
    if (debug_rules) {
        DB_Rule(call_U1039, 416, 0);
    }
    (tmp_0 = parameter_value);
    CarryOutActivity(V33_choosing_notable_locale_o, tmp_0);
    rfalse;
    rfalse;
];
[ call_U1040 tmp_0 ct_0 ct_1 tmp_1 tmp_2;
    if (debug_rules) {
        DB_Rule(call_U1040, 417, 0);
    }
    (tmp_0 = parameter_value);
    TableSort(table_data_U2, table_column_id_U7, 1);
    @push ct_0;
    @push ct_1;
    for (((tmp_1 = table_data_U2),((tmp_2 = 1),((ct_0 = tmp_1),(ct_1 = tmp_2)))):(tmp_2 <= TableRows(tmp_1)):((tmp_2)++,((ct_0 = tmp_1),(ct_1 = tmp_2)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            CarryOutActivity(V34_printing_a_locale_paragra, TableLookUpEntry(ct_0, table_column_id_U6, ct_1));
        }
    }
    @pull ct_1;
    @pull ct_0;
    rfalse;
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U1041 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1 tmp_4 tmp_5;
    if (debug_rules) {
        DB_Rule(call_U1041, 418, 0);
    }
    (tmp_0 = parameter_value);
    (tmp_1 = 0);
    for (((tmp_2 = (call_U1042)(0)),(tmp_3 = (call_U1042)(tmp_2))):tmp_2:((tmp_2 = tmp_3),(tmp_3 = (call_U1042)(tmp_3)))) {
        call_U284(tmp_2);
    }
    @push ct_0;
    @push ct_1;
    for (((tmp_2 = table_data_U2),((tmp_3 = 1),((ct_0 = tmp_2),(ct_1 = tmp_3)))):(tmp_3 <= TableRows(tmp_2)):((tmp_3)++,((ct_0 = tmp_2),(ct_1 = tmp_3)))) {
        if ((TableRowIsBlank(ct_0, ct_1) == 0)) {
            if ((TableLookUpEntry(ct_0, table_column_id_U7, ct_1) > 0)) {
                call_U283(TableLookUpEntry(ct_0, table_column_id_U6, ct_1));
            }
            (tmp_1 = (tmp_1 + 1));
        }
    }
    @pull ct_1;
    @pull ct_0;
    if ((tmp_1 > 0)) {
        for (((tmp_2 = (call_U1043)(0)),(tmp_3 = (call_U1043)(tmp_2))):tmp_2:((tmp_2 = tmp_3),(tmp_3 = (call_U1043)(tmp_3)))) {
            if (call_U288(tmp_2)) {
                call_U284(tmp_2);
            }
        }
        BeginActivity(V11_listing_nondescript_items, tmp_0);
        if (((call_U1044)() == 0)) {
            AbandonActivity(V11_listing_nondescript_items, tmp_0);
        } else {
            if ((~~(ForActivity(V11_listing_nondescript_items, tmp_0)))) {
                if ((tmp_0 == real_location)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),as_block_constant_U141)))))));
                } else {
                    if ((((tmp_0 ofclass K6_supporter)) || ((tmp_0 ofclass K12_animal)))) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),as_block_constant_U142)))))));
                    } else {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),as_block_constant_U143)))))));
                    }
                }
                if (((Global_Vars-->24) > 0)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),as_block_constant_U144)))))));
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),as_block_constant_U145)))))));
                }
                (tmp_2 = 0);
                (tmp_3 = 1);
                for (((tmp_4 = (call_U1045)(0)),(tmp_5 = (call_U1045)(tmp_4))):tmp_4:((tmp_4 = tmp_5),(tmp_5 = (call_U1045)(tmp_5)))) {
                    if ((~~((HolderOf(tmp_4) == tmp_2)))) {
                        if ((tmp_2 == 0)) {
                            (tmp_2 = HolderOf(tmp_4));
                        } else {
                            (tmp_3 = 0);
                        }
                    }
                    if (call_U288(tmp_4)) {
                        call_U284(tmp_4);
                    }
                }
                (list_filter_routine = call_U1046);
                if ((((tmp_3 == 1)) && ((~~((tmp_2 == 0)))))) {
                    WriteListFrom(child(tmp_2), 2776);
                } else {
                    (say__p = 1);
                    ParaContent();
                    objectloop (tmp_4 ofclass Object && (tmp_4 ofclass Object)) {
                        if ((((tmp_4 ofclass K2_thing)) && (call_U282(tmp_4)))) {
                            give tmp_4 workflag2;
                        } else {
                            give tmp_4 ~workflag2;
                        }
                    }
                    WriteListOfMarkedObjects(((((ENGLISH_BIT + RECURSE_BIT) + PARTINV_BIT) + TERSE_BIT) + CONCEAL_BIT));
                }
                if ((tmp_0 == real_location)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),(((LocalParking-->(4)) = ct_0),(((LocalParking-->(5)) = ct_1),(((LocalParking-->(6)) = tmp_4),(((LocalParking-->(7)) = tmp_5),as_block_constant_U146)))))))));
                }
                (say__p = 1);
                ParaContent();
                print ".";
                ParaContent();
                DivideParagraphPoint();
                print "^";
                (list_filter_routine = 0);
            }
            EndActivity(V11_listing_nondescript_items, tmp_0);
        }
    }
    rfalse;
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U1042 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        return x;
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U1043 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        return x;
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U1044 x x_ix counter;
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if (call_U282(x)) {
            (counter)++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
[ call_U1045 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        if (call_U282(x)) {
            return x;
        }
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U1046 reason x x_ix total counter selection best best_with;
    if ((reason >= 0)) {
        (x = reason);
        (reason = -1);
    }
    switch (reason) {
        -7:
            if ((property_loop_sign > 0)) {
                (best = MIN_NEGATIVE_NUMBER);
            } else {
                (best = MAX_POSITIVE_NUMBER);
            }
            for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                if ((((x ofclass K2_thing)) && (call_U291(x)))) {
                    if ((property_loop_sign > 0)) {
                        if ((_final_propertyvalue(OBJECT_TY, x, property_to_be_totalled) >= best)) {
                            (best = _final_propertyvalue(OBJECT_TY, x, property_to_be_totalled));
                            (best_with = x);
                        }
                    } else {
                        if ((_final_propertyvalue(OBJECT_TY, x, property_to_be_totalled) <= best)) {
                            (best = _final_propertyvalue(OBJECT_TY, x, property_to_be_totalled));
                            (best_with = x);
                        }
                    }
                }
            }
            return best_with;
            ;
        -6:
            for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                if ((((x ofclass K2_thing)) && (call_U291(x)))) {
                    (total = REAL_NUMBER_TY_Plus(total, _final_propertyvalue(OBJECT_TY, x, property_to_be_totalled)));
                    jump NextOuterLoop_7;
                }
                .NextOuterLoop_7;
            }
            return total;
            ;
        -5:
            for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                if ((((x ofclass K2_thing)) && (call_U291(x)))) {
                    (total = (total + _final_propertyvalue(OBJECT_TY, x, property_to_be_totalled)));
                    jump NextOuterLoop_6;
                }
                .NextOuterLoop_6;
            }
            return total;
            ;
        -4:
            (selection = -1);
            while (1) {
                (counter = 0);
                for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                    if ((((x ofclass K2_thing)) && (call_U291(x)))) {
                        (counter)++;
                        if ((counter == selection)) {
                            return x;
                        }
                        jump NextOuterLoop_8;
                    }
                    .NextOuterLoop_8;
                }
                if ((((counter == 0)) || ((selection >= 0)))) {
                    rfalse;
                }
                (selection = random(counter));
            }
            -3:
                for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                    if ((((x ofclass K2_thing)) && (call_U291(x)))) {
                        (counter)++;
                        jump NextOuterLoop_5;
                    }
                    .NextOuterLoop_5;
                }
                return counter;
                ;
            -2:
                if ((x_ix > 0)) {
                    (x_ix)--;
                    jump NextOuterLoop_4;
                }
                if (x) {
                    jump NextOuterLoop_4;
                }
                for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
                    if ((((x ofclass K2_thing)) && (call_U291(x)))) {
                        return x;
                    }
                    .NextOuterLoop_4;
                }
                rfalse;
                ;
            -1:
                if ((((x ofclass K2_thing)) && ((((x ofclass K2_thing)) && (call_U291(x)))))) {
                    rtrue;
                }
                rfalse;
                ;
            ;
    }
];
[ call_U1047;
    ResponseViaActivity(response_id_U141);
];
[ call_U1048 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1049;
    ResponseViaActivity(response_id_U142);
];
[ call_U1050 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    (tmp_3 = (LocalParking-->(3)));
    (ct_0 = (LocalParking-->(4)));
    (ct_1 = (LocalParking-->(5)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~On [the domain] [we] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1051;
    ResponseViaActivity(response_id_U143);
];
[ call_U1052 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    (tmp_3 = (LocalParking-->(3)));
    (ct_0 = (LocalParking-->(4)));
    (ct_1 = (LocalParking-->(5)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~In [the domain] [we] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "In ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1053;
    ResponseViaActivity(response_id_U144);
];
[ call_U1054 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the player][can] also see ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(player);
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " also see ";
    rtrue;
];
[ call_U1055;
    ResponseViaActivity(response_id_U145);
];
[ call_U1056 tmp_0 tmp_1 tmp_2 tmp_3 ct_0 ct_1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the player][can] see ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(player);
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " see ";
    rtrue;
];
[ call_U1057;
    ResponseViaActivity(response_id_U146);
];
[ call_U1058 tmp_0 tmp_1 tmp_2 tmp_3 tmp_4 tmp_5 ct_0 ct_1;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ here~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " here";
    rtrue;
];
[ call_U1059 tmp_0 tmp_1;
    if (debug_rules) {
        DB_Rule(call_U1059, 419, 0);
    }
    (tmp_0 = parameter_value);
    (tmp_1 = child(tmp_0));
    while ((tmp_1 ofclass K2_thing)) {
        call_U1840(tmp_1, 5);
        (tmp_1 = sibling(tmp_1));
    }
    rfalse;
    RulebookSucceeds(0, 0);
    rtrue;
    rfalse;
];
[ call_U1060 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1060, 420, 0);
        }
        if (IndirectlyContains(tmp_0, player)) {
            call_U1840(tmp_0, 0);
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1060, 420, 2);
        }
    }
    rfalse;
];
[ call_U1061 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1061, 421, 0);
        }
        if (call_U264(tmp_0)) {
            call_U1840(tmp_0, 0);
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1061, 421, 2);
        }
    }
    rfalse;
];
[ call_U1062 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1062, 422, 0);
        }
        if (call_U276(tmp_0)) {
            call_U1840(tmp_0, 0);
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1062, 422, 2);
        }
    }
    rfalse;
];
[ call_U1063 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1063, 423, 0);
        }
        if ((~~(call_U288(tmp_0)))) {
            PronounNotice(tmp_0);
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1063, 423, 2);
        }
    }
    rfalse;
];
[ call_U1064 tmp_0;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1064, 424, 0);
        }
        if ((~~(call_U288(tmp_0)))) {
            if (say__p) {
                (say__p = 1);
                ParaContent();
                DivideParagraphPoint();
            }
            CarryOutActivity(V10_writing_a_paragraph_about, tmp_0);
            if (say__p) {
                ((Global_Vars-->24) = ((Global_Vars-->24) + 1));
                call_U289(tmp_0);
                (say__p = 1);
                ParaContent();
                DivideParagraphPoint();
            }
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1064, 424, 2);
        }
    }
    rfalse;
];
[ call_U1065 tmp_0 tmp_1 tmp_2;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1065, 425, 0);
        }
        if ((~~(call_U288(tmp_0)))) {
            if (((ProvidesProperty(OBJECT_TY, tmp_0, A_initial)) && ((((~~(call_U273(tmp_0)))) && ((~~(((BlkValueCompare)(GProperty(OBJECT_TY, tmp_0, A_initial),bc_U64) == 0)))))))) {
                ((Global_Vars-->24) = ((Global_Vars-->24) + 1));
                (say__p = 1);
                ParaContent();
                @push self;
                TEXT_TY_Say(GProperty(OBJECT_TY, (self = tmp_0), A_initial));
                @pull self;
                (say__p = 1);
                ParaContent();
                DivideParagraphPoint();
                print "^";
                if (call_U1066(tmp_0)) {
                    for (((tmp_1 = (call_U1067)(tmp_0,0)),(tmp_2 = (call_U1067)(tmp_0,tmp_1))):tmp_1:((tmp_1 = tmp_2),(tmp_2 = (call_U1067)(tmp_0,tmp_2)))) {
                        call_U283(tmp_1);
                        if (call_U288(tmp_1)) {
                            call_U284(tmp_1);
                        }
                    }
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U147))));
                    WriteListFrom(child(tmp_0), 3800);
                    (say__p = 1);
                    ParaContent();
                    print ".";
                    ParaContent();
                    DivideParagraphPoint();
                    print "^";
                }
                call_U289(tmp_0);
            }
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1065, 425, 2);
        }
    }
    rfalse;
];
[ call_U1066 const_0 x x_ix;
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && (call_U227(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1067 const_0 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                return x;
            }
            .NextOuterLoop_4;
        }
    }
    rfalse;
];
[ call_U1068;
    ResponseViaActivity(response_id_U147);
];
[ call_U1069 tmp_0 tmp_1 tmp_2;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~On [the item] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1070 tmp_0 tmp_1 tmp_2;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K6_supporter)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1070, 426, 0);
        }
        for (((tmp_1 = (call_U1071)(tmp_0,tmp_0,tmp_0,0)),(tmp_2 = (call_U1071)(tmp_0,tmp_0,tmp_0,tmp_1))):tmp_1:((tmp_1 = tmp_2),(tmp_2 = (call_U1071)(tmp_0,tmp_0,tmp_0,tmp_2)))) {
            if ((((~~((tmp_1 ofclass K8_person)))) && ((((~~(((BlkValueCompare)(GProperty(OBJECT_TY, tmp_1, A_initial),bc_U65) == 0)))) && ((~~(call_U276(tmp_1)))))))) {
                call_U289(tmp_1);
                (say__p = 1);
                ParaContent();
                @push self;
                TEXT_TY_Say(GProperty(OBJECT_TY, (self = tmp_1), A_initial));
                @pull self;
                (say__p = 1);
                ParaContent();
                DivideParagraphPoint();
                print "^";
            }
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1070, 426, 2);
        }
    }
    rfalse;
];
[ call_U1071 const_0 const_1 const_2 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    objectloop (x in const_2) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && ((((~~(call_U273(x)))) && ((((const_0 ofclass K6_supporter)) && (ProvidesProperty(OBJECT_TY, const_1, A_initial)))))))) {
                return x;
            }
            .NextOuterLoop_4;
        }
    }
    rfalse;
];
[ call_U1072 tmp_0 tmp_1 tmp_2;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1072, 428, 0);
        }
        if (((call_U264(tmp_0)) && ((~~(IndirectlyContains(tmp_0, player)))))) {
            if (call_U1073(tmp_0)) {
                PronounNotice(tmp_0);
                for (((tmp_1 = (call_U1074)(tmp_0,0)),(tmp_2 = (call_U1074)(tmp_0,tmp_1))):tmp_1:((tmp_1 = tmp_2),(tmp_2 = (call_U1074)(tmp_0,tmp_2)))) {
                    call_U283(tmp_1);
                    if (call_U288(tmp_1)) {
                        call_U284(tmp_1);
                    }
                }
                ((Global_Vars-->24) = ((Global_Vars-->24) + 1));
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U148))));
                WriteListFrom(child(tmp_0), 3800);
                (say__p = 1);
                ParaContent();
                print ".";
                ParaContent();
                DivideParagraphPoint();
                print "^";
            }
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1072, 428, 2);
        }
    }
    rfalse;
];
[ call_U1073 const_0 x x_ix;
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && (call_U227(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1074 const_0 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                return x;
            }
            .NextOuterLoop_4;
        }
    }
    rfalse;
];
[ call_U1075;
    ResponseViaActivity(response_id_U148);
];
[ call_U1076 tmp_0 tmp_1 tmp_2;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~On [the item] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1077 tmp_0 tmp_1 tmp_2;
    if (((((tmp_0 = parameter_value),(((parameter_value ofclass K2_thing)) && (((tmp_0 = parameter_value),1))))) || (((tmp_0 = 0),0)))) {
        if (debug_rules) {
            DB_Rule(call_U1077, 429, 0);
        }
        if (((call_U288(tmp_0)) && ((((~~(call_U276(tmp_0)))) && ((((~~(call_U264(tmp_0)))) && ((~~(IndirectlyContains(tmp_0, player)))))))))) {
            if (call_U1078(tmp_0)) {
                PronounNotice(tmp_0);
                for (((tmp_1 = (call_U1079)(tmp_0,0)),(tmp_2 = (call_U1079)(tmp_0,tmp_1))):tmp_1:((tmp_1 = tmp_2),(tmp_2 = (call_U1079)(tmp_0,tmp_2)))) {
                    call_U283(tmp_1);
                    if (call_U288(tmp_1)) {
                        call_U284(tmp_1);
                    }
                }
                ((Global_Vars-->24) = ((Global_Vars-->24) + 1));
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U149))));
                WriteListFrom(child(tmp_0), 3800);
                (say__p = 1);
                ParaContent();
                print ".";
                ParaContent();
                DivideParagraphPoint();
                print "^";
            }
        }
        rfalse;
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1077, 429, 2);
        }
    }
    rfalse;
];
[ call_U1078 const_0 x x_ix;
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && (call_U227(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1079 const_0 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                return x;
            }
            .NextOuterLoop_4;
        }
    }
    rfalse;
];
[ call_U1080;
    ResponseViaActivity(response_id_U149);
];
[ call_U1081 tmp_0 tmp_1 tmp_2;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~On [the item] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1082;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1082, 430, 0);
        }
        if ((child(player) == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U150);
            print "^";
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1082, 430, 3);
        }
    }
    rfalse;
];
[ call_U1083;
    ResponseViaActivity(response_id_U150);
];
[ call_U1084;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [are] carrying nothing.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carrying nothing.";
    rtrue;
];
[ call_U1085;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1085, 431, 0);
        }
        (say__p = 1);
        ParaContent();
        TEXT_TY_Say(as_block_constant_U151);
        WriteListFrom(child(player), 8215);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1085, 431, 3);
        }
    }
    rfalse;
];
[ call_U1086;
    ResponseViaActivity(response_id_U151);
];
[ call_U1087;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [are] carrying:[line break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carrying:";
    ParaContent();
    print "^";
    rtrue;
];
[ call_U1088;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1088, 432, 0);
        }
        if ((((~~((actor == player)))) && ((keep_silent == 0)))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U152);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1088, 432, 2);
        }
    }
    rfalse;
];
[ call_U1089;
    ResponseViaActivity(response_id_U152);
];
[ call_U1090;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [look] through [their] possessions.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb9(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " through ";
    ParaContent();
    call_U183();
    ParaContent();
    print " possessions.";
    rtrue;
];
[ call_U1091;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1091, 433, 0);
        }
        if ((actor == noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U153);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1091, 433, 2);
        }
    }
    rfalse;
];
[ call_U1092;
    ResponseViaActivity(response_id_U153);
];
[ call_U1093;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [are] always self-possessed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " always self-possessed.";
    rtrue;
];
[ call_U1094;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1094, 434, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U154);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1094, 434, 2);
        }
    }
    rfalse;
];
[ call_U1095;
    ResponseViaActivity(response_id_U154);
];
[ call_U1096;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~I don't suppose [the noun] [would care] for that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "I don't suppose ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb11);
    (say__p = 1);
    ParaContent();
    print " for that.";
    rtrue;
];
[ call_U1097 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1097, 435, 0);
        }
        if ((((PartOf(noun) ofclass K2_thing)) && (((tmp_0 = PartOf(noun)),1)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U155));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1097, 435, 2);
        }
    }
    rfalse;
];
[ call_U1098;
    ResponseViaActivity(response_id_U155);
];
[ call_U1099 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [seem] to be a part of [the whole].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U178();
    ParaContent();
    print " ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to be a part of ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1100 tmp_0 tmp_1;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1100, 436, 0);
        }
        (tmp_0 = CommonAncestor(actor, noun));
        (tmp_1 = CoreOfParentOfCoreOf(noun));
        while ((((~~((tmp_1 == 0)))) && ((~~((tmp_1 == tmp_0)))))) {
            if ((tmp_1 ofclass K8_person)) {
                if ((actor == player)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U156)));
                    print "^";
                }
                rtrue;
            }
            (tmp_1 = CoreOfParentOfCoreOf(tmp_1));
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1100, 436, 2);
        }
    }
    rfalse;
];
[ call_U1101;
    ResponseViaActivity(response_id_U156);
];
[ call_U1102 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [seem] to belong to [the owner].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U178();
    ParaContent();
    print " ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to belong to ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1103 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1103, 437, 0);
        }
        (tmp_0 = noun);
        while ((((~~((tmp_0 == 0)))) && ((~~((tmp_0 ofclass K1_room)))))) {
            (tmp_0 = CoreOfParentOfCoreOf(tmp_0));
        }
        if ((tmp_0 == 0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U157));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1103, 437, 2);
        }
    }
    rfalse;
];
[ call_U1104;
    ResponseViaActivity(response_id_U157);
];
[ call_U1105 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [aren't] available.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U178();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " available.";
    rtrue;
];
[ call_U1106 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1106, 438, 0);
        }
        (tmp_0 = CommonAncestor(actor, noun));
        if ((tmp_0 == noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U158));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1106, 438, 2);
        }
    }
    rfalse;
];
[ call_U1107;
    ResponseViaActivity(response_id_U158);
];
[ call_U1108 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [would have] to get^[if noun is a supporter]off[otherwise]out of[end if] [the noun] first.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb4);
    (say__p = 1);
    ParaContent();
    print " to get ";
    if ((~~((noun ofclass K6_supporter)))) {
        jump L_Say0;
    }
    ParaContent();
    print "off";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "out of";
    .L_SayX0;
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " first.";
    rtrue;
];
[ call_U1109;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1109, 439, 0);
        }
        if ((((actor == CarrierOf(noun))) || ((actor == WearerOf(noun))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U159);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1109, 439, 2);
        }
    }
    rfalse;
];
[ call_U1110;
    ResponseViaActivity(response_id_U159);
];
[ call_U1111;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] already [have] [regarding the noun][those].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " already ";
    ConjugateVerb4(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U177();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1112;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1112, 440, 0);
        }
        if (call_U264(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U160);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1112, 440, 2);
        }
    }
    rfalse;
];
[ call_U1113;
    ResponseViaActivity(response_id_U160);
];
[ call_U1114;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] hardly portable.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U192();
    ParaContent();
    print " hardly portable.";
    rtrue;
];
[ call_U1115;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1115, 441, 0);
        }
        if ((~~((noun ofclass K2_thing)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U161);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1115, 441, 2);
        }
    }
    rfalse;
];
[ call_U1116;
    ResponseViaActivity(response_id_U161);
];
[ call_U1117;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [cannot] carry [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carry ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1118;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1118, 442, 0);
        }
        if (call_U258(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U162);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1118, 442, 2);
        }
    }
    rfalse;
];
[ call_U1119;
    ResponseViaActivity(response_id_U162);
];
[ call_U1120;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] fixed in place.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U192();
    ParaContent();
    print " fixed in place.";
    rtrue;
];
[ call_U1121 tmp_0 tmp_1 tmp_2 tmp_3;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1121, 443, 0);
        }
        if (((call_U1122)() >= GProperty(OBJECT_TY, actor, A_capacity))) {
            if (((((call_U1123()) && (((tmp_0 = (LocalParking-->(0))),1)))) || (((tmp_0 = 0),0)))) {
                (tmp_1 = 0);
                for (((tmp_2 = (call_U1124)(0)),(tmp_3 = (call_U1124)(tmp_2))):tmp_2:((tmp_2 = tmp_3),(tmp_3 = (call_U1124)(tmp_3)))) {
                    if ((((~~(call_U246(tmp_2)))) && ((~~((tmp_2 == tmp_0)))))) {
                        (tmp_1 = tmp_2);
                    }
                }
                if ((~~((tmp_1 == 0)))) {
                    if ((actor == player)) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),(((LocalParking-->(3)) = tmp_3),as_block_constant_U163)))));
                    }
                    @push keep_silent;
                    (keep_silent = 1);
                    @push say__p;
                    @push say__pc;
                    ClearParagraphing(1);
                    TryAction(0, actor, ##Insert, tmp_1, tmp_0);
                    DivideParagraphPoint();
                    @pull say__pc;
                    @pull say__p;
                    AdjustParagraphPoint();
                    @pull keep_silent;
                    if ((~~((tmp_0 == ContainerOf(tmp_1))))) {
                        rtrue;
                    }
                }
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1121, 443, 2);
        }
    }
    rfalse;
];
[ call_U1122 x x_ix counter;
    objectloop (x in actor) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1123 x x_ix;
    for ((x = 0):0:) {
        if ((actor == HolderOf(x))) {
            ((LocalParking-->(0)) = x);
            rtrue;
        }
    }
    rfalse;
];
[ call_U1124 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    objectloop (x in actor) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                return x;
            }
            .NextOuterLoop_4;
        }
    }
    rfalse;
];
[ call_U1125;
    ResponseViaActivity(response_id_U163);
];
[ call_U1126 tmp_1 tmp_0 tmp_2 tmp_3;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    (tmp_3 = (LocalParking-->(3)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(putting [the transferred item] into [the current working sack]^to make room)[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(putting ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print " into ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " to make room)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1127;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1127, 444, 0);
        }
        if (((call_U1128)() >= GProperty(OBJECT_TY, actor, A_capacity))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U164);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1127, 444, 2);
        }
    }
    rfalse;
];
[ call_U1128 x x_ix counter;
    objectloop (x in actor) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1129;
    ResponseViaActivity(response_id_U164);
];
[ call_U1130;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We]['re] carrying too many things already.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carrying too many things already.";
    rtrue;
];
[ call_U1131;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1131, 445, 0);
        }
        MoveObject(noun, actor);
        if ((actor == player)) {
            call_U274(noun);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1131, 445, 2);
        }
    }
    rfalse;
];
[ call_U1132;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1132, 446, 0);
        }
        if ((keep_silent == 0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U165);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U166);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1132, 446, 2);
        }
    }
    rfalse;
];
[ call_U1133;
    ResponseViaActivity(response_id_U165);
];
[ call_U1134;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Taken.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Taken.";
    rtrue;
];
[ call_U1135;
    ResponseViaActivity(response_id_U166);
];
[ call_U1136;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [pick] up [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb12(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " up ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1137;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1137, 447, 0);
        }
        if ((~~((HolderOf(noun) == second)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U167);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1137, 447, 2);
        }
    }
    rfalse;
];
[ call_U1138;
    ResponseViaActivity(response_id_U167);
];
[ call_U1139;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~But [regarding the noun][they] [aren't] there now.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U181();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " there now.";
    rtrue;
];
[ call_U1140 tmp_0;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1140, 448, 0);
        }
        (tmp_0 = HolderOf(noun));
        if ((tmp_0 ofclass K8_person)) {
            if ((tmp_0 == actor)) {
                return GVS_Convert(##Disrobe, noun, 0);
            }
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U168));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1140, 448, 2);
        }
    }
    rfalse;
];
[ call_U1141;
    ResponseViaActivity(response_id_U168);
];
[ call_U1142 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [seem] to belong to [the owner].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U178();
    ParaContent();
    print " ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to belong to ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1143;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1143, 449, 0);
        }
        return GVS_Convert(##Take, noun, 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1143, 449, 2);
        }
    }
    rfalse;
];
[ call_U1144;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1144, 450, 0);
        }
        if ((noun == actor)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U169);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1144, 450, 2);
        }
    }
    rfalse;
];
[ call_U1145;
    ResponseViaActivity(response_id_U169);
];
[ call_U1146;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [lack] the dexterity.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb13(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " the dexterity.";
    rtrue;
];
[ call_U1147;
    if ((((act_requester == 0)) && ((((noun ofclass K2_thing)) && ((actor == PartOf(noun))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1147, 451, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U170);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1147, 451, 2);
        }
    }
    rfalse;
];
[ call_U1148;
    ResponseViaActivity(response_id_U170);
];
[ call_U1149;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't drop] part of [ourselves].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb14);
    (say__p = 1);
    ParaContent();
    print " part of ";
    ParaContent();
    call_U170();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1150;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1150, 452, 0);
        }
        if ((HolderOf(actor) == ContainerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U171);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1150, 452, 2);
        }
    }
    rfalse;
];
[ call_U1151;
    ResponseViaActivity(response_id_U171);
];
[ call_U1152;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [are] already here.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already here.";
    rtrue;
];
[ call_U1153;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1153, 453, 0);
        }
        if ((actor == CarrierOf(noun))) {
            rfalse;
        }
        if ((actor == WearerOf(noun))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U172);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1153, 453, 2);
        }
    }
    rfalse;
];
[ call_U1154;
    ResponseViaActivity(response_id_U172);
];
[ call_U1155;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [haven't] got [regarding the noun][those].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb15(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " got ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U177();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1156;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1156, 454, 0);
        }
        if ((actor == WearerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U173);
            }
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Disrobe, noun, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1156, 454, 2);
        }
    }
    rfalse;
];
[ call_U1157;
    ResponseViaActivity(response_id_U173);
];
[ call_U1158;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first taking [the noun] off)[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1159 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1159, 455, 0);
        }
        (tmp_0 = HolderOf(actor));
        if ((tmp_0 ofclass K1_room)) {
            rfalse;
        }
        if (ProvidesProperty(OBJECT_TY, tmp_0, A_capacity)) {
            if ((tmp_0 ofclass K6_supporter)) {
                if (((call_U1160)(tmp_0) >= GProperty(OBJECT_TY, tmp_0, A_capacity))) {
                    if ((actor == player)) {
                        (prior_named_noun = 0);
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U174));
                        print "^";
                    }
                    rtrue;
                }
            } else {
                if ((tmp_0 ofclass K5_container)) {
                    if (((call_U1161)(tmp_0) >= GProperty(OBJECT_TY, tmp_0, A_capacity))) {
                        if ((actor == player)) {
                            (prior_named_noun = 0);
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U175));
                            print "^";
                        }
                        rtrue;
                    }
                }
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1159, 455, 2);
        }
    }
    rfalse;
];
[ call_U1160 const_0 x x_ix counter;
    objectloop (x in const_0) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1161 const_0 x x_ix counter;
    for ((x = TestContainmentRange(const_0)):x:(x = TestContainmentRange(const_0, x))) {
        if ((x ofclass K2_thing)) {
            (counter)++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
[ call_U1162;
    ResponseViaActivity(response_id_U174);
];
[ call_U1163 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no more room on [the receptacle].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U194();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room on ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1164;
    ResponseViaActivity(response_id_U175);
];
[ call_U1165 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no more room in [the receptacle].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U194();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room in ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1166;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1166, 456, 0);
        }
        MoveObject(noun, HolderOf(actor));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1166, 456, 2);
        }
    }
    rfalse;
];
[ call_U1167;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1167, 457, 0);
        }
        if ((keep_silent == 0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U176);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U177);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1167, 457, 2);
        }
    }
    rfalse;
];
[ call_U1168;
    ResponseViaActivity(response_id_U176);
];
[ call_U1169;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Dropped.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Dropped.";
    rtrue;
];
[ call_U1170;
    ResponseViaActivity(response_id_U177);
];
[ call_U1171;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [put] down [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb16(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " down ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1172;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1172, 458, 0);
        }
        if ((((second == I_down_U1)) || ((second == SupporterOf(actor))))) {
            return GVS_Convert(##Drop, noun, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1172, 458, 2);
        }
    }
    rfalse;
];
[ call_U1173;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1173, 459, 0);
        }
        if ((actor == CarrierOf(noun))) {
            rfalse;
        }
        if ((actor == WearerOf(noun))) {
            rfalse;
        }
        CarryOutActivity(V28_implicitly_taking, noun);
        if ((actor == CarrierOf(noun))) {
            rfalse;
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1173, 459, 2);
        }
    }
    rfalse;
];
[ call_U1174 tmp_0 tmp_1 tmp_2;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1174, 460, 0);
        }
        (tmp_0 = CoreOf(noun));
        (tmp_1 = CoreOf(second));
        (tmp_2 = CommonAncestor(tmp_0, tmp_1));
        if ((tmp_2 == tmp_0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U178))));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1174, 460, 2);
        }
    }
    rfalse;
];
[ call_U1175;
    ResponseViaActivity(response_id_U178);
];
[ call_U1176 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't put] something on top of itself.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb16);
    (say__p = 1);
    ParaContent();
    print " something on top of itself.";
    rtrue;
];
[ call_U1177;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1177, 461, 0);
        }
        if ((~~((second ofclass K6_supporter)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U179);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1177, 461, 2);
        }
    }
    rfalse;
];
[ call_U1178;
    ResponseViaActivity(response_id_U179);
];
[ call_U1179;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Putting things on [the second noun] [would achieve] nothing.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Putting things on ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb17);
    (say__p = 1);
    ParaContent();
    print " nothing.";
    rtrue;
];
[ call_U1180;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1180, 462, 0);
        }
        if ((actor == WearerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U180);
            }
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Disrobe, noun, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1180, 462, 2);
        }
    }
    rfalse;
];
[ call_U1181;
    ResponseViaActivity(response_id_U180);
];
[ call_U1182;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first taking [regarding the noun][them] off)[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U185();
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1183;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1183, 463, 0);
        }
        if (ProvidesProperty(OBJECT_TY, second, A_capacity)) {
            if (((call_U1184)() >= GProperty(OBJECT_TY, second, A_capacity))) {
                if ((actor == player)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U181);
                    print "^";
                }
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1183, 463, 2);
        }
    }
    rfalse;
];
[ call_U1184 x x_ix counter;
    objectloop (x in second) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1185;
    ResponseViaActivity(response_id_U181);
];
[ call_U1186;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no more room on [the second noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U194();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room on ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1187;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1187, 464, 0);
        }
        MoveObject(noun, second);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1187, 464, 2);
        }
    }
    rfalse;
];
[ call_U1188;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1188, 465, 0);
        }
        if ((keep_silent == 0)) {
            if ((((actor == player)) && ((multiflag == 1)))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U182);
                print "^";
                rtrue;
            }
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1188, 465, 2);
        }
    }
    rfalse;
];
[ call_U1189;
    ResponseViaActivity(response_id_U182);
];
[ call_U1190;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Done.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Done.";
    rtrue;
];
[ call_U1191;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1191, 466, 0);
        }
        if ((keep_silent == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U183);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1191, 466, 2);
        }
    }
    rfalse;
];
[ call_U1192;
    ResponseViaActivity(response_id_U183);
];
[ call_U1193;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [put] [the noun] on [the second noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb16(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " on ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1194;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1194, 467, 0);
        }
        if ((((second == I_down_U1)) || ((second == ContainerOf(actor))))) {
            return GVS_Convert(##Drop, noun, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1194, 467, 2);
        }
    }
    rfalse;
];
[ call_U1195;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1195, 468, 0);
        }
        if ((second == ContainerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U184);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1195, 468, 2);
        }
    }
    rfalse;
];
[ call_U1196;
    ResponseViaActivity(response_id_U184);
];
[ call_U1197;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [are] already there.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already there.";
    rtrue;
];
[ call_U1198 tmp_0 tmp_1 tmp_2;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1198, 469, 0);
        }
        (tmp_0 = CoreOf(noun));
        (tmp_1 = CoreOf(second));
        (tmp_2 = CommonAncestor(tmp_0, tmp_1));
        if ((tmp_2 == tmp_0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U185))));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1198, 469, 2);
        }
    }
    rfalse;
];
[ call_U1199;
    ResponseViaActivity(response_id_U185);
];
[ call_U1200 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't put] something inside itself.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb16);
    (say__p = 1);
    ParaContent();
    print " something inside itself.";
    rtrue;
];
[ call_U1201;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1201, 470, 0);
        }
        if ((actor == CarrierOf(noun))) {
            rfalse;
        }
        if ((actor == WearerOf(noun))) {
            rfalse;
        }
        CarryOutActivity(V28_implicitly_taking, noun);
        if ((actor == CarrierOf(noun))) {
            rfalse;
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1201, 470, 2);
        }
    }
    rfalse;
];
[ call_U1202;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1202, 471, 0);
        }
        if ((((second ofclass K5_container)) && (call_U306(second)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U186);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1202, 471, 2);
        }
    }
    rfalse;
];
[ call_U1203;
    ResponseViaActivity(response_id_U186);
];
[ call_U1204;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The second noun] [are] closed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " closed.";
    rtrue;
];
[ call_U1205;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1205, 472, 0);
        }
        if ((~~((second ofclass K5_container)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U187);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1205, 472, 2);
        }
    }
    rfalse;
];
[ call_U1206;
    ResponseViaActivity(response_id_U187);
];
[ call_U1207;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the second noun][Those] [can't contain] things.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(second);
    ParaContent();
    call_U178();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb18);
    (say__p = 1);
    ParaContent();
    print " things.";
    rtrue;
];
[ call_U1208;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1208, 473, 0);
        }
        if ((actor == WearerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U188);
            }
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Disrobe, noun, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1208, 473, 2);
        }
    }
    rfalse;
];
[ call_U1209;
    ResponseViaActivity(response_id_U188);
];
[ call_U1210;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first taking [regarding the noun][them] off)[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U185();
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1211;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1211, 474, 0);
        }
        if (ProvidesProperty(OBJECT_TY, second, A_capacity)) {
            if (((call_U1212)() >= GProperty(OBJECT_TY, second, A_capacity))) {
                if ((actor == player)) {
                    (prior_named_noun = 0);
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U189);
                    print "^";
                }
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1211, 474, 2);
        }
    }
    rfalse;
];
[ call_U1212 x x_ix counter;
    for ((x = TestContainmentRange(second)):x:(x = TestContainmentRange(second, x))) {
        if ((x ofclass K2_thing)) {
            (counter)++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
[ call_U1213;
    ResponseViaActivity(response_id_U189);
];
[ call_U1214;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no more room in [the second noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U194();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room in ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1215;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1215, 475, 0);
        }
        MoveObject(noun, second);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1215, 475, 2);
        }
    }
    rfalse;
];
[ call_U1216;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1216, 476, 0);
        }
        if ((keep_silent == 0)) {
            if ((((actor == player)) && ((multiflag == 1)))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U190);
                print "^";
                rtrue;
            }
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1216, 476, 2);
        }
    }
    rfalse;
];
[ call_U1217;
    ResponseViaActivity(response_id_U190);
];
[ call_U1218;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Done.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Done.";
    rtrue;
];
[ call_U1219;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1219, 477, 0);
        }
        if ((keep_silent == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U191);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1219, 477, 2);
        }
    }
    rfalse;
];
[ call_U1220;
    ResponseViaActivity(response_id_U191);
];
[ call_U1221;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [put] [the noun] into [the second noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb16(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " into ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1222;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1222, 478, 0);
        }
        if ((((~~((noun ofclass K2_thing)))) || ((~~(call_U252(noun)))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U192);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1222, 478, 2);
        }
    }
    rfalse;
];
[ call_U1223;
    ResponseViaActivity(response_id_U192);
];
[ call_U1224;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] plainly inedible.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U192();
    ParaContent();
    print " plainly inedible.";
    rtrue;
];
[ call_U1225;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1225, 479, 0);
        }
        if ((actor == WearerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U193);
            }
            TryAction(0, actor, ##Disrobe, noun, 0);
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1225, 479, 2);
        }
    }
    rfalse;
];
[ call_U1226;
    ResponseViaActivity(response_id_U193);
];
[ call_U1227;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first taking [the noun] off)[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1228 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1228, 480, 0);
        }
        if ((((~~((actor == HolderOf(noun))))) && (call_U1229()))) {
            (tmp_0 = HolderOf(noun));
            while ((~~((tmp_0 ofclass K8_person)))) {
                (tmp_0 = HolderOf(tmp_0));
            }
            if ((~~((tmp_0 == actor)))) {
                if ((((actor == player)) && ((keep_silent == 0)))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U194));
                    print "^";
                }
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1228, 480, 2);
        }
    }
    rfalse;
];
[ call_U1229 x x_ix;
    for ((x = K8_person_First):x:(x = (x.K8_person_Next))) {
        if (IndirectlyContains(x, noun)) {
            rtrue;
        }
    }
    rfalse;
];
[ call_U1230;
    ResponseViaActivity(response_id_U194);
];
[ call_U1231 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The owner] [might not appreciate] that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(tmp_0);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb20);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1232;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1232, 481, 0);
        }
        if (((call_U261(noun)) && ((~~((actor == CarrierOf(noun))))))) {
            CarryOutActivity(V28_implicitly_taking, noun);
            if ((~~((actor == CarrierOf(noun))))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1232, 481, 2);
        }
    }
    rfalse;
];
[ call_U1233;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1233, 482, 0);
        }
        RemoveFromPlay(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1233, 482, 2);
        }
    }
    rfalse;
];
[ call_U1234;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1234, 483, 0);
        }
        if ((keep_silent == 0)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U195);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U196);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1234, 483, 2);
        }
    }
    rfalse;
];
[ call_U1235;
    ResponseViaActivity(response_id_U195);
];
[ call_U1236;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [eat] [the noun]. Not bad.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb21(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ". Not bad.";
    rtrue;
];
[ call_U1237;
    ResponseViaActivity(response_id_U196);
];
[ call_U1238;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [eat] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb21(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1239 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U1());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U1 tmp_0 tmp_1 tmp_2;
    if ((action == ##Go)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1239, 484, 0);
        }
        ((MStack-->(MstVO(var_id_U42, 4))) = move_pushing);
        ((MStack-->(MstVO(var_id_U42, 0))) = LocationOf(actor));
        if ((((ContainerOf(actor) ofclass K14_vehicle)) && (((call_U294(ContainerOf(actor))) && (((tmp_0 = ContainerOf(actor)),1)))))) {
            ((MStack-->(MstVO(var_id_U42, 3))) = tmp_0);
        }
        (tmp_1 = 0);
        if ((noun ofclass K3_direction)) {
            (tmp_2 = noun);
            (tmp_1 = (
                ! This evaluates last
                formal_rv+
                0*(
                    ! This evaluates second
                    ((
                        (((((((formal_par0 ofclass K3_direction)) && ((formal_par0 ofclass K3_direction)))) && ((((formal_rv = RoomOrDoorFrom(formal_par1, formal_par0)))|(1))))) || (ArgumentTypeFailed(1815, 6)))
                    ))
                +
                    ! This evaluate first
                    (((formal_par1 = (MStack-->(MstVO(var_id_U42, 0)))) + (formal_par0 = tmp_2))))
            )
            );
        } else {
            if ((noun ofclass K4_door)) {
                (tmp_1 = noun);
            }
        }
        if ((tmp_1 ofclass K4_door)) {
            ((MStack-->(MstVO(var_id_U42, 2))) = tmp_1);
            (tmp_1 = (
                ! This evaluates last
                formal_rv+
                0*(
                    ! This evaluates second
                    ((
                        (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, formal_par1)))|(1))))) || (ArgumentTypeFailed(1820, 6)))
                    ))
                +
                    ! This evaluate first
                    (((formal_par1 = (MStack-->(MstVO(var_id_U42, 0)))) + (formal_par0 = tmp_1))))
            )
            );
        }
        ((MStack-->(MstVO(var_id_U42, 1))) = tmp_1);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1239, 484, 2);
        }
    }
    rfalse;
];
[ call_U1240 tmp_0;
    if ((((act_requester == 0)) && (((((self = actor),1)) && ((((SupporterOf(actor) ofclass K6_supporter)) && (((tmp_0 = SupporterOf(actor)),1)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1240, 485, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U197));
        }
        @push keep_silent;
        (keep_silent = 1);
        @push say__p;
        @push say__pc;
        ClearParagraphing(1);
        TryAction(0, actor, ##Exit, 0, 0);
        DivideParagraphPoint();
        @pull say__pc;
        @pull say__p;
        AdjustParagraphPoint();
        @pull keep_silent;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1240, 485, 2);
        }
    }
    rfalse;
];
[ call_U1241;
    ResponseViaActivity(response_id_U197);
];
[ call_U1242 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first getting off [the chaise])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first getting off ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1243 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1243, 486, 0);
        }
        (tmp_0 = HolderOf(actor));
        if ((tmp_0 == (MStack-->(MstVO(var_id_U42, 0))))) {
            rfalse;
        }
        if ((tmp_0 == (MStack-->(MstVO(var_id_U42, 3))))) {
            rfalse;
        }
        if ((actor == player)) {
            if ((tmp_0 ofclass K6_supporter)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U198));
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U199));
                print "^";
            }
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1243, 486, 2);
        }
    }
    rfalse;
];
[ call_U1244;
    ResponseViaActivity(response_id_U198);
];
[ call_U1245 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [would have] to get off [the nonvehicle] first.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb4);
    (say__p = 1);
    ParaContent();
    print " to get off ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " first.";
    rtrue;
];
[ call_U1246;
    ResponseViaActivity(response_id_U199);
];
[ call_U1247 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [would have] to get out of [the nonvehicle] first.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb4);
    (say__p = 1);
    ParaContent();
    print " to get out of ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print " first.";
    rtrue;
];
[ call_U1248;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1248, 487, 0);
        }
        if ((((~~(((MStack-->(MstVO(var_id_U42, 2))) == 0)))) && (call_U276((MStack-->(MstVO(var_id_U42, 2))))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U200);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1248, 487, 2);
        }
    }
    rfalse;
];
[ call_U1249;
    ResponseViaActivity(response_id_U200);
];
[ call_U1250;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't go] that way.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb22);
    (say__p = 1);
    ParaContent();
    print " that way.";
    rtrue;
];
[ call_U1251;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1251, 488, 0);
        }
        if ((((~~(((MStack-->(MstVO(var_id_U42, 2))) == 0)))) && (call_U306((MStack-->(MstVO(var_id_U42, 2))))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U201);
            }
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Open, (MStack-->(MstVO(var_id_U42, 2))), 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if (call_U303((MStack-->(MstVO(var_id_U42, 2))))) {
                rfalse;
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1251, 488, 2);
        }
    }
    rfalse;
];
[ call_U1252;
    ResponseViaActivity(response_id_U201);
];
[ call_U1253;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first opening [the door gone through])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first opening ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 2))));
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1254 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U2());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U2 tmp_0 tmp_1;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1254, 489, 0);
        }
        (tmp_0 = 0);
        if ((noun ofclass K3_direction)) {
            (tmp_1 = noun);
            (tmp_0 = (
                ! This evaluates last
                formal_rv+
                0*(
                    ! This evaluates second
                    ((
                        (((((((formal_par0 ofclass K3_direction)) && ((formal_par0 ofclass K3_direction)))) && ((((formal_rv = RoomOrDoorFrom(formal_par1, formal_par0)))|(1))))) || (ArgumentTypeFailed(1858, 6)))
                    ))
                +
                    ! This evaluate first
                    (((formal_par1 = (MStack-->(MstVO(var_id_U42, 0)))) + (formal_par0 = tmp_1))))
            )
            );
        } else {
            if ((noun ofclass K4_door)) {
                (tmp_0 = noun);
            }
        }
        if ((tmp_0 ofclass K4_door)) {
            (tmp_0 = (
                ! This evaluates last
                formal_rv+
                0*(
                    ! This evaluates second
                    ((
                        (((((((formal_par0 ofclass K4_door)) && ((formal_par0 ofclass K4_door)))) && ((((formal_rv = OtherSideOfDoor(formal_par0, formal_par1)))|(1))))) || (ArgumentTypeFailed(1862, 6)))
                    ))
                +
                    ! This evaluate first
                    (((formal_par1 = (MStack-->(MstVO(var_id_U42, 0)))) + (formal_par0 = tmp_0))))
            )
            );
        }
        ((MStack-->(MstVO(var_id_U42, 1))) = tmp_0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1254, 489, 2);
        }
    }
    rfalse;
];
[ call_U1255;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1255, 490, 0);
        }
        if (((MStack-->(MstVO(var_id_U42, 1))) == 0)) {
            if (((MStack-->(MstVO(var_id_U42, 2))) == 0)) {
                if ((actor == player)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U202);
                    print "^";
                }
                rtrue;
            }
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U203);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1255, 490, 2);
        }
    }
    rfalse;
];
[ call_U1256;
    ResponseViaActivity(response_id_U202);
];
[ call_U1257;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't go] that way.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb22);
    (say__p = 1);
    ParaContent();
    print " that way.";
    rtrue;
];
[ call_U1258;
    ResponseViaActivity(response_id_U203);
];
[ call_U1259;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't], since [the door gone through] [lead] nowhere.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ", since ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 2))));
    ParaContent();
    print " ";
    ConjugateVerb23(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nowhere.";
    rtrue;
];
[ call_U1260;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1260, 491, 0);
        }
        if (((MStack-->(MstVO(var_id_U42, 3))) == 0)) {
            MoveDuringGoing(actor, (MStack-->(MstVO(var_id_U42, 1))));
        } else {
            MoveDuringGoing((MStack-->(MstVO(var_id_U42, 3))), (MStack-->(MstVO(var_id_U42, 1))));
        }
        if ((~~((real_location == LocationOf(player))))) {
            (real_location = LocationOf(player));
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1260, 491, 2);
        }
    }
    rfalse;
];
[ call_U1261;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1261, 492, 0);
        }
        if ((((actor == player)) || (((((MStack-->(MstVO(var_id_U42, 3))) == ContainerOf(player))) || (((MStack-->(MstVO(var_id_U42, 4))) == ContainerOf(player))))))) {
            MoveFloatingObjects();
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1261, 492, 2);
        }
    }
    rfalse;
];
[ call_U1262;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1262, 493, 0);
        }
        if ((((actor == player)) || (((((MStack-->(MstVO(var_id_U42, 3))) == ContainerOf(player))) || (((MStack-->(MstVO(var_id_U42, 4))) == ContainerOf(player))))))) {
            SilentlyConsiderLight();
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1262, 493, 2);
        }
    }
    rfalse;
];
[ call_U1263 RV;
    @push I7SFRAME;
    StackFrameCreate(0);
    @push formal_par0;
    @push formal_par1;
    (RV = kernel1_U3());
    @pull formal_par1;
    @pull formal_par0;
    @pull I7SFRAME;
    return RV;
];
[ kernel1_U3 tmp_0 tmp_1 tmp_2;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1263, 494, 0);
        }
        if ((player == actor)) {
            if ((keep_silent == 0)) {
                LookAfterGoing();
            }
        } else {
            if ((noun ofclass K3_direction)) {
                if ((((real_location == (MStack-->(MstVO(var_id_U42, 0))))) || (((((MStack-->(MstVO(var_id_U42, 3))) == ContainerOf(player))) || (((MStack-->(MstVO(var_id_U42, 4))) == ContainerOf(player))))))) {
                    if (((MStack-->(MstVO(var_id_U42, 0))) == (MStack-->(MstVO(var_id_U42, 1))))) {
                        rfalse;
                    } else {
                        if ((noun == I_up_U1)) {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say(as_block_constant_U204);
                        } else {
                            if ((noun == I_down_U1)) {
                                (say__p = 1);
                                ParaContent();
                                TEXT_TY_Say(as_block_constant_U205);
                            } else {
                                (say__p = 1);
                                ParaContent();
                                TEXT_TY_Say(as_block_constant_U206);
                            }
                        }
                    }
                } else {
                    (tmp_0 = GProperty(OBJECT_TY, noun, A_P_opposite));
                    if ((real_location == (MStack-->(MstVO(var_id_U42, 1))))) {
                        (tmp_1 = (
                            ! This evaluates last
                            formal_rv+
                            0*(
                                ! This evaluates second
                                ((
                                    (((((((formal_par1 ofclass K1_room)) && ((formal_par1 ofclass K1_room)))) && ((((formal_rv = MapConnection(formal_par1, formal_par0)))|(1))))) || (ArgumentTypeFailed(1913, 6)))
                                ))
                            +
                                ! This evaluate first
                                (((formal_par1 = real_location) + (formal_par0 = tmp_0))))
                        )
                        );
                        (tmp_2 = (
                            ! This evaluates last
                            formal_rv+
                            0*(
                                ! This evaluates second
                                ((
                                    (((((((formal_par0 ofclass K3_direction)) && ((formal_par0 ofclass K3_direction)))) && ((((formal_rv = MapConnection(formal_par1, formal_par0)))|(1))))) || (ArgumentTypeFailed(1915, 6)))
                                ))
                            +
                                ! This evaluate first
                                (((formal_par1 = (MStack-->(MstVO(var_id_U42, 0)))) + (formal_par0 = noun))))
                        )
                        );
                        if ((((tmp_1 == (MStack-->(MstVO(var_id_U42, 0))))) || ((tmp_1 == tmp_2)))) {
                            if ((tmp_0 == I_up_U1)) {
                                (say__p = 1);
                                ParaContent();
                                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U207))));
                            } else {
                                if ((tmp_0 == I_down_U1)) {
                                    (say__p = 1);
                                    ParaContent();
                                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U208))));
                                } else {
                                    (say__p = 1);
                                    ParaContent();
                                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U209))));
                                }
                            }
                        } else {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U210))));
                        }
                    } else {
                        if ((tmp_0 == I_up_U1)) {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U211))));
                        } else {
                            if ((tmp_0 == I_down_U1)) {
                                (say__p = 1);
                                ParaContent();
                                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U212))));
                            } else {
                                (say__p = 1);
                                ParaContent();
                                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U213))));
                            }
                        }
                    }
                }
            } else {
                if ((real_location == (MStack-->(MstVO(var_id_U42, 0))))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U214))));
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U215))));
                }
            }
            if ((~~(((MStack-->(MstVO(var_id_U42, 3))) == 0)))) {
                (say__p = 1);
                ParaContent();
                print " ";
                if (((MStack-->(MstVO(var_id_U42, 3))) ofclass K6_supporter)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U216))));
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U217))));
                }
            }
            if ((~~(((MStack-->(MstVO(var_id_U42, 4))) == 0)))) {
                if (((MStack-->(MstVO(var_id_U42, 4))) == ContainerOf(player))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U218))));
                } else {
                    if (((MStack-->(MstVO(var_id_U42, 3))) == ContainerOf(player))) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U219))));
                    } else {
                        if ((real_location == (MStack-->(MstVO(var_id_U42, 0))))) {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U220))));
                        } else {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U221))));
                        }
                    }
                }
            }
            if (((((MStack-->(MstVO(var_id_U42, 3))) == ContainerOf(player))) && ((~~(((MStack-->(MstVO(var_id_U42, 4))) == ContainerOf(player))))))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),(((LocalParking-->(2)) = tmp_2),as_block_constant_U222))));
                (say__p = 1);
                ParaContent();
                print ".";
                print "^";
                TryAction(0, player, ##Look, 0, 0);
                rfalse;
            }
            (say__p = 1);
            ParaContent();
            print ".";
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1263, 494, 2);
        }
    }
    rfalse;
];
[ call_U1264;
    ResponseViaActivity(response_id_U204);
];
[ call_U1265;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [go] up~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb22(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " up";
    rtrue;
];
[ call_U1266;
    ResponseViaActivity(response_id_U205);
];
[ call_U1267;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [go] down~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb22(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " down";
    rtrue;
];
[ call_U1268;
    ResponseViaActivity(response_id_U206);
];
[ call_U1269;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [go] [noun]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb22(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    PrintShortName(noun);
    rtrue;
];
[ call_U1270;
    ResponseViaActivity(response_id_U207);
];
[ call_U1271 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [arrive] from above~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " from above";
    rtrue;
];
[ call_U1272;
    ResponseViaActivity(response_id_U208);
];
[ call_U1273 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [arrive] from below~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " from below";
    rtrue;
];
[ call_U1274;
    ResponseViaActivity(response_id_U209);
];
[ call_U1275 tmp_0 tmp_1 tmp_2;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [arrive] from [the back way]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " from ";
    ParaContent();
    DefArt(tmp_0);
    rtrue;
];
[ call_U1276;
    ResponseViaActivity(response_id_U210);
];
[ call_U1277 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [arrive]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    rtrue;
];
[ call_U1278;
    ResponseViaActivity(response_id_U211);
];
[ call_U1279 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [arrive] at [the room gone to] from above~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " at ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 1))));
    ParaContent();
    print " from above";
    rtrue;
];
[ call_U1280;
    ResponseViaActivity(response_id_U212);
];
[ call_U1281 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [arrive] at [the room gone to] from below~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " at ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 1))));
    ParaContent();
    print " from below";
    rtrue;
];
[ call_U1282;
    ResponseViaActivity(response_id_U213);
];
[ call_U1283 tmp_0 tmp_1 tmp_2;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    (tmp_2 = (LocalParking-->(2)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [arrive] at [the room gone to] from [the back way]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " at ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 1))));
    ParaContent();
    print " from ";
    ParaContent();
    DefArt(tmp_0);
    rtrue;
];
[ call_U1284;
    ResponseViaActivity(response_id_U214);
];
[ call_U1285 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [go] through [the noun]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb22(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " through ";
    ParaContent();
    DefArt(noun);
    rtrue;
];
[ call_U1286;
    ResponseViaActivity(response_id_U215);
];
[ call_U1287 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [arrive] from [the noun]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb24(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " from ";
    ParaContent();
    DefArt(noun);
    rtrue;
];
[ call_U1288;
    ResponseViaActivity(response_id_U216);
];
[ call_U1289 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~on [the vehicle gone by]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "on ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 3))));
    rtrue;
];
[ call_U1290;
    ResponseViaActivity(response_id_U217);
];
[ call_U1291 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~in [the vehicle gone by]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "in ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 3))));
    rtrue;
];
[ call_U1292;
    ResponseViaActivity(response_id_U218);
];
[ call_U1293 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~, pushing [the thing gone with] in front, and [us] along too~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ", pushing ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 4))));
    ParaContent();
    print " in front, and ";
    ParaContent();
    call_U168();
    ParaContent();
    print " along too";
    rtrue;
];
[ call_U1294;
    ResponseViaActivity(response_id_U219);
];
[ call_U1295 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~, pushing [the thing gone with] in front~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ", pushing ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 4))));
    ParaContent();
    print " in front";
    rtrue;
];
[ call_U1296;
    ResponseViaActivity(response_id_U220);
];
[ call_U1297 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~, pushing [the thing gone with] away~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ", pushing ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 4))));
    ParaContent();
    print " away";
    rtrue;
];
[ call_U1298;
    ResponseViaActivity(response_id_U221);
];
[ call_U1299 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~, pushing [the thing gone with] in~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ", pushing ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U42, 4))));
    ParaContent();
    print " in";
    rtrue;
];
[ call_U1300;
    ResponseViaActivity(response_id_U222);
];
[ call_U1301 tmp_0 tmp_1 tmp_2;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~, taking [us] along~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print ", taking ";
    ParaContent();
    call_U168();
    ParaContent();
    print " along";
    rtrue;
];
[ call_U1302 tmp_0;
    if ((((action == ##Enter)) && ((actor == player)))) {
        if (debug_rules) {
            DB_Rule(call_U1302, 495, 0);
        }
        if (((((call_U1303()) && (((tmp_0 = (LocalParking-->(0))),1)))) || (((tmp_0 = 0),0)))) {
            (noun = tmp_0);
        } else {
            rfalse;
        }
        RulebookSucceeds(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1302, 495, 4);
        }
    }
    rfalse;
];
[ call_U1303 x x_ix;
    for ((x = TestContainmentRange(real_location)):x:(x = TestContainmentRange(real_location, x))) {
        if ((((x ofclass K2_thing)) && (call_U294(x)))) {
            ((LocalParking-->(0)) = x);
            rtrue;
        }
    }
    rfalse;
];
[ call_U1304;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1304, 496, 0);
        }
        if ((noun ofclass K4_door)) {
            return GVS_Convert(##Go, noun, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1304, 496, 2);
        }
    }
    rfalse;
];
[ call_U1305;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1305, 497, 0);
        }
        if ((noun ofclass K3_direction)) {
            return GVS_Convert(##Go, noun, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1305, 497, 2);
        }
    }
    rfalse;
];
[ call_U1306 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1306, 498, 0);
        }
        if ((actor == noun)) {
            rfalse;
        }
        (tmp_0 = CommonAncestor(actor, noun));
        if ((tmp_0 == noun)) {
            if ((player == actor)) {
                if ((noun ofclass K6_supporter)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U223));
                    print "^";
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U224));
                    print "^";
                }
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1306, 498, 2);
        }
    }
    rfalse;
];
[ call_U1307;
    ResponseViaActivity(response_id_U223);
];
[ call_U1308 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~But [we]['re] already on [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    call_U167();
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1309;
    ResponseViaActivity(response_id_U224);
];
[ call_U1310 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~But [we]['re] already in [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    call_U167();
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already in ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1311;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1311, 499, 0);
        }
        if ((~~(call_U294(noun)))) {
            if ((player == actor)) {
                if ((matched_text = SnippetIncludes(Consult_Grammar6, players_command))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U225);
                    print "^";
                } else {
                    if ((matched_text = SnippetIncludes(Consult_Grammar7, players_command))) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say(as_block_constant_U226);
                        print "^";
                    } else {
                        if ((matched_text = SnippetIncludes(Consult_Grammar8, players_command))) {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say(as_block_constant_U227);
                            print "^";
                        } else {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say(as_block_constant_U228);
                            print "^";
                        }
                    }
                }
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1311, 499, 2);
        }
    }
    rfalse;
];
[ call_U1312;
    ResponseViaActivity(response_id_U225);
];
[ call_U1313;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] not something [we] [can] stand on.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U192();
    ParaContent();
    print " not something ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " stand on.";
    rtrue;
];
[ call_U1314;
    ResponseViaActivity(response_id_U226);
];
[ call_U1315;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] not something [we] [can] sit down on.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U192();
    ParaContent();
    print " not something ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " sit down on.";
    rtrue;
];
[ call_U1316;
    ResponseViaActivity(response_id_U227);
];
[ call_U1317;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] not something [we] [can] lie down on.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U192();
    ParaContent();
    print " not something ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " lie down on.";
    rtrue;
];
[ call_U1318;
    ResponseViaActivity(response_id_U228);
];
[ call_U1319;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] not something [we] [can] enter.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U192();
    ParaContent();
    print " not something ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " enter.";
    rtrue;
];
[ call_U1320;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1320, 500, 0);
        }
        if ((((noun ofclass K5_container)) && (call_U306(noun)))) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U229);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1320, 500, 2);
        }
    }
    rfalse;
];
[ call_U1321;
    ResponseViaActivity(response_id_U229);
];
[ call_U1322;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't get] into the closed [noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb25);
    (say__p = 1);
    ParaContent();
    print " into the closed ";
    ParaContent();
    PrintShortName(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1323;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1323, 501, 0);
        }
        if (ProvidesProperty(OBJECT_TY, noun, A_capacity)) {
            if ((noun ofclass K6_supporter)) {
                if (((call_U1324)() >= GProperty(OBJECT_TY, noun, A_capacity))) {
                    if ((actor == player)) {
                        (prior_named_noun = 0);
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say(as_block_constant_U230);
                        print "^";
                    }
                    rtrue;
                }
            } else {
                if ((noun ofclass K5_container)) {
                    if (((call_U1325)() >= GProperty(OBJECT_TY, noun, A_capacity))) {
                        if ((actor == player)) {
                            (prior_named_noun = 0);
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say(as_block_constant_U231);
                            print "^";
                        }
                        rtrue;
                    }
                }
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1323, 501, 2);
        }
    }
    rfalse;
];
[ call_U1324 x x_ix counter;
    objectloop (x in noun) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1325 x x_ix counter;
    for ((x = TestContainmentRange(noun)):x:(x = TestContainmentRange(noun, x))) {
        if ((x ofclass K2_thing)) {
            (counter)++;
            jump NextOuterLoop_5;
        }
        .NextOuterLoop_5;
    }
    return counter;
];
[ call_U1326;
    ResponseViaActivity(response_id_U230);
];
[ call_U1327;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no more room on [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U194();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1328;
    ResponseViaActivity(response_id_U231);
];
[ call_U1329;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no more room in [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U194();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no more room in ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1330 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1330, 502, 0);
        }
        (tmp_0 = CommonAncestor(actor, noun));
        if ((tmp_0 == actor)) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U232));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1330, 502, 2);
        }
    }
    rfalse;
];
[ call_U1331;
    ResponseViaActivity(response_id_U232);
];
[ call_U1332 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can] only get into something free-standing.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " only get into something free-standing.";
    rtrue;
];
[ call_U1333 tmp_0 tmp_1;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1333, 503, 0);
        }
        if ((HolderOf(actor) == HolderOf(noun))) {
            rfalse;
        }
        (tmp_0 = CommonAncestor(actor, noun));
        while ((~~((HolderOf(actor) == tmp_0)))) {
            (tmp_1 = HolderOf(actor));
            if ((player == actor)) {
                if ((((tmp_1 ofclass K6_supporter)) || ((tmp_1 ofclass K12_animal)))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U233)));
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U234)));
                }
            }
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Exit, 0, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((HolderOf(actor) == tmp_1)) {
                rtrue;
            }
        }
        if ((HolderOf(actor) == noun)) {
            rtrue;
        }
        if ((HolderOf(actor) == HolderOf(noun))) {
            rfalse;
        }
        (tmp_1 = HolderOf(noun));
        if ((tmp_1 == PartOf(noun))) {
            (tmp_1 = HolderOf(tmp_1));
        }
        while ((tmp_1 ofclass K2_thing)) {
            if ((HolderOf(tmp_1) == tmp_0)) {
                if ((player == actor)) {
                    if ((tmp_1 ofclass K6_supporter)) {
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U235)));
                    } else {
                        if ((tmp_1 ofclass K5_container)) {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U236)));
                        } else {
                            (say__p = 1);
                            ParaContent();
                            TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U237)));
                        }
                    }
                }
                @push keep_silent;
                (keep_silent = 1);
                @push say__p;
                @push say__pc;
                ClearParagraphing(1);
                TryAction(0, actor, ##Enter, tmp_1, 0);
                DivideParagraphPoint();
                @pull say__pc;
                @pull say__p;
                AdjustParagraphPoint();
                @pull keep_silent;
                if ((~~((HolderOf(actor) == tmp_1)))) {
                    rtrue;
                }
                return GVS_Convert(##Enter, noun, 0);
                rfalse;
            }
            (tmp_1 = HolderOf(tmp_1));
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1333, 503, 2);
        }
    }
    rfalse;
];
[ call_U1334;
    ResponseViaActivity(response_id_U233);
];
[ call_U1335 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(getting off [the current home])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(getting off ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1336;
    ResponseViaActivity(response_id_U234);
];
[ call_U1337 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(getting out of [the current home])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(getting out of ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1338;
    ResponseViaActivity(response_id_U235);
];
[ call_U1339 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(getting onto [the target])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(getting onto ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1340;
    ResponseViaActivity(response_id_U236);
];
[ call_U1341 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(getting into [the target])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(getting into ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1342;
    ResponseViaActivity(response_id_U237);
];
[ call_U1343 tmp_1 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(entering [the target])[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(entering ";
    ParaContent();
    DefArt(tmp_1);
    ParaContent();
    print ")";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1344;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1344, 504, 0);
        }
        move actor to noun;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1344, 504, 2);
        }
    }
    rfalse;
];
[ call_U1345;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1345, 505, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                if ((noun ofclass K6_supporter)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U238);
                    print "^";
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U239);
                    print "^";
                }
            }
        } else {
            if ((noun ofclass K5_container)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U240);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U241);
                print "^";
            }
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1345, 505, 2);
        }
    }
    rfalse;
];
[ call_U1346;
    ResponseViaActivity(response_id_U238);
];
[ call_U1347;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [get] onto [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " onto ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1348;
    ResponseViaActivity(response_id_U239);
];
[ call_U1349;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [get] into [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " into ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1350;
    ResponseViaActivity(response_id_U240);
];
[ call_U1351;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [get] into [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " into ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1352;
    ResponseViaActivity(response_id_U241);
];
[ call_U1353;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [get] onto [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " onto ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1354;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1354, 506, 0);
        }
        if ((actor == player)) {
            call_U1839(noun);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1354, 506, 2);
        }
    }
    rfalse;
];
[ call_U1355;
    if ((action == ##Exit)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1355, 507, 0);
        }
        ((MStack-->(MstVO(var_id_U44, 0))) = HolderOf(actor));
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1355, 507, 2);
        }
    }
    rfalse;
];
[ call_U1356 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1356, 508, 0);
        }
        (tmp_0 = LocationOf(actor));
        if (((MStack-->(MstVO(var_id_U44, 0))) == tmp_0)) {
            if ((~~((RoomOrDoorFrom(tmp_0, out_obj) == 0)))) {
                return GVS_Convert(##Go, out_obj, 0);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1356, 508, 2);
        }
    }
    rfalse;
];
[ call_U1357 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1357, 509, 0);
        }
        (tmp_0 = LocationOf(actor));
        if (((MStack-->(MstVO(var_id_U44, 0))) == tmp_0)) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U242));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1357, 509, 2);
        }
    }
    rfalse;
];
[ call_U1358;
    ResponseViaActivity(response_id_U242);
];
[ call_U1359 tmp_0;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~But [we] [aren't] in anything at the [if story tense is present^tense]moment[otherwise]time[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " in anything at the ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "moment";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "time";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1360 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1360, 510, 0);
        }
        if ((((ContainerOf(actor) ofclass K5_container)) && (((call_U306(ContainerOf(actor))) && (((tmp_0 = ContainerOf(actor)),1)))))) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),as_block_constant_U243));
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1360, 510, 2);
        }
    }
    rfalse;
];
[ call_U1361;
    ResponseViaActivity(response_id_U243);
];
[ call_U1362 tmp_0;
    (tmp_0 = (LocalParking-->(0)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~You can't get out of the closed [cage].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "You can't get out of the closed ";
    ParaContent();
    PrintShortName(tmp_0);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1363 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1363, 511, 0);
        }
        if ((((SupporterOf(actor) ofclass K6_supporter)) && (((tmp_0 = SupporterOf(actor)),1)))) {
            return GVS_Convert(##GetOff, tmp_0, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1363, 511, 2);
        }
    }
    rfalse;
];
[ call_U1364 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1364, 512, 0);
        }
        (tmp_0 = CoreOfParentOfCoreOf((MStack-->(MstVO(var_id_U44, 0)))));
        move actor to tmp_0;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1364, 512, 2);
        }
    }
    rfalse;
];
[ call_U1365;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1365, 513, 0);
        }
        if ((keep_silent == 0)) {
            if ((actor == player)) {
                if (((MStack-->(MstVO(var_id_U44, 0))) ofclass K6_supporter)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U244);
                    print "^";
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U245);
                    print "^";
                }
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U246);
                print "^";
            }
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1365, 513, 2);
        }
    }
    rfalse;
];
[ call_U1366;
    ResponseViaActivity(response_id_U244);
];
[ call_U1367;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [get] off [the container exited from].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " off ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U44, 0))));
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1368;
    ResponseViaActivity(response_id_U245);
];
[ call_U1369;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [get] out of [the container exited from].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " out of ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U44, 0))));
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1370;
    ResponseViaActivity(response_id_U246);
];
[ call_U1371;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [get] out of [the container exited from].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " out of ";
    ParaContent();
    DefArt((MStack-->(MstVO(var_id_U44, 0))));
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1372;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1372, 514, 0);
        }
        if ((actor == player)) {
            SilentlyConsiderLight();
            LookAfterGoing();
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1372, 514, 2);
        }
    }
    rfalse;
];
[ call_U1373;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1373, 515, 0);
        }
        if ((noun == SupporterOf(actor))) {
            rfalse;
        }
        if ((noun == CarrierOf(actor))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U247);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1373, 515, 2);
        }
    }
    rfalse;
];
[ call_U1374;
    ResponseViaActivity(response_id_U247);
];
[ call_U1375;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~But [we] [aren't] on [the noun] at the [if story tense is present^tense]moment[otherwise]time[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " at the ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "moment";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "time";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1376 tmp_0;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1376, 516, 0);
        }
        (tmp_0 = CoreOfParentOfCoreOf(noun));
        move actor to tmp_0;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1376, 516, 2);
        }
    }
    rfalse;
];
[ call_U1377;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1377, 517, 0);
        }
        if ((keep_silent == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U248);
            print "^";
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1377, 517, 2);
        }
    }
    rfalse;
];
[ call_U1378;
    ResponseViaActivity(response_id_U248);
];
[ call_U1379;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [get] off [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb25(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " off ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1380;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1380, 518, 0);
        }
        if ((actor == player)) {
            LookAfterGoing();
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1380, 518, 2);
        }
    }
    rfalse;
];
[ call_U1381;
    if ((action == ##Look)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1381, 519, 0);
        }
        if ((actor == player)) {
            FindVisibilityLevels();
        }
        ((MStack-->(MstVO(var_id_U46, 2))) = visibility_levels);
        ((MStack-->(MstVO(var_id_U46, 3))) = visibility_ceiling);
        ((MStack-->(MstVO(var_id_U46, 0))) = ##Look);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1381, 519, 2);
        }
    }
    rfalse;
];
[ call_U1382 tmp_0 tmp_1;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1382, 520, 0);
        }
        for (((tmp_0 = (call_U1383)(0)),(tmp_1 = (call_U1383)(tmp_0))):tmp_0:((tmp_0 = tmp_1),(tmp_1 = (call_U1383)(tmp_1)))) {
            call_U290(tmp_0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1382, 520, 3);
        }
    }
    rfalse;
];
[ call_U1383 x x_ix;
    if ((x_ix > 0)) {
        (x_ix)--;
        jump NextOuterLoop_4;
    }
    if (x) {
        jump NextOuterLoop_4;
    }
    for ((x = K2_thing_First):x:(x = (x.K2_thing_Next))) {
        return x;
        .NextOuterLoop_4;
    }
    rfalse;
];
[ call_U1384 tmp_0 tmp_1;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1384, 521, 0);
        }
        (say__p = 1);
        ParaContent();
        style bold;
        if (((MStack-->(MstVO(var_id_U46, 2))) == 0)) {
            BeginActivity(V12_printing_the_name_of_a_da);
            if ((~~(ForActivity(V12_printing_the_name_of_a_da)))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U249);
            }
            EndActivity(V12_printing_the_name_of_a_da);
        } else {
            if (((MStack-->(MstVO(var_id_U46, 3))) == real_location)) {
                (say__p = 1);
                ParaContent();
                PrintShortName((MStack-->(MstVO(var_id_U46, 3))));
            } else {
                (say__p = 1);
                ParaContent();
                CDefArt((MStack-->(MstVO(var_id_U46, 3))));
            }
        }
        (say__p = 1);
        ParaContent();
        style roman;
        (tmp_0 = VisibilityParent(actor));
        for ((tmp_1 = 2):(tmp_1 <= (MStack-->(MstVO(var_id_U46, 2)))):(tmp_1)++) {
            if ((((tmp_0 ofclass K6_supporter)) || ((tmp_0 ofclass K12_animal)))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U250)));
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say((((LocalParking-->(0)) = tmp_0),(((LocalParking-->(1)) = tmp_1),as_block_constant_U251)));
            }
            (tmp_0 = VisibilityParent(tmp_0));
        }
        (say__p = 1);
        ParaContent();
        print "^";
        (say__p = 1);
        ParaContent();
        SpecialLookSpacingBreak();
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1384, 521, 3);
        }
    }
    rfalse;
];
[ call_U1385;
    ResponseViaActivity(response_id_U249);
];
[ call_U1386;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Darkness~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Darkness";
    rtrue;
];
[ call_U1387;
    ResponseViaActivity(response_id_U250);
];
[ call_U1388 tmp_0 tmp_1;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ (on [the intermediate level])~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " (on ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    rtrue;
];
[ call_U1389;
    ResponseViaActivity(response_id_U251);
];
[ call_U1390 tmp_0 tmp_1;
    (tmp_0 = (LocalParking-->(0)));
    (tmp_1 = (LocalParking-->(1)));
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~ (in [the intermediate level])~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print " (in ";
    ParaContent();
    DefArt(tmp_0);
    ParaContent();
    print ")";
    rtrue;
];
[ call_U1391;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1391, 522, 0);
        }
        if (((MStack-->(MstVO(var_id_U46, 2))) == 0)) {
            if ((lookmode == 3)) {
                rfalse;
            }
            if ((((lookmode == 1)) && (((((MStack-->(MstVO(var_id_U46, 1))) == 1)) && (((Global_Vars-->16) == 1)))))) {
                rfalse;
            }
            BeginActivity(V13_printing_the_description_);
            if ((~~(ForActivity(V13_printing_the_description_)))) {
                (prior_named_noun = 0);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U252);
                print "^";
            }
            EndActivity(V13_printing_the_description_);
        } else {
            if (((MStack-->(MstVO(var_id_U46, 3))) == real_location)) {
                if ((lookmode == 3)) {
                    rfalse;
                }
                if ((((lookmode == 1)) && (((((MStack-->(MstVO(var_id_U46, 1))) == 1)) && (call_U240(real_location)))))) {
                    rfalse;
                }
                PrintOrRun(location, A_description);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1391, 522, 3);
        }
    }
    rfalse;
];
[ call_U1392;
    ResponseViaActivity(response_id_U252);
];
[ call_U1393;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[It] [are] pitch dark, and [we] [can't see] a thing.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U193();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " pitch dark, and ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb3);
    (say__p = 1);
    ParaContent();
    print " a thing.";
    rtrue;
];
[ call_U1394 tmp_0 tmp_1 tmp_2;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1394, 523, 0);
        }
        if (((MStack-->(MstVO(var_id_U46, 2))) > 0)) {
            (tmp_0 = actor);
            (tmp_1 = (MStack-->(MstVO(var_id_U46, 2))));
            while ((tmp_1 > 0)) {
                call_U283(tmp_0);
                (tmp_0 = VisibilityParent(tmp_0));
                (tmp_1 = (tmp_1 - 1));
            }
            (tmp_2 = (MStack-->(MstVO(var_id_U46, 2))));
            while ((tmp_2 > 0)) {
                (tmp_0 = actor);
                (tmp_1 = 0);
                while ((tmp_1 < tmp_2)) {
                    (tmp_0 = VisibilityParent(tmp_0));
                    (tmp_1 = (tmp_1 + 1));
                }
                call_U1839(tmp_0);
                (tmp_2 = (tmp_2 - 1));
            }
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1394, 523, 3);
        }
    }
    rfalse;
];
[ call_U1395;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1395, 524, 0);
        }
        if ((location == thedark)) {
            ((Global_Vars-->16) = 1);
        } else {
            if ((real_location ofclass K1_room)) {
                call_U241(real_location);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1395, 524, 3);
        }
    }
    rfalse;
];
[ call_U1396;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1396, 525, 0);
        }
        if ((~~((actor == player)))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U253);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1396, 525, 2);
        }
    }
    rfalse;
];
[ call_U1397;
    ResponseViaActivity(response_id_U253);
];
[ call_U1398;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [look] around.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb9(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " around.";
    rtrue;
];
[ call_U1399;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1399, 526, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_description)) && ((~~(((BlkValueCompare)(GProperty(OBJECT_TY, noun, A_description),bc_U66) == 0)))))) {
            (say__p = 1);
            ParaContent();
            @push self;
            TEXT_TY_Say(GProperty(OBJECT_TY, (self = noun), A_description));
            @pull self;
            ParaContent();
            print "^";
            ((MStack-->(MstVO(var_id_U47, 0))) = 1);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1399, 526, 3);
        }
    }
    rfalse;
];
[ call_U1400;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1400, 527, 0);
        }
        if ((noun ofclass K3_direction)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U254);
            print "^";
            ((MStack-->(MstVO(var_id_U47, 0))) = 1);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1400, 527, 3);
        }
    }
    rfalse;
];
[ call_U1401;
    ResponseViaActivity(response_id_U254);
];
[ call_U1402;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [see] nothing unexpected in that direction.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb3(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing unexpected in that direction.";
    rtrue;
];
[ call_U1403;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1403, 528, 0);
        }
        if ((noun ofclass K5_container)) {
            if (((call_U303(noun)) || (call_U297(noun)))) {
                if (((call_U1404()) && (call_U1405()))) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U255);
                    WriteListFrom(child(noun), 3144);
                    (say__p = 1);
                    ParaContent();
                    print ".";
                    print "^";
                    ((MStack-->(MstVO(var_id_U47, 0))) = 1);
                } else {
                    if (((MStack-->(MstVO(var_id_U47, 0))) == 0)) {
                        if ((noun == ContainerOf(player))) {
                            rfalse;
                        }
                        (say__p = 1);
                        ParaContent();
                        TEXT_TY_Say(as_block_constant_U256);
                        print "^";
                        ((MStack-->(MstVO(var_id_U47, 0))) = 1);
                    }
                }
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1403, 528, 3);
        }
    }
    rfalse;
];
[ call_U1404 x x_ix;
    for ((x = TestContainmentRange(noun)):x:(x = TestContainmentRange(noun, x))) {
        if ((((x ofclass K2_thing)) && (call_U279(x)))) {
            if ((~~(call_U264(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1405 x x_ix;
    for ((x = TestContainmentRange(noun)):x:(x = TestContainmentRange(noun, x))) {
        if ((x ofclass K2_thing)) {
            if ((~~((x == player)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1406;
    ResponseViaActivity(response_id_U255);
];
[ call_U1407;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~In [the noun] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "In ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1408;
    ResponseViaActivity(response_id_U256);
];
[ call_U1409;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [are] empty.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " empty.";
    rtrue;
];
[ call_U1410;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1410, 529, 0);
        }
        if ((noun ofclass K6_supporter)) {
            if (((call_U1411()) && (call_U1412()))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U257);
                WriteListFrom(child(noun), 3288);
                (say__p = 1);
                ParaContent();
                print ".";
                print "^";
                ((MStack-->(MstVO(var_id_U47, 0))) = 1);
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1410, 529, 3);
        }
    }
    rfalse;
];
[ call_U1411 x x_ix;
    objectloop (x in noun) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && (call_U279(x)))) {
                if ((~~(call_U264(x)))) {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ call_U1412 x x_ix;
    objectloop (x in noun) {
        if ((SupporterOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                if ((~~((x == player)))) {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ call_U1413;
    ResponseViaActivity(response_id_U257);
];
[ call_U1414;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~On [the noun] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1415;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1415, 530, 0);
        }
        if (ProvidesProperty(OBJECT_TY, noun, A_on)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U258);
            print "^";
            ((MStack-->(MstVO(var_id_U47, 0))) = 1);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1415, 530, 3);
        }
    }
    rfalse;
];
[ call_U1416;
    ResponseViaActivity(response_id_U258);
];
[ call_U1417;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [are] [if story tense is present tense]currently [end if]switched^[if the noun is switched on]on[otherwise]off[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "currently ";
    .L_Say0;
    ParaContent();
    print "switched ";
    if ((~~(call_U333(noun)))) {
        jump L_Say1;
    }
    ParaContent();
    print "on";
    jump L_SayX1;
    .L_Say1;
    ParaContent();
    print "off";
    .L_SayX1;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1418;
    if ((actor == player)) {
        if (debug_rules) {
            DB_Rule(call_U1418, 531, 0);
        }
        if (((MStack-->(MstVO(var_id_U47, 0))) == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U259);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1418, 531, 3);
        }
    }
    rfalse;
];
[ call_U1419;
    ResponseViaActivity(response_id_U259);
];
[ call_U1420;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [see] nothing special about [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb3(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing special about ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1421;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1421, 532, 0);
        }
        if ((~~((actor == player)))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U260);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1421, 532, 2);
        }
    }
    rfalse;
];
[ call_U1422;
    ResponseViaActivity(response_id_U260);
];
[ call_U1423;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [look] closely at [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb9(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " closely at ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1424;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1424, 533, 0);
        }
        if ((player == actor)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U261);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1424, 533, 2);
        }
    }
    rfalse;
];
[ call_U1425;
    ResponseViaActivity(response_id_U261);
];
[ call_U1426;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [find] nothing of interest.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb26(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing of interest.";
    rtrue;
];
[ call_U1427;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1427, 534, 0);
        }
        if ((keep_silent == 0)) {
            if ((~~((actor == player)))) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U262);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1427, 534, 2);
        }
    }
    rfalse;
];
[ call_U1428;
    ResponseViaActivity(response_id_U262);
];
[ call_U1429;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [look] under [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb9(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " under ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1430;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1430, 535, 0);
        }
        if ((((~~((noun ofclass K5_container)))) && ((~~((noun ofclass K6_supporter)))))) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U263);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1430, 535, 2);
        }
    }
    rfalse;
];
[ call_U1431;
    ResponseViaActivity(response_id_U263);
];
[ call_U1432;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [find] nothing of interest.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb26(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing of interest.";
    rtrue;
];
[ call_U1433;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1433, 536, 0);
        }
        if ((((noun ofclass K5_container)) && (((call_U306(noun)) && (call_U300(noun)))))) {
            if ((player == actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U264);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1433, 536, 2);
        }
    }
    rfalse;
];
[ call_U1434;
    ResponseViaActivity(response_id_U264);
];
[ call_U1435;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't see] inside, since [the noun] [are] closed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb3);
    (say__p = 1);
    ParaContent();
    print " inside, since ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " closed.";
    rtrue;
];
[ call_U1436;
    if ((((actor == player)) && ((noun ofclass K5_container)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1436, 537, 0);
        }
        if (call_U1437()) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U265);
            WriteListFrom(child(noun), 3144);
            (say__p = 1);
            ParaContent();
            print ".";
            print "^";
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U266);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1436, 537, 2);
        }
    }
    rfalse;
];
[ call_U1437 x x_ix;
    for ((x = TestContainmentRange(noun)):x:(x = TestContainmentRange(noun, x))) {
        if ((((x ofclass K2_thing)) && (call_U279(x)))) {
            if ((~~(call_U264(x)))) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ call_U1438;
    ResponseViaActivity(response_id_U265);
];
[ call_U1439;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~In [the noun] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "In ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1440;
    ResponseViaActivity(response_id_U266);
];
[ call_U1441;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [are] empty.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " empty.";
    rtrue;
];
[ call_U1442;
    if ((((actor == player)) && ((noun ofclass K6_supporter)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1442, 538, 0);
        }
        if (call_U1443()) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U267);
            WriteListFrom(child(noun), 3144);
            (say__p = 1);
            ParaContent();
            print ".";
            print "^";
        } else {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U268);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1442, 538, 2);
        }
    }
    rfalse;
];
[ call_U1443 x x_ix;
    objectloop (x in noun) {
        if ((SupporterOf(x) == parent(x))) {
            if ((((x ofclass K2_thing)) && (call_U279(x)))) {
                if ((~~(call_U264(x)))) {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ call_U1444;
    ResponseViaActivity(response_id_U267);
];
[ call_U1445;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~On [the noun] ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "On ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " ";
    rtrue;
];
[ call_U1446;
    ResponseViaActivity(response_id_U268);
];
[ call_U1447;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] nothing on [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U194();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1448;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1448, 539, 0);
        }
        if ((~~((actor == player)))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U269);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1448, 539, 2);
        }
    }
    rfalse;
];
[ call_U1449;
    ResponseViaActivity(response_id_U269);
];
[ call_U1450;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [search] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb27(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1451;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1451, 540, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U270);
            print "^";
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U271);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1451, 540, 2);
        }
    }
    rfalse;
];
[ call_U1452;
    ResponseViaActivity(response_id_U270);
];
[ call_U1453;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [discover] nothing of interest in [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb28(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing of interest in ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1454;
    ResponseViaActivity(response_id_U271);
];
[ call_U1455;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [look] at [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb9(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " at ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1456;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1456, 541, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_lockable)) && (call_U315(noun)))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U272);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1456, 541, 2);
        }
    }
    rfalse;
];
[ call_U1457;
    ResponseViaActivity(response_id_U272);
];
[ call_U1458;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [don't] seem to be something [we] [can] lock.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U178();
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " seem to be something ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " lock.";
    rtrue;
];
[ call_U1459;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1459, 542, 0);
        }
        if (call_U318(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U273);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1459, 542, 2);
        }
    }
    rfalse;
];
[ call_U1460;
    ResponseViaActivity(response_id_U273);
];
[ call_U1461;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] locked at the [if story tense is present^tense]moment[otherwise]time[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U192();
    ParaContent();
    print " locked at the ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "moment";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "time";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1462;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1462, 543, 0);
        }
        if (call_U303(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U274);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1462, 543, 2);
        }
    }
    rfalse;
];
[ call_U1463;
    ResponseViaActivity(response_id_U274);
];
[ call_U1464;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~First [we] [would have] to close [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "First ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb4);
    (say__p = 1);
    ParaContent();
    print " to close ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1465;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1465, 544, 0);
        }
        if ((((~~((HolderOf(second) == actor)))) || ((((~~(ProvidesProperty(OBJECT_TY, noun, A_with_key)))) || ((~~((GProperty(OBJECT_TY, noun, A_with_key) == second)))))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U275);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1465, 544, 2);
        }
    }
    rfalse;
];
[ call_U1466;
    ResponseViaActivity(response_id_U275);
];
[ call_U1467;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the second noun][Those] [don't] seem to fit the lock.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(second);
    ParaContent();
    call_U178();
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " seem to fit the lock.";
    rtrue;
];
[ call_U1468;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1468, 545, 0);
        }
        call_U319(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1468, 545, 2);
        }
    }
    rfalse;
];
[ call_U1469;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1469, 546, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U276);
                print "^";
            }
        } else {
            if (call_U212(actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U277);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1469, 546, 2);
        }
    }
    rfalse;
];
[ call_U1470;
    ResponseViaActivity(response_id_U276);
];
[ call_U1471;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [lock] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb30(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1472;
    ResponseViaActivity(response_id_U277);
];
[ call_U1473;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [lock] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb30(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1474;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1474, 547, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_lockable)) && (call_U315(noun)))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U278);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1474, 547, 2);
        }
    }
    rfalse;
];
[ call_U1475;
    ResponseViaActivity(response_id_U278);
];
[ call_U1476;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][Those] [don't] seem to be something [we] [can] unlock.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U178();
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " seem to be something ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unlock.";
    rtrue;
];
[ call_U1477;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1477, 548, 0);
        }
        if ((~~(call_U318(noun)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U279);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1477, 548, 2);
        }
    }
    rfalse;
];
[ call_U1478;
    ResponseViaActivity(response_id_U279);
];
[ call_U1479;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] unlocked at the [if story tense is present^tense]moment[otherwise]time[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U192();
    ParaContent();
    print " unlocked at the ";
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "moment";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "time";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1480;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1480, 549, 0);
        }
        if ((((~~((HolderOf(second) == actor)))) || ((((~~(ProvidesProperty(OBJECT_TY, noun, A_with_key)))) || ((~~((GProperty(OBJECT_TY, noun, A_with_key) == second)))))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U280);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1480, 549, 2);
        }
    }
    rfalse;
];
[ call_U1481;
    ResponseViaActivity(response_id_U280);
];
[ call_U1482;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the second noun][Those] [don't] seem to fit the lock.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(second);
    ParaContent();
    call_U178();
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " seem to fit the lock.";
    rtrue;
];
[ call_U1483;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1483, 550, 0);
        }
        call_U320(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1483, 550, 2);
        }
    }
    rfalse;
];
[ call_U1484;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1484, 551, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U281);
                print "^";
            }
        } else {
            if (call_U212(actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U282);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1484, 551, 2);
        }
    }
    rfalse;
];
[ call_U1485;
    ResponseViaActivity(response_id_U281);
];
[ call_U1486;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [unlock] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb31(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1487;
    ResponseViaActivity(response_id_U282);
];
[ call_U1488;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [unlock] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb31(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1489;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1489, 552, 0);
        }
        if (ProvidesProperty(OBJECT_TY, noun, A_on)) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U283);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1489, 552, 2);
        }
    }
    rfalse;
];
[ call_U1490;
    ResponseViaActivity(response_id_U283);
];
[ call_U1491;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [aren't] something [we] [can] switch.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U182();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " something ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " switch.";
    rtrue;
];
[ call_U1492;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1492, 553, 0);
        }
        if (call_U333(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U284);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1492, 553, 2);
        }
    }
    rfalse;
];
[ call_U1493;
    ResponseViaActivity(response_id_U284);
];
[ call_U1494;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] already on.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U192();
    ParaContent();
    print " already on.";
    rtrue;
];
[ call_U1495;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1495, 554, 0);
        }
        call_U334(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1495, 554, 2);
        }
    }
    rfalse;
];
[ call_U1496;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1496, 555, 0);
        }
        if ((keep_silent == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U285);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1496, 555, 2);
        }
    }
    rfalse;
];
[ call_U1497;
    ResponseViaActivity(response_id_U285);
];
[ call_U1498;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [switch] [the noun] on.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb32(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " on.";
    rtrue;
];
[ call_U1499;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1499, 556, 0);
        }
        if (ProvidesProperty(OBJECT_TY, noun, A_on)) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U286);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1499, 556, 2);
        }
    }
    rfalse;
];
[ call_U1500;
    ResponseViaActivity(response_id_U286);
];
[ call_U1501;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [aren't] something [we] [can] switch.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U182();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " something ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " switch.";
    rtrue;
];
[ call_U1502;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1502, 557, 0);
        }
        if (call_U336(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U287);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1502, 557, 2);
        }
    }
    rfalse;
];
[ call_U1503;
    ResponseViaActivity(response_id_U287);
];
[ call_U1504;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] already off.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U192();
    ParaContent();
    print " already off.";
    rtrue;
];
[ call_U1505;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1505, 558, 0);
        }
        call_U337(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1505, 558, 2);
        }
    }
    rfalse;
];
[ call_U1506;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1506, 559, 0);
        }
        if ((keep_silent == 0)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U288);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1506, 559, 2);
        }
    }
    rfalse;
];
[ call_U1507;
    ResponseViaActivity(response_id_U288);
];
[ call_U1508;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [switch] [the noun] off.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb32(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " off.";
    rtrue;
];
[ call_U1509;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1509, 560, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_openable)) && (call_U309(noun)))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U289);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1509, 560, 2);
        }
    }
    rfalse;
];
[ call_U1510;
    ResponseViaActivity(response_id_U289);
];
[ call_U1511;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [aren't] something [we] [can] open.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U182();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " something ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " open.";
    rtrue;
];
[ call_U1512;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1512, 561, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_lockable)) && (call_U318(noun)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U290);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1512, 561, 2);
        }
    }
    rfalse;
];
[ call_U1513;
    ResponseViaActivity(response_id_U290);
];
[ call_U1514;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [seem] to be locked.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U182();
    ParaContent();
    print " ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to be locked.";
    rtrue;
];
[ call_U1515;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1515, 562, 0);
        }
        if (call_U303(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U291);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1515, 562, 2);
        }
    }
    rfalse;
];
[ call_U1516;
    ResponseViaActivity(response_id_U291);
];
[ call_U1517;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] already open.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U192();
    ParaContent();
    print " already open.";
    rtrue;
];
[ call_U1518;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1518, 563, 0);
        }
        call_U304(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1518, 563, 2);
        }
    }
    rfalse;
];
[ call_U1519;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1519, 564, 0);
        }
        if ((((actor == player)) && ((((((noun ofclass K5_container)) && (call_U300(noun)))) && ((((~~((child(noun) == 0)))) && ((~~(IndirectlyContains(noun, actor)))))))))) {
            if ((keep_silent == 0)) {
                if ((actor == player)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U292);
                    WriteListFrom(child(noun), 2120);
                    (say__p = 1);
                    ParaContent();
                    print ".";
                    print "^";
                }
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1519, 564, 2);
        }
    }
    rfalse;
];
[ call_U1520;
    ResponseViaActivity(response_id_U292);
];
[ call_U1521;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [open] [the noun], revealing ~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb33(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ", revealing ";
    rtrue;
];
[ call_U1522;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1522, 565, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U293);
                print "^";
            }
        } else {
            if (TestVisibility(player, actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U294);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U295);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1522, 565, 2);
        }
    }
    rfalse;
];
[ call_U1523;
    ResponseViaActivity(response_id_U293);
];
[ call_U1524;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [open] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb33(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1525;
    ResponseViaActivity(response_id_U294);
];
[ call_U1526;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [open] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb33(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1527;
    ResponseViaActivity(response_id_U295);
];
[ call_U1528;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [open].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb33(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1529;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1529, 566, 0);
        }
        if (((ProvidesProperty(OBJECT_TY, noun, A_openable)) && (call_U309(noun)))) {
            rfalse;
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U296);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1529, 566, 2);
        }
    }
    rfalse;
];
[ call_U1530;
    ResponseViaActivity(response_id_U296);
];
[ call_U1531;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [aren't] something [we] [can] close.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U182();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " something ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb8(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " close.";
    rtrue;
];
[ call_U1532;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1532, 567, 0);
        }
        if (call_U306(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U297);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1532, 567, 2);
        }
    }
    rfalse;
];
[ call_U1533;
    ResponseViaActivity(response_id_U297);
];
[ call_U1534;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They're] already closed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U192();
    ParaContent();
    print " already closed.";
    rtrue;
];
[ call_U1535;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1535, 568, 0);
        }
        call_U307(noun);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1535, 568, 2);
        }
    }
    rfalse;
];
[ call_U1536;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1536, 569, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U298);
                print "^";
            }
        } else {
            if (TestVisibility(player, actor)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U299);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U300);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1536, 569, 2);
        }
    }
    rfalse;
];
[ call_U1537;
    ResponseViaActivity(response_id_U298);
];
[ call_U1538;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [close] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb34(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1539;
    ResponseViaActivity(response_id_U299);
];
[ call_U1540;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [close] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb34(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1541;
    ResponseViaActivity(response_id_U300);
];
[ call_U1542;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [close].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb34(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1543;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1543, 570, 0);
        }
        if ((((~~((noun ofclass K2_thing)))) || ((~~(call_U267(noun)))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U301);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1543, 570, 2);
        }
    }
    rfalse;
];
[ call_U1544;
    ResponseViaActivity(response_id_U301);
];
[ call_U1545;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't wear] [regarding the noun][those]!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb35);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U177();
    ParaContent();
    print "!";
    rtrue;
];
[ call_U1546;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1546, 571, 0);
        }
        if ((~~((HolderOf(noun) == actor)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U302);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1546, 571, 2);
        }
    }
    rfalse;
];
[ call_U1547;
    ResponseViaActivity(response_id_U302);
];
[ call_U1548;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [aren't] holding [regarding the noun][those]!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " holding ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U177();
    ParaContent();
    print "!";
    rtrue;
];
[ call_U1549;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1549, 572, 0);
        }
        if ((actor == WearerOf(noun))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U303);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1549, 572, 2);
        }
    }
    rfalse;
];
[ call_U1550;
    ResponseViaActivity(response_id_U303);
];
[ call_U1551;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We]['re] already wearing [regarding the noun][those]!~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " already wearing ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U177();
    ParaContent();
    print "!";
    rtrue;
];
[ call_U1552;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1552, 573, 0);
        }
        WearObject(noun, actor);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1552, 573, 2);
        }
    }
    rfalse;
];
[ call_U1553;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1553, 574, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U304);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U305);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1553, 574, 2);
        }
    }
    rfalse;
];
[ call_U1554;
    ResponseViaActivity(response_id_U304);
];
[ call_U1555;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [put] on [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb16(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1556;
    ResponseViaActivity(response_id_U305);
];
[ call_U1557;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [put] on [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb16(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1558;
    if ((((action == ##Disrobe)) && ((((actor == player)) && ((((noun ofclass K2_thing)) && (call_U209(noun)))))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1558, 575, 0);
        }
        RulebookSucceeds(RULEBOOK_OUTCOME_TY, outcome_it_is_very_likely_U1);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1558, 575, 2);
        }
    }
    rfalse;
];
[ call_U1559;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1559, 576, 0);
        }
        if ((~~((actor == WearerOf(noun))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U306);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1559, 576, 2);
        }
    }
    rfalse;
];
[ call_U1560;
    ResponseViaActivity(response_id_U306);
];
[ call_U1561;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [aren't] wearing [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " wearing ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1562;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1562, 577, 0);
        }
        if (((call_U1563)() >= GProperty(OBJECT_TY, actor, A_capacity))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U307);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1562, 577, 2);
        }
    }
    rfalse;
];
[ call_U1563 x x_ix counter;
    objectloop (x in actor) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1564;
    ResponseViaActivity(response_id_U307);
];
[ call_U1565;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We]['re] carrying too many things already.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ConjugateVerb7(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carrying too many things already.";
    rtrue;
];
[ call_U1566;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1566, 578, 0);
        }
        MoveObject(noun, actor);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1566, 578, 2);
        }
    }
    rfalse;
];
[ call_U1567;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1567, 579, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U308);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U309);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1567, 579, 2);
        }
    }
    rfalse;
];
[ call_U1568;
    ResponseViaActivity(response_id_U308);
];
[ call_U1569;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [take] off [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb36(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " off ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1570;
    ResponseViaActivity(response_id_U309);
];
[ call_U1571;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [take] off [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb36(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " off ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1572;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1572, 580, 0);
        }
        if ((~~((actor == HolderOf(noun))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U310);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1572, 580, 2);
        }
    }
    rfalse;
];
[ call_U1573;
    ResponseViaActivity(response_id_U310);
];
[ call_U1574;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [aren't] holding [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " holding ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1575;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1575, 581, 0);
        }
        if ((actor == second)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U311);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1575, 581, 2);
        }
    }
    rfalse;
];
[ call_U1576;
    ResponseViaActivity(response_id_U311);
];
[ call_U1577;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [can't give] [the noun] to [ourselves].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb37);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " to ";
    ParaContent();
    call_U170();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1578;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1578, 582, 0);
        }
        if ((~~((second ofclass K8_person)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U312);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1578, 582, 2);
        }
    }
    rfalse;
];
[ call_U1579;
    ResponseViaActivity(response_id_U312);
];
[ call_U1580;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The second noun] [aren't] able to receive things.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " able to receive things.";
    rtrue;
];
[ call_U1581;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1581, 583, 0);
        }
        if ((actor == WearerOf(noun))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U313);
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Disrobe, noun, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1581, 583, 2);
        }
    }
    rfalse;
];
[ call_U1582;
    ResponseViaActivity(response_id_U313);
];
[ call_U1583;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first taking [the noun] off)[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1584;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1584, 584, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U314);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1584, 584, 2);
        }
    }
    rfalse;
];
[ call_U1585;
    ResponseViaActivity(response_id_U314);
];
[ call_U1586;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The second noun] [don't] seem interested.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " seem interested.";
    rtrue;
];
[ call_U1587;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1587, 585, 0);
        }
        if (((call_U1588)() >= GProperty(OBJECT_TY, second, A_capacity))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U315);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1587, 585, 2);
        }
    }
    rfalse;
];
[ call_U1588 x x_ix counter;
    objectloop (x in second) {
        if ((CarrierOf(x) == parent(x))) {
            if ((x ofclass K2_thing)) {
                (counter)++;
                jump NextOuterLoop_5;
            }
            .NextOuterLoop_5;
        }
    }
    return counter;
];
[ call_U1589;
    ResponseViaActivity(response_id_U315);
];
[ call_U1590;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The second noun] [are] carrying too many things already.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " carrying too many things already.";
    rtrue;
];
[ call_U1591;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1591, 586, 0);
        }
        MoveObject(noun, second, 0, 0);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1591, 586, 2);
        }
    }
    rfalse;
];
[ call_U1592;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1592, 587, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U316);
            print "^";
        } else {
            if ((second == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U317);
                print "^";
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U318);
                print "^";
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1592, 587, 2);
        }
    }
    rfalse;
];
[ call_U1593;
    ResponseViaActivity(response_id_U316);
];
[ call_U1594;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [give] [the noun] to [the second noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb37(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " to ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1595;
    ResponseViaActivity(response_id_U317);
];
[ call_U1596;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [give] [the noun] to [us].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb37(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " to ";
    ParaContent();
    call_U168();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1597;
    ResponseViaActivity(response_id_U318);
];
[ call_U1598;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [give] [the noun] to [the second noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb37(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " to ";
    ParaContent();
    DefArt(second);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1599;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1599, 588, 0);
        }
        if ((~~((actor == HolderOf(noun))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U319);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1599, 588, 2);
        }
    }
    rfalse;
];
[ call_U1600;
    ResponseViaActivity(response_id_U319);
];
[ call_U1601;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [aren't] holding [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " holding ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1602;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1602, 589, 0);
        }
        if ((actor == second)) {
            return GVS_Convert(##Examine, noun, 0);
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1602, 589, 2);
        }
    }
    rfalse;
];
[ call_U1603;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1603, 590, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U320);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1603, 590, 2);
        }
    }
    rfalse;
];
[ call_U1604;
    ResponseViaActivity(response_id_U320);
];
[ call_U1605;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The second noun] [are] unimpressed.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(second);
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unimpressed.";
    rtrue;
];
[ call_U1606;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1606, 591, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U321);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1606, 591, 2);
        }
    }
    rfalse;
];
[ call_U1607;
    ResponseViaActivity(response_id_U321);
];
[ call_U1608;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~That [seem] unnecessary.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "That ";
    ConjugateVerb6(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unnecessary.";
    rtrue;
];
[ call_U1609;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1609, 592, 0);
        }
        if ((actor == WearerOf(noun))) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U322);
            @push keep_silent;
            (keep_silent = 1);
            @push say__p;
            @push say__pc;
            ClearParagraphing(1);
            TryAction(0, actor, ##Disrobe, noun, 0);
            DivideParagraphPoint();
            @pull say__pc;
            @pull say__p;
            AdjustParagraphPoint();
            @pull keep_silent;
            if ((actor == WearerOf(noun))) {
                rtrue;
            }
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1609, 592, 2);
        }
    }
    rfalse;
];
[ call_U1610;
    ResponseViaActivity(response_id_U322);
];
[ call_U1611;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~(first taking [the noun] off)[command clarification break]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "(first taking ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print " off)";
    ParaContent();
    CommandClarificationBreak();
    rtrue;
];
[ call_U1612;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1612, 593, 0);
        }
        if ((~~((second ofclass K8_person)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U323);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1612, 593, 2);
        }
    }
    rfalse;
];
[ call_U1613;
    ResponseViaActivity(response_id_U323);
];
[ call_U1614;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Futile.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Futile.";
    rtrue;
];
[ call_U1615;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1615, 594, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U324);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1615, 594, 2);
        }
    }
    rfalse;
];
[ call_U1616;
    ResponseViaActivity(response_id_U324);
];
[ call_U1617;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [lack] the nerve when it [if story tense is the past^tense]came[otherwise]comes[end if] to the crucial moment.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb13(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " the nerve when it ";
    if ((~~((story_tense == I_past_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "came";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "comes";
    .L_SayX0;
    ParaContent();
    print " to the crucial moment.";
    rtrue;
];
[ call_U1618;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1618, 595, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U325);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1618, 595, 2);
        }
    }
    rfalse;
];
[ call_U1619;
    ResponseViaActivity(response_id_U325);
];
[ call_U1620;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Violence [aren't] the answer to this one.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Violence ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " the answer to this one.";
    rtrue;
];
[ call_U1621;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1621, 596, 0);
        }
        if ((noun == actor)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U326);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1621, 596, 2);
        }
    }
    rfalse;
];
[ call_U1622;
    ResponseViaActivity(response_id_U326);
];
[ call_U1623;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [don't] get much from that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb29(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " get much from that.";
    rtrue;
];
[ call_U1624;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1624, 597, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U327);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1624, 597, 2);
        }
    }
    rfalse;
];
[ call_U1625;
    ResponseViaActivity(response_id_U327);
];
[ call_U1626;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [might not] like that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " like that.";
    rtrue;
];
[ call_U1627;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1627, 598, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U328);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1627, 598, 2);
        }
    }
    rfalse;
];
[ call_U1628;
    ResponseViaActivity(response_id_U328);
];
[ call_U1629;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no reply.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U194();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no reply.";
    rtrue;
];
[ call_U1630;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1630, 599, 0);
        }
        if ((actor == noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U329);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1630, 599, 2);
        }
    }
    rfalse;
];
[ call_U1631;
    ResponseViaActivity(response_id_U329);
];
[ call_U1632;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [talk] to [ourselves] a while.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb38(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to ";
    ParaContent();
    call_U170();
    ParaContent();
    print " a while.";
    rtrue;
];
[ call_U1633;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1633, 600, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U330);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1633, 600, 2);
        }
    }
    rfalse;
];
[ call_U1634;
    ResponseViaActivity(response_id_U330);
];
[ call_U1635;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This [provoke] no reaction.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This ";
    ConjugateVerb39(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no reaction.";
    rtrue;
];
[ call_U1636;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1636, 601, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U331);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1636, 601, 2);
        }
    }
    rfalse;
];
[ call_U1637;
    ResponseViaActivity(response_id_U331);
];
[ call_U1638;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There] [are] no reply.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U194();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " no reply.";
    rtrue;
];
[ call_U1639;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1639, 602, 0);
        }
        if ((((actor == noun)) && ((actor == player)))) {
            TryAction(0, player, ##Inv, 0, 0);
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1639, 602, 2);
        }
    }
    rfalse;
];
[ call_U1640;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1640, 603, 0);
        }
        return ConvertToRequest(noun, ##Give, second, actor);
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1640, 603, 2);
        }
    }
    rfalse;
];
[ call_U1641;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1641, 604, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (prior_named_noun = 0);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U332);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U333);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1641, 604, 2);
        }
    }
    rfalse;
];
[ call_U1642;
    ResponseViaActivity(response_id_U332);
];
[ call_U1643;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Time [pass].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Time ";
    ConjugateVerb40(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1644;
    ResponseViaActivity(response_id_U333);
];
[ call_U1645;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [wait].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb41(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1646;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1646, 605, 0);
        }
        if ((noun == actor)) {
            if ((actor == player)) {
                if ((keep_silent == 0)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U334);
                    print "^";
                }
            } else {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U335);
                print "^";
            }
            rtrue;
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1646, 605, 2);
        }
    }
    rfalse;
];
[ call_U1647;
    ResponseViaActivity(response_id_U334);
];
[ call_U1648;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [achieve] nothing by this.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb17(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing by this.";
    rtrue;
];
[ call_U1649;
    ResponseViaActivity(response_id_U335);
];
[ call_U1650;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [touch] [themselves].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb42(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    call_U189();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1651;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1651, 606, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                if ((keep_silent == 0)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U336);
                    print "^";
                }
            } else {
                if ((noun == player)) {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U337);
                    print "^";
                } else {
                    (say__p = 1);
                    ParaContent();
                    TEXT_TY_Say(as_block_constant_U338);
                    print "^";
                }
            }
            rtrue;
        }
        rfalse;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1651, 606, 2);
        }
    }
    rfalse;
];
[ call_U1652;
    ResponseViaActivity(response_id_U336);
];
[ call_U1653;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [might not like] that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1654;
    ResponseViaActivity(response_id_U337);
];
[ call_U1655;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [touch] [us].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb42(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    call_U168();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1656;
    ResponseViaActivity(response_id_U338);
];
[ call_U1657;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [touch] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb42(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1658;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1658, 607, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U339);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U340);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1658, 607, 2);
        }
    }
    rfalse;
];
[ call_U1659;
    ResponseViaActivity(response_id_U339);
];
[ call_U1660;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [feel] nothing unexpected.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb44(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing unexpected.";
    rtrue;
];
[ call_U1661;
    ResponseViaActivity(response_id_U340);
];
[ call_U1662;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [touch] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb42(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1663;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1663, 608, 0);
        }
        if ((~~((actor == HolderOf(noun))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U341);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1663, 608, 2);
        }
    }
    rfalse;
];
[ call_U1664;
    ResponseViaActivity(response_id_U341);
];
[ call_U1665;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~But [we] [aren't] holding [regarding the noun][those].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "But ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " holding ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U177();
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1666;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1666, 609, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U342);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U343);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1666, 609, 2);
        }
    }
    rfalse;
];
[ call_U1667;
    ResponseViaActivity(response_id_U342);
];
[ call_U1668;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [wave] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb45(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1669;
    ResponseViaActivity(response_id_U343);
];
[ call_U1670;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [wave] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb45(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1671;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1671, 610, 0);
        }
        if (call_U258(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U344);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1671, 610, 2);
        }
    }
    rfalse;
];
[ call_U1672;
    ResponseViaActivity(response_id_U344);
];
[ call_U1673;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [are] fixed in place.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U182();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " fixed in place.";
    rtrue;
];
[ call_U1674;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1674, 611, 0);
        }
        if (call_U264(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U345);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1674, 611, 2);
        }
    }
    rfalse;
];
[ call_U1675;
    ResponseViaActivity(response_id_U345);
];
[ call_U1676;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [are] unable to.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unable to.";
    rtrue;
];
[ call_U1677;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1677, 612, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U346);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1677, 612, 2);
        }
    }
    rfalse;
];
[ call_U1678;
    ResponseViaActivity(response_id_U346);
];
[ call_U1679;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [might not like] that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1680;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1680, 613, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (prior_named_noun = 0);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U347);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U348);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1680, 613, 2);
        }
    }
    rfalse;
];
[ call_U1681;
    ResponseViaActivity(response_id_U347);
];
[ call_U1682;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nothing obvious [happen].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nothing obvious ";
    ConjugateVerb46(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1683;
    ResponseViaActivity(response_id_U348);
];
[ call_U1684;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [pull] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb47(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1685;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1685, 614, 0);
        }
        if (call_U258(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U349);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1685, 614, 2);
        }
    }
    rfalse;
];
[ call_U1686;
    ResponseViaActivity(response_id_U349);
];
[ call_U1687;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [are] fixed in place.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U182();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " fixed in place.";
    rtrue;
];
[ call_U1688;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1688, 615, 0);
        }
        if (call_U264(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U350);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1688, 615, 2);
        }
    }
    rfalse;
];
[ call_U1689;
    ResponseViaActivity(response_id_U350);
];
[ call_U1690;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [are] unable to.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unable to.";
    rtrue;
];
[ call_U1691;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1691, 616, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U351);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1691, 616, 2);
        }
    }
    rfalse;
];
[ call_U1692;
    ResponseViaActivity(response_id_U351);
];
[ call_U1693;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [might not like] that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1694;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1694, 617, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (prior_named_noun = 0);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U352);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U353);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1694, 617, 2);
        }
    }
    rfalse;
];
[ call_U1695;
    ResponseViaActivity(response_id_U352);
];
[ call_U1696;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nothing obvious [happen].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nothing obvious ";
    ConjugateVerb46(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1697;
    ResponseViaActivity(response_id_U353);
];
[ call_U1698;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [push] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb48(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1699;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1699, 618, 0);
        }
        if (call_U258(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U354);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1699, 618, 2);
        }
    }
    rfalse;
];
[ call_U1700;
    ResponseViaActivity(response_id_U354);
];
[ call_U1701;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [are] fixed in place.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U182();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " fixed in place.";
    rtrue;
];
[ call_U1702;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1702, 619, 0);
        }
        if (call_U264(noun)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U355);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1702, 619, 2);
        }
    }
    rfalse;
];
[ call_U1703;
    ResponseViaActivity(response_id_U355);
];
[ call_U1704;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [are] unable to.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " unable to.";
    rtrue;
];
[ call_U1705;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1705, 620, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U356);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1705, 620, 2);
        }
    }
    rfalse;
];
[ call_U1706;
    ResponseViaActivity(response_id_U356);
];
[ call_U1707;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [might not like] that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1708;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1708, 621, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (prior_named_noun = 0);
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U357);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U358);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1708, 621, 2);
        }
    }
    rfalse;
];
[ call_U1709;
    ResponseViaActivity(response_id_U357);
];
[ call_U1710;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nothing obvious [happen].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nothing obvious ";
    ConjugateVerb46(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1711;
    ResponseViaActivity(response_id_U358);
];
[ call_U1712;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [turn] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb49(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1713;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1713, 622, 0);
        }
        if ((~~(call_U270(noun)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U359);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1713, 622, 2);
        }
    }
    rfalse;
];
[ call_U1714;
    ResponseViaActivity(response_id_U359);
];
[ call_U1715;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [cannot] be pushed from place to place.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " be pushed from place to place.";
    rtrue;
];
[ call_U1716;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1716, 623, 0);
        }
        if ((~~((second ofclass K3_direction)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U360);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1716, 623, 2);
        }
    }
    rfalse;
];
[ call_U1717;
    ResponseViaActivity(response_id_U360);
];
[ call_U1718;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[regarding the noun][They] [aren't] a direction.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U182();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " a direction.";
    rtrue;
];
[ call_U1719;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1719, 624, 0);
        }
        if ((((second == I_up_U1)) || ((second == I_down_U1)))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U361);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1719, 624, 2);
        }
    }
    rfalse;
];
[ call_U1720;
    ResponseViaActivity(response_id_U361);
];
[ call_U1721;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [cannot] be pushed up or down.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " be pushed up or down.";
    rtrue;
];
[ call_U1722;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1722, 625, 0);
        }
        if (IndirectlyContains(noun, actor)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U362);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1722, 625, 2);
        }
    }
    rfalse;
];
[ call_U1723;
    ResponseViaActivity(response_id_U362);
];
[ call_U1724;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [cannot] be pushed from here.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " be pushed from here.";
    rtrue;
];
[ call_U1725;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1725, 626, 0);
        }
        return ConvertToGoingWithPush();
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1725, 626, 2);
        }
    }
    rfalse;
];
[ call_U1726;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1726, 627, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U363);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1726, 627, 2);
        }
    }
    rfalse;
];
[ call_U1727;
    ResponseViaActivity(response_id_U363);
];
[ call_U1728;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [cannot] be pushed from place to place.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb8(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " be pushed from place to place.";
    rtrue;
];
[ call_U1729;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1729, 628, 0);
        }
        if ((noun ofclass K8_person)) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U364);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1729, 628, 2);
        }
    }
    rfalse;
];
[ call_U1730;
    ResponseViaActivity(response_id_U364);
];
[ call_U1731;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [might not like] that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1732;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1732, 629, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U365);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U366);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1732, 629, 2);
        }
    }
    rfalse;
];
[ call_U1733;
    ResponseViaActivity(response_id_U365);
];
[ call_U1734;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [achieve] nothing by this.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb17(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing by this.";
    rtrue;
];
[ call_U1735;
    ResponseViaActivity(response_id_U366);
];
[ call_U1736;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [squeeze] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb50(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1737;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1737, 630, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U367);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1737, 630, 2);
        }
    }
    rfalse;
];
[ call_U1738;
    ResponseViaActivity(response_id_U367);
];
[ call_U1739;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~That was a rhetorical question.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "That was a rhetorical question.";
    rtrue;
];
[ call_U1740;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1740, 631, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U368);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1740, 631, 2);
        }
    }
    rfalse;
];
[ call_U1741;
    ResponseViaActivity(response_id_U368);
];
[ call_U1742;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~That was a rhetorical question.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "That was a rhetorical question.";
    rtrue;
];
[ call_U1743;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1743, 632, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U369);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1743, 632, 2);
        }
    }
    rfalse;
];
[ call_U1744;
    ResponseViaActivity(response_id_U369);
];
[ call_U1745;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~This dangerous act [would achieve] little.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "This dangerous act ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb17);
    (say__p = 1);
    ParaContent();
    print " little.";
    rtrue;
];
[ call_U1746;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1746, 633, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U370);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1746, 633, 2);
        }
    }
    rfalse;
];
[ call_U1747;
    ResponseViaActivity(response_id_U370);
];
[ call_U1748;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~The dreadful truth [are], this [are not] a dream.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "The dreadful truth ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ", this ";
    ConjugateVerb1(CV_NEG, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " a dream.";
    rtrue;
];
[ call_U1749;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1749, 634, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U371);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1749, 634, 2);
        }
    }
    rfalse;
];
[ call_U1750;
    ResponseViaActivity(response_id_U371);
];
[ call_U1751;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~What a good idea.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "What a good idea.";
    rtrue;
];
[ call_U1752;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1752, 635, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U372);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U373);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1752, 635, 2);
        }
    }
    rfalse;
];
[ call_U1753;
    ResponseViaActivity(response_id_U372);
];
[ call_U1754;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [smell] nothing unexpected.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb51(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing unexpected.";
    rtrue;
];
[ call_U1755;
    ResponseViaActivity(response_id_U373);
];
[ call_U1756;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [sniff].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb52(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1757;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1757, 636, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U374);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U375);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1757, 636, 2);
        }
    }
    rfalse;
];
[ call_U1758;
    ResponseViaActivity(response_id_U374);
];
[ call_U1759;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [hear] nothing unexpected.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb53(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing unexpected.";
    rtrue;
];
[ call_U1760;
    ResponseViaActivity(response_id_U375);
];
[ call_U1761;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [listen].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb54(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1762;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1762, 637, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U376);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U377);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1762, 637, 2);
        }
    }
    rfalse;
];
[ call_U1763;
    ResponseViaActivity(response_id_U376);
];
[ call_U1764;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [taste] nothing unexpected.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb55(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " nothing unexpected.";
    rtrue;
];
[ call_U1765;
    ResponseViaActivity(response_id_U377);
];
[ call_U1766;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [taste] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb55(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1767;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1767, 638, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U378);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1767, 638, 2);
        }
    }
    rfalse;
];
[ call_U1768;
    ResponseViaActivity(response_id_U378);
];
[ call_U1769;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Cutting [regarding the noun][them] up [would achieve] little.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Cutting ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U185();
    ParaContent();
    print " up ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb17);
    (say__p = 1);
    ParaContent();
    print " little.";
    rtrue;
];
[ call_U1770;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1770, 639, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U379);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U380);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1770, 639, 2);
        }
    }
    rfalse;
];
[ call_U1771;
    ResponseViaActivity(response_id_U379);
];
[ call_U1772;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [jump] on the spot.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb56(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on the spot.";
    rtrue;
];
[ call_U1773;
    ResponseViaActivity(response_id_U380);
];
[ call_U1774;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [jump] on the spot.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb56(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on the spot.";
    rtrue;
];
[ call_U1775;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1775, 640, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U381);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1775, 640, 2);
        }
    }
    rfalse;
];
[ call_U1776;
    ResponseViaActivity(response_id_U381);
];
[ call_U1777;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [would achieve] nothing by this.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb10(CV_POS, PNToVP(), story_tense, ConjugateVerb17);
    (say__p = 1);
    ParaContent();
    print " nothing by this.";
    rtrue;
];
[ call_U1778;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1778, 641, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U382);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1778, 641, 2);
        }
    }
    rfalse;
];
[ call_U1779;
    ResponseViaActivity(response_id_U382);
];
[ call_U1780;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There's] nothing suitable to drink here.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U198();
    ParaContent();
    print " nothing suitable to drink here.";
    rtrue;
];
[ call_U1781;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1781, 642, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U383);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1781, 642, 2);
        }
    }
    rfalse;
];
[ call_U1782;
    ResponseViaActivity(response_id_U383);
];
[ call_U1783;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Oh, don't [if American dialect option is^active]apologize[otherwise]apologise[end if].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Oh, don't ";
    if ((~~(call_U69(use_option_id_U2)))) {
        jump L_Say0;
    }
    ParaContent();
    print "apologize";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "apologise";
    .L_SayX0;
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1784;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1784, 643, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U384);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1784, 643, 2);
        }
    }
    rfalse;
];
[ call_U1785;
    ResponseViaActivity(response_id_U384);
];
[ call_U1786;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[There's] nothing sensible to swing here.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U198();
    ParaContent();
    print " nothing sensible to swing here.";
    rtrue;
];
[ call_U1787;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1787, 644, 0);
        }
        if ((((noun ofclass K8_person)) && ((~~((noun == actor)))))) {
            if ((actor == player)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U385);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1787, 644, 2);
        }
    }
    rfalse;
];
[ call_U1788;
    ResponseViaActivity(response_id_U385);
];
[ call_U1789;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The noun] [might not like] that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(noun);
    ParaContent();
    print " ";
    ConjugateVerb19(CV_NEG, PNToVP(), story_tense, ConjugateVerb43);
    (say__p = 1);
    ParaContent();
    print " that.";
    rtrue;
];
[ call_U1790;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1790, 645, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U386);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U387);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1790, 645, 2);
        }
    }
    rfalse;
];
[ call_U1791;
    ResponseViaActivity(response_id_U386);
];
[ call_U1792;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [rub] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb57(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1793;
    ResponseViaActivity(response_id_U387);
];
[ call_U1794;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [rub] [the noun].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb57(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    DefArt(noun);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1795;
    if ((((act_requester == 0)) && ((noun ofclass K2_thing)))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1795, 646, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U388);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1795, 646, 2);
        }
    }
    rfalse;
];
[ call_U1796;
    ResponseViaActivity(response_id_U388);
];
[ call_U1797;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~No, [we] [can't set] [regarding the noun][those] to anything.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "No, ";
    ParaContent();
    call_U167();
    ParaContent();
    print " ";
    ConjugateVerb2(CV_POS, PNToVP(), story_tense, ConjugateVerb58);
    (say__p = 1);
    ParaContent();
    print " ";
    ParaContent();
    RegardingSingleObject(noun);
    ParaContent();
    call_U177();
    ParaContent();
    print " to anything.";
    rtrue;
];
[ call_U1798;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1798, 647, 0);
        }
        if ((actor == player)) {
            if ((keep_silent == 0)) {
                (say__p = 1);
                ParaContent();
                TEXT_TY_Say(as_block_constant_U389);
                print "^";
            }
        } else {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U390);
            print "^";
        }
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1798, 647, 2);
        }
    }
    rfalse;
];
[ call_U1799;
    ResponseViaActivity(response_id_U389);
];
[ call_U1800;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [wave].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb45(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1801;
    ResponseViaActivity(response_id_U390);
];
[ call_U1802;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[The actor] [wave].~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    CDefArt(actor);
    ParaContent();
    print " ";
    ConjugateVerb45(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print ".";
    rtrue;
];
[ call_U1803;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1803, 648, 0);
        }
        if ((actor == player)) {
            (prior_named_noun = 0);
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U391);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1803, 648, 2);
        }
    }
    rfalse;
];
[ call_U1804;
    ResponseViaActivity(response_id_U391);
];
[ call_U1805;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Nothing [are] on sale.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Nothing ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " on sale.";
    rtrue;
];
[ call_U1806;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1806, 649, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U392);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1806, 649, 2);
        }
    }
    rfalse;
];
[ call_U1807;
    ResponseViaActivity(response_id_U392);
];
[ call_U1808;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Little [are] to be achieved by that.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Little ";
    ConjugateVerb1(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " to be achieved by that.";
    rtrue;
];
[ call_U1809;
    if ((act_requester == 0)) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1809, 650, 0);
        }
        if ((actor == player)) {
            (say__p = 1);
            ParaContent();
            TEXT_TY_Say(as_block_constant_U393);
            print "^";
        }
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1809, 650, 2);
        }
    }
    rfalse;
];
[ call_U1810;
    ResponseViaActivity(response_id_U393);
];
[ call_U1811;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~[We] [aren't] feeling especially drowsy.~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    call_U172();
    ParaContent();
    print " ";
    ConjugateVerb5(CV_POS, PNToVP(), story_tense);
    (say__p = 1);
    ParaContent();
    print " feeling especially drowsy.";
    rtrue;
];
[ call_U1812 sk;
    rfalse;
];
[ call_U1813 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K1_room)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "description: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_description), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_description));
                    print (char) 34;
                }
                print "^";
                if (GProperty(OBJECT_TY, t_0, A_map_region)) {
                    print "map region: ";
                    (PrintShortName)(GProperty(OBJECT_TY, t_0, A_map_region));
                    print "^";
                }
            }
        } else {
            if ((t_0 ofclass K1_room)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_light)) && ((t_0 has light)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "lighted";
                }
                if (((AllowInShowme(A_light)) && ((~~((t_0 has light)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "dark";
                }
                if (((AllowInShowme(A_visited)) && ((t_0 has visited)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "visited";
                }
                if (((AllowInShowme(A_visited)) && ((~~((t_0 has visited)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unvisited";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1814 sk;
    rfalse;
];
[ call_U1815 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K2_thing)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "description: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_description), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_description));
                    print (char) 34;
                }
                print "^";
                print "initial appearance: ";
                if ((TEXT_TY_Compare(GProperty(OBJECT_TY, t_0, A_initial), EMPTY_TEXT_VALUE) == 0)) {
                    print "none";
                } else {
                    print (char) 34;
                    (TEXT_TY_Say)(GProperty(OBJECT_TY, t_0, A_initial));
                    print (char) 34;
                }
                print "^";
                if (GProperty(OBJECT_TY, t_0, A_with_key)) {
                    print "matching key: ";
                    (PrintShortName)(GProperty(OBJECT_TY, t_0, A_with_key));
                    print "^";
                }
            }
        } else {
            if ((t_0 ofclass K2_thing)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_light)) && ((t_0 has light)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "lit";
                }
                if (((AllowInShowme(A_light)) && ((~~((t_0 has light)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unlit";
                }
                if (((AllowInShowme(A_edible)) && ((t_0 has edible)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "edible";
                }
                if (((AllowInShowme(A_edible)) && ((~~((t_0 has edible)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "inedible";
                }
                if (((AllowInShowme(A_static)) && ((t_0 has static)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "fixed in place";
                }
                if (((AllowInShowme(A_static)) && ((~~((t_0 has static)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "portable";
                }
                if (((AllowInShowme(A_scenery)) && ((t_0 has scenery)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "scenery";
                }
                if (((AllowInShowme(A_clothing)) && ((t_0 has clothing)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "wearable";
                }
                if (((AllowInShowme(A_pushable)) && ((t_0 has pushable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "pushable between rooms";
                }
                if (((AllowInShowme(A_moved)) && ((t_0 has moved)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "handled";
                }
                if (((AllowInShowme(A_concealed)) && ((t_0 has concealed)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "undescribed";
                }
                if (((AllowInShowme(A_concealed)) && ((~~((t_0 has concealed)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "described";
                }
                if (((AllowInShowme(A_workflag)) && ((t_0 has workflag)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "marked for listing";
                }
                if (((AllowInShowme(A_workflag)) && ((~~((t_0 has workflag)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unmarked for listing";
                }
                if (((AllowInShowme(A_mentioned)) && ((t_0 has mentioned)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "mentioned";
                }
                if (((AllowInShowme(A_mentioned)) && ((~~((t_0 has mentioned)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unmentioned";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1816 sk;
    rfalse;
];
[ call_U1817 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K3_direction)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                if (GProperty(OBJECT_TY, t_0, A_P_opposite)) {
                    print "opposite: ";
                    (PrintShortName)(GProperty(OBJECT_TY, t_0, A_P_opposite));
                    print "^";
                }
            }
        } else {
            if ((t_0 ofclass K3_direction)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_scenery)) && ((t_0 has scenery)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "scenery";
                }
                if (((AllowInShowme(A_workflag)) && ((t_0 has workflag)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "marked for listing";
                }
                if (((AllowInShowme(A_workflag)) && ((~~((t_0 has workflag)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unmarked for listing";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1818 sk;
    rfalse;
];
[ call_U1819 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K4_door)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                if (GProperty(OBJECT_TY, t_0, A_door_to)) {
                    print "leading-through destination: ";
                    (PrintShortName)(GProperty(OBJECT_TY, t_0, A_door_to));
                    print "^";
                }
            }
        } else {
            if ((t_0 ofclass K4_door)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_open)) && ((t_0 has open)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "open";
                }
                if (((AllowInShowme(A_open)) && ((~~((t_0 has open)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "closed";
                }
                if (((AllowInShowme(A_openable)) && ((t_0 has openable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "openable";
                }
                if (((AllowInShowme(A_openable)) && ((~~((t_0 has openable)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unopenable";
                }
                if (((AllowInShowme(A_lockable)) && ((t_0 has lockable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "lockable";
                }
                if (((AllowInShowme(A_locked)) && ((t_0 has locked)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "locked";
                }
                if (((AllowInShowme(A_locked)) && ((~~((t_0 has locked)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unlocked";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1820 sk;
    rfalse;
];
[ call_U1821 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K5_container)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "carrying capacity: ";
                (call_U8)(GProperty(OBJECT_TY, t_0, A_capacity));
                print "^";
            }
        } else {
            if ((t_0 ofclass K5_container)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_enterable)) && ((t_0 has enterable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "enterable";
                }
                if (((AllowInShowme(A_transparent)) && ((t_0 has transparent)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "transparent";
                }
                if (((AllowInShowme(A_transparent)) && ((~~((t_0 has transparent)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "opaque";
                }
                if (((AllowInShowme(A_open)) && ((t_0 has open)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "open";
                }
                if (((AllowInShowme(A_open)) && ((~~((t_0 has open)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "closed";
                }
                if (((AllowInShowme(A_openable)) && ((t_0 has openable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "openable";
                }
                if (((AllowInShowme(A_openable)) && ((~~((t_0 has openable)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unopenable";
                }
                if (((AllowInShowme(A_lockable)) && ((t_0 has lockable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "lockable";
                }
                if (((AllowInShowme(A_locked)) && ((t_0 has locked)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "locked";
                }
                if (((AllowInShowme(A_locked)) && ((~~((t_0 has locked)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "unlocked";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1822 sk;
    rfalse;
];
[ call_U1823 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K6_supporter)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "carrying capacity: ";
                (call_U8)(GProperty(OBJECT_TY, t_0, A_capacity));
                print "^";
            }
        } else {
            if ((t_0 ofclass K6_supporter)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_enterable)) && ((t_0 has enterable)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "enterable";
                }
                if (((AllowInShowme(A_transparent)) && ((t_0 has transparent)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "transparent";
                }
                if (((AllowInShowme(A_transparent)) && ((~~((t_0 has transparent)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "opaque";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1824 sk;
    rfalse;
];
[ call_U1825 sk;
    rfalse;
];
[ call_U1826 which na t_0;
    #ifdef DEBUG;
        if (which) {
            if ((t_0 ofclass K8_person)) {
                if ((na > 0)) {
                    (na = 0);
                    print "^";
                }
                print "carrying capacity: ";
                (call_U8)(GProperty(OBJECT_TY, t_0, A_capacity));
                print "^";
            }
        } else {
            if ((t_0 ofclass K8_person)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_transparent)) && ((t_0 has transparent)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "transparent";
                }
                if (((AllowInShowme(A_transparent)) && ((~~((t_0 has transparent)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "opaque";
                }
                if (((AllowInShowme(A_female)) && ((t_0 has female)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "female";
                }
                if (((AllowInShowme(A_female)) && ((~~((t_0 has female)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "male";
                }
                if (((AllowInShowme(A_neuter)) && ((t_0 has neuter)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "neuter";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1827 sk;
    rfalse;
];
[ call_U1828 sk;
    rfalse;
];
[ call_U1829 sk;
    rfalse;
];
[ call_U1830 sk;
    rfalse;
];
[ call_U1831 sk;
    rfalse;
];
[ call_U1832 which na t_0;
    #ifdef DEBUG;
        if (which) {
        } else {
            if ((t_0 ofclass K13_device)) {
                if ((na > 0)) {
                    (na = 0);
                    print "; ";
                }
                if (((AllowInShowme(A_on)) && ((t_0 has on)))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "switched on";
                }
                if (((AllowInShowme(A_on)) && ((~~((t_0 has on)))))) {
                    if (((na)++ > 0)) {
                        print ", ";
                    }
                    print "switched off";
                }
            }
        }
        return na;
    #endif;
];
[ call_U1833 sk;
    rfalse;
];
[ call_U1834 sk;
    rfalse;
];
[ call_U1835 sk;
    return I_didn_t_understand_error_U1;
];
[ E6 value;
    switch (value) {
        I_didn_t_understand_error_U1:
            print "didn't understand error";
            ;
        I_only_understood_as_far_as__U1:
            print "only understood as far as error";
            ;
        I_didn_t_understand_that_num_U1:
            print "didn't understand that number error";
            ;
        I_can_only_do_that_to_someth_U1:
            print "can only do that to something animate error";
            ;
        I_can_t_see_any_such_thing_e_U1:
            print "can't see any such thing error";
            ;
        I_said_too_little_error_U1:
            print "said too little error";
            ;
        I_aren_t_holding_that_error_U1:
            print "aren't holding that error";
            ;
        I_can_t_use_multiple_objects_U1:
            print "can't use multiple objects error";
            ;
        I_can_only_use_multiple_obje_U1:
            print "can only use multiple objects error";
            ;
        I_not_sure_what_it_refers_to_U1:
            print "not sure what it refers to error";
            ;
        I_excepted_something_not_inc_U1:
            print "excepted something not included error";
            ;
        I_not_a_verb_i_recognise_err_U1:
            print "not a verb I recognise error";
            ;
        I_not_something_you_need_to__U1:
            print "not something you need to refer to error";
            ;
        I_can_t_see_it_at_the_moment_U1:
            print "can't see it at the moment error";
            ;
        I_didn_t_understand_the_way__U1:
            print "didn't understand the way that finished error";
            ;
        I_not_enough_of_those_availa_U1:
            print "not enough of those available error";
            ;
        I_nothing_to_do_error_U1:
            print "nothing to do error";
            ;
        I_referred_to_a_determinatio_U1:
            print "referred to a determination of scope error";
            ;
        I_noun_did_not_make_sense_in_U1:
            print "noun did not make sense in that context error";
            ;
        I_i_beg_your_pardon_error_U1:
            print "I beg your pardon error";
            ;
        I_can_t_again_the_addressee__U1:
            print "can't again the addressee error";
            ;
        I_comma_can_t_begin_error_U1:
            print "comma can't begin error";
            ;
        I_can_t_see_whom_to_talk_to__U1:
            print "can't see whom to talk to error";
            ;
        I_can_t_talk_to_inanimate_th_U1:
            print "can't talk to inanimate things error";
            ;
        I_didn_t_understand_addresse_U1:
            print "didn't understand addressee's last name error";
            ;
        default:
            print "<illegal command parser error>";
            ;
    }
];
[ call_U1836 x;
    return ((x%25) + 1);
];
[ call_U1837 x;
    return (((x + 23)%25) + 1);
];
[ call_U1838 a b;
    if ((((a == 0)) && ((b == 0)))) {
        return random(25);
    }
    if ((a == b)) {
        return b;
    }
    if ((a > b)) {
        return (b + (random(MAX_POSITIVE_NUMBER)%((a - b) + 1)));
    }
    return (a + (random(MAX_POSITIVE_NUMBER)%((b - a) + 1)));
];
[ CommandPromptText;
    return (Global_Vars-->17);
];
[ call_U1839 t_0;
    CarryOutActivity(V32_printing_the_locale_descr, t_0);
    rfalse;
];
[ call_U1840 t_0 t_1 ct_0 ct_1;
    if ((t_0 ofclass K2_thing)) {
        if ((t_1 <= 0)) {
            call_U289(t_0);
        }
        if (ExistsTableLookUpCorr(table_data_U2, table_column_id_U6, table_column_id_U6, t_0)) {
            (ct_0 = table_data_U2);
            (ct_1 = TableRowCorr(ct_0, table_column_id_U6, t_0));
            if ((t_1 <= 0)) {
                TableBlankOutRow(ct_0, ct_1);
            } else {
                (TableLookUpEntry)(ct_0,table_column_id_U7,ct_1,1,t_1);
            }
        } else {
            if ((t_1 > 0)) {
                (ct_0 = table_data_U2);
                (ct_1 = TableBlankRow(ct_0));
                (TableLookUpEntry)(ct_0,table_column_id_U6,ct_1,1,t_0);
                (TableLookUpEntry)(ct_0,table_column_id_U7,ct_1,1,t_1);
            }
        }
    }
    rfalse;
];
[ call_U1841;
    (say__p = 1);
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "here";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "there";
    .L_SayX0;
    rfalse;
];
[ call_U1842;
    (say__p = 1);
    if ((~~((story_tense == I_present_tense_U1)))) {
        jump L_Say0;
    }
    ParaContent();
    print "now";
    jump L_SayX0;
    .L_Say0;
    ParaContent();
    print "then";
    .L_SayX0;
    rfalse;
];
[ call_U1843 t_0;
    CarryOutActivity(V4_issuing_the_response_text, t_0);
    rfalse;
];
[ ConjugateVerb3 fn vp t modal_to;
    switch (fn) {
        1:
            print "see";
            ;
        2:
            print "seen";
            ;
        3:
            print "seeing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "sees";
                    } else {
                        print "see";
                    }
                    ;
                2:
                    print "saw";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has seen";
                    } else {
                        print "have seen";
                    }
                    ;
                4:
                    print "had seen";
                    ;
                5:
                    print "will see";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not see";
                    } else {
                        print "do not see";
                    }
                    ;
                2:
                    print "did not see";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not seen";
                    } else {
                        print "have not seen";
                    }
                    ;
                4:
                    print "had not seen";
                    ;
                5:
                    print "will not see";
                    ;
            }
            ;
    }
];
[ call_U1844 fn vp t modal_to;
    (t = ConjugateVerb3(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb6 fn vp t modal_to;
    switch (fn) {
        1:
            print "seem";
            ;
        2:
            print "seemed";
            ;
        3:
            print "seeming";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "seems";
                    } else {
                        print "seem";
                    }
                    ;
                2:
                    print "seemed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has seemed";
                    } else {
                        print "have seemed";
                    }
                    ;
                4:
                    print "had seemed";
                    ;
                5:
                    print "will seem";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not seem";
                    } else {
                        print "do not seem";
                    }
                    ;
                2:
                    print "did not seem";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not seemed";
                    } else {
                        print "have not seemed";
                    }
                    ;
                4:
                    print "had not seemed";
                    ;
                5:
                    print "will not seem";
                    ;
            }
            ;
    }
];
[ call_U1845 fn vp t modal_to;
    (t = ConjugateVerb6(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb9 fn vp t modal_to;
    switch (fn) {
        1:
            print "look";
            ;
        2:
            print "looked";
            ;
        3:
            print "looking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "looks";
                    } else {
                        print "look";
                    }
                    ;
                2:
                    print "looked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has looked";
                    } else {
                        print "have looked";
                    }
                    ;
                4:
                    print "had looked";
                    ;
                5:
                    print "will look";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not look";
                    } else {
                        print "do not look";
                    }
                    ;
                2:
                    print "did not look";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not looked";
                    } else {
                        print "have not looked";
                    }
                    ;
                4:
                    print "had not looked";
                    ;
                5:
                    print "will not look";
                    ;
            }
            ;
    }
];
[ call_U1846 fn vp t modal_to;
    (t = ConjugateVerb9(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb11 fn vp t modal_to;
    switch (fn) {
        1:
            print "care";
            ;
        2:
            print "cared";
            ;
        3:
            print "caring";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "cares";
                    } else {
                        print "care";
                    }
                    ;
                2:
                    print "cared";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has cared";
                    } else {
                        print "have cared";
                    }
                    ;
                4:
                    print "had cared";
                    ;
                5:
                    print "will care";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not care";
                    } else {
                        print "do not care";
                    }
                    ;
                2:
                    print "did not care";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not cared";
                    } else {
                        print "have not cared";
                    }
                    ;
                4:
                    print "had not cared";
                    ;
                5:
                    print "will not care";
                    ;
            }
            ;
    }
];
[ call_U1847 fn vp t modal_to;
    (t = ConjugateVerb11(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb12 fn vp t modal_to;
    switch (fn) {
        1:
            print "pick";
            ;
        2:
            print "picked";
            ;
        3:
            print "picking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "picks";
                    } else {
                        print "pick";
                    }
                    ;
                2:
                    print "picked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has picked";
                    } else {
                        print "have picked";
                    }
                    ;
                4:
                    print "had picked";
                    ;
                5:
                    print "will pick";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not pick";
                    } else {
                        print "do not pick";
                    }
                    ;
                2:
                    print "did not pick";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not picked";
                    } else {
                        print "have not picked";
                    }
                    ;
                4:
                    print "had not picked";
                    ;
                5:
                    print "will not pick";
                    ;
            }
            ;
    }
];
[ call_U1848 fn vp t modal_to;
    (t = ConjugateVerb12(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb13 fn vp t modal_to;
    switch (fn) {
        1:
            print "lack";
            ;
        2:
            print "lacked";
            ;
        3:
            print "lacking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "lacks";
                    } else {
                        print "lack";
                    }
                    ;
                2:
                    print "lacked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has lacked";
                    } else {
                        print "have lacked";
                    }
                    ;
                4:
                    print "had lacked";
                    ;
                5:
                    print "will lack";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not lack";
                    } else {
                        print "do not lack";
                    }
                    ;
                2:
                    print "did not lack";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not lacked";
                    } else {
                        print "have not lacked";
                    }
                    ;
                4:
                    print "had not lacked";
                    ;
                5:
                    print "will not lack";
                    ;
            }
            ;
    }
];
[ call_U1849 fn vp t modal_to;
    (t = ConjugateVerb13(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb14 fn vp t modal_to;
    switch (fn) {
        1:
            print "drop";
            ;
        2:
            print "dropped";
            ;
        3:
            print "dropping";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "drops";
                    } else {
                        print "drop";
                    }
                    ;
                2:
                    print "dropped";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has dropped";
                    } else {
                        print "have dropped";
                    }
                    ;
                4:
                    print "had dropped";
                    ;
                5:
                    print "will drop";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not drop";
                    } else {
                        print "do not drop";
                    }
                    ;
                2:
                    print "did not drop";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not dropped";
                    } else {
                        print "have not dropped";
                    }
                    ;
                4:
                    print "had not dropped";
                    ;
                5:
                    print "will not drop";
                    ;
            }
            ;
    }
];
[ call_U1850 fn vp t modal_to;
    (t = ConjugateVerb14(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb16 fn vp t modal_to;
    switch (fn) {
        1:
            print "put";
            ;
        2:
            print "put";
            ;
        3:
            print "putting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "puts";
                    } else {
                        print "put";
                    }
                    ;
                2:
                    print "put";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has put";
                    } else {
                        print "have put";
                    }
                    ;
                4:
                    print "had put";
                    ;
                5:
                    print "will put";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not put";
                    } else {
                        print "do not put";
                    }
                    ;
                2:
                    print "did not put";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not put";
                    } else {
                        print "have not put";
                    }
                    ;
                4:
                    print "had not put";
                    ;
                5:
                    print "will not put";
                    ;
            }
            ;
    }
];
[ call_U1851 fn vp t modal_to;
    (t = ConjugateVerb16(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb17 fn vp t modal_to;
    switch (fn) {
        1:
            print "achieve";
            ;
        2:
            print "achieved";
            ;
        3:
            print "achieving";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "achieves";
                    } else {
                        print "achieve";
                    }
                    ;
                2:
                    print "achieved";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has achieved";
                    } else {
                        print "have achieved";
                    }
                    ;
                4:
                    print "had achieved";
                    ;
                5:
                    print "will achieve";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not achieve";
                    } else {
                        print "do not achieve";
                    }
                    ;
                2:
                    print "did not achieve";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not achieved";
                    } else {
                        print "have not achieved";
                    }
                    ;
                4:
                    print "had not achieved";
                    ;
                5:
                    print "will not achieve";
                    ;
            }
            ;
    }
];
[ call_U1852 fn vp t modal_to;
    (t = ConjugateVerb17(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb18 fn vp t modal_to;
    switch (fn) {
        1:
            print "contain";
            ;
        2:
            print "contained";
            ;
        3:
            print "containing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record8;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "contains";
                    } else {
                        print "contain";
                    }
                    ;
                2:
                    print "contained";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has contained";
                    } else {
                        print "have contained";
                    }
                    ;
                4:
                    print "had contained";
                    ;
                5:
                    print "will contain";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not contain";
                    } else {
                        print "do not contain";
                    }
                    ;
                2:
                    print "did not contain";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not contained";
                    } else {
                        print "have not contained";
                    }
                    ;
                4:
                    print "had not contained";
                    ;
                5:
                    print "will not contain";
                    ;
            }
            ;
    }
];
[ call_U1853 fn vp t modal_to;
    (t = ConjugateVerb18(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record8;
    }
];
[ ConjugateVerb20 fn vp t modal_to;
    switch (fn) {
        1:
            print "appreciate";
            ;
        2:
            print "appreciated";
            ;
        3:
            print "appreciating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "appreciates";
                    } else {
                        print "appreciate";
                    }
                    ;
                2:
                    print "appreciated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has appreciated";
                    } else {
                        print "have appreciated";
                    }
                    ;
                4:
                    print "had appreciated";
                    ;
                5:
                    print "will appreciate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not appreciate";
                    } else {
                        print "do not appreciate";
                    }
                    ;
                2:
                    print "did not appreciate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not appreciated";
                    } else {
                        print "have not appreciated";
                    }
                    ;
                4:
                    print "had not appreciated";
                    ;
                5:
                    print "will not appreciate";
                    ;
            }
            ;
    }
];
[ call_U1854 fn vp t modal_to;
    (t = ConjugateVerb20(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb21 fn vp t modal_to;
    switch (fn) {
        1:
            print "eat";
            ;
        2:
            print "eaten";
            ;
        3:
            print "eating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "eats";
                    } else {
                        print "eat";
                    }
                    ;
                2:
                    print "ate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has eaten";
                    } else {
                        print "have eaten";
                    }
                    ;
                4:
                    print "had eaten";
                    ;
                5:
                    print "will eat";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not eat";
                    } else {
                        print "do not eat";
                    }
                    ;
                2:
                    print "did not eat";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not eaten";
                    } else {
                        print "have not eaten";
                    }
                    ;
                4:
                    print "had not eaten";
                    ;
                5:
                    print "will not eat";
                    ;
            }
            ;
    }
];
[ call_U1855 fn vp t modal_to;
    (t = ConjugateVerb21(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb22 fn vp t modal_to;
    switch (fn) {
        1:
            print "go";
            ;
        2:
            print "gone";
            ;
        3:
            print "going";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "goes";
                    } else {
                        print "go";
                    }
                    ;
                2:
                    print "went";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has gone";
                    } else {
                        print "have gone";
                    }
                    ;
                4:
                    print "had gone";
                    ;
                5:
                    print "will go";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not go";
                    } else {
                        print "do not go";
                    }
                    ;
                2:
                    print "did not go";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not gone";
                    } else {
                        print "have not gone";
                    }
                    ;
                4:
                    print "had not gone";
                    ;
                5:
                    print "will not go";
                    ;
            }
            ;
    }
];
[ call_U1856 fn vp t modal_to;
    (t = ConjugateVerb22(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb23 fn vp t modal_to;
    switch (fn) {
        1:
            print "lead";
            ;
        2:
            print "led";
            ;
        3:
            print "leading";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "leads";
                    } else {
                        print "lead";
                    }
                    ;
                2:
                    print "led";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has led";
                    } else {
                        print "have led";
                    }
                    ;
                4:
                    print "had led";
                    ;
                5:
                    print "will lead";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not lead";
                    } else {
                        print "do not lead";
                    }
                    ;
                2:
                    print "did not lead";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not led";
                    } else {
                        print "have not led";
                    }
                    ;
                4:
                    print "had not led";
                    ;
                5:
                    print "will not lead";
                    ;
            }
            ;
    }
];
[ call_U1857 fn vp t modal_to;
    (t = ConjugateVerb23(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb24 fn vp t modal_to;
    switch (fn) {
        1:
            print "arrive";
            ;
        2:
            print "arrived";
            ;
        3:
            print "arriving";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "arrives";
                    } else {
                        print "arrive";
                    }
                    ;
                2:
                    print "arrived";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has arrived";
                    } else {
                        print "have arrived";
                    }
                    ;
                4:
                    print "had arrived";
                    ;
                5:
                    print "will arrive";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not arrive";
                    } else {
                        print "do not arrive";
                    }
                    ;
                2:
                    print "did not arrive";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not arrived";
                    } else {
                        print "have not arrived";
                    }
                    ;
                4:
                    print "had not arrived";
                    ;
                5:
                    print "will not arrive";
                    ;
            }
            ;
    }
];
[ call_U1858 fn vp t modal_to;
    (t = ConjugateVerb24(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb25 fn vp t modal_to;
    switch (fn) {
        1:
            print "get";
            ;
        2:
            print "got";
            ;
        3:
            print "getting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "gets";
                    } else {
                        print "get";
                    }
                    ;
                2:
                    print "got";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has got";
                    } else {
                        print "have got";
                    }
                    ;
                4:
                    print "had got";
                    ;
                5:
                    print "will get";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not get";
                    } else {
                        print "do not get";
                    }
                    ;
                2:
                    print "did not get";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not got";
                    } else {
                        print "have not got";
                    }
                    ;
                4:
                    print "had not got";
                    ;
                5:
                    print "will not get";
                    ;
            }
            ;
    }
];
[ call_U1859 fn vp t modal_to;
    (t = ConjugateVerb25(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb26 fn vp t modal_to;
    switch (fn) {
        1:
            print "find";
            ;
        2:
            print "found";
            ;
        3:
            print "finding";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "finds";
                    } else {
                        print "find";
                    }
                    ;
                2:
                    print "found";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has found";
                    } else {
                        print "have found";
                    }
                    ;
                4:
                    print "had found";
                    ;
                5:
                    print "will find";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not find";
                    } else {
                        print "do not find";
                    }
                    ;
                2:
                    print "did not find";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not found";
                    } else {
                        print "have not found";
                    }
                    ;
                4:
                    print "had not found";
                    ;
                5:
                    print "will not find";
                    ;
            }
            ;
    }
];
[ call_U1860 fn vp t modal_to;
    (t = ConjugateVerb26(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb27 fn vp t modal_to;
    switch (fn) {
        1:
            print "search";
            ;
        2:
            print "searched";
            ;
        3:
            print "searching";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "searches";
                    } else {
                        print "search";
                    }
                    ;
                2:
                    print "searched";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has searched";
                    } else {
                        print "have searched";
                    }
                    ;
                4:
                    print "had searched";
                    ;
                5:
                    print "will search";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not search";
                    } else {
                        print "do not search";
                    }
                    ;
                2:
                    print "did not search";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not searched";
                    } else {
                        print "have not searched";
                    }
                    ;
                4:
                    print "had not searched";
                    ;
                5:
                    print "will not search";
                    ;
            }
            ;
    }
];
[ call_U1861 fn vp t modal_to;
    (t = ConjugateVerb27(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb28 fn vp t modal_to;
    switch (fn) {
        1:
            print "discover";
            ;
        2:
            print "discovered";
            ;
        3:
            print "discovering";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "discovers";
                    } else {
                        print "discover";
                    }
                    ;
                2:
                    print "discovered";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has discovered";
                    } else {
                        print "have discovered";
                    }
                    ;
                4:
                    print "had discovered";
                    ;
                5:
                    print "will discover";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not discover";
                    } else {
                        print "do not discover";
                    }
                    ;
                2:
                    print "did not discover";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not discovered";
                    } else {
                        print "have not discovered";
                    }
                    ;
                4:
                    print "had not discovered";
                    ;
                5:
                    print "will not discover";
                    ;
            }
            ;
    }
];
[ call_U1862 fn vp t modal_to;
    (t = ConjugateVerb28(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb30 fn vp t modal_to;
    switch (fn) {
        1:
            print "lock";
            ;
        2:
            print "locked";
            ;
        3:
            print "locking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "locks";
                    } else {
                        print "lock";
                    }
                    ;
                2:
                    print "locked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has locked";
                    } else {
                        print "have locked";
                    }
                    ;
                4:
                    print "had locked";
                    ;
                5:
                    print "will lock";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not lock";
                    } else {
                        print "do not lock";
                    }
                    ;
                2:
                    print "did not lock";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not locked";
                    } else {
                        print "have not locked";
                    }
                    ;
                4:
                    print "had not locked";
                    ;
                5:
                    print "will not lock";
                    ;
            }
            ;
    }
];
[ call_U1863 fn vp t modal_to;
    (t = ConjugateVerb30(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb31 fn vp t modal_to;
    switch (fn) {
        1:
            print "unlock";
            ;
        2:
            print "unlocked";
            ;
        3:
            print "unlocking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record2;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "unlocks";
                    } else {
                        print "unlock";
                    }
                    ;
                2:
                    print "unlocked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has unlocked";
                    } else {
                        print "have unlocked";
                    }
                    ;
                4:
                    print "had unlocked";
                    ;
                5:
                    print "will unlock";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not unlock";
                    } else {
                        print "do not unlock";
                    }
                    ;
                2:
                    print "did not unlock";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not unlocked";
                    } else {
                        print "have not unlocked";
                    }
                    ;
                4:
                    print "had not unlocked";
                    ;
                5:
                    print "will not unlock";
                    ;
            }
            ;
    }
];
[ call_U1864 fn vp t modal_to;
    (t = ConjugateVerb31(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record2;
    }
];
[ ConjugateVerb32 fn vp t modal_to;
    switch (fn) {
        1:
            print "switch";
            ;
        2:
            print "switched";
            ;
        3:
            print "switching";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "switches";
                    } else {
                        print "switch";
                    }
                    ;
                2:
                    print "switched";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has switched";
                    } else {
                        print "have switched";
                    }
                    ;
                4:
                    print "had switched";
                    ;
                5:
                    print "will switch";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not switch";
                    } else {
                        print "do not switch";
                    }
                    ;
                2:
                    print "did not switch";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not switched";
                    } else {
                        print "have not switched";
                    }
                    ;
                4:
                    print "had not switched";
                    ;
                5:
                    print "will not switch";
                    ;
            }
            ;
    }
];
[ call_U1865 fn vp t modal_to;
    (t = ConjugateVerb32(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb33 fn vp t modal_to;
    switch (fn) {
        1:
            print "open";
            ;
        2:
            print "opened";
            ;
        3:
            print "opening";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "opens";
                    } else {
                        print "open";
                    }
                    ;
                2:
                    print "opened";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has opened";
                    } else {
                        print "have opened";
                    }
                    ;
                4:
                    print "had opened";
                    ;
                5:
                    print "will open";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not open";
                    } else {
                        print "do not open";
                    }
                    ;
                2:
                    print "did not open";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not opened";
                    } else {
                        print "have not opened";
                    }
                    ;
                4:
                    print "had not opened";
                    ;
                5:
                    print "will not open";
                    ;
            }
            ;
    }
];
[ call_U1866 fn vp t modal_to;
    (t = ConjugateVerb33(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb34 fn vp t modal_to;
    switch (fn) {
        1:
            print "close";
            ;
        2:
            print "closed";
            ;
        3:
            print "closing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "closes";
                    } else {
                        print "close";
                    }
                    ;
                2:
                    print "closed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has closed";
                    } else {
                        print "have closed";
                    }
                    ;
                4:
                    print "had closed";
                    ;
                5:
                    print "will close";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not close";
                    } else {
                        print "do not close";
                    }
                    ;
                2:
                    print "did not close";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not closed";
                    } else {
                        print "have not closed";
                    }
                    ;
                4:
                    print "had not closed";
                    ;
                5:
                    print "will not close";
                    ;
            }
            ;
    }
];
[ call_U1867 fn vp t modal_to;
    (t = ConjugateVerb34(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb35 fn vp t modal_to;
    switch (fn) {
        1:
            print "wear";
            ;
        2:
            print "worn";
            ;
        3:
            print "wearing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record14;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "wears";
                    } else {
                        print "wear";
                    }
                    ;
                2:
                    print "wore";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has worn";
                    } else {
                        print "have worn";
                    }
                    ;
                4:
                    print "had worn";
                    ;
                5:
                    print "will wear";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not wear";
                    } else {
                        print "do not wear";
                    }
                    ;
                2:
                    print "did not wear";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not worn";
                    } else {
                        print "have not worn";
                    }
                    ;
                4:
                    print "had not worn";
                    ;
                5:
                    print "will not wear";
                    ;
            }
            ;
    }
];
[ call_U1868 fn vp t modal_to;
    (t = ConjugateVerb35(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record14;
    }
];
[ ConjugateVerb36 fn vp t modal_to;
    switch (fn) {
        1:
            print "take";
            ;
        2:
            print "taken";
            ;
        3:
            print "taking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "takes";
                    } else {
                        print "take";
                    }
                    ;
                2:
                    print "took";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has taken";
                    } else {
                        print "have taken";
                    }
                    ;
                4:
                    print "had taken";
                    ;
                5:
                    print "will take";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not take";
                    } else {
                        print "do not take";
                    }
                    ;
                2:
                    print "did not take";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not taken";
                    } else {
                        print "have not taken";
                    }
                    ;
                4:
                    print "had not taken";
                    ;
                5:
                    print "will not take";
                    ;
            }
            ;
    }
];
[ call_U1869 fn vp t modal_to;
    (t = ConjugateVerb36(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb37 fn vp t modal_to;
    switch (fn) {
        1:
            print "give";
            ;
        2:
            print "given";
            ;
        3:
            print "giving";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "gives";
                    } else {
                        print "give";
                    }
                    ;
                2:
                    print "gave";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has given";
                    } else {
                        print "have given";
                    }
                    ;
                4:
                    print "had given";
                    ;
                5:
                    print "will give";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not give";
                    } else {
                        print "do not give";
                    }
                    ;
                2:
                    print "did not give";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not given";
                    } else {
                        print "have not given";
                    }
                    ;
                4:
                    print "had not given";
                    ;
                5:
                    print "will not give";
                    ;
            }
            ;
    }
];
[ call_U1870 fn vp t modal_to;
    (t = ConjugateVerb37(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb38 fn vp t modal_to;
    switch (fn) {
        1:
            print "talk";
            ;
        2:
            print "talked";
            ;
        3:
            print "talking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "talks";
                    } else {
                        print "talk";
                    }
                    ;
                2:
                    print "talked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has talked";
                    } else {
                        print "have talked";
                    }
                    ;
                4:
                    print "had talked";
                    ;
                5:
                    print "will talk";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not talk";
                    } else {
                        print "do not talk";
                    }
                    ;
                2:
                    print "did not talk";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not talked";
                    } else {
                        print "have not talked";
                    }
                    ;
                4:
                    print "had not talked";
                    ;
                5:
                    print "will not talk";
                    ;
            }
            ;
    }
];
[ call_U1871 fn vp t modal_to;
    (t = ConjugateVerb38(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb39 fn vp t modal_to;
    switch (fn) {
        1:
            print "provoke";
            ;
        2:
            print "provoked";
            ;
        3:
            print "provoking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "provokes";
                    } else {
                        print "provoke";
                    }
                    ;
                2:
                    print "provoked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has provoked";
                    } else {
                        print "have provoked";
                    }
                    ;
                4:
                    print "had provoked";
                    ;
                5:
                    print "will provoke";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not provoke";
                    } else {
                        print "do not provoke";
                    }
                    ;
                2:
                    print "did not provoke";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not provoked";
                    } else {
                        print "have not provoked";
                    }
                    ;
                4:
                    print "had not provoked";
                    ;
                5:
                    print "will not provoke";
                    ;
            }
            ;
    }
];
[ call_U1872 fn vp t modal_to;
    (t = ConjugateVerb39(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb40 fn vp t modal_to;
    switch (fn) {
        1:
            print "pass";
            ;
        2:
            print "passed";
            ;
        3:
            print "passing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "passes";
                    } else {
                        print "pass";
                    }
                    ;
                2:
                    print "passed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has passed";
                    } else {
                        print "have passed";
                    }
                    ;
                4:
                    print "had passed";
                    ;
                5:
                    print "will pass";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not pass";
                    } else {
                        print "do not pass";
                    }
                    ;
                2:
                    print "did not pass";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not passed";
                    } else {
                        print "have not passed";
                    }
                    ;
                4:
                    print "had not passed";
                    ;
                5:
                    print "will not pass";
                    ;
            }
            ;
    }
];
[ call_U1873 fn vp t modal_to;
    (t = ConjugateVerb40(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb41 fn vp t modal_to;
    switch (fn) {
        1:
            print "wait";
            ;
        2:
            print "waited";
            ;
        3:
            print "waiting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "waits";
                    } else {
                        print "wait";
                    }
                    ;
                2:
                    print "waited";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has waited";
                    } else {
                        print "have waited";
                    }
                    ;
                4:
                    print "had waited";
                    ;
                5:
                    print "will wait";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not wait";
                    } else {
                        print "do not wait";
                    }
                    ;
                2:
                    print "did not wait";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not waited";
                    } else {
                        print "have not waited";
                    }
                    ;
                4:
                    print "had not waited";
                    ;
                5:
                    print "will not wait";
                    ;
            }
            ;
    }
];
[ call_U1874 fn vp t modal_to;
    (t = ConjugateVerb41(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb42 fn vp t modal_to;
    switch (fn) {
        1:
            print "touch";
            ;
        2:
            print "touched";
            ;
        3:
            print "touching";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "touches";
                    } else {
                        print "touch";
                    }
                    ;
                2:
                    print "touched";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has touched";
                    } else {
                        print "have touched";
                    }
                    ;
                4:
                    print "had touched";
                    ;
                5:
                    print "will touch";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not touch";
                    } else {
                        print "do not touch";
                    }
                    ;
                2:
                    print "did not touch";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not touched";
                    } else {
                        print "have not touched";
                    }
                    ;
                4:
                    print "had not touched";
                    ;
                5:
                    print "will not touch";
                    ;
            }
            ;
    }
];
[ call_U1875 fn vp t modal_to;
    (t = ConjugateVerb42(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb43 fn vp t modal_to;
    switch (fn) {
        1:
            print "like";
            ;
        2:
            print "liked";
            ;
        3:
            print "liking";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "likes";
                    } else {
                        print "like";
                    }
                    ;
                2:
                    print "liked";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has liked";
                    } else {
                        print "have liked";
                    }
                    ;
                4:
                    print "had liked";
                    ;
                5:
                    print "will like";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not like";
                    } else {
                        print "do not like";
                    }
                    ;
                2:
                    print "did not like";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not liked";
                    } else {
                        print "have not liked";
                    }
                    ;
                4:
                    print "had not liked";
                    ;
                5:
                    print "will not like";
                    ;
            }
            ;
    }
];
[ call_U1876 fn vp t modal_to;
    (t = ConjugateVerb43(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb44 fn vp t modal_to;
    switch (fn) {
        1:
            print "feel";
            ;
        2:
            print "felt";
            ;
        3:
            print "feeling";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "feels";
                    } else {
                        print "feel";
                    }
                    ;
                2:
                    print "felt";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has felt";
                    } else {
                        print "have felt";
                    }
                    ;
                4:
                    print "had felt";
                    ;
                5:
                    print "will feel";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not feel";
                    } else {
                        print "do not feel";
                    }
                    ;
                2:
                    print "did not feel";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not felt";
                    } else {
                        print "have not felt";
                    }
                    ;
                4:
                    print "had not felt";
                    ;
                5:
                    print "will not feel";
                    ;
            }
            ;
    }
];
[ call_U1877 fn vp t modal_to;
    (t = ConjugateVerb44(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb45 fn vp t modal_to;
    switch (fn) {
        1:
            print "wave";
            ;
        2:
            print "waved";
            ;
        3:
            print "waving";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "waves";
                    } else {
                        print "wave";
                    }
                    ;
                2:
                    print "waved";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has waved";
                    } else {
                        print "have waved";
                    }
                    ;
                4:
                    print "had waved";
                    ;
                5:
                    print "will wave";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not wave";
                    } else {
                        print "do not wave";
                    }
                    ;
                2:
                    print "did not wave";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not waved";
                    } else {
                        print "have not waved";
                    }
                    ;
                4:
                    print "had not waved";
                    ;
                5:
                    print "will not wave";
                    ;
            }
            ;
    }
];
[ call_U1878 fn vp t modal_to;
    (t = ConjugateVerb45(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb46 fn vp t modal_to;
    switch (fn) {
        1:
            print "happen";
            ;
        2:
            print "happened";
            ;
        3:
            print "happening";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "happens";
                    } else {
                        print "happen";
                    }
                    ;
                2:
                    print "happened";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has happened";
                    } else {
                        print "have happened";
                    }
                    ;
                4:
                    print "had happened";
                    ;
                5:
                    print "will happen";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not happen";
                    } else {
                        print "do not happen";
                    }
                    ;
                2:
                    print "did not happen";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not happened";
                    } else {
                        print "have not happened";
                    }
                    ;
                4:
                    print "had not happened";
                    ;
                5:
                    print "will not happen";
                    ;
            }
            ;
    }
];
[ call_U1879 fn vp t modal_to;
    (t = ConjugateVerb46(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb47 fn vp t modal_to;
    switch (fn) {
        1:
            print "pull";
            ;
        2:
            print "pulled";
            ;
        3:
            print "pulling";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "pulls";
                    } else {
                        print "pull";
                    }
                    ;
                2:
                    print "pulled";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has pulled";
                    } else {
                        print "have pulled";
                    }
                    ;
                4:
                    print "had pulled";
                    ;
                5:
                    print "will pull";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not pull";
                    } else {
                        print "do not pull";
                    }
                    ;
                2:
                    print "did not pull";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not pulled";
                    } else {
                        print "have not pulled";
                    }
                    ;
                4:
                    print "had not pulled";
                    ;
                5:
                    print "will not pull";
                    ;
            }
            ;
    }
];
[ call_U1880 fn vp t modal_to;
    (t = ConjugateVerb47(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb48 fn vp t modal_to;
    switch (fn) {
        1:
            print "push";
            ;
        2:
            print "pushed";
            ;
        3:
            print "pushing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "pushes";
                    } else {
                        print "push";
                    }
                    ;
                2:
                    print "pushed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has pushed";
                    } else {
                        print "have pushed";
                    }
                    ;
                4:
                    print "had pushed";
                    ;
                5:
                    print "will push";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not push";
                    } else {
                        print "do not push";
                    }
                    ;
                2:
                    print "did not push";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not pushed";
                    } else {
                        print "have not pushed";
                    }
                    ;
                4:
                    print "had not pushed";
                    ;
                5:
                    print "will not push";
                    ;
            }
            ;
    }
];
[ call_U1881 fn vp t modal_to;
    (t = ConjugateVerb48(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb49 fn vp t modal_to;
    switch (fn) {
        1:
            print "turn";
            ;
        2:
            print "turned";
            ;
        3:
            print "turning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "turns";
                    } else {
                        print "turn";
                    }
                    ;
                2:
                    print "turned";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has turned";
                    } else {
                        print "have turned";
                    }
                    ;
                4:
                    print "had turned";
                    ;
                5:
                    print "will turn";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not turn";
                    } else {
                        print "do not turn";
                    }
                    ;
                2:
                    print "did not turn";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not turned";
                    } else {
                        print "have not turned";
                    }
                    ;
                4:
                    print "had not turned";
                    ;
                5:
                    print "will not turn";
                    ;
            }
            ;
    }
];
[ call_U1882 fn vp t modal_to;
    (t = ConjugateVerb49(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb50 fn vp t modal_to;
    switch (fn) {
        1:
            print "squeeze";
            ;
        2:
            print "squeezed";
            ;
        3:
            print "squeezing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "squeezes";
                    } else {
                        print "squeeze";
                    }
                    ;
                2:
                    print "squeezed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has squeezed";
                    } else {
                        print "have squeezed";
                    }
                    ;
                4:
                    print "had squeezed";
                    ;
                5:
                    print "will squeeze";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not squeeze";
                    } else {
                        print "do not squeeze";
                    }
                    ;
                2:
                    print "did not squeeze";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not squeezed";
                    } else {
                        print "have not squeezed";
                    }
                    ;
                4:
                    print "had not squeezed";
                    ;
                5:
                    print "will not squeeze";
                    ;
            }
            ;
    }
];
[ call_U1883 fn vp t modal_to;
    (t = ConjugateVerb50(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb51 fn vp t modal_to;
    switch (fn) {
        1:
            print "smell";
            ;
        2:
            print "smelled";
            ;
        3:
            print "smelling";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "smells";
                    } else {
                        print "smell";
                    }
                    ;
                2:
                    print "smelled";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has smelled";
                    } else {
                        print "have smelled";
                    }
                    ;
                4:
                    print "had smelled";
                    ;
                5:
                    print "will smell";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not smell";
                    } else {
                        print "do not smell";
                    }
                    ;
                2:
                    print "did not smell";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not smelled";
                    } else {
                        print "have not smelled";
                    }
                    ;
                4:
                    print "had not smelled";
                    ;
                5:
                    print "will not smell";
                    ;
            }
            ;
    }
];
[ call_U1884 fn vp t modal_to;
    (t = ConjugateVerb51(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb52 fn vp t modal_to;
    switch (fn) {
        1:
            print "sniff";
            ;
        2:
            print "sniffed";
            ;
        3:
            print "sniffing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "sniffs";
                    } else {
                        print "sniff";
                    }
                    ;
                2:
                    print "sniffed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has sniffed";
                    } else {
                        print "have sniffed";
                    }
                    ;
                4:
                    print "had sniffed";
                    ;
                5:
                    print "will sniff";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not sniff";
                    } else {
                        print "do not sniff";
                    }
                    ;
                2:
                    print "did not sniff";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not sniffed";
                    } else {
                        print "have not sniffed";
                    }
                    ;
                4:
                    print "had not sniffed";
                    ;
                5:
                    print "will not sniff";
                    ;
            }
            ;
    }
];
[ call_U1885 fn vp t modal_to;
    (t = ConjugateVerb52(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb53 fn vp t modal_to;
    switch (fn) {
        1:
            print "hear";
            ;
        2:
            print "heard";
            ;
        3:
            print "hearing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "hears";
                    } else {
                        print "hear";
                    }
                    ;
                2:
                    print "heard";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has heard";
                    } else {
                        print "have heard";
                    }
                    ;
                4:
                    print "had heard";
                    ;
                5:
                    print "will hear";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not hear";
                    } else {
                        print "do not hear";
                    }
                    ;
                2:
                    print "did not hear";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not heard";
                    } else {
                        print "have not heard";
                    }
                    ;
                4:
                    print "had not heard";
                    ;
                5:
                    print "will not hear";
                    ;
            }
            ;
    }
];
[ call_U1886 fn vp t modal_to;
    (t = ConjugateVerb53(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb54 fn vp t modal_to;
    switch (fn) {
        1:
            print "listen";
            ;
        2:
            print "listened";
            ;
        3:
            print "listening";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "listens";
                    } else {
                        print "listen";
                    }
                    ;
                2:
                    print "listened";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has listened";
                    } else {
                        print "have listened";
                    }
                    ;
                4:
                    print "had listened";
                    ;
                5:
                    print "will listen";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not listen";
                    } else {
                        print "do not listen";
                    }
                    ;
                2:
                    print "did not listen";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not listened";
                    } else {
                        print "have not listened";
                    }
                    ;
                4:
                    print "had not listened";
                    ;
                5:
                    print "will not listen";
                    ;
            }
            ;
    }
];
[ call_U1887 fn vp t modal_to;
    (t = ConjugateVerb54(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb55 fn vp t modal_to;
    switch (fn) {
        1:
            print "taste";
            ;
        2:
            print "tasted";
            ;
        3:
            print "tasting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "tastes";
                    } else {
                        print "taste";
                    }
                    ;
                2:
                    print "tasted";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has tasted";
                    } else {
                        print "have tasted";
                    }
                    ;
                4:
                    print "had tasted";
                    ;
                5:
                    print "will taste";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not taste";
                    } else {
                        print "do not taste";
                    }
                    ;
                2:
                    print "did not taste";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not tasted";
                    } else {
                        print "have not tasted";
                    }
                    ;
                4:
                    print "had not tasted";
                    ;
                5:
                    print "will not taste";
                    ;
            }
            ;
    }
];
[ call_U1888 fn vp t modal_to;
    (t = ConjugateVerb55(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb56 fn vp t modal_to;
    switch (fn) {
        1:
            print "jump";
            ;
        2:
            print "jumped";
            ;
        3:
            print "jumping";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "jumps";
                    } else {
                        print "jump";
                    }
                    ;
                2:
                    print "jumped";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has jumped";
                    } else {
                        print "have jumped";
                    }
                    ;
                4:
                    print "had jumped";
                    ;
                5:
                    print "will jump";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not jump";
                    } else {
                        print "do not jump";
                    }
                    ;
                2:
                    print "did not jump";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not jumped";
                    } else {
                        print "have not jumped";
                    }
                    ;
                4:
                    print "had not jumped";
                    ;
                5:
                    print "will not jump";
                    ;
            }
            ;
    }
];
[ call_U1889 fn vp t modal_to;
    (t = ConjugateVerb56(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb57 fn vp t modal_to;
    switch (fn) {
        1:
            print "rub";
            ;
        2:
            print "rubbed";
            ;
        3:
            print "rubbing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "rubs";
                    } else {
                        print "rub";
                    }
                    ;
                2:
                    print "rubbed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has rubbed";
                    } else {
                        print "have rubbed";
                    }
                    ;
                4:
                    print "had rubbed";
                    ;
                5:
                    print "will rub";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not rub";
                    } else {
                        print "do not rub";
                    }
                    ;
                2:
                    print "did not rub";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not rubbed";
                    } else {
                        print "have not rubbed";
                    }
                    ;
                4:
                    print "had not rubbed";
                    ;
                5:
                    print "will not rub";
                    ;
            }
            ;
    }
];
[ call_U1890 fn vp t modal_to;
    (t = ConjugateVerb57(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb58 fn vp t modal_to;
    switch (fn) {
        1:
            print "set";
            ;
        2:
            print "set";
            ;
        3:
            print "setting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "sets";
                    } else {
                        print "set";
                    }
                    ;
                2:
                    print "set";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has set";
                    } else {
                        print "have set";
                    }
                    ;
                4:
                    print "had set";
                    ;
                5:
                    print "will set";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not set";
                    } else {
                        print "do not set";
                    }
                    ;
                2:
                    print "did not set";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not set";
                    } else {
                        print "have not set";
                    }
                    ;
                4:
                    print "had not set";
                    ;
                5:
                    print "will not set";
                    ;
            }
            ;
    }
];
[ call_U1891 fn vp t modal_to;
    (t = ConjugateVerb58(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb84 fn vp t modal_to;
    switch (fn) {
        1:
            print "begin";
            ;
        2:
            print "begun";
            ;
        3:
            print "beginning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "begins";
                    } else {
                        print "begin";
                    }
                    ;
                2:
                    print "began";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has begun";
                    } else {
                        print "have begun";
                    }
                    ;
                4:
                    print "had begun";
                    ;
                5:
                    print "will begin";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not begin";
                    } else {
                        print "do not begin";
                    }
                    ;
                2:
                    print "did not begin";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not begun";
                    } else {
                        print "have not begun";
                    }
                    ;
                4:
                    print "had not begun";
                    ;
                5:
                    print "will not begin";
                    ;
            }
            ;
    }
];
[ call_U1892 fn vp t modal_to;
    (t = ConjugateVerb84(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1893 fn vp t modal_to;
    (t = ConjugateVerb84(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " when";
];
[ ConjugateVerb85 fn vp t modal_to;
    switch (fn) {
        1:
            print "end";
            ;
        2:
            print "ended";
            ;
        3:
            print "ending";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "ends";
                    } else {
                        print "end";
                    }
                    ;
                2:
                    print "ended";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has ended";
                    } else {
                        print "have ended";
                    }
                    ;
                4:
                    print "had ended";
                    ;
                5:
                    print "will end";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not end";
                    } else {
                        print "do not end";
                    }
                    ;
                2:
                    print "did not end";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not ended";
                    } else {
                        print "have not ended";
                    }
                    ;
                4:
                    print "had not ended";
                    ;
                5:
                    print "will not end";
                    ;
            }
            ;
    }
];
[ call_U1894 fn vp t modal_to;
    (t = ConjugateVerb85(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1895 fn vp t modal_to;
    (t = ConjugateVerb85(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " when";
];
[ call_U1896 fn vp t modal_to;
    (t = ConjugateVerb85(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb31 fn vp t modal_to;
    switch (fn) {
        1:
            print "end";
            ;
        2:
            print "ended";
            ;
        3:
            print "ending";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "ends";
                    } else {
                        print "end";
                    }
                    ;
                2:
                    print "ended";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has ended";
                    } else {
                        print "have ended";
                    }
                    ;
                4:
                    print "had ended";
                    ;
                5:
                    print "will end";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not end";
                    } else {
                        print "do not end";
                    }
                    ;
                2:
                    print "did not end";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not ended";
                    } else {
                        print "have not ended";
                    }
                    ;
                4:
                    print "had not ended";
                    ;
                5:
                    print "will not end";
                    ;
            }
            ;
    }
];
[ ConjugateVerb86 fn vp t modal_to;
    switch (fn) {
        1:
            print "understand";
            ;
        2:
            print "understood";
            ;
        3:
            print "understanding";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "understands";
                    } else {
                        print "understand";
                    }
                    ;
                2:
                    print "understood";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has understood";
                    } else {
                        print "have understood";
                    }
                    ;
                4:
                    print "had understood";
                    ;
                5:
                    print "will understand";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not understand";
                    } else {
                        print "do not understand";
                    }
                    ;
                2:
                    print "did not understand";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not understood";
                    } else {
                        print "have not understood";
                    }
                    ;
                4:
                    print "had not understood";
                    ;
                5:
                    print "will not understand";
                    ;
            }
            ;
    }
];
[ call_U1897 fn vp t modal_to;
    (t = ConjugateVerb86(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1898 fn vp t modal_to;
    (t = ConjugateVerb86(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb87 fn vp t modal_to;
    switch (fn) {
        1:
            print "release";
            ;
        2:
            print "released";
            ;
        3:
            print "releasing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "releases";
                    } else {
                        print "release";
                    }
                    ;
                2:
                    print "released";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has released";
                    } else {
                        print "have released";
                    }
                    ;
                4:
                    print "had released";
                    ;
                5:
                    print "will release";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not release";
                    } else {
                        print "do not release";
                    }
                    ;
                2:
                    print "did not release";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not released";
                    } else {
                        print "have not released";
                    }
                    ;
                4:
                    print "had not released";
                    ;
                5:
                    print "will not release";
                    ;
            }
            ;
    }
];
[ call_U1899 fn vp t modal_to;
    (t = ConjugateVerb87(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1900 fn vp t modal_to;
    (t = ConjugateVerb87(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " along with";
];
[ ConjugateVerb88 fn vp t modal_to;
    switch (fn) {
        1:
            print "index";
            ;
        2:
            print "indexed";
            ;
        3:
            print "indexing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "indexes";
                    } else {
                        print "index";
                    }
                    ;
                2:
                    print "indexed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has indexed";
                    } else {
                        print "have indexed";
                    }
                    ;
                4:
                    print "had indexed";
                    ;
                5:
                    print "will index";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not index";
                    } else {
                        print "do not index";
                    }
                    ;
                2:
                    print "did not index";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not indexed";
                    } else {
                        print "have not indexed";
                    }
                    ;
                4:
                    print "had not indexed";
                    ;
                5:
                    print "will not index";
                    ;
            }
            ;
    }
];
[ call_U1901 fn vp t modal_to;
    (t = ConjugateVerb88(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1902 fn vp t modal_to;
    (t = ConjugateVerb88(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
    print " map with";
];
[ ConjugateModalVerb32 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb33 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb34 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb35 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb36 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb37 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb38 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb39 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb89 fn vp t modal_to;
    switch (fn) {
        1:
            print "support";
            ;
        2:
            print "supported";
            ;
        3:
            print "supporting";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record9;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "supports";
                    } else {
                        print "support";
                    }
                    ;
                2:
                    print "supported";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has supported";
                    } else {
                        print "have supported";
                    }
                    ;
                4:
                    print "had supported";
                    ;
                5:
                    print "will support";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not support";
                    } else {
                        print "do not support";
                    }
                    ;
                2:
                    print "did not support";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not supported";
                    } else {
                        print "have not supported";
                    }
                    ;
                4:
                    print "had not supported";
                    ;
                5:
                    print "will not support";
                    ;
            }
            ;
    }
];
[ call_U1903 fn vp t modal_to;
    (t = ConjugateVerb89(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record9;
    }
];
[ ConjugateModalVerb40 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb90 fn vp t modal_to;
    switch (fn) {
        1:
            print "incorporate";
            ;
        2:
            print "incorporated";
            ;
        3:
            print "incorporating";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record10;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "incorporates";
                    } else {
                        print "incorporate";
                    }
                    ;
                2:
                    print "incorporated";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has incorporated";
                    } else {
                        print "have incorporated";
                    }
                    ;
                4:
                    print "had incorporated";
                    ;
                5:
                    print "will incorporate";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not incorporate";
                    } else {
                        print "do not incorporate";
                    }
                    ;
                2:
                    print "did not incorporate";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not incorporated";
                    } else {
                        print "have not incorporated";
                    }
                    ;
                4:
                    print "had not incorporated";
                    ;
                5:
                    print "will not incorporate";
                    ;
            }
            ;
    }
];
[ call_U1904 fn vp t modal_to;
    (t = ConjugateVerb90(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record10;
    }
];
[ ConjugateModalVerb41 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb42 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb43 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb91 fn vp t modal_to;
    switch (fn) {
        1:
            print "enclose";
            ;
        2:
            print "enclosed";
            ;
        3:
            print "enclosing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record11;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "encloses";
                    } else {
                        print "enclose";
                    }
                    ;
                2:
                    print "enclosed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has enclosed";
                    } else {
                        print "have enclosed";
                    }
                    ;
                4:
                    print "had enclosed";
                    ;
                5:
                    print "will enclose";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not enclose";
                    } else {
                        print "do not enclose";
                    }
                    ;
                2:
                    print "did not enclose";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not enclosed";
                    } else {
                        print "have not enclosed";
                    }
                    ;
                4:
                    print "had not enclosed";
                    ;
                5:
                    print "will not enclose";
                    ;
            }
            ;
    }
];
[ call_U1905 fn vp t modal_to;
    (t = ConjugateVerb91(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record11;
    }
];
[ ConjugateVerb92 fn vp t modal_to;
    switch (fn) {
        1:
            print "carry";
            ;
        2:
            print "carried";
            ;
        3:
            print "carrying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record12;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "carries";
                    } else {
                        print "carry";
                    }
                    ;
                2:
                    print "carried";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has carried";
                    } else {
                        print "have carried";
                    }
                    ;
                4:
                    print "had carried";
                    ;
                5:
                    print "will carry";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not carry";
                    } else {
                        print "do not carry";
                    }
                    ;
                2:
                    print "did not carry";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not carried";
                    } else {
                        print "have not carried";
                    }
                    ;
                4:
                    print "had not carried";
                    ;
                5:
                    print "will not carry";
                    ;
            }
            ;
    }
];
[ call_U1906 fn vp t modal_to;
    (t = ConjugateVerb92(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record12;
    }
];
[ ConjugateVerb93 fn vp t modal_to;
    switch (fn) {
        1:
            print "hold";
            ;
        2:
            print "held";
            ;
        3:
            print "holding";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record13;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "holds";
                    } else {
                        print "hold";
                    }
                    ;
                2:
                    print "held";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has held";
                    } else {
                        print "have held";
                    }
                    ;
                4:
                    print "had held";
                    ;
                5:
                    print "will hold";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not hold";
                    } else {
                        print "do not hold";
                    }
                    ;
                2:
                    print "did not hold";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not held";
                    } else {
                        print "have not held";
                    }
                    ;
                4:
                    print "had not held";
                    ;
                5:
                    print "will not hold";
                    ;
            }
            ;
    }
];
[ call_U1907 fn vp t modal_to;
    (t = ConjugateVerb93(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record13;
    }
];
[ ConjugateVerb94 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to see";
            ;
        2:
            print "been able to see";
            ;
        3:
            print "being able to see";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record15;
            ;
        CV_POS:
            switch (t) {
                1:
                    print "can see";
                    ;
                2:
                    print "could see";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been able to see";
                    } else {
                        print "have been able to see";
                    }
                    ;
                4:
                    print "had been able to see";
                    ;
                5:
                    print "will be able to see";
                    ;
                6:
                    print "see";
                    ;
                7:
                    print "see";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    print "cannot see";
                    ;
                2:
                    print "could not see";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been able to see";
                    } else {
                        print "have not been able to see";
                    }
                    ;
                4:
                    print "had not been able to see";
                    ;
                5:
                    print "will not be able to see";
                    ;
                6:
                    print "see";
                    ;
                7:
                    print "see";
                    ;
            }
            ;
    }
];
[ call_U1908 fn vp t modal_to;
    (t = ConjugateVerb94(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record15;
    }
];
[ ConjugateVerb95 fn vp t modal_to;
    switch (fn) {
        1:
            print "be able to touch";
            ;
        2:
            print "been able to touch";
            ;
        3:
            print "being able to touch";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record16;
            ;
        CV_POS:
            switch (t) {
                1:
                    print "can touch";
                    ;
                2:
                    print "could touch";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been able to touch";
                    } else {
                        print "have been able to touch";
                    }
                    ;
                4:
                    print "had been able to touch";
                    ;
                5:
                    print "will be able to touch";
                    ;
                6:
                    print "touch";
                    ;
                7:
                    print "touch";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    print "cannot touch";
                    ;
                2:
                    print "could not touch";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been able to touch";
                    } else {
                        print "have not been able to touch";
                    }
                    ;
                4:
                    print "had not been able to touch";
                    ;
                5:
                    print "will not be able to touch";
                    ;
                6:
                    print "touch";
                    ;
                7:
                    print "touch";
                    ;
            }
            ;
    }
];
[ call_U1909 fn vp t modal_to;
    (t = ConjugateVerb95(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record16;
    }
];
[ ConjugateVerb96 fn vp t modal_to;
    switch (fn) {
        1:
            print "conceal";
            ;
        2:
            print "concealed";
            ;
        3:
            print "concealing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record17;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "conceals";
                    } else {
                        print "conceal";
                    }
                    ;
                2:
                    print "concealed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has concealed";
                    } else {
                        print "have concealed";
                    }
                    ;
                4:
                    print "had concealed";
                    ;
                5:
                    print "will conceal";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not conceal";
                    } else {
                        print "do not conceal";
                    }
                    ;
                2:
                    print "did not conceal";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not concealed";
                    } else {
                        print "have not concealed";
                    }
                    ;
                4:
                    print "had not concealed";
                    ;
                5:
                    print "will not conceal";
                    ;
            }
            ;
    }
];
[ call_U1910 fn vp t modal_to;
    (t = ConjugateVerb96(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record17;
    }
];
[ ConjugateModalVerb44 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb45 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb46 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb47 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb48 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb49 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb50 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ ConjugateVerb97 fn vp t modal_to;
    switch (fn) {
        1:
            print "die";
            ;
        2:
            print "died";
            ;
        3:
            print "dying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "dies";
                    } else {
                        print "die";
                    }
                    ;
                2:
                    print "died";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has died";
                    } else {
                        print "have died";
                    }
                    ;
                4:
                    print "had died";
                    ;
                5:
                    print "will die";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not die";
                    } else {
                        print "do not die";
                    }
                    ;
                2:
                    print "did not die";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not died";
                    } else {
                        print "have not died";
                    }
                    ;
                4:
                    print "had not died";
                    ;
                5:
                    print "will not die";
                    ;
            }
            ;
    }
];
[ call_U1911 fn vp t modal_to;
    (t = ConjugateVerb97(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb98 fn vp t modal_to;
    switch (fn) {
        1:
            print "need";
            ;
        2:
            print "needed";
            ;
        3:
            print "needing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "needs";
                    } else {
                        print "need";
                    }
                    ;
                2:
                    print "needed";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has needed";
                    } else {
                        print "have needed";
                    }
                    ;
                4:
                    print "had needed";
                    ;
                5:
                    print "will need";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not need";
                    } else {
                        print "do not need";
                    }
                    ;
                2:
                    print "did not need";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not needed";
                    } else {
                        print "have not needed";
                    }
                    ;
                4:
                    print "had not needed";
                    ;
                5:
                    print "will not need";
                    ;
            }
            ;
    }
];
[ call_U1912 fn vp t modal_to;
    (t = ConjugateVerb98(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb99 fn vp t modal_to;
    switch (fn) {
        1:
            print "say";
            ;
        2:
            print "said";
            ;
        3:
            print "saying";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "says";
                    } else {
                        print "say";
                    }
                    ;
                2:
                    print "said";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has said";
                    } else {
                        print "have said";
                    }
                    ;
                4:
                    print "had said";
                    ;
                5:
                    print "will say";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not say";
                    } else {
                        print "do not say";
                    }
                    ;
                2:
                    print "did not say";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not said";
                    } else {
                        print "have not said";
                    }
                    ;
                4:
                    print "had not said";
                    ;
                5:
                    print "will not say";
                    ;
            }
            ;
    }
];
[ call_U1913 fn vp t modal_to;
    (t = ConjugateVerb99(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateModalVerb51 fn vp t modal_to;
    switch (fn) {
        1:
            print "see";
            ;
        2:
            print "seen";
            ;
        3:
            print "seeing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "sees";
                    } else {
                        print "see";
                    }
                    ;
                2:
                    print "saw";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has seen";
                    } else {
                        print "have seen";
                    }
                    ;
                4:
                    print "had seen";
                    ;
                5:
                    print "will see";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not see";
                    } else {
                        print "do not see";
                    }
                    ;
                2:
                    print "did not see";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not seen";
                    } else {
                        print "have not seen";
                    }
                    ;
                4:
                    print "had not seen";
                    ;
                5:
                    print "will not see";
                    ;
            }
            ;
    }
];
[ ConjugateModalVerb52 fn vp t modal_to;
    switch (fn) {
        1:
            print "touch";
            ;
        2:
            print "touched";
            ;
        3:
            print "touching";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "touches";
                    } else {
                        print "touch";
                    }
                    ;
                2:
                    print "touched";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has touched";
                    } else {
                        print "have touched";
                    }
                    ;
                4:
                    print "had touched";
                    ;
                5:
                    print "will touch";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not touch";
                    } else {
                        print "do not touch";
                    }
                    ;
                2:
                    print "did not touch";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not touched";
                    } else {
                        print "have not touched";
                    }
                    ;
                4:
                    print "had not touched";
                    ;
                5:
                    print "will not touch";
                    ;
            }
            ;
    }
];
[ ConjugateVerb100 fn vp t modal_to;
    switch (fn) {
        1:
            print "win";
            ;
        2:
            print "won";
            ;
        3:
            print "winning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "wins";
                    } else {
                        print "win";
                    }
                    ;
                2:
                    print "won";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has won";
                    } else {
                        print "have won";
                    }
                    ;
                4:
                    print "had won";
                    ;
                5:
                    print "will win";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not win";
                    } else {
                        print "do not win";
                    }
                    ;
                2:
                    print "did not win";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not won";
                    } else {
                        print "have not won";
                    }
                    ;
                4:
                    print "had not won";
                    ;
                5:
                    print "will not win";
                    ;
            }
            ;
    }
];
[ call_U1914 fn vp t modal_to;
    (t = ConjugateVerb100(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ Noun_Filter1 x;
    (x = noun);
    return (noun ofclass K3_direction);
];
[ Noun_Filter2 x;
    (x = noun);
    return (noun ofclass K3_direction);
];
[ Noun_Filter3 x;
    (x = noun);
    return (noun ofclass K3_direction);
];
[ Noun_Filter4 x;
    (x = noun);
    return (((noun ofclass K2_thing)) && (call_U333(noun)));
];
[ call_U1915;
    #ifdef DEBUG;
        if (suppress_text_substitution) {
            print "~Simi is a cute little baby girl. [if Simi has a milky]She is holding a bottle of milky.[end if]~";
            rtrue;
        }
    #endif;
    (say__p = 1);
    ParaContent();
    print "Simi is a cute little baby girl. ";
    if ((~~((I_simi_U1 == OwnerOf(I_milky_U1))))) {
        jump L_Say0;
    }
    ParaContent();
    print "She is holding a bottle of milky.";
    .L_Say0;
    rtrue;
];
[ call_U1916 sk;
    rfalse;
];
[ call_U1917 t_0;
    if (t_0) {
        return (t_0 has absent);
    }
    rfalse;
];
[ call_U1918 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_absent, 1);
    }
    rfalse;
];
[ call_U1919 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_absent, 0);
    }
    rfalse;
];
[ call_U1920 t_0;
    if (t_0) {
        return (t_0 has door);
    }
    rfalse;
];
[ call_U1921 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_door, 1);
    }
    rfalse;
];
[ call_U1922 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_door, 0);
    }
    rfalse;
];
[ call_U1923 t_0;
    if (t_0) {
        return (t_0 has mark_as_room);
    }
    rfalse;
];
[ call_U1924 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mark_as_room, 1);
    }
    rfalse;
];
[ call_U1925 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mark_as_room, 0);
    }
    rfalse;
];
[ call_U1926 t_0;
    if (t_0) {
        return (t_0 has mark_as_thing);
    }
    rfalse;
];
[ call_U1927 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mark_as_thing, 1);
    }
    rfalse;
];
[ call_U1928 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_mark_as_thing, 0);
    }
    rfalse;
];
[ call_U1929 t_0;
    if (t_0) {
        return (t_0 has container);
    }
    rfalse;
];
[ call_U1930 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_container, 1);
    }
    rfalse;
];
[ call_U1931 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_container, 0);
    }
    rfalse;
];
[ call_U1932 t_0;
    if (t_0) {
        return (t_0 has supporter);
    }
    rfalse;
];
[ call_U1933 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_supporter, 1);
    }
    rfalse;
];
[ call_U1934 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_supporter, 0);
    }
    rfalse;
];
[ call_U1935 t_0;
    if (t_0) {
        return (t_0 has switchable);
    }
    rfalse;
];
[ call_U1936 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_switchable, 1);
    }
    rfalse;
];
[ call_U1937 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_switchable, 0);
    }
    rfalse;
];
[ call_U1938 t_0;
    if (t_0) {
        return (t_0 has animate);
    }
    rfalse;
];
[ call_U1939 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_animate, 1);
    }
    rfalse;
];
[ call_U1940 t_0;
    if (t_0) {
        return WriteGProperty(OBJECT_TY, t_0, A_animate, 0);
    }
    rfalse;
];
[ call_U1941;
    if ((((action == ##Eat)) && ((((actor == player)) && ((noun == I_simi_U1)))))) {
        (self = noun);
        if (debug_rules) {
            DB_Rule(call_U1941, 800, 0);
        }
        (say__p = 1);
        ParaContent();
        print "You can't eat baby Simi!!!!";
        print "^";
        RulebookFails(0, 0);
        rtrue;
    } else {
        if ((debug_rules > 1)) {
            DB_Rule(call_U1941, 800, 2);
        }
    }
    rfalse;
];
[ ConjugateVerb1 fn vp t modal_to;
    switch (fn) {
        1:
            print "be";
            ;
        2:
            print "been";
            ;
        3:
            print "being";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record3;
            ;
        CV_POS:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am";
                            ;
                        4:
                            print "are";
                            ;
                        2:
                            print "are";
                            ;
                        5:
                            print "are";
                            ;
                        3:
                            print "is";
                            ;
                        6:
                            print "are";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was";
                            ;
                        4:
                            print "were";
                            ;
                        2:
                            print "were";
                            ;
                        5:
                            print "were";
                            ;
                        3:
                            print "was";
                            ;
                        6:
                            print "were";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has been";
                    } else {
                        print "have been";
                    }
                    ;
                4:
                    print "had been";
                    ;
                5:
                    print "will be";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    switch (vp) {
                        1:
                            print "am not";
                            ;
                        4:
                            print "are not";
                            ;
                        2:
                            print "are not";
                            ;
                        5:
                            print "are not";
                            ;
                        3:
                            print "is not";
                            ;
                        6:
                            print "are not";
                            ;
                    }
                    ;
                2:
                    switch (vp) {
                        1:
                            print "was not";
                            ;
                        4:
                            print "were not";
                            ;
                        2:
                            print "were not";
                            ;
                        5:
                            print "were not";
                            ;
                        3:
                            print "was not";
                            ;
                        6:
                            print "were not";
                            ;
                    }
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not been";
                    } else {
                        print "have not been";
                    }
                    ;
                4:
                    print "had not been";
                    ;
                5:
                    print "will not be";
                    ;
            }
            ;
    }
];
[ call_U1942 fn vp t modal_to;
    (t = ConjugateVerb1(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return Rel_Record3;
    }
];
[ ConjugateModalVerb1 fn vp t modal_to;
    switch (fn) {
        1:
            print "auxiliary-have";
            ;
        2:
            print "had";
            ;
        3:
            print "having";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "has";
                    } else {
                        print "have";
                    }
                    ;
                2:
                    print "had";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "has not";
                    } else {
                        print "have not";
                    }
                    ;
                2:
                    print "had not";
                    ;
            }
            ;
    }
];
[ ConjugateVerb59 fn vp t modal_to;
    switch (fn) {
        1:
            print "mean";
            ;
        2:
            print "meant";
            ;
        3:
            print "meaning";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return Rel_Record4;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "means";
                    } else {
                        print "mean";
                    }
                    ;
                2:
                    print "meant";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has meant";
                    } else {
                        print "have meant";
                    }
                    ;
                4:
                    print "had meant";
                    ;
                5:
                    print "will mean";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not mean";
                    } else {
                        print "do not mean";
                    }
                    ;
                2:
                    print "did not mean";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not meant";
                    } else {
                        print "have not meant";
                    }
                    ;
                4:
                    print "had not meant";
                    ;
                5:
                    print "will not mean";
                    ;
            }
            ;
    }
];
[ call_U1943 fn vp t modal_to;
    (t = ConjugateVerb59(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ ConjugateVerb60 fn vp t modal_to;
    switch (fn) {
        1:
            print "do";
            ;
        2:
            print "done";
            ;
        3:
            print "doing";
            ;
        CV_MODAL:
            rfalse;
            ;
        CV_MEANING:
            return MEANINGLESS_RR;
            ;
        CV_POS:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does";
                    } else {
                        print "do";
                    }
                    ;
                2:
                    print "did";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has done";
                    } else {
                        print "have done";
                    }
                    ;
                4:
                    print "had done";
                    ;
                5:
                    print "will do";
                    ;
            }
            ;
        CV_NEG:
            switch (t) {
                1:
                    if ((vp == 3)) {
                        print "does not";
                    } else {
                        print "do not";
                    }
                    ;
                2:
                    print "did not";
                    ;
                3:
                    if ((vp == 3)) {
                        print "has not done";
                    } else {
                        print "have not done";
                    }
                    ;
                4:
                    print "had not done";
                    ;
                5:
                    print "will not do";
                    ;
            }
            ;
    }
];
[ call_U1944 fn vp t modal_to;
    (t = ConjugateVerb60(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1945 fn vp t modal_to;
    (t = ConjugateVerb60(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1946 fn vp t modal_to;
    (t = ConjugateVerb60(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1947 fn vp t modal_to;
    (t = ConjugateVerb60(fn, vp, t, modal_to));
    if ((fn == CV_MODAL)) {
        return t;
    }
    if ((fn == CV_MEANING)) {
        return MEANINGLESS_RR;
    }
];
[ call_U1948 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == Y)) {
                rtrue;
            }
            rfalse;
            ;
        default:
            RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record3);
            ;
    }
    rfalse;
];
[ call_U1949 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((BlkValueCompare((X)(CV_MEANING), Y) == 0)) {
                rtrue;
            }
            rfalse;
            ;
        default:
            RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record4);
            ;
    }
    rfalse;
];
[ call_U1950 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == OwnerOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                rfalse;
            } else {
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                rfalse;
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
            } else {
                if ((Y == RLIST_ALL_Y)) {
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MoveObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U1951 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((RlnGetF(X, RR_HANDLER))(X,RELS_TEST,Y,0)) {
                rtrue;
            }
            rfalse;
            ;
        default:
            RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record6);
            ;
    }
    rfalse;
];
[ call_U1952 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (0) {
                rtrue;
            }
            rfalse;
            ;
        default:
            RunTimeProblem(RTP_RELMINIMAL, task, 0, Rel_Record7);
            ;
    }
    rfalse;
];
[ call_U1953 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == ContainerOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    if ((call_U1953)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    if ((call_U1953)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                if ((call_U1953)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                if ((call_U1953)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    objectloop (Z3 ofclass Object && (Z3 ofclass Object)) {
                        if ((call_U1953)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                        objectloop (Z3 ofclass Object && (Z3 ofclass Object)) {
                            if ((call_U1953)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MoveObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U1954 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == SupporterOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = 0):0:) {
                    if ((call_U1954)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U1954)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = 0):0:) {
                if ((call_U1954)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U1954)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = 0):0:) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U1954)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = 0):0:) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U1954)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MoveObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U1955 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == PartOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U1955)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U1955)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U1955)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U1955)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U1955)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U1955)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MakePart(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U1956 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (IndirectlyContains(X, Y)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    if ((call_U1956)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    if ((call_U1956)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                if ((call_U1956)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                if ((call_U1956)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                    objectloop (Z3 ofclass Object && (Z3 ofclass Object)) {
                        if ((call_U1956)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    objectloop (Z1 ofclass Object && (Z1 ofclass Object)) {
                        objectloop (Z3 ofclass Object && (Z3 ofclass Object)) {
                            if ((call_U1956)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ call_U1957 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == CarrierOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    if ((call_U1957)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U1957)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                if ((call_U1957)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U1957)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U1957)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U1957)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MoveObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U1958 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == HolderOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    if ((call_U1958)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U1958)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                if ((call_U1958)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U1958)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U1958)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U1958)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            MoveObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U1959 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if ((X == WearerOf(Y))) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    if ((call_U1959)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U1959)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                if ((call_U1959)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U1959)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U1959)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K8_person_First):Z1:(Z1 = (Z1.K8_person_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U1959)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
        RELS_ASSERT_TRUE:
            WearObject(Y, X);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            rfalse;
            ;
    }
    rfalse;
];
[ call_U1960 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (TestVisibility(X, Y)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U1960)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U1960)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U1960)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U1960)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U1960)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U1960)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ call_U1961 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (TestTouchability(X, Y)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U1961)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U1961)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U1961)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U1961)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U1961)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U1961)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ call_U1962 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (TestConcealment(X, Y)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U1962)(rr,RELS_TEST,Z1,X)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            } else {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    if ((call_U1962)(rr,RELS_TEST,X,Z1)) {
                        if ((Y == RLANY_CAN_GET_X)) {
                            rtrue;
                        }
                        if ((Y == RLANY_CAN_GET_Y)) {
                            rtrue;
                        }
                        return Z1;
                    }
                }
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                return DefaultValueOfKOV(OBJECT_TY);
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U1962)(rr,RELS_TEST,Z1,X)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                if ((call_U1962)(rr,RELS_TEST,X,Z1)) {
                    LIST_OF_TY_InsertItem(Y, Z1);
                }
            }
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
                for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                    for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                        if ((call_U1962)(rr,RELS_TEST,Z1,Z3)) {
                            LIST_OF_TY_InsertItem(X, Z1, 0, 0, 1);
                        }
                    }
                }
            } else {
                if ((Y == RLIST_ALL_Y)) {
                    for ((Z1 = K2_thing_First):Z1:(Z1 = (Z1.K2_thing_Next))) {
                        for ((Z3 = K2_thing_First):Z3:(Z3 = (Z3.K2_thing_Next))) {
                            if ((call_U1962)(rr,RELS_TEST,Z1,Z3)) {
                                LIST_OF_TY_InsertItem(X, Z3, 0, 0, 1);
                            }
                        }
                    }
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ call_U1963 rr task X Y Z1 Z2 Z3 Z4;
    switch (task) {
        RELS_TEST:
            if (0) {
                rtrue;
            }
            rfalse;
            ;
        RELS_LOOKUP_ANY:
            if ((((Y == RLANY_GET_X)) || ((Y == RLANY_CAN_GET_X)))) {
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                rfalse;
            } else {
                if ((Y == RLANY_CAN_GET_X)) {
                    rfalse;
                }
                if ((Y == RLANY_CAN_GET_Y)) {
                    rfalse;
                }
                rfalse;
            }
            ;
        RELS_LOOKUP_ALL_X:
            LIST_OF_TY_SetLength(Y, 0);
            return Y;
            ;
        RELS_LOOKUP_ALL_Y:
            LIST_OF_TY_SetLength(Y, 0);
            return Y;
            ;
        RELS_LIST:
            LIST_OF_TY_SetLength(X, 0);
            if ((Y == RLIST_ALL_X)) {
            } else {
                if ((Y == RLIST_ALL_Y)) {
                }
            }
            return X;
            ;
    }
    rfalse;
];
[ parse_name1 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name2 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name3 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name4 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name5 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name6 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name7 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name8 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name9 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name10 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name11 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name12 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ parse_name13 original_wn group_wn try_from_wn n f w rv g ss spn pass pass1_n pass2_n;
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Parse_name called^";
        }
    #endif;
    if ((parser_action == ##TheSame)) {
        rfalse;
    }
    (original_wn = wn);
    (pass = 1);
    while ((pass <= 3)) {
        (wn = original_wn);
        (try_from_wn = wn);
        (f = 0);
        (n = 0);
        while (1) {
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((((pass == 1)) || ((pass == 2)))) {
            }
            if ((((parser_action ~= ##TheSame)) && ((pass == 1)))) {
                while (WordInProperty(NextWordStopped(), self, A_name)) {
                    (f = 1);
                }
                (wn)--;
                (try_from_wn = wn);
            }
            if ((Cond_Token1() == GPR_FAIL)) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'your')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'former')) {
                jump Fail_1;
            }
            if ((NextWordStopped() ~= 'self')) {
                jump Fail_1;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_1;
            (wn = try_from_wn);
            if ((Cond_Token2() == GPR_FAIL)) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'my')) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'former')) {
                jump Fail_2;
            }
            if ((NextWordStopped() ~= 'self')) {
                jump Fail_2;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_2;
            (wn = try_from_wn);
            if ((Cond_Token3() == GPR_FAIL)) {
                jump Fail_3;
            }
            if ((NextWordStopped() ~= 'former')) {
                jump Fail_3;
            }
            if ((NextWordStopped() ~= 'self')) {
                jump Fail_3;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_3;
            (wn = try_from_wn);
            if ((Cond_Token4() == GPR_FAIL)) {
                jump Fail_4;
            }
            if ((NextWordStopped() ~= 'former')) {
                jump Fail_4;
            }
            (try_from_wn = wn);
            (f = 1);
            continue;
            .Fail_4;
            (wn = try_from_wn);
            break;
        }
        while (WordInProperty(NextWordStopped(), self, A_name)) {
            (n)++;
        }
        if (((f) || ((n > 0)))) {
            (n = ((n + try_from_wn) - original_wn));
        }
        if ((pass == 1)) {
            (pass1_n = n);
        }
        if ((pass == 2)) {
            (pass2_n = n);
        }
        (pass)++;
    }
    #ifdef DEBUG;
        if ((parser_trace >= 3)) {
            print "Pass 1: ";
            print pass1_n;
            print " Pass 2: ";
            print pass2_n;
            print " Pass 3: ";
            print n;
            print "^";
        }
    #endif;
    if ((pass1_n > n)) {
        (n = pass1_n);
    }
    if ((pass2_n > n)) {
        (n = pass2_n);
    }
    (wn = (original_wn + n));
    if ((n == 0)) {
        return -1;
    }
    DetectPluralWord(original_wn, n);
    return n;
];
[ Cond_Token1;
    if ((~~((player == selfobj)))) {
        return GPR_PREPOSITION;
    }
    return GPR_FAIL;
];
[ Cond_Token2;
    if ((~~((player == selfobj)))) {
        return GPR_PREPOSITION;
    }
    return GPR_FAIL;
];
[ Cond_Token3;
    if ((~~((player == selfobj)))) {
        return GPR_PREPOSITION;
    }
    return GPR_FAIL;
];
[ Cond_Token4;
    if ((~~((player == selfobj)))) {
        return GPR_PREPOSITION;
    }
    return GPR_FAIL;
];
[ Consult_Grammar1 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'restart')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar2 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'restore')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar3 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'amusing')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar4 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'quit')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar5 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'undo')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar6 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'stand')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar7 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'sit')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ Consult_Grammar8 range_from range_words original_wn group_wn v w rv;
    (wn = range_from);
    (original_wn = wn);
    (rv = GPR_PREPOSITION);
    if ((NextWordStopped() ~= 'lie')) {
        jump Fail_1;
    }
    if ((((range_words == 0)) || (((wn - range_from) == range_words)))) {
        return rv;
    }
    .Fail_1;
    (rv = GPR_PREPOSITION);
    (wn = original_wn);
    return GPR_FAIL;
];
[ MistakeActionSub;
    switch (understand_as_mistake_number) {
        default:
            print "I didn't understand that sentence.^";
            rtrue;
            ;
    }
    (say__p = 1);
];
[ Prop_Falsity reason obj;
    rfalse;
];
[ FINAL_CODE_STARTUP_R addr res;
    #ifdef TARGET_GLULX;
    @gestalt 9 0 res;
    if (res == 0) rfalse;
    addr = #classes_table;
    @accelparam 0 addr;
    @accelparam 1 INDIV_PROP_START;
    @accelparam 2 Class;
    @accelparam 3 Object;
    @accelparam 4 Routine;
    @accelparam 5 String;
    addr = #globals_array + WORDSIZE * #g$self;
    @accelparam 6 addr;
    @accelparam 7 NUM_ATTR_BYTES;
    addr = #cpv__start;
    @accelparam 8 addr;
    @accelfunc 1 Z__Region;
    @accelfunc 2 CP__Tab;
    @accelfunc 3 RA__Pr;
    @accelfunc 4 RL__Pr;
    @accelfunc 5 OC__Cl;
    @accelfunc 6 RV__Pr;
    @accelfunc 7 OP__Pr;
    #endif;
    rfalse;
];
[ DebugAction a anames str;
    #ifdef TARGET_GLULX;
    if (a < 4096) {
        if (a < 0 || a >= #identifiers_table-->7) print "<invalid action ", a, ">";
        else {
            str = #identifiers_table-->6;
            str = str-->a;
            if (str) print (string) str; else print "<unnamed action ", a, ">";
            return;
        }
    }
    #endif;
    #ifdef TARGET_ZCODE;
    if (a < 4096) {
        anames = #identifiers_table;
        anames = anames + 2*(anames-->0) + 2*48;
        print (string) anames-->a;
        return;
    }
    #endif;
    if ((a >= 4096)) {
        print "<fake action ";
        print (a - 4096);
        print ">";
    } else {
        print "<action ";
        print a;
        print ">";
    }
];
[ DebugAttribute a anames str;
    #ifdef TARGET_GLULX;
    if (a < 0 || a >= NUM_ATTR_BYTES*8) print "<invalid attribute ", a, ">";
    else {
        str = #identifiers_table-->4;
        str = str-->a;
        if (str) print (string) str; else print "<unnamed attribute ", a, ">";
    }
    return;
    #endif;
    #ifdef TARGET_ZCODE;
    if (a < 0 || a >= 48) print "<invalid attribute ", a, ">";
    else {
        anames = #identifiers_table; anames = anames + 2*(anames-->0);
        print (string) anames-->a;
    }
    return;
    #endif;
    print "<attribute ";
    print a;
    print ">";
];
[ DebugProperty p pnames str;
    print (property) p;
    return;
    print "<property ";
    print p;
    print ">";
];
[ DecimalNumber num;
    print num;
];
[ PrintI6Text x;
    if ((x ofclass String)) {
        print (string) x;
    }
    if ((x ofclass Routine)) {
        return (x)();
    }
    if ((x == EMPTY_TEXT_PACKED)) {
        rfalse;
    }
    rtrue;
];
[ I7_String x;
    TEXT_TY_Say(x);
];
[ PrintOrRun obj prop no_break pv st routine_return_value;
    @push self;
    (self = obj);
    if ((prop == 0)) {
        PrintShortName(prop);
        (routine_return_value = 1);
    } else {
        (routine_return_value = TEXT_TY_Say(_final_propertyvalue(OBJECT_TY, obj, prop)));
    }
    @pull self;
    if (routine_return_value) {
        (say__p = 1);
        if ((no_break == 0)) {
            print "^";
            DivideParagraphPoint();
        }
    }
    return routine_return_value;
];
[ DA_Number n;
    print n;
];
[ DA_TruthState n;
    if ((n == 0)) {
        print "false";
    } else {
        print "true";
    }
];
[ SayPhraseName closure;
    if ((closure == 0)) {
        print "nothing";
    } else {
        print (string) (closure-->(2));
    }
];
[ KindAtomic kind;
    if ((((kind >= 0)) && ((kind < BASE_KIND_HWM)))) {
        return kind;
    }
    return (kind-->(0));
];
[ KindBaseArity kind;
    if ((((kind >= 0)) && ((kind < BASE_KIND_HWM)))) {
        rfalse;
    }
    return (kind-->(1));
];
[ KindBaseTerm kind n;
    if ((((kind >= 0)) && ((kind < BASE_KIND_HWM)))) {
        return UNKNOWN_TY;
    }
    return (kind-->((2 + n)));
];
[ GenerateRandomNumber n m s;
    if ((n == m)) {
        return n;
    }
    if ((n > m)) {
        (s = n);
        (n = m);
        (m = s);
    }
    (n)--;
    return (random((m - n)) + n);
];
[ PrintSpaces n;
    while ((n > 0)) {
        print " ";
        (n = (n - 1));
    }
];
[ SwapWorkflags obj lst;
    objectloop (obj ofclass Object && (obj ofclass Object)) {
        (lst = 0);
        if ((obj has workflag2)) {
            (lst = 1);
        }
        give obj ~workflag2;
        if ((obj has workflag)) {
            give obj workflag2;
        }
        give obj ~workflag;
        if (lst) {
            give obj workflag;
        }
    }
];
[ ZRegion addr;
    switch (metaclass(addr)) {
        0:
            rfalse;
            ;
        Object, Class:
            rtrue;
            ;
        Routine:
            return 2;
            ;
        String:
            return 3;
            ;
    }
];
[ Memcpy to_addr from_addr size n;
    @mcopy size from_addr to_addr;
];
[ Arrcpy to_array to_entry_size from_array from_entry_size no_entries n val;
    if ((to_entry_size == from_entry_size)) {
        Memcpy(to_array, from_array, (to_entry_size*no_entries));
    } else {
        if ((((to_entry_size == 2)) && ((from_entry_size == 4)))) {
            for ((n = 0):(n < no_entries):(n)++) {
                (val = (from_array-->(n)));
                ((to_array->(0)) = ((val/256)%256));
                ((to_array->(1)) = (val%256));
                (to_array = (to_array + 2));
            }
        } else {
            print "*** Arrcpy doesn't support this ***";
            new_line;
            rtrue;
        }
    }
];
[ PrintVerbAsValue vb;
    if ((vb == 0)) {
        print "(no verb)";
    } else {
        print "verb ";
        (vb)(1);
    }
];
[ VerbIsMeaningful vb;
    if (((vb) && ((BlkValueCompare((vb)(CV_MEANING), MEANINGLESS_RR) ~= 0)))) {
        rtrue;
    }
    rfalse;
];
[ VerbIsModal vb;
    if (((vb) && ((vb)(CV_MODAL)))) {
        rtrue;
    }
    rfalse;
];
[ SEED_RANDOM_NUMBER_GENERATOR_R i;
    if (RNG_SEED_AT_START_OF_PLAY) {
        VM_Seed_RNG(RNG_SEED_AT_START_OF_PLAY);
    }
    for ((i = 1):(i <= 100):(i)++) {
        random(i);
    }
    rfalse;
];
[ DictionaryWordToVerbNum dword verbnum i;
    (dword = ((dword + #dict_par2) - 1));
    @aloads dword 0 verbnum;
    (verbnum = (65535 - verbnum));
    return verbnum;
];
[ RegardingSingleObject obj;
    (prior_named_list = 1);
    (prior_named_list_gender = -1);
    (prior_named_noun = obj);
];
[ RegardingNumber n;
    (prior_named_list = n);
    (prior_named_list_gender = -1);
    (prior_named_noun = 0);
];
[ I7_SOO_PAR oldval count;
    if ((count <= 1)) {
        return count;
    }
    return random(count);
];
[ I7_SOO_RAN oldval count v;
    if ((count <= 1)) {
        return count;
    }
    (v = oldval);
    while ((v == oldval)) {
        (v = random(count));
    }
    return v;
];
[ I7_SOO_STI oldval count v;
    if (oldval) {
        return oldval;
    }
    return I7_SOO_PAR(oldval, count);
];
[ I7_SOO_CYC oldval count;
    (oldval)++;
    if ((oldval > count)) {
        (oldval = 1);
    }
    return oldval;
];
[ I7_SOO_STOP oldval count;
    (oldval)++;
    if ((oldval > count)) {
        (oldval = count);
    }
    return oldval;
];
[ I7_SOO_TAP oldval count tn rn c;
    if ((count <= 1)) {
        return count;
    }
    (tn = ((count*(count + 1))/2));
    (rn = random(tn));
    for ((c = 1):(c <= count):(c)++) {
        (rn = (rn - c));
        if ((rn <= 0)) {
            return ((count - c) + 1);
        }
    }
];
[ I7_SOO_TRAN oldval count;
    if ((oldval < count)) {
        return (oldval + 1);
    }
    return ((count + 1) + I7_SOO_RAN((oldval%(count + 1)), count));
];
[ I7_SOO_TPAR oldval count;
    if ((oldval < count)) {
        return (oldval + 1);
    }
    return ((count + 1) + I7_SOO_PAR((oldval%(count + 1)), count));
];
[ I7_SOO_SHU oldval count sd ct v i j s ssd scope cc base;
    (base = (count + 1));
    (v = (oldval%base));
    (oldval = (oldval/base));
    (ct = (oldval%base));
    (sd = (oldval/base));
    if ((count > 32)) {
        return I7_SOO_PAR(oldval, count);
    }
    if ((count <= 1)) {
        (v = count);
    } else {
        (cc = (base*base));
        (scope = ((MAX_POSITIVE_NUMBER - 1)/cc));
        if ((sd == 0)) {
            (sd = random(scope));
            (ct = 0);
        }
        for ((i = 0):(i < count):(i)++) {
            ((I7_SOO_SHUF->(i)) = i);
        }
        (ssd = sd);
        for ((i = 0):(i < (count - 1)):(i)++) {
            (j = ((sd%(count - i)) + i));
            (sd = ((sd*31973) + 17));
            if ((sd < 0)) {
                (sd = (-(sd)));
            }
            (s = (I7_SOO_SHUF->(j)));
            ((I7_SOO_SHUF->(j)) = (I7_SOO_SHUF->(i)));
            ((I7_SOO_SHUF->(i)) = s);
        }
        (v = ((I7_SOO_SHUF->(ct)) + 1));
        (ct)++;
        if ((ct >= count)) {
            (ct = 0);
            (ssd = 0);
        }
    }
    return ((v + (ct*base)) + ((ssd*base)*base));
];
[ RoundOffValue t1 t2;
    if ((t1 >= 0)) {
        return (((t1 + (t2/2))/t2)*t2);
    }
    return (-(((((-(t1)) + (t2/2))/t2)*t2)));
];
[ glk_exit _vararg_count;
    @glk 1 _vararg_count 0;
    rfalse;
];
[ glk_tick _vararg_count;
    @glk 3 _vararg_count 0;
    rfalse;
];
[ glk_gestalt _vararg_count ret;
    @glk 4 _vararg_count ret;
    return ret;
];
[ glk_gestalt_ext _vararg_count ret;
    @glk 5 _vararg_count ret;
    return ret;
];
[ glk_window_iterate _vararg_count ret;
    @glk 32 _vararg_count ret;
    return ret;
];
[ glk_window_get_rock _vararg_count ret;
    @glk 33 _vararg_count ret;
    return ret;
];
[ glk_window_get_root _vararg_count ret;
    @glk 34 _vararg_count ret;
    return ret;
];
[ glk_window_open _vararg_count ret;
    @glk 35 _vararg_count ret;
    return ret;
];
[ glk_window_close _vararg_count;
    @glk 36 _vararg_count 0;
    rfalse;
];
[ glk_window_get_size _vararg_count;
    @glk 37 _vararg_count 0;
    rfalse;
];
[ glk_window_set_arrangement _vararg_count;
    @glk 38 _vararg_count 0;
    rfalse;
];
[ glk_window_get_arrangement _vararg_count;
    @glk 39 _vararg_count 0;
    rfalse;
];
[ glk_window_get_type _vararg_count ret;
    @glk 40 _vararg_count ret;
    return ret;
];
[ glk_window_get_parent _vararg_count ret;
    @glk 41 _vararg_count ret;
    return ret;
];
[ glk_window_clear _vararg_count;
    @glk 42 _vararg_count 0;
    rfalse;
];
[ glk_window_move_cursor _vararg_count;
    @glk 43 _vararg_count 0;
    rfalse;
];
[ glk_window_get_stream _vararg_count ret;
    @glk 44 _vararg_count ret;
    return ret;
];
[ glk_window_set_echo_stream _vararg_count;
    @glk 45 _vararg_count 0;
    rfalse;
];
[ glk_window_get_echo_stream _vararg_count ret;
    @glk 46 _vararg_count ret;
    return ret;
];
[ glk_set_window _vararg_count;
    @glk 47 _vararg_count 0;
    rfalse;
];
[ glk_window_get_sibling _vararg_count ret;
    @glk 48 _vararg_count ret;
    return ret;
];
[ glk_stream_iterate _vararg_count ret;
    @glk 64 _vararg_count ret;
    return ret;
];
[ glk_stream_get_rock _vararg_count ret;
    @glk 65 _vararg_count ret;
    return ret;
];
[ glk_stream_open_file _vararg_count ret;
    @glk 66 _vararg_count ret;
    return ret;
];
[ glk_stream_open_memory _vararg_count ret;
    @glk 67 _vararg_count ret;
    return ret;
];
[ glk_stream_close _vararg_count;
    @glk 68 _vararg_count 0;
    rfalse;
];
[ glk_stream_set_position _vararg_count;
    @glk 69 _vararg_count 0;
    rfalse;
];
[ glk_stream_get_position _vararg_count ret;
    @glk 70 _vararg_count ret;
    return ret;
];
[ glk_stream_set_current _vararg_count;
    @glk 71 _vararg_count 0;
    rfalse;
];
[ glk_stream_get_current _vararg_count ret;
    @glk 72 _vararg_count ret;
    return ret;
];
[ glk_stream_open_resource _vararg_count ret;
    @glk 73 _vararg_count ret;
    return ret;
];
[ glk_fileref_create_temp _vararg_count ret;
    @glk 96 _vararg_count ret;
    return ret;
];
[ glk_fileref_create_by_name _vararg_count ret;
    @glk 97 _vararg_count ret;
    return ret;
];
[ glk_fileref_create_by_prompt _vararg_count ret;
    @glk 98 _vararg_count ret;
    return ret;
];
[ glk_fileref_destroy _vararg_count;
    @glk 99 _vararg_count 0;
    rfalse;
];
[ glk_fileref_iterate _vararg_count ret;
    @glk 100 _vararg_count ret;
    return ret;
];
[ glk_fileref_get_rock _vararg_count ret;
    @glk 101 _vararg_count ret;
    return ret;
];
[ glk_fileref_delete_file _vararg_count;
    @glk 102 _vararg_count 0;
    rfalse;
];
[ glk_fileref_does_file_exist _vararg_count ret;
    @glk 103 _vararg_count ret;
    return ret;
];
[ glk_fileref_create_from_fileref _vararg_count ret;
    @glk 104 _vararg_count ret;
    return ret;
];
[ glk_put_char _vararg_count;
    @glk 128 _vararg_count 0;
    rfalse;
];
[ glk_put_char_stream _vararg_count;
    @glk 129 _vararg_count 0;
    rfalse;
];
[ glk_put_string _vararg_count;
    @glk 130 _vararg_count 0;
    rfalse;
];
[ glk_put_string_stream _vararg_count;
    @glk 131 _vararg_count 0;
    rfalse;
];
[ glk_put_buffer _vararg_count;
    @glk 132 _vararg_count 0;
    rfalse;
];
[ glk_put_buffer_stream _vararg_count;
    @glk 133 _vararg_count 0;
    rfalse;
];
[ glk_set_style _vararg_count;
    @glk 134 _vararg_count 0;
    rfalse;
];
[ glk_set_style_stream _vararg_count;
    @glk 135 _vararg_count 0;
    rfalse;
];
[ glk_get_char_stream _vararg_count ret;
    @glk 144 _vararg_count ret;
    return ret;
];
[ glk_get_line_stream _vararg_count ret;
    @glk 145 _vararg_count ret;
    return ret;
];
[ glk_get_buffer_stream _vararg_count ret;
    @glk 146 _vararg_count ret;
    return ret;
];
[ glk_char_to_lower _vararg_count ret;
    @glk 160 _vararg_count ret;
    return ret;
];
[ glk_char_to_upper _vararg_count ret;
    @glk 161 _vararg_count ret;
    return ret;
];
[ glk_stylehint_set _vararg_count;
    @glk 176 _vararg_count 0;
    rfalse;
];
[ glk_stylehint_clear _vararg_count;
    @glk 177 _vararg_count 0;
    rfalse;
];
[ glk_style_distinguish _vararg_count ret;
    @glk 178 _vararg_count ret;
    return ret;
];
[ glk_style_measure _vararg_count ret;
    @glk 179 _vararg_count ret;
    return ret;
];
[ glk_select _vararg_count;
    @glk 192 _vararg_count 0;
    rfalse;
];
[ glk_select_poll _vararg_count;
    @glk 193 _vararg_count 0;
    rfalse;
];
[ glk_request_line_event _vararg_count;
    @glk 208 _vararg_count 0;
    rfalse;
];
[ glk_cancel_line_event _vararg_count;
    @glk 209 _vararg_count 0;
    rfalse;
];
[ glk_request_char_event _vararg_count;
    @glk 210 _vararg_count 0;
    rfalse;
];
[ glk_cancel_char_event _vararg_count;
    @glk 211 _vararg_count 0;
    rfalse;
];
[ glk_request_mouse_event _vararg_count;
    @glk 212 _vararg_count 0;
    rfalse;
];
[ glk_cancel_mouse_event _vararg_count;
    @glk 213 _vararg_count 0;
    rfalse;
];
[ glk_request_timer_events _vararg_count;
    @glk 214 _vararg_count 0;
    rfalse;
];
[ glk_image_get_info _vararg_count ret;
    @glk 224 _vararg_count ret;
    return ret;
];
[ glk_image_draw _vararg_count ret;
    @glk 225 _vararg_count ret;
    return ret;
];
[ glk_image_draw_scaled _vararg_count ret;
    @glk 226 _vararg_count ret;
    return ret;
];
[ glk_window_flow_break _vararg_count;
    @glk 232 _vararg_count 0;
    rfalse;
];
[ glk_window_erase_rect _vararg_count;
    @glk 233 _vararg_count 0;
    rfalse;
];
[ glk_window_fill_rect _vararg_count;
    @glk 234 _vararg_count 0;
    rfalse;
];
[ glk_window_set_background_color _vararg_count;
    @glk 235 _vararg_count 0;
    rfalse;
];
[ glk_schannel_iterate _vararg_count ret;
    @glk 240 _vararg_count ret;
    return ret;
];
[ glk_schannel_get_rock _vararg_count ret;
    @glk 241 _vararg_count ret;
    return ret;
];
[ glk_schannel_create _vararg_count ret;
    @glk 242 _vararg_count ret;
    return ret;
];
[ glk_schannel_destroy _vararg_count;
    @glk 243 _vararg_count 0;
    rfalse;
];
[ glk_schannel_create_ext _vararg_count ret;
    @glk 244 _vararg_count ret;
    return ret;
];
[ glk_schannel_play_multi _vararg_count ret;
    @glk 247 _vararg_count ret;
    return ret;
];
[ glk_schannel_play _vararg_count ret;
    @glk 248 _vararg_count ret;
    return ret;
];
[ glk_schannel_play_ext _vararg_count ret;
    @glk 249 _vararg_count ret;
    return ret;
];
[ glk_schannel_stop _vararg_count;
    @glk 250 _vararg_count 0;
    rfalse;
];
[ glk_schannel_set_volume _vararg_count;
    @glk 251 _vararg_count 0;
    rfalse;
];
[ glk_sound_load_hint _vararg_count;
    @glk 252 _vararg_count 0;
    rfalse;
];
[ glk_schannel_set_volume_ext _vararg_count;
    @glk 253 _vararg_count 0;
    rfalse;
];
[ glk_schannel_pause _vararg_count;
    @glk 254 _vararg_count 0;
    rfalse;
];
[ glk_schannel_unpause _vararg_count;
    @glk 255 _vararg_count 0;
    rfalse;
];
[ glk_set_hyperlink _vararg_count;
    @glk 256 _vararg_count 0;
    rfalse;
];
[ glk_set_hyperlink_stream _vararg_count;
    @glk 257 _vararg_count 0;
    rfalse;
];
[ glk_request_hyperlink_event _vararg_count;
    @glk 258 _vararg_count 0;
    rfalse;
];
[ glk_cancel_hyperlink_event _vararg_count;
    @glk 259 _vararg_count 0;
    rfalse;
];
[ glk_buffer_to_lower_case_uni _vararg_count ret;
    @glk 288 _vararg_count ret;
    return ret;
];
[ glk_buffer_to_upper_case_uni _vararg_count ret;
    @glk 289 _vararg_count ret;
    return ret;
];
[ glk_buffer_to_title_case_uni _vararg_count ret;
    @glk 290 _vararg_count ret;
    return ret;
];
[ glk_buffer_canon_decompose_uni _vararg_count ret;
    @glk 291 _vararg_count ret;
    return ret;
];
[ glk_buffer_canon_normalize_uni _vararg_count ret;
    @glk 292 _vararg_count ret;
    return ret;
];
[ glk_put_char_uni _vararg_count;
    @glk 296 _vararg_count 0;
    rfalse;
];
[ glk_put_string_uni _vararg_count;
    @glk 297 _vararg_count 0;
    rfalse;
];
[ glk_put_buffer_uni _vararg_count;
    @glk 298 _vararg_count 0;
    rfalse;
];
[ glk_put_char_stream_uni _vararg_count;
    @glk 299 _vararg_count 0;
    rfalse;
];
[ glk_put_string_stream_uni _vararg_count;
    @glk 300 _vararg_count 0;
    rfalse;
];
[ glk_put_buffer_stream_uni _vararg_count;
    @glk 301 _vararg_count 0;
    rfalse;
];
[ glk_get_char_stream_uni _vararg_count ret;
    @glk 304 _vararg_count ret;
    return ret;
];
[ glk_get_buffer_stream_uni _vararg_count ret;
    @glk 305 _vararg_count ret;
    return ret;
];
[ glk_get_line_stream_uni _vararg_count ret;
    @glk 306 _vararg_count ret;
    return ret;
];
[ glk_stream_open_file_uni _vararg_count ret;
    @glk 312 _vararg_count ret;
    return ret;
];
[ glk_stream_open_memory_uni _vararg_count ret;
    @glk 313 _vararg_count ret;
    return ret;
];
[ glk_stream_open_resource_uni _vararg_count ret;
    @glk 314 _vararg_count ret;
    return ret;
];
[ glk_request_char_event_uni _vararg_count;
    @glk 320 _vararg_count 0;
    rfalse;
];
[ glk_request_line_event_uni _vararg_count;
    @glk 321 _vararg_count 0;
    rfalse;
];
[ glk_set_echo_line_event _vararg_count;
    @glk 336 _vararg_count 0;
    rfalse;
];
[ glk_set_terminators_line_event _vararg_count;
    @glk 337 _vararg_count 0;
    rfalse;
];
[ glk_current_time _vararg_count;
    @glk 352 _vararg_count 0;
    rfalse;
];
[ glk_current_simple_time _vararg_count ret;
    @glk 353 _vararg_count ret;
    return ret;
];
[ glk_time_to_date_utc _vararg_count;
    @glk 360 _vararg_count 0;
    rfalse;
];
[ glk_time_to_date_local _vararg_count;
    @glk 361 _vararg_count 0;
    rfalse;
];
[ glk_simple_time_to_date_utc _vararg_count;
    @glk 362 _vararg_count 0;
    rfalse;
];
[ glk_simple_time_to_date_local _vararg_count;
    @glk 363 _vararg_count 0;
    rfalse;
];
[ glk_date_to_time_utc _vararg_count;
    @glk 364 _vararg_count 0;
    rfalse;
];
[ glk_date_to_time_local _vararg_count;
    @glk 365 _vararg_count 0;
    rfalse;
];
[ glk_date_to_simple_time_utc _vararg_count ret;
    @glk 366 _vararg_count ret;
    return ret;
];
[ glk_date_to_simple_time_local _vararg_count ret;
    @glk 367 _vararg_count ret;
    return ret;
];
[ HandleGlkEvent x1 x2 x3;
    rfalse;
];
[ IdentifyGlkObject x1 x2 x3 x4;
    rfalse;
];
[ InitGlkWindow x1;
    rfalse;
];
[ VM_PreInitialise res;
    @gestalt 4 2 res;
    if ((res == 0)) {
        quit;
    }
    (unicode_gestalt_ok = 0);
    if (glk_gestalt(gestalt_Unicode, 0)) {
        (unicode_gestalt_ok = 1);
    }
    @setiosys 2 0;
];
[ VM_Initialise res sty i;
    @gestalt 4 2 res;
    if ((res == 0)) {
        quit;
    }
    GGRecoverObjects();
    if (glk_gestalt(gestalt_Sound, 0)) {
        if ((gg_foregroundchan == 0)) {
            (gg_foregroundchan = glk_schannel_create(GG_FOREGROUNDCHAN_ROCK));
        }
        if ((gg_backgroundchan == 0)) {
            (gg_backgroundchan = glk_schannel_create(GG_BACKGROUNDCHAN_ROCK));
        }
    }
    if (((KIT_CONFIGURATION_BITMAP)&(FIX_RNG_TCBIT))) {
        @random 10000 i;
        (i = ((-(i)) - 2000));
        @setrandom i;
    }
    (res = InitGlkWindow(0));
    if ((res ~= 0)) {
        rtrue;
    }
    if ((gg_mainwin == 0)) {
        (res = InitGlkWindow(GG_MAINWIN_ROCK));
        if ((res == 0)) {
            glk_stylehint_set(wintype_TextBuffer, style_Header, stylehint_Justification, 0);
            glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Weight, 0);
            glk_stylehint_set(wintype_TextBuffer, style_Emphasized, stylehint_Oblique, 1);
            (gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK));
        }
        if ((gg_mainwin == 0)) {
            quit;
        }
    } else {
        glk_window_clear(gg_mainwin);
    }
    if ((gg_statuswin == 0)) {
        (res = InitGlkWindow(GG_STATUSWIN_ROCK));
        if ((res == 0)) {
            (statuswin_cursize = statuswin_size);
            for ((sty = 0):(sty < style_NUMSTYLES):(sty)++) {
                glk_stylehint_set(wintype_TextGrid, sty, stylehint_ReverseColor, 1);
            }
            (gg_statuswin = glk_window_open(gg_mainwin, (winmethod_Fixed + winmethod_Above), statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK));
        }
    }
    glk_set_window(gg_mainwin);
    InitGlkWindow(1);
    ((buffer3-->(0)) = 0);
];
[ GGRecoverObjects id;
    (gg_mainwin = 0);
    (gg_statuswin = 0);
    (gg_quotewin = 0);
    (gg_scriptfref = 0);
    (gg_scriptstr = 0);
    (gg_savestr = 0);
    (statuswin_cursize = 0);
    (gg_foregroundchan = 0);
    (gg_backgroundchan = 0);
    (gg_commandstr = 0);
    (gg_command_reading = 0);
    IdentifyGlkObject(0);
    (id = glk_stream_iterate(0, gg_arguments));
    while (id) {
        switch ((gg_arguments-->(0))) {
            GG_SAVESTR_ROCK:
                (gg_savestr = id);
                ;
            GG_SCRIPTSTR_ROCK:
                (gg_scriptstr = id);
                ;
            GG_COMMANDWSTR_ROCK:
                (gg_commandstr = id);
                (gg_command_reading = 0);
                ;
            GG_COMMANDRSTR_ROCK:
                (gg_commandstr = id);
                (gg_command_reading = 1);
                ;
            default:
                IdentifyGlkObject(1, 1, id, (gg_arguments-->(0)));
                ;
        }
        (id = glk_stream_iterate(id, gg_arguments));
    }
    (id = glk_window_iterate(0, gg_arguments));
    while (id) {
        switch ((gg_arguments-->(0))) {
            GG_MAINWIN_ROCK:
                (gg_mainwin = id);
                ;
            GG_STATUSWIN_ROCK:
                (gg_statuswin = id);
                ;
            GG_QUOTEWIN_ROCK:
                (gg_quotewin = id);
                ;
            default:
                IdentifyGlkObject(1, 0, id, (gg_arguments-->(0)));
                ;
        }
        (id = glk_window_iterate(id, gg_arguments));
    }
    (id = glk_fileref_iterate(0, gg_arguments));
    while (id) {
        switch ((gg_arguments-->(0))) {
            GG_SCRIPTFREF_ROCK:
                (gg_scriptfref = id);
                ;
            default:
                IdentifyGlkObject(1, 2, id, (gg_arguments-->(0)));
                ;
        }
        (id = glk_fileref_iterate(id, gg_arguments));
    }
    if (glk_gestalt(gestalt_Sound, 0)) {
        (id = glk_schannel_iterate(0, gg_arguments));
        while (id) {
            switch ((gg_arguments-->(0))) {
                GG_FOREGROUNDCHAN_ROCK:
                    (gg_foregroundchan = id);
                    ;
                GG_BACKGROUNDCHAN_ROCK:
                    (gg_backgroundchan = id);
                    ;
                default:
                    IdentifyGlkObject(1, 3, id, (gg_arguments-->(0)));
                    ;
            }
            (id = glk_schannel_iterate(id, gg_arguments));
        }
        if ((gg_foregroundchan ~= 0)) {
            glk_schannel_stop(gg_foregroundchan);
        }
        if ((gg_backgroundchan ~= 0)) {
            glk_schannel_stop(gg_backgroundchan);
        }
    }
    IdentifyGlkObject(2);
];
[ VM_Describe_Release i;
    print "Release ";
    @aloads ROM_GAMERELEASE 0 i;
    print i;
    print " / Serial number ";
    for ((i = 0):(i < 6):(i)++) {
        print (char) (ROM_GAMESERIAL->(i));
    }
];
[ VM_KeyChar win nostat done res ix jx ch;
    (jx = ch);
    if ((win == 0)) {
        (win = gg_mainwin);
    }
    if ((((gg_commandstr ~= 0)) && ((gg_command_reading ~= 0)))) {
        (done = glk_get_line_stream(gg_commandstr, gg_arguments, 31));
        if ((done == 0)) {
            glk_stream_close(gg_commandstr, 0);
            (gg_commandstr = 0);
            (gg_command_reading = 0);
        } else {
            if (((gg_arguments->((done - 1))) == 10)) {
                (done = (done - 1));
            }
            (res = (gg_arguments->(0)));
            if ((res == 92)) {
                (res = 0);
                for ((ix = 1):(ix < done):(ix)++) {
                    (ch = (gg_arguments->(ix)));
                    if ((((ch >= 48)) && ((ch <= 57)))) {
                        @shiftl res 4 res;
                        (res = (res + (ch - 48)));
                    } else {
                        if ((((ch >= 97)) && ((ch <= 102)))) {
                            @shiftl res 4 res;
                            (res = (res + ((ch + 10) - 97)));
                        } else {
                            if ((((ch >= 65)) && ((ch <= 70)))) {
                                @shiftl res 4 res;
                                (res = (res + ((ch + 10) - 65)));
                            }
                        }
                    }
                }
            }
            jump KCPContinue;
        }
    }
    (done = 0);
    glk_request_char_event(win);
    while ((~~(done))) {
        glk_select(gg_event);
        switch ((gg_event-->(0))) {
            5:
                if (nostat) {
                    glk_cancel_char_event(win);
                    (res = -2147483648);
                    (done = 1);
                    break;
                }
                DrawStatusLine();
                ;
            2:
                if (((gg_event-->(1)) == win)) {
                    (res = (gg_event-->(2)));
                    (done = 1);
                }
                ;
        }
        (ix = HandleGlkEvent(gg_event, 1, gg_arguments));
        if ((ix == 2)) {
            (res = (gg_arguments-->(0)));
            (done = 1);
        } else {
            if ((ix == -1)) {
                (done = 0);
            }
        }
    }
    if ((((gg_commandstr ~= 0)) && ((gg_command_reading == 0)))) {
        if ((((((res < 32)) || ((res >= 256)))) || ((res == 92 or 32)))) {
            glk_put_char_stream(gg_commandstr, 92);
            (done = 0);
            (jx = res);
            for ((ix = 0):(ix < 8):(ix)++) {
                @ushiftr jx 28 ch;
                @shiftl jx 4 jx;
                (ch = ((ch)&(15)));
                if ((((ch ~= 0)) || ((ix == 7)))) {
                    (done = 1);
                }
                if (done) {
                    if ((((ch >= 0)) && ((ch <= 9)))) {
                        (ch = (ch + 48));
                    } else {
                        (ch = ((ch - 10) + 65));
                    }
                    glk_put_char_stream(gg_commandstr, ch);
                }
            }
        } else {
            glk_put_char_stream(gg_commandstr, res);
        }
        glk_put_char_stream(gg_commandstr, 10);
    }
    .KCPContinue;
    return res;
];
[ VM_KeyDelay tenths key done ix;
    glk_request_char_event(gg_mainwin);
    glk_request_timer_events((tenths*100));
    while ((~~(done))) {
        glk_select(gg_event);
        (ix = HandleGlkEvent(gg_event, 1, gg_arguments));
        if ((ix == 2)) {
            (key = (gg_arguments-->(0)));
            (done = 1);
        } else {
            if ((((ix >= 0)) && (((gg_event-->(0)) == 1 or 2)))) {
                (key = (gg_event-->(2)));
                (done = 1);
            }
        }
    }
    glk_cancel_char_event(gg_mainwin);
    glk_request_timer_events(0);
    return key;
];
[ VM_ReadKeyboard a_buffer a_table done ix;
    if ((((gg_commandstr ~= 0)) && ((gg_command_reading ~= 0)))) {
        (done = glk_get_line_stream(gg_commandstr, (a_buffer + WORDSIZE), ((INPUT_BUFFER_LEN - WORDSIZE) - 1)));
        if ((done == 0)) {
            glk_stream_close(gg_commandstr, 0);
            (gg_commandstr = 0);
            (gg_command_reading = 0);
        } else {
            if ((((a_buffer + WORDSIZE)->((done - 1))) == 10)) {
                (done = (done - 1));
            }
            ((a_buffer-->(0)) = done);
            VM_Style(INPUT_VMSTY);
            glk_put_buffer((a_buffer + WORDSIZE), done);
            VM_Style(NORMAL_VMSTY);
            print "^";
            jump KPContinue;
        }
    }
    (done = 0);
    glk_request_line_event(gg_mainwin, (a_buffer + WORDSIZE), (INPUT_BUFFER_LEN - WORDSIZE), 0);
    while ((~~(done))) {
        glk_select(gg_event);
        switch ((gg_event-->(0))) {
            5:
                DrawStatusLine();
                ;
            3:
                if (((gg_event-->(1)) == gg_mainwin)) {
                    ((a_buffer-->(0)) = (gg_event-->(2)));
                    (done = 1);
                }
                ;
        }
        (ix = HandleGlkEvent(gg_event, 0, a_buffer));
        if ((ix == 2)) {
            (done = 1);
        } else {
            if ((ix == -1)) {
                (done = 0);
            }
        }
    }
    if ((((gg_commandstr ~= 0)) && ((gg_command_reading == 0)))) {
        glk_put_buffer_stream(gg_commandstr, (a_buffer + WORDSIZE), (a_buffer-->(0)));
        glk_put_char_stream(gg_commandstr, 10);
    }
    .KPContinue;
    VM_Tokenise(a_buffer, a_table);
    if (gg_quotewin) {
        glk_window_close(gg_quotewin, 0);
        (gg_quotewin = 0);
    }
    if (((KIT_CONFIGURATION_BITMAP)&(ECHO_COMMANDS_TCBIT))) {
        print "** ";
        for ((ix = WORDSIZE):(ix < ((a_buffer-->(0)) + WORDSIZE)):(ix)++) {
            print (char) (a_buffer->(ix));
        }
        print "^";
    }
];
[ VM_CopyBuffer bto bfrom i;
    for ((i = 0):(i < INPUT_BUFFER_LEN):(i)++) {
        ((bto->(i)) = (bfrom->(i)));
    }
];
[ VM_PrintToBuffer buf len a b c;
    if (b) {
        if ((((((metaclass(a) == Object)) && (((_final_propertylength(OBJECT_TY, a, b)) == WORDSIZE)))) && ((metaclass(_final_propertyvalue(OBJECT_TY, a, b)) == String)))) {
            ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, _final_propertyvalue(OBJECT_TY, a, b)));
        } else {
            if ((metaclass(a) == Routine)) {
                ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, a, b, c));
            } else {
                ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, a, b));
            }
        }
    } else {
        if ((metaclass(a) == Routine)) {
            ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, a, b, c));
        } else {
            ((buf-->(0)) = Glulx_PrintAnyToArray((buf + WORDSIZE), len, a));
        }
    }
    if (((buf-->(0)) > len)) {
        ((buf-->(0)) = len);
    }
    return (buf-->(0));
];
[ VM_Tokenise buf tab cx numwords len bx ix wx wpos wlen val res dictlen entrylen;
    (len = (buf-->(0)));
    (buf = (buf + WORDSIZE));
    (cx = 0);
    (numwords = 0);
    while ((cx < len)) {
        while ((((cx < len)) && (((buf->(cx)) == 32)))) {
            (cx)++;
        }
        if ((cx >= len)) {
            break;
        }
        (bx = cx);
        if (((buf->(cx)) == 46 or 44 or 34)) {
            (cx)++;
        } else {
            while ((((cx < len)) && (((buf->(cx)) ~= 32 or 46 or 44 or 34)))) {
                (cx)++;
            }
        }
        ((tab-->(((numwords*3) + 2))) = (cx - bx));
        ((tab-->(((numwords*3) + 3))) = (WORDSIZE + bx));
        (numwords)++;
        if ((numwords >= MAX_BUFFER_WORDS)) {
            break;
        }
    }
    ((tab-->(0)) = numwords);
    (dictlen = (#dictionary_table-->(0)));
    (entrylen = (DICT_WORD_SIZE + 7));
    for ((wx = 0):(wx < numwords):(wx)++) {
        (wlen = (tab-->(((wx*3) + 2))));
        (wpos = (tab-->(((wx*3) + 3))));
        if ((wlen > DICT_WORD_SIZE)) {
            (wlen = DICT_WORD_SIZE);
        }
        (cx = (wpos - WORDSIZE));
        for ((ix = 0):(ix < wlen):(ix)++) {
            ((gg_tokenbuf->(ix)) = VM_UpperToLowerCase((buf->((cx + ix)))));
        }
        for (:(ix < DICT_WORD_SIZE):(ix)++) {
            ((gg_tokenbuf->(ix)) = 0);
        }
        (val = (#dictionary_table + WORDSIZE));
        @binarysearch gg_tokenbuf DICT_WORD_SIZE val entrylen dictlen 1 1 res;
        ((tab-->(((wx*3) + 1))) = res);
    }
];
[ LTI_Insert i ch b y;
    (b = buffer);
    (y = (b-->(0)));
    if ((y > INPUT_BUFFER_LEN)) {
        (y = INPUT_BUFFER_LEN);
    }
    for ((y = (y + WORDSIZE)):(y > i):(y)--) {
        ((b->(y)) = (b->((y - 1))));
    }
    ((b->(i)) = ch);
    if (((b-->(0)) < INPUT_BUFFER_LEN)) {
        ((b-->(0)))++;
    }
];
[ VM_InvalidDictionaryAddress addr;
    if ((addr < 0)) {
        rtrue;
    }
    rfalse;
];
[ VM_DictionaryAddressToNumber w;
    return w;
];
[ VM_NumberToDictionaryAddress n;
    return n;
];
[ GGWordCompare str1 str2 ix jx;
    for ((ix = 0):(ix < DICT_WORD_SIZE):(ix)++) {
        (jx = ((str1->(ix)) - (str2->(ix))));
        if ((jx ~= 0)) {
            return jx;
        }
    }
    rfalse;
];
[ VM_CommandTableAddress i;
    return (#grammar_table-->((i + 1)));
];
[ VM_PrintCommandWords i wd j dictlen entrylen;
    (dictlen = (#dictionary_table-->(0)));
    (entrylen = (DICT_WORD_SIZE + 7));
    for ((j = 0):(j < dictlen):(j)++) {
        (wd = ((#dictionary_table + WORDSIZE) + (entrylen*j)));
        if ((DictionaryWordToVerbNum(wd) == i)) {
            print "'";
            print (address) wd;
            print "' ";
        }
    }
];
[ VM_Seed_RNG n;
    @setrandom n;
];
[ VM_AllocateMemory amount i;
    @gestalt 7 0 i;
    if ((i == 0)) {
        return i;
    }
    @malloc amount i;
    return i;
];
[ VM_FreeMemory address i;
    @gestalt 7 0 i;
    if ((i == 0)) {
        rtrue;
    }
    @mfree address;
];
[ VM_Picture resource_ID;
    if (glk_gestalt(gestalt_Graphics, 0)) {
        glk_image_draw(gg_mainwin, resource_ID, imagealign_InlineCenter, 0);
    } else {
        print "[Picture number ";
        print resource_ID;
        print " here.]^";
    }
];
[ VM_SoundEffect resource_ID;
    if (glk_gestalt(gestalt_Sound, 0)) {
        glk_schannel_play(gg_foregroundchan, resource_ID);
    } else {
        print "[Sound effect number ";
        print resource_ID;
        print " here.]^";
    }
];
[ VM_Style sty;
    switch (sty) {
        NORMAL_VMSTY:
            glk_set_style(style_Normal);
            ;
        HEADER_VMSTY:
            glk_set_style(style_Header);
            ;
        SUBHEADER_VMSTY:
            glk_set_style(style_Subheader);
            ;
        NOTE_VMSTY:
            glk_set_style(style_Note);
            ;
        ALERT_VMSTY:
            glk_set_style(style_Alert);
            ;
        BLOCKQUOTE_VMSTY:
            glk_set_style(style_BlockQuote);
            ;
        INPUT_VMSTY:
            glk_set_style(style_Input);
            ;
    }
];
[ VM_UpperToLowerCase c;
    return glk_char_to_lower(c);
];
[ VM_LowerToUpperCase c;
    return glk_char_to_upper(c);
];
[ Glulx_PrintAnything _vararg_count obj mclass;
    if ((_vararg_count == 0)) {
        rtrue;
    }
    @copy sp obj;
    (_vararg_count)--;
    if ((obj == 0)) {
        rtrue;
    }
    if (((obj->(0)) == 96)) {
        print (address) obj;
        rtrue;
    }
    (mclass = metaclass(obj));
    switch (mclass) {
        0:
            rtrue;
            ;
        String:
            print (string) obj;
            rtrue;
            ;
        Routine:
            @call obj _vararg_count 0;
            rtrue;
            ;
        Object:
            if ((_vararg_count == 0)) {
                PrintShortName(obj);
            } else {
                @copy obj sp;
                (_vararg_count)++;
                @call PrintOrRun _vararg_count 0;
            }
            rtrue;
            ;
    }
];
[ Glulx_PrintAnyToArray _vararg_count arr arrlen str oldstr len;
    @copy sp arr;
    @copy sp arrlen;
    (_vararg_count = (_vararg_count - 2));
    (oldstr = glk_stream_get_current());
    (str = glk_stream_open_memory(arr, arrlen, 1, 0));
    if ((str == 0)) {
        rfalse;
    }
    glk_stream_set_current(str);
    @call Glulx_PrintAnything _vararg_count 0;
    glk_stream_set_current(oldstr);
    @copy -1 sp;
    @copy str sp;
    @glk 68 2 0;
    @copy sp len;
    @copy sp 0;
    return len;
];
[ Glulx_ChangeAnyToCString _vararg_count ix len;
    (ix = (GG_ANYTOSTRING_LEN - 2));
    @copy ix sp;
    (ix = (AnyToStrArr + 1));
    @copy ix sp;
    (ix = (_vararg_count + 2));
    @call Glulx_PrintAnyToArray ix len;
    ((AnyToStrArr->(0)) = 224);
    if ((len >= GG_ANYTOSTRING_LEN)) {
        (len = (GG_ANYTOSTRING_LEN - 1));
    }
    ((AnyToStrArr->((len + 1))) = 0);
    return AnyToStrArr;
];
[ VM_ClearScreen window;
    if ((window == WIN_ALL or WIN_MAIN)) {
        glk_window_clear(gg_mainwin);
        if (gg_quotewin) {
            glk_window_close(gg_quotewin, 0);
            (gg_quotewin = 0);
        }
    }
    if (((gg_statuswin) && ((window == WIN_ALL or WIN_STATUS)))) {
        glk_window_clear(gg_statuswin);
    }
];
[ VM_ScreenWidth id;
    (id = gg_mainwin);
    if (((gg_statuswin) && (statuswin_current))) {
        (id = gg_statuswin);
    }
    glk_window_get_size(id, gg_arguments, 0);
    return (gg_arguments-->(0));
];
[ VM_ScreenHeight;
    glk_window_get_size(gg_mainwin, 0, gg_arguments);
    return (gg_arguments-->(0));
];
[ VM_SetWindowColours f b window doclear i fwd bwd swin;
    if (((((clr_on) && (f))) && (b))) {
        if (window) {
            (swin = (5 - window));
        }
        (fwd = MakeColourWord(f));
        (bwd = MakeColourWord(b));
        for ((i = 0):(i < style_NUMSTYLES):(i)++) {
            if ((((f == CLR_DEFAULT)) || ((b == CLR_DEFAULT)))) {
                glk_stylehint_clear(swin, i, stylehint_TextColor);
                glk_stylehint_clear(swin, i, stylehint_BackColor);
            } else {
                glk_stylehint_set(swin, i, stylehint_TextColor, fwd);
                glk_stylehint_set(swin, i, stylehint_BackColor, bwd);
            }
        }
        if (gg_statuswin) {
            glk_window_close(gg_statuswin, 0);
        }
        (gg_statuswin = 0);
        if (((doclear) || ((((window ~= 1)) && ((((clr_fg ~= f)) || ((clr_bg ~= b)))))))) {
            glk_window_close(gg_mainwin, 0);
            (gg_mainwin = glk_window_open(0, 0, 0, wintype_TextBuffer, GG_MAINWIN_ROCK));
            if ((gg_scriptstr ~= 0)) {
                glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
            }
        }
        (gg_statuswin = glk_window_open(gg_mainwin, (winmethod_Fixed + winmethod_Above), statuswin_cursize, wintype_TextGrid, GG_STATUSWIN_ROCK));
        if (((statuswin_current) && (gg_statuswin))) {
            VM_MoveCursorInStatusLine();
        } else {
            VM_MainWindow();
        }
        if ((window ~= 2)) {
            (clr_fgstatus = f);
            (clr_bgstatus = b);
        }
        if ((window ~= 1)) {
            (clr_fg = f);
            (clr_bg = b);
        }
    }
];
[ VM_RestoreWindowColours;
    if (clr_on) {
        VM_SetWindowColours(clr_fg, clr_bg, 2);
        VM_SetWindowColours(clr_fgstatus, clr_bgstatus, 1, 1);
        VM_ClearScreen();
    }
];
[ MakeColourWord c;
    if ((c > 9)) {
        return c;
    }
    (c = (c - 2));
    return (((16711680*((c)&(1))) + (65280*(((c)&(2)) ~= 0))) + (255*(((c)&(4)) ~= 0)));
];
[ VM_MainWindow;
    glk_set_window(gg_mainwin);
    (statuswin_current = 0);
];
[ VM_StatusLineHeight hgt;
    if ((gg_statuswin == 0)) {
        rtrue;
    }
    if ((hgt == statuswin_cursize)) {
        rtrue;
    }
    glk_window_set_arrangement(glk_window_get_parent(gg_statuswin), 18, hgt, 0);
    (statuswin_cursize = hgt);
];
[ VM_MoveCursorInStatusLine line column;
    if ((gg_statuswin == 0)) {
        rtrue;
    }
    glk_set_window(gg_statuswin);
    if ((line == 0)) {
        (line = 1);
        (column = 1);
    }
    glk_window_move_cursor(gg_statuswin, (column - 1), (line - 1));
    (statuswin_current = 1);
];
[ Box__Routine maxwid arr ix lines lastnl parwin;
    (maxwid = 0);
    (lines = (arr-->(0)));
    if ((gg_quotewin == 0)) {
        ((gg_arguments-->(0)) = lines);
        (ix = InitGlkWindow(GG_QUOTEWIN_ROCK));
        if ((ix == 0)) {
            (gg_quotewin = glk_window_open(gg_mainwin, (winmethod_Fixed + winmethod_Above), lines, wintype_TextBuffer, GG_QUOTEWIN_ROCK));
        }
    } else {
        (parwin = glk_window_get_parent(gg_quotewin));
        glk_window_set_arrangement(parwin, 18, lines, 0);
    }
    (lastnl = 1);
    if (gg_quotewin) {
        glk_window_clear(gg_quotewin);
        glk_set_window(gg_quotewin);
        (lastnl = 0);
    }
    VM_Style(BLOCKQUOTE_VMSTY);
    for ((ix = 0):(ix < lines):(ix)++) {
        print (string) (arr-->((ix + 1)));
        if ((((ix < (lines - 1))) || (lastnl))) {
            print "^";
        }
    }
    VM_Style(NORMAL_VMSTY);
    if (gg_quotewin) {
        glk_set_window(gg_mainwin);
    }
];
[ Unsigned__Compare x y;
    @jleu x y ?lesseq;
    rtrue;
    .lesseq;
    @jeq x y ?equal;
    return (-(1));
    .equal;
    rfalse;
];
[ RT__ChLDW x y;
    @aload x y sp;
    @return sp;
];
[ RT__ChLDB x y;
    @aloadb x y sp;
    @return sp;
];
[ ClearParagraphing r;
    (say__p = 0);
    (say__pc = 0);
];
[ DivideParagraphPoint;
    if (say__p) {
        print "^";
        (say__p = 0);
        (say__pc = ((say__pc)|(PARA_COMPLETED)));
        (say__pc_save = 1);
        if (((say__pc)&(PARA_PROMPTSKIP))) {
            (say__pc = (say__pc - PARA_PROMPTSKIP));
        }
        if (((say__pc)&(PARA_SUPPRESSPROMPTSKIP))) {
            (say__pc = (say__pc - PARA_SUPPRESSPROMPTSKIP));
        }
    }
    (say__pc = ((say__pc)|(PARA_CONTENTEXPECTED)));
    (say__pc_save = ((say__pc)&(PARA_COMPLETED)));
];
[ AdjustParagraphPoint;
    if (say__pc_save) {
        (say__pc = ((say__pc)|(PARA_COMPLETED)));
    }
];
[ ParaContent;
    if (((say__pc)&(PARA_CONTENTEXPECTED))) {
        (say__pc = (say__pc - PARA_CONTENTEXPECTED));
        (say__p = 1);
    }
];
[ GoingLookBreak;
    if ((((say__pc)&(PARA_COMPLETED)) == 0)) {
        print "^";
    }
    ClearParagraphing(10);
];
[ CommandClarificationBreak;
    print "^";
    ClearParagraphing(11);
];
[ RunParagraphOn;
    (say__p = 0);
    (say__pc = ((say__pc)|(PARA_PROMPTSKIP)));
    (say__pc = ((say__pc)|(PARA_SUPPRESSPROMPTSKIP)));
];
[ SpecialLookSpacingBreak;
    (say__p = 0);
    (say__pc = ((say__pc)|(PARA_PROMPTSKIP)));
];
[ EnsureBreakBeforePrompt;
    if (((say__p) || (((((say__pc)&(PARA_PROMPTSKIP))) && ((((say__pc)&(PARA_SUPPRESSPROMPTSKIP)) == 0)))))) {
        print "^";
    }
    ClearParagraphing(12);
];
[ PrintSingleParagraph matter;
    (say__p = 1);
    (say__pc = ((say__pc)|(PARA_NORULEBOOKBREAKS)));
    TEXT_TY_Say(matter);
    DivideParagraphPoint();
    (say__pc = 0);
];
[ STextSubstitution;
    if ((say__n ~= 1)) {
        print "s";
    }
];
[ EnglishNumber n;
    LanguageNumber(n);
];
[ LanguageNumber n f;
    if ((n == 0)) {
        print "zero";
        rfalse;
    }
    if ((n == MIN_NEGATIVE_NUMBER)) {
        print "minus two billion";
        (n = 147483648);
        (f = 1);
    }
    if ((n < 0)) {
        print "minus ";
        (n = (-(n)));
    }
    if ((n >= 1000000000)) {
        if ((f == 1)) {
            print ", ";
        }
        LanguageNumber((n/1000000000));
        print " billion";
        (n = (n%1000000000));
        (f = 1);
    }
    if ((n >= 1000000)) {
        if ((f == 1)) {
            print ", ";
        }
        LanguageNumber((n/1000000));
        print " million";
        (n = (n%1000000));
        (f = 1);
    }
    if ((n >= 1000)) {
        if ((f == 1)) {
            print ", ";
        }
        LanguageNumber((n/1000));
        print " thousand";
        (n = (n%1000));
        (f = 1);
    }
    if ((n >= 100)) {
        if ((f == 1)) {
            print ", ";
        }
        LanguageNumber((n/100));
        print " hundred";
        (n = (n%100));
        (f = 1);
    }
    if ((n == 0)) {
        rfalse;
    }
    if (((KIT_CONFIGURATION_BITMAP)&(DIALECT_US_TCBIT))) {
        if ((f == 1)) {
            print " ";
        }
    } else {
        if ((f == 1)) {
            print " and ";
        }
    }
    if ((((n >= 20)) && ((n < 100)))) {
        switch ((n/10)) {
            2:
                print "twenty";
                ;
            3:
                print "thirty";
                ;
            4:
                print "forty";
                ;
            5:
                print "fifty";
                ;
            6:
                print "sixty";
                ;
            7:
                print "seventy";
                ;
            8:
                print "eighty";
                ;
            9:
                print "ninety";
                ;
        }
        if (((n%10) ~= 0)) {
            print "-";
            LanguageNumber((n%10));
        }
    } else {
        switch (n) {
            1:
                print "one";
                ;
            2:
                print "two";
                ;
            3:
                print "three";
                ;
            4:
                print "four";
                ;
            5:
                print "five";
                ;
            6:
                print "six";
                ;
            7:
                print "seven";
                ;
            8:
                print "eight";
                ;
            9:
                print "nine";
                ;
            10:
                print "ten";
                ;
            11:
                print "eleven";
                ;
            12:
                print "twelve";
                ;
            13:
                print "thirteen";
                ;
            14:
                print "fourteen";
                ;
            15:
                print "fifteen";
                ;
            16:
                print "sixteen";
                ;
            17:
                print "seventeen";
                ;
            18:
                print "eighteen";
                ;
            19:
                print "nineteen";
                ;
        }
    }
];
[ SquareRoot num op res one n x;
    if ((num < 0)) {
        RunTimeProblem(RTP_NEGATIVEROOT);
        rtrue;
    }
    @gestalt 11 0 n;
    if (n) {
        @numtof num x;
        @sqrt x x;
        @ftonumz x num;
        return num;
    }
    (op = num);
    if ((num < 0)) {
        RunTimeProblem(RTP_NEGATIVEROOT);
        rtrue;
    }
    for ((one = WORD_NEXTTOHIGHBIT):(one > op):(one = (one/4))) {
    }
    while ((one ~= 0)) {
        if ((op >= (res + one))) {
            (op = ((op - res) - one));
            (res = ((res/2) + one));
        } else {
            (res = (res/2));
        }
        (one = (one/4));
    }
    return res;
];
[ CubeRoot num neg x y n;
    @gestalt 11 0 n;
    if (n) {
        if ((num < 0)) {
            (neg = 1);
            (num = (-(num)));
        }
        @numtof num x;
        @pow x 1051372203 x;
        @ftonumz x num;
        if (neg) {
            return (-(num));
        } else {
            return num;
        }
    }
    if ((num < 0)) {
        (x = (-(SquareRoot((-(num))))));
    } else {
        (x = SquareRoot(num));
    }
    for ((n = 0):(((y ~= x)) && (((n)++ < 100))):((y = x),(x = (((2*x) + ((num/x)/x))/3)))) {
    }
    return x;
];
[ NUMBER_TY_Abs x;
    if ((x < 0)) {
        return (-(x));
    }
    return x;
];
[ IntegerDivide A B;
    if ((B == 0)) {
        RunTimeProblem(RTP_DIVZERO);
        rfalse;
    }
    return (A/B);
];
[ IntegerRemainder A B;
    if ((B == 0)) {
        RunTimeProblem(RTP_DIVZERO);
        rfalse;
    }
    return (A%B);
];
[ UnsignedCompare x y u v;
    @jleu x y ?lesseq;
    rtrue;
    .lesseq;
    @jeq x y ?equal;
    return (-(1));
    .equal;
    rfalse;
];
[ SignedCompare x y;
    if ((x > y)) {
        rtrue;
    }
    if ((x == y)) {
        rfalse;
    }
    return (-(1));
];
[ REAL_NUMBER_TY_Say fp;
    Float(fp);
];
[ REAL_NUMBER_TY_Compare r1 r2;
    @jflt r1 r2 ?less;
    @jfeq r1 r2 0 ?same;
    rtrue;
    .same;
    rfalse;
    .less;
    return (-(1));
];
[ NUMBER_TY_to_REAL_NUMBER_TY int real;
    @numtof int real;
    return real;
];
[ REAL_NUMBER_TY_to_NUMBER_TY real int;
    @ftonumn real int;
    return int;
];
[ REAL_NUMBER_TY_Sin in out;
    @sin in out;
    return out;
];
[ REAL_NUMBER_TY_Cos in out;
    @cos in out;
    return out;
];
[ REAL_NUMBER_TY_Tan in out;
    @tan in out;
    return out;
];
[ REAL_NUMBER_TY_Arcsin in out;
    @asin in out;
    return out;
];
[ REAL_NUMBER_TY_Arccos in out;
    @acos in out;
    return out;
];
[ REAL_NUMBER_TY_Arctan in out;
    @atan in out;
    return out;
];
[ REAL_NUMBER_TY_Sinh in tmp out;
    @exp in tmp;
    @fsub M_0 in in;
    @exp in out;
    @fadd tmp out out;
    @fmul out M_HALF out;
    return out;
];
[ REAL_NUMBER_TY_Cosh in tmp out;
    @exp in tmp;
    @fsub M_0 in in;
    @exp in out;
    @fsub tmp out out;
    @fmul out M_HALF out;
    return out;
];
[ REAL_NUMBER_TY_Tanh in s c t;
    (s = REAL_NUMBER_TY_Sinh(in));
    (c = REAL_NUMBER_TY_Cosh(in));
    @fdiv s c t;
    return t;
];
[ REAL_NUMBER_TY_Reciprocal in out;
    @fdiv M_1 in out;
    return out;
];
[ REAL_NUMBER_TY_Negate in out;
    @fsub M_0 in out;
    return out;
];
[ REAL_NUMBER_TY_Plus x y out;
    @fadd x y out;
    return out;
];
[ REAL_NUMBER_TY_Minus x y out;
    @fsub x y out;
    return out;
];
[ REAL_NUMBER_TY_Times x y out;
    @fmul x y out;
    return out;
];
[ REAL_NUMBER_TY_Divide x y out;
    @fdiv x y out;
    return out;
];
[ REAL_NUMBER_TY_Remainder x y r q;
    @fmod x y r q;
    return r;
];
[ REAL_NUMBER_TY_Approximate x y quotient out;
    @fdiv x y quotient;
    @fadd quotient M_HALF quotient;
    @floor quotient quotient;
    @fmul quotient y out;
    return out;
];
[ REAL_NUMBER_TY_Root x out;
    @sqrt x out;
    return out;
];
[ REAL_NUMBER_TY_Cube_Root x out;
    @pow x M_THIRD out;
    return out;
];
[ REAL_NUMBER_TY_Pow x y out;
    @pow x y out;
    return out;
];
[ REAL_NUMBER_TY_Exp x out;
    @exp x out;
    return out;
];
[ REAL_NUMBER_TY_Log x out;
    @log x out;
    return out;
];
[ REAL_NUMBER_TY_BLog x n d out;
    @log x out;
    if ((n == 10)) {
        (d = M_LOG10);
    } else {
        @numtof n d;
        @log d d;
    }
    @fdiv out d out;
    return out;
];
[ REAL_NUMBER_TY_Floor x out;
    @floor x out;
    return out;
];
[ REAL_NUMBER_TY_Ceiling x out;
    @ceil x out;
    return out;
];
[ REAL_NUMBER_TY_Abs x;
    return ((x)&(2147483647));
];
[ REAL_NUMBER_TY_Nan x;
    @jisnan x ?Nan;
    rfalse;
    .Nan;
    rtrue;
];
[ FloatParse buf len useall res ix val ch ten negative intpart fracpart fracdiv expon expnegative count;
    if ((len == 0)) {
        return FLOAT_NAN;
    }
    (ix = 0);
    (negative = 0);
    (intpart = 0);
    (fracpart = 0);
    @numtof 10 ten;
    (ch = (buf->(ix)));
    if ((ch == 45)) {
        (negative = 1);
        (ix)++;
    } else {
        if ((ch == 43)) {
            (ix)++;
        }
    }
    for ((count = 0):(ix < len):((ix)++,(count)++)) {
        (ch = (buf->(ix)));
        if ((((ch < 48)) || ((ch > 57)))) {
            break;
        }
        (val = (ch - 48));
        @numtof val val;
        @fmul intpart ten intpart;
        @fadd intpart val intpart;
    }
    if ((((ix < len)) && (((buf->(ix)) == 46)))) {
        (ix)++;
        @numtof 1 fracdiv;
        for (:(ix < len):((ix)++,(count)++)) {
            (ch = (buf->(ix)));
            if ((((ch < 48)) || ((ch > 57)))) {
                break;
            }
            (val = (ch - 48));
            @numtof val val;
            @fmul fracpart ten fracpart;
            @fadd fracpart val fracpart;
            @fmul fracdiv ten fracdiv;
        }
        @fdiv fracpart fracdiv fracpart;
    }
    if ((count == 0)) {
        return FLOAT_NAN;
    }
    @fadd intpart fracpart res;
    if ((((ix < len)) && (((buf->(ix)) == 101 or 69 or 32 or 42 or 120 or 88 or 215)))) {
        if (((buf->(ix)) == 101 or 69)) {
            (ix)++;
            if ((ix == len)) {
                return FLOAT_NAN;
            }
        } else {
            while ((((ix < len)) && (((buf->(ix)) == 32)))) {
                (ix)++;
            }
            if ((ix == len)) {
                return FLOAT_NAN;
            }
            if (((buf->(ix)) ~= 42 or 120 or 88 or 215)) {
                return FLOAT_NAN;
            }
            (ix)++;
            while ((((ix < len)) && (((buf->(ix)) == 32)))) {
                (ix)++;
            }
            if ((ix == len)) {
                return FLOAT_NAN;
            }
            if (((buf->(ix)) ~= 49)) {
                return FLOAT_NAN;
            }
            (ix)++;
            if (((buf->(ix)) ~= 48)) {
                return FLOAT_NAN;
            }
            (ix)++;
            if (((buf->(ix)) ~= 94)) {
                return FLOAT_NAN;
            }
            (ix)++;
        }
        (expnegative = 0);
        (ch = (buf->(ix)));
        if ((ch == 45)) {
            (expnegative = 1);
            (ix)++;
        } else {
            if ((ch == 43)) {
                (ix)++;
            }
        }
        (expon = 0);
        for ((count = 0):(ix < len):((ix)++,(count)++)) {
            (ch = (buf->(ix)));
            if ((((ch < 48)) || ((ch > 57)))) {
                break;
            }
            (expon = ((10*expon) + (ch - 48)));
        }
        if ((count == 0)) {
            return FLOAT_NAN;
        }
        if (expnegative) {
            (expon = (-(expon)));
        }
        if (expon) {
            @numtof expon expon;
            @pow ten expon val;
            @fmul res val res;
        }
    }
    if (negative) {
        (res = ((-2147483648)|(res)));
    }
    if (((useall) && ((ix ~= len)))) {
        return FLOAT_NAN;
    }
    return res;
];
[ Float val prec pval;
    (pval = ((val)&(2147483647)));
    @jz pval ?UseFloatDec;
    @jfge pval 1232348160 ?UseFloatExp;
    @jflt pval 953267991 ?UseFloatExp;
    .UseFloatDec;
    return FloatDec(val, prec);
    .UseFloatExp;
    return FloatExp(val, prec);
];
[ FloatExp val prec log10val expo fexpo idig ix pow10;
    if ((prec == 0)) {
        (prec = 5);
    }
    if ((prec > 8)) {
        (prec = 8);
    }
    (pow10 = (PowersOfTen-->(prec)));
    if (((val)&(-2147483648))) {
        @streamchar 45;
        (val = ((val)&(2147483647)));
    }
    @jisnan val ?IsNan;
    @jisinf val ?IsInf;
    if ((val == 0)) {
        (expo = 0);
        (idig = 0);
        jump DoPrint;
    }
    @log val sp;
    @fdiv sp 1075010958 log10val;
    @floor log10val fexpo;
    @ftonumn fexpo expo;
    @fsub log10val fexpo sp;
    @numtof prec sp;
    @fadd sp sp sp;
    @fmul sp 1075010958 sp;
    @exp sp sp;
    @ftonumn sp idig;
    .DoPrint;
    if ((idig >= (10*pow10))) {
        (expo)++;
        @div idig 10 idig;
    }
    while ((prec > 1)) {
        @mod idig 10 sp;
        @jnz sp ?DoneTrimming;
        @div pow10 10 pow10;
        @div idig 10 idig;
        (prec)--;
    }
    .DoneTrimming;
    for ((ix = 0):(ix <= prec):(ix)++) {
        @div idig pow10 sp;
        @mod sp 10 sp;
        @streamnum sp;
        if ((ix == 0)) {
            @streamchar 46;
        }
        @div pow10 10 pow10;
    }
    if ((((KIT_CONFIGURATION_BITMAP)&(PROGRAMMING_EXPONENTS_TCBIT)) == 0)) {
        PrintMultiplicationSign();
        @streamchar 49;
        @streamchar 48;
        @streamchar 94;
        @streamnum expo;
    } else {
        @streamchar 101;
        if ((expo < 0)) {
            @streamchar 45;
            @neg expo expo;
        } else {
            @streamchar 43;
        }
        if ((expo < 10)) {
            @streamchar 48;
        }
        @streamnum expo;
    }
    rtrue;
    .IsNan;
    PrintNan();
    rtrue;
    .IsInf;
    PrintInfinity();
    rtrue;
];
[ FloatDec val prec log10val int fint extra0 frac idig ix pow10;
    if ((prec == 0)) {
        (prec = 5);
    }
    if ((prec > 8)) {
        (prec = 8);
    }
    (pow10 = (PowersOfTen-->(prec)));
    if (((val)&(-2147483648))) {
        @streamchar 45;
        (val = ((val)&(2147483647)));
    }
    @jisnan val ?IsNan;
    @jisinf val ?IsInf;
    (extra0 = 0);
    @fmod val 1065353216 frac fint;
    @ftonumz fint int;
    if ((int == 2147483647)) {
        @log fint sp;
        @fdiv sp 1075010958 log10val;
        @ftonumz log10val extra0;
        @sub extra0 8 extra0;
        @numtof extra0 sp;
        @fsub log10val sp sp;
        @fmul sp 1075010958 sp;
        @exp sp sp;
        @ftonumz sp int;
    }
    @streamnum int;
    for ((ix = 0):(ix < extra0):(ix)++) {
        @streamchar 48;
    }
    @streamchar 46;
    @log frac sp;
    @fdiv sp 1075010958 log10val;
    @numtof prec sp;
    @fadd log10val sp sp;
    @fmul sp 1075010958 sp;
    @exp sp sp;
    @ftonumn sp idig;
    if ((idig >= pow10)) {
        (idig = (pow10 - 1));
    }
    while ((prec > 1)) {
        @mod idig 10 sp;
        @jnz sp ?DoneTrimming;
        @div pow10 10 pow10;
        @div idig 10 idig;
        (prec)--;
    }
    .DoneTrimming;
    @div pow10 10 pow10;
    for ((ix = 0):(ix < prec):(ix)++) {
        @div idig pow10 sp;
        @mod sp 10 sp;
        @streamnum sp;
        @div pow10 10 pow10;
    }
    rtrue;
    .IsNan;
    PrintNan();
    rtrue;
    .IsInf;
    PrintInfinity();
    rtrue;
];
[ PrintInfinity;
    @streamunichar 8734;
];
[ PrintNan;
    @streamunichar 9888;
];
[ PrintMultiplicationSign;
    print " ";
    @streamunichar 215;
    print " ";
];
[ FileIO_Error extf err_text struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        print "^*** Error on unknown file: ";
        print (string) err_text;
        print " ***^";
    } else {
        (struc = (TableOfExternalFiles-->(extf)));
        print "^*** Error on file '";
        print (string) (struc-->(AUXF_FILENAME));
        print "': ";
        print (string) err_text;
        print " ***^";
    }
    RunTimeProblem(RTP_FILEIOERROR);
    rfalse;
];
[ FileIO_Exists extf fref struc rv usage;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        rfalse;
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((((struc == 0)) || (((struc-->(AUXF_MAGIC)) ~= AUXF_MAGIC_VALUE)))) {
        rfalse;
    }
    if ((struc-->(AUXF_BINARY))) {
        (usage = fileusage_BinaryMode);
    } else {
        (usage = fileusage_TextMode);
    }
    (fref = glk_fileref_create_by_name((fileusage_Data + usage), Glulx_ChangeAnyToCString((struc-->(AUXF_FILENAME))), 0));
    (rv = glk_fileref_does_file_exist(fref));
    glk_fileref_destroy(fref);
    return rv;
];
[ FileIO_Ready extf struc fref usage str ch;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        rfalse;
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((((struc == 0)) || (((struc-->(AUXF_MAGIC)) ~= AUXF_MAGIC_VALUE)))) {
        rfalse;
    }
    if ((struc-->(AUXF_BINARY))) {
        (usage = fileusage_BinaryMode);
    } else {
        (usage = fileusage_TextMode);
    }
    (fref = glk_fileref_create_by_name((fileusage_Data + usage), Glulx_ChangeAnyToCString((struc-->(AUXF_FILENAME))), 0));
    if ((glk_fileref_does_file_exist(fref) == 0)) {
        glk_fileref_destroy(fref);
        rfalse;
    }
    (str = glk_stream_open_file(fref, filemode_Read, 0));
    (ch = glk_get_char_stream(str));
    glk_stream_close(str, 0);
    glk_fileref_destroy(fref);
    if ((ch ~= 42)) {
        rfalse;
    }
    rtrue;
];
[ FileIO_MarkReady extf readiness struc fref str ch usage;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to open a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((((struc == 0)) || (((struc-->(AUXF_MAGIC)) ~= AUXF_MAGIC_VALUE)))) {
        rfalse;
    }
    if ((struc-->(AUXF_BINARY))) {
        (usage = fileusage_BinaryMode);
    } else {
        (usage = fileusage_TextMode);
    }
    (fref = glk_fileref_create_by_name((fileusage_Data + usage), Glulx_ChangeAnyToCString((struc-->(AUXF_FILENAME))), 0));
    if ((glk_fileref_does_file_exist(fref) == 0)) {
        glk_fileref_destroy(fref);
        return FileIO_Error(extf, "only existing files can be marked");
    }
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_CLOSED)) {
        glk_fileref_destroy(fref);
        return FileIO_Error(extf, "only closed files can be marked");
    }
    (str = glk_stream_open_file(fref, filemode_ReadWrite, 0));
    glk_stream_set_position(str, 0, 0);
    if (readiness) {
        (ch = 42);
    } else {
        (ch = 45);
    }
    glk_put_char_stream(str, ch);
    glk_stream_close(str, 0);
    glk_fileref_destroy(fref);
];
[ FileIO_Open extf write_flag append_flag struc fref str mode ix ch not_this_ifid owner force_header usage;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to open a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((((struc == 0)) || (((struc-->(AUXF_MAGIC)) ~= AUXF_MAGIC_VALUE)))) {
        rfalse;
    }
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_CLOSED)) {
        return FileIO_Error(extf, "tried to open a file already open");
    }
    if ((struc-->(AUXF_BINARY))) {
        (usage = fileusage_BinaryMode);
    } else {
        (usage = fileusage_TextMode);
    }
    (fref = glk_fileref_create_by_name((fileusage_Data + usage), Glulx_ChangeAnyToCString((struc-->(AUXF_FILENAME))), 0));
    if (write_flag) {
        if (append_flag) {
            (mode = filemode_WriteAppend);
            if ((glk_fileref_does_file_exist(fref) == 0)) {
                (force_header = 1);
            }
        } else {
            (mode = filemode_Write);
        }
    } else {
        (mode = filemode_Read);
        if ((glk_fileref_does_file_exist(fref) == 0)) {
            glk_fileref_destroy(fref);
            return FileIO_Error(extf, "tried to open a file which does not exist");
        }
    }
    (str = glk_stream_open_file(fref, mode, 0));
    glk_fileref_destroy(fref);
    if ((str == 0)) {
        return FileIO_Error(extf, "tried to open a file but failed");
    }
    ((struc-->(AUXF_STREAM)) = str);
    if (write_flag) {
        if (append_flag) {
            ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_OPEN_FOR_APPEND);
        } else {
            ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_OPEN_FOR_WRITE);
        }
        glk_stream_set_current(str);
        if ((((append_flag == 0)) || (force_header))) {
            print "- ";
            for ((ix = 6):(ix <= (UUID_ARRAY->(0))):(ix)++) {
                print (char) (UUID_ARRAY->(ix));
            }
            print " ";
            print (string) (struc-->(AUXF_FILENAME));
            print "^";
        }
    } else {
        ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_OPEN_FOR_READ);
        (ch = FileIO_GetC(extf));
        if ((ch ~= 45 or 42)) {
            jump BadFile;
        }
        if ((ch == 45)) {
            return FileIO_Error(extf, "tried to open a file which was incomplete");
        }
        (ch = FileIO_GetC(extf));
        if ((ch ~= 32)) {
            jump BadFile;
        }
        (ch = FileIO_GetC(extf));
        if ((ch ~= 47)) {
            jump BadFile;
        }
        (ch = FileIO_GetC(extf));
        if ((ch ~= 47)) {
            jump BadFile;
        }
        (owner = (struc-->(AUXF_IFID_OF_OWNER)));
        (ix = 3);
        if ((owner == UUID_ARRAY)) {
            (ix = 8);
        }
        if ((owner ~= NULL)) {
            for (:(ix <= (owner->(0))):(ix)++) {
                (ch = FileIO_GetC(extf));
                if ((ch == -1)) {
                    jump BadFile;
                }
                if ((ch ~= (owner->(ix)))) {
                    (not_this_ifid = 1);
                }
                if ((ch == 32)) {
                    break;
                }
            }
            if ((not_this_ifid == 0)) {
                (ch = FileIO_GetC(extf));
                if ((ch ~= 32)) {
                    jump BadFile;
                }
            }
        }
        while ((ch ~= -1)) {
            (ch = FileIO_GetC(extf));
            if ((ch == 10 or 13)) {
                break;
            }
        }
        if (not_this_ifid) {
            ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_CLOSED);
            glk_stream_close(str, 0);
            return FileIO_Error(extf, "tried to open a file owned by another project");
        }
    }
    return (struc-->(AUXF_STREAM));
    .BadFile;
    ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_CLOSED);
    glk_stream_close(str, 0);
    return FileIO_Error(extf, "tried to open a file which seems to be malformed");
];
[ FileIO_Close extf struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to open a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_OPEN_FOR_READ or AUXF_STATUS_IS_OPEN_FOR_WRITE or AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
        return FileIO_Error(extf, "tried to close a file which is not open");
    }
    if (((struc-->(AUXF_STATUS)) == AUXF_STATUS_IS_OPEN_FOR_WRITE or AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
        glk_stream_set_position((struc-->(AUXF_STREAM)), 0, 0);
        glk_put_char_stream((struc-->(AUXF_STREAM)), 42);
    }
    glk_stream_close((struc-->(AUXF_STREAM)), 0);
    ((struc-->(AUXF_STATUS)) = AUXF_STATUS_IS_CLOSED);
];
[ FileIO_GetC extf struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return (-(1));
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_OPEN_FOR_READ)) {
        return (-(1));
    }
    return glk_get_char_stream((struc-->(AUXF_STREAM)));
];
[ FileIO_PutC extf char struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to write to a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if (((struc-->(AUXF_STATUS)) ~= AUXF_STATUS_IS_OPEN_FOR_WRITE or AUXF_STATUS_IS_OPEN_FOR_APPEND)) {
        return FileIO_Error(extf, "tried to write to a file which is not open for writing");
    }
    return glk_put_char_stream((struc-->(AUXF_STREAM)), char);
];
[ FileIO_PrintLine extf ch struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to write to a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    for (:1:) {
        (ch = FileIO_GetC(extf));
        if ((ch == -1)) {
            rfalse;
        }
        if ((ch == 10 or 13)) {
            print "^";
            rtrue;
        }
        print (char) ch;
    }
];
[ FileIO_PrintContents extf tab struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to access a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((struc-->(AUXF_BINARY))) {
        return FileIO_Error(extf, "printing text will not work with binary files");
    }
    if ((FileIO_Open(extf, 0) == 0)) {
        rfalse;
    }
    while (FileIO_PrintLine(extf)) {
    }
    FileIO_Close(extf);
    rtrue;
];
[ FileIO_PutContents extf text append_flag struc str ch oldstream;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to access a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((struc-->(AUXF_BINARY))) {
        return FileIO_Error(extf, "writing text will not work with binary files");
    }
    (oldstream = glk_stream_get_current());
    (str = FileIO_Open(extf, 1, append_flag));
    if ((str == 0)) {
        rfalse;
    }
    @push say__p;
    @push say__pc;
    ClearParagraphing(19);
    TEXT_TY_Say(text);
    FileIO_Close(extf);
    if (oldstream) {
        glk_stream_set_current(oldstream);
    }
    @pull say__pc;
    @pull say__p;
    rfalse;
];
[ FileIO_PutTable extf tab rv struc oldstream;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to write table to a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((struc-->(AUXF_BINARY))) {
        return FileIO_Error(extf, "writing a table will not work with binary files");
    }
    (oldstream = glk_stream_get_current());
    if ((FileIO_Open(extf, 1) == 0)) {
        rfalse;
    }
    (rv = TablePrint(tab));
    FileIO_Close(extf);
    if (oldstream) {
        glk_stream_set_current(oldstream);
    }
    if (rv) {
        return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
    }
    rtrue;
];
[ FileIO_GetTable extf tab struc;
    if ((((extf < 1)) || ((extf > NO_EXTERNAL_FILES)))) {
        return FileIO_Error(extf, "tried to read table from a non-file");
    }
    (struc = (TableOfExternalFiles-->(extf)));
    if ((struc-->(AUXF_BINARY))) {
        return FileIO_Error(extf, "reading a table will not work with binary files");
    }
    if ((FileIO_Open(extf, 0) == 0)) {
        rfalse;
    }
    TableRead(tab, extf);
    FileIO_Close(extf);
    rtrue;
];
[ SetSortDomain swapf compf;
    (I7S_Swap = swapf);
    (I7S_Comp = compf);
];
[ SortArray tab col dir size algorithm;
    (I7S_Tab = tab);
    (I7S_Col = col);
    (I7S_Dir = dir);
    SortRange(0, size, algorithm);
];
[ SortRange x y algorithm;
    if (((y - x) < 2)) {
        rtrue;
    }
    if (algorithm) {
        (algorithm)(x,y);
    } else {
        InPlaceMergeSortAlgorithm(x, y);
    }
];
[ CompareFields x y;
    return (I7S_Dir*(I7S_Comp)(I7S_Tab,I7S_Col,(x + 1),(y + 1),I7S_Dir));
];
[ ExchangeFields x y r;
    (r = (I7S_Swap)(I7S_Tab,(x + 1),(y + 1)));
    return r;
];
[ OldSortAlgorithm x y f i j;
    if (((y - x) < 2)) {
        rtrue;
    }
    (f = 1);
    while (f) {
        (f = 0);
        for ((i = x):(i < y):(i)++) {
            for ((j = (i + 1)):(j < y):(j)++) {
                if ((CompareFields(i, j) > 0)) {
                    ExchangeFields(i, j);
                    (f = 1);
                    break;
                }
            }
        }
    }
];
[ InsertionSortAlgorithm from to i j;
    if ((to > (from + 1))) {
        for ((i = (from + 1)):(i < to):(i)++) {
            for ((j = i):(j > from):(j)--) {
                if ((CompareFields(j, (j - 1)) < 0)) {
                    ExchangeFields(j, (j - 1));
                } else {
                    break;
                }
            }
        }
    }
];
[ InPlaceMergeSortAlgorithm from to middle;
    if (((to - from) < 12)) {
        if (((to - from) < 2)) {
            rtrue;
        }
        InsertionSortAlgorithm(from, to);
        rtrue;
    }
    (middle = ((from + to)/2));
    InPlaceMergeSortAlgorithm(from, middle);
    InPlaceMergeSortAlgorithm(middle, to);
    IPMS_Merge(from, middle, to, (middle - from), (to - middle));
];
[ IPMS_Lower from to val len half mid;
    (len = (to - from));
    while ((len > 0)) {
        (half = (len/2));
        (mid = (from + half));
        if ((CompareFields(mid, val) < 0)) {
            (from = (mid + 1));
            (len = ((len - half) - 1));
        } else {
            (len = half);
        }
    }
    return from;
];
[ IPMS_Upper from to val len half mid;
    (len = (to - from));
    while ((len > 0)) {
        (half = (len/2));
        (mid = (from + half));
        if ((CompareFields(val, mid) < 0)) {
            (len = half);
        } else {
            (from = (mid + 1));
            (len = ((len - half) - 1));
        }
    }
    return from;
];
[ IPMS_Reverse from to;
    while ((from < to)) {
        ExchangeFields((from)++, (to)--);
    }
];
[ IPMS_Rotate from mid to n val shift p1 p2;
    if ((((from == mid)) || ((mid == to)))) {
        rtrue;
    }
    IPMS_Reverse(from, (mid - 1));
    IPMS_Reverse(mid, (to - 1));
    IPMS_Reverse(from, (to - 1));
];
[ IPMS_Merge from pivot to len1 len2 first_cut second_cut len11 len22 new_mid;
    if ((((len1 == 0)) || ((len2 == 0)))) {
        rtrue;
    }
    if (((len1 + len2) == 2)) {
        if ((CompareFields(pivot, from) < 0)) {
            ExchangeFields(pivot, from);
        }
        rtrue;
    }
    if ((len1 > len2)) {
        (len11 = (len1/2));
        (first_cut = (from + len11));
        (second_cut = IPMS_Lower(pivot, to, first_cut));
        (len22 = (second_cut - pivot));
    } else {
        (len22 = (len2/2));
        (second_cut = (pivot + len22));
        (first_cut = IPMS_Upper(from, pivot, second_cut));
        (len11 = (first_cut - from));
    }
    IPMS_Rotate(first_cut, pivot, second_cut);
    (new_mid = (first_cut + len22));
    IPMS_Merge(from, first_cut, new_mid, len11, len22);
    IPMS_Merge(new_mid, second_cut, to, (len1 - len11), (len2 - len22));
];
[ TableFindCol tab col f i no_cols n;
    (no_cols = (tab-->(0)));
    for ((i = 1):(i <= no_cols):(i)++) {
        if ((col == ((((tab-->(i))-->(1)))&(TB_COLUMN_NUMBER)))) {
            return i;
        }
    }
    if (f) {
        RunTimeProblem(RTP_TABLE_NOCOL, tab);
        rfalse;
    }
    rfalse;
];
[ TableRows tab first_col;
    (first_col = (tab-->(1)));
    if ((first_col == 0)) {
        rfalse;
    }
    return ((first_col-->(0)) - COL_HSIZE);
];
[ CheckTableEntryIsBlank tab col row i at;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    if ((((tab-->(col))-->((row + COL_HSIZE))) ~= TABLE_NOVALUE)) {
        print "*** CTEIB on nonblank value ";
        print tab;
        print " ";
        print col;
        print " ";
        print row;
        print " ***^";
    }
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (row)--;
    (at = (((tab-->(col))-->(2)) + (row/8)));
    if ((((TB_Blanks->(at)))&((CheckTableEntryIsBlank_LU->((row%8)))))) {
        rtrue;
    }
    rfalse;
];
[ ForceTableEntryBlank tab col row i at oldv flags;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    (flags = ((tab-->(col))-->(1)));
    (oldv = ((tab-->(col))-->((row + COL_HSIZE))));
    if (((((flags)&(TB_COLUMN_ALLOCATED))) && ((oldv ~= 0 or TABLE_NOVALUE)))) {
        BlkValueFree(oldv);
    }
    (((tab-->(col))-->((row + COL_HSIZE))) = TABLE_NOVALUE);
    if (((flags)&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (row)--;
    (at = (((tab-->(col))-->(2)) + (row/8)));
    ((TB_Blanks->(at)) = (((TB_Blanks->(at)))|((CheckTableEntryIsBlank_LU->((row%8))))));
];
[ ForceTableEntryNonBlank tab col row i at oldv flags tc kov;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (flags = ((tab-->(col))-->(1)));
    (oldv = ((tab-->(col))-->((row + COL_HSIZE))));
    if (((((flags)&(TB_COLUMN_ALLOCATED))) && ((oldv == 0 or TABLE_NOVALUE)))) {
        (kov = UNKNOWN_TY);
        (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
        (kov = TC_KOV(tc));
        if ((kov ~= UNKNOWN_TY)) {
            (((tab-->(col))-->((row + COL_HSIZE))) = BlkValueCreate(kov));
        }
    }
    (row)--;
    (at = (((tab-->(col))-->(2)) + (row/8)));
    ((TB_Blanks->(at)) = (((TB_Blanks->(at)))&((CheckTableEntryIsNonBlank_LU->((row%8))))));
];
[ TableSwapBlankBits tab row1 row2 col at1 at2 bit1 bit2;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (row1)--;
    (at1 = (((tab-->(col))-->(2)) + (row1/8)));
    (row2)--;
    (at2 = (((tab-->(col))-->(2)) + (row2/8)));
    (bit1 = (((TB_Blanks->(at1)))&((CheckTableEntryIsBlank_LU->((row1%8))))));
    (bit2 = (((TB_Blanks->(at2)))&((CheckTableEntryIsBlank_LU->((row2%8))))));
    if (bit1) {
        (bit1 = 1);
    }
    if (bit2) {
        (bit2 = 1);
    }
    if ((bit1 == bit2)) {
        rtrue;
    }
    if (bit1) {
        ((TB_Blanks->(at1)) = (((TB_Blanks->(at1)))&((CheckTableEntryIsNonBlank_LU->((row1%8))))));
        ((TB_Blanks->(at2)) = (((TB_Blanks->(at2)))|((CheckTableEntryIsBlank_LU->((row2%8))))));
    } else {
        ((TB_Blanks->(at1)) = (((TB_Blanks->(at1)))|((CheckTableEntryIsBlank_LU->((row1%8))))));
        ((TB_Blanks->(at2)) = (((TB_Blanks->(at2)))&((CheckTableEntryIsNonBlank_LU->((row2%8))))));
    }
];
[ TableMoveBlankBitsDown tab row1 row2 col at atp1 bit rx;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rtrue;
    }
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_NOBLANKBITS))) {
        rtrue;
    }
    (row1)--;
    (row2)--;
    (at = (((tab-->(col))-->(2)) + (row1/8)));
    (bit = (((TB_Blanks->(at)))&((CheckTableEntryIsBlank_LU->((row1%8))))));
    if (bit) {
        (bit = 1);
    }
    for ((rx = row1):(rx < row2):(rx)++) {
        (atp1 = (((tab-->(col))-->(2)) + ((rx + 1)/8)));
        (at = (((tab-->(col))-->(2)) + (rx/8)));
        if ((((TB_Blanks->(atp1)))&((CheckTableEntryIsBlank_LU->(((rx + 1)%8)))))) {
            ((TB_Blanks->(at)) = (((TB_Blanks->(at)))|((CheckTableEntryIsBlank_LU->((rx%8))))));
        } else {
            ((TB_Blanks->(at)) = (((TB_Blanks->(at)))&((CheckTableEntryIsNonBlank_LU->((rx%8))))));
        }
    }
    (at = (((tab-->(col))-->(2)) + (row2/8)));
    if (bit) {
        ((TB_Blanks->(at)) = (((TB_Blanks->(at)))|((CheckTableEntryIsBlank_LU->((row2%8))))));
    } else {
        ((TB_Blanks->(at)) = (((TB_Blanks->(at)))&((CheckTableEntryIsNonBlank_LU->((row2%8))))));
    }
];
[ TableRowCorr tab col lookup_value lookup_col i j f v;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 1));
    }
    (lookup_col = (tab-->(col)));
    (j = ((lookup_col-->(0)) - COL_HSIZE));
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED))) {
        (f = 1);
    }
    if (f) {
        for ((i = 1):(i <= j):(i)++) {
            (v = (lookup_col-->((i + COL_HSIZE))));
            if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
                continue;
            }
            if ((BlkValueCompare(v, lookup_value) == 0)) {
                return i;
            }
        }
    } else {
        for ((i = 1):(i <= j):(i)++) {
            if ((((lookup_value == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
                continue;
            }
            if (((lookup_col-->((i + COL_HSIZE))) == lookup_value)) {
                return i;
            }
        }
    }
    return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];
[ ExistsTableRowCorr tab col entry i k v f kov;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rfalse;
    }
    (f = 0);
    if (((((tab-->(col))-->(1)))&(TB_COLUMN_TOPIC))) {
        (f = 1);
    } else {
        if (((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED))) {
            (f = 2);
        }
    }
    (k = TableRows(tab));
    for ((i = 1):(i <= k):(i)++) {
        (v = ((tab-->(col))-->((i + COL_HSIZE))));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
            continue;
        }
        switch (f) {
            1:
                if (((v)((entry/100),(entry%100)) ~= GPR_FAIL)) {
                    return i;
                }
                ;
            2:
                if ((BlkValueCompare(v, entry) == 0)) {
                    return i;
                }
                ;
            default:
                if ((v == entry)) {
                    return i;
                }
                ;
        }
    }
    rfalse;
];
[ TableLookUpCorr tab col1 col2 lookup_value write_flag write_value cola1 cola2 i j v f;
    if ((col1 >= 100)) {
        (col1 = TableFindCol(tab, col1, 1));
    }
    if ((col2 >= 100)) {
        (col2 = TableFindCol(tab, col2, 1));
    }
    (cola1 = (tab-->(col1)));
    (cola2 = (tab-->(col2)));
    (j = (cola2-->(0)));
    (f = 0);
    if (((((tab-->(col2))-->(1)))&(TB_COLUMN_ALLOCATED))) {
        (f = 1);
    }
    if (((((tab-->(col2))-->(1)))&(TB_COLUMN_TOPIC))) {
        (f = 2);
    }
    for ((i = (1 + COL_HSIZE)):(i <= j):(i)++) {
        (v = (cola2-->(i)));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col2, (i - COL_HSIZE))))) {
            continue;
        }
        if ((f == 1)) {
            if ((BlkValueCompare(v, lookup_value) ~= 0)) {
                continue;
            }
        } else {
            if ((f == 2)) {
                if (((v)((lookup_value/100),(lookup_value%100)) == GPR_FAIL)) {
                    continue;
                }
            } else {
                if ((v ~= lookup_value)) {
                    continue;
                }
            }
        }
        if (write_flag) {
            if ((write_flag == 4)) {
                ForceTableEntryBlank(tab, col1, (i - COL_HSIZE));
            } else {
                ForceTableEntryNonBlank(tab, col1, (i - COL_HSIZE));
            }
            switch (write_flag) {
                1:
                    ((cola1-->(i)) = write_value);
                    ;
                2:
                    ((cola1-->(i)) = ((cola1-->(i)) + write_value));
                    ;
                3:
                    ((cola1-->(i)) = ((cola1-->(i)) - write_value));
                    ;
                5:
                    return (cola1-->(i));
                    ;
            }
            rfalse;
        }
        (v = (cola1-->(i)));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col1, (i - COL_HSIZE))))) {
            continue;
        }
        return v;
    }
    return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];
[ ExistsTableLookUpCorr tab col1 col2 lookup_value cola1 cola2 i j f;
    if ((col1 >= 100)) {
        (col1 = TableFindCol(tab, col1, 0));
    }
    if ((col2 >= 100)) {
        (col2 = TableFindCol(tab, col2, 0));
    }
    if (((col1*col2) == 0)) {
        rfalse;
    }
    (cola1 = (tab-->(col1)));
    (cola2 = (tab-->(col2)));
    (j = (cola2-->(0)));
    (f = 0);
    if (((((tab-->(col2))-->(1)))&(TB_COLUMN_ALLOCATED))) {
        (f = 1);
    }
    if (((((tab-->(col2))-->(1)))&(TB_COLUMN_TOPIC))) {
        (f = 2);
    }
    for ((i = (1 + COL_HSIZE)):(i <= j):(i)++) {
        if (((((cola1-->(i)) == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col1, (i - COL_HSIZE))))) {
            continue;
        }
        if ((f == 1)) {
            if ((BlkValueCompare((cola2-->(i)), lookup_value) ~= 0)) {
                continue;
            }
        } else {
            if ((f == 2)) {
                if ((((cola2-->(i)))((lookup_value/100),(lookup_value%100)) == GPR_FAIL)) {
                    continue;
                }
            } else {
                if (((cola2-->(i)) ~= lookup_value)) {
                    continue;
                }
            }
        }
        rtrue;
    }
    rfalse;
];
[ TableLookUpEntry tab col index write_flag write_value v;
    if ((tab == 0)) {
        return RunTimeProblem(RTP_TABLE_NOTABLE2);
    }
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 1));
    }
    if ((((index < 1)) || ((index > TableRows(tab))))) {
        RunTimeProblem(RTP_TABLE_NOROW, tab, index);
        (index = 1);
    }
    if (write_flag) {
        switch (write_flag) {
            1:
                ForceTableEntryNonBlank(tab, col, index);
                (((tab-->(col))-->((index + COL_HSIZE))) = write_value);
                ;
            2:
                ForceTableEntryNonBlank(tab, col, index);
                (((tab-->(col))-->((index + COL_HSIZE))) = (((tab-->(col))-->((index + COL_HSIZE))) + write_value));
                ;
            3:
                ForceTableEntryNonBlank(tab, col, index);
                (((tab-->(col))-->((index + COL_HSIZE))) = (((tab-->(col))-->((index + COL_HSIZE))) - write_value));
                ;
            4:
                ForceTableEntryBlank(tab, col, index);
                ;
            5:
                ForceTableEntryNonBlank(tab, col, index);
                return ((tab-->(col))-->((index + COL_HSIZE)));
                ;
        }
        rfalse;
    }
    (v = ((tab-->(col))-->((index + COL_HSIZE))));
    if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, index)))) {
        RunTimeProblem(RTP_TABLE_NOENTRY, tab, col, index);
        rfalse;
    }
    return v;
];
[ ExistsTableLookUpEntry tab col index v;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col));
    }
    if ((col == 0)) {
        rfalse;
    }
    if ((((index < 1)) || ((index > TableRows(tab))))) {
        rfalse;
    }
    (v = ((tab-->(col))-->((index + COL_HSIZE))));
    if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, index)))) {
        rfalse;
    }
    rtrue;
];
[ TableRowIsBlank tab j k;
    for ((k = 1):(k <= (tab-->(0))):(k)++) {
        if ((((tab-->(k))-->((j + COL_HSIZE))) ~= TABLE_NOVALUE)) {
            rfalse;
        }
        if ((CheckTableEntryIsBlank(tab, k, j) == 0)) {
            rfalse;
        }
    }
    rtrue;
];
[ TableBlankOutRow tab row k;
    if ((tab == 0)) {
        return RunTimeProblem(RTP_TABLE_NOTABLE);
    }
    for ((k = 1):(k <= (tab-->(0))):(k)++) {
        ForceTableEntryBlank(tab, k, row);
    }
];
[ TableBlankOutColumn tab col n k;
    if ((tab == 0)) {
        return RunTimeProblem(RTP_TABLE_NOTABLE);
    }
    (n = TableRows(tab));
    for ((k = 1):(k <= n):(k)++) {
        ForceTableEntryBlank(tab, col, k);
    }
];
[ TableBlankOutAll tab n k;
    if ((tab == 0)) {
        return RunTimeProblem(RTP_TABLE_NOTABLE);
    }
    (n = TableRows(tab));
    for ((k = 1):(k <= n):(k)++) {
        TableBlankOutRow(tab, k);
    }
];
[ TableBlankRows tab i j c;
    (i = TableRows(tab));
    for ((j = 1):(j <= i):(j)++) {
        if (TableRowIsBlank(tab, j)) {
            (c)++;
        }
    }
    return c;
];
[ TableFilledRows tab;
    return (TableRows(tab) - TableBlankRows(tab));
];
[ TableBlankRow tab i j;
    (i = TableRows(tab));
    for ((j = 1):(j <= i):(j)++) {
        if (TableRowIsBlank(tab, j)) {
            return j;
        }
    }
    RunTimeProblem(RTP_TABLE_NOMOREBLANKS, tab);
    return i;
];
[ TableRandomRow tab i j k;
    (i = TableRows(tab));
    (j = TableFilledRows(tab));
    if ((j == 0)) {
        return RunTimeProblem(RTP_TABLE_NOROWS, tab);
    }
    if ((j > 1)) {
        (j = random(j));
    }
    for ((k = 1):(k <= i):(k)++) {
        if ((TableRowIsBlank(tab, k) == 0)) {
            (j)--;
        }
        if ((j == 0)) {
            return k;
        }
    }
];
[ TableSwapRows tab i j k l v1 v2;
    if ((i == j)) {
        rtrue;
    }
    (l = (tab-->(0)));
    for ((k = 1):(k <= l):(k)++) {
        (v1 = ((tab-->(k))-->((i + COL_HSIZE))));
        (v2 = ((tab-->(k))-->((j + COL_HSIZE))));
        (((tab-->(k))-->((i + COL_HSIZE))) = v2);
        (((tab-->(k))-->((j + COL_HSIZE))) = v1);
        if ((((v1 == TABLE_NOVALUE)) || ((v2 == TABLE_NOVALUE)))) {
            TableSwapBlankBits(tab, i, j, k);
        }
    }
];
[ TableCompareRows tab col row1 row2 dir val1 val2 bl1 bl2 f;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 0));
    }
    (val1 = ((tab-->(col))-->((row1 + COL_HSIZE))));
    (val2 = ((tab-->(col))-->((row2 + COL_HSIZE))));
    if ((val1 == TABLE_NOVALUE)) {
        (bl1 = CheckTableEntryIsBlank(tab, col, row1));
    }
    if ((val2 == TABLE_NOVALUE)) {
        (bl2 = CheckTableEntryIsBlank(tab, col, row2));
    }
    if ((((val1 == val2)) && ((bl1 == bl2)))) {
        if ((val1 ~= TABLE_NOVALUE)) {
            rfalse;
        }
        if ((bl1 == 0)) {
            rfalse;
        }
        if (TableRowIsBlank(tab, row1)) {
            if (TableRowIsBlank(tab, row2)) {
                rfalse;
            }
            return (-(dir));
        }
        if (TableRowIsBlank(tab, row2)) {
            return dir;
        }
        rfalse;
    }
    if (bl1) {
        return dir;
    }
    if (bl2) {
        return (-(dir));
    }
    (f = ((tab-->(col))-->(1)));
    if (((f)&(TB_COLUMN_ALLOCATED))) {
        if ((BlkValueCompare(val2, val1) < 0)) {
            rtrue;
        }
        return (-(1));
    } else {
        if (((f)&(TB_COLUMN_REAL))) {
            if ((REAL_NUMBER_TY_Compare(val1, val2) > 0)) {
                rtrue;
            }
            return (-(1));
        } else {
            if (((f)&(TB_COLUMN_SIGNED))) {
                if ((val1 > val2)) {
                    rtrue;
                }
                return (-(1));
            } else {
                if ((UnsignedCompare(val1, val2) > 0)) {
                    rtrue;
                }
                return (-(1));
            }
        }
    }
];
[ TableMoveRowDown tab r1 r2 rx k l m v f;
    if ((r1 == r2)) {
        rtrue;
    }
    (l = (tab-->(0)));
    for ((k = 1):(k <= l):(k)++) {
        (f = 0);
        (m = ((tab-->(k))-->((r1 + COL_HSIZE))));
        if ((m == TABLE_NOVALUE)) {
            (f = 1);
        }
        for ((rx = r1):(rx < r2):(rx)++) {
            (v = ((tab-->(k))-->(((rx + COL_HSIZE) + 1))));
            (((tab-->(k))-->((rx + COL_HSIZE))) = v);
            if ((v == TABLE_NOVALUE)) {
                (f = 1);
            }
        }
        (((tab-->(k))-->((r2 + COL_HSIZE))) = m);
        if (f) {
            TableMoveBlankBitsDown(tab, r1, r2, k);
        }
    }
];
[ TableShuffle tab i to;
    TableMoveBlanksToBack(tab, 1, TableRows(tab));
    (to = TableFilledRows(tab));
    for ((i = 2):(i <= to):(i)++) {
        TableSwapRows(tab, i, random(i));
    }
];
[ TableNextRow tab col row dir i k val v dv min_dv min_at signed_arithmetic f blk z;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 0));
    }
    (f = ((tab-->(col))-->(1)));
    if (((f)&(TB_COLUMN_ALLOCATED))) {
        (blk = 1);
    }
    (signed_arithmetic = ((f)&(TB_COLUMN_SIGNED)));
    if ((row == 0)) {
        if (signed_arithmetic) {
            if ((dir == 1)) {
                (val = -2147483648);
            } else {
                (val = 2147483647);
            }
        } else {
            if ((dir == 1)) {
                (val = 0);
            } else {
                (val = -1);
            }
        }
    } else {
        (val = ((tab-->(col))-->((row + COL_HSIZE))));
    }
    if (signed_arithmetic) {
        (min_dv = 2147483647);
    } else {
        (min_dv = -1);
    }
    (k = TableRows(tab));
    if ((dir == 1)) {
        for ((i = 1):(i <= k):(i)++) {
            (v = ((tab-->(col))-->((i + COL_HSIZE))));
            if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
                continue;
            }
            if (blk) {
                (dv = v);
                if ((row == 0)) {
                    (z = 1);
                } else {
                    (z = BlkValueCompare(v, val));
                }
                (f = (((((z > 0)) || ((((z == 0)) && ((i > row)))))) && ((((min_at == 0)) || ((BlkValueCompare(v, min_dv) < 0))))));
            } else {
                (dv = (dir*v));
                if (signed_arithmetic) {
                    (f = (((((dv > (dir*val))) || ((((v == val)) && ((i > row)))))) && ((dv < min_dv))));
                } else {
                    (f = (((((UnsignedCompare(dv, (dir*val)) > 0)) || ((((v == val)) && ((i > row)))))) && ((UnsignedCompare(dv, min_dv) < 0))));
                }
            }
            if (f) {
                (min_dv = dv);
                (min_at = i);
            }
        }
    } else {
        for ((i = k):(i >= 1):(i)--) {
            (v = ((tab-->(col))-->((i + COL_HSIZE))));
            if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
                continue;
            }
            if (blk) {
                (dv = v);
                if ((row == 0)) {
                    (z = -1);
                } else {
                    (z = BlkValueCompare(v, val));
                }
                (f = (((((z < 0)) || ((((z == 0)) && ((i < row)))))) && ((((min_at == 0)) || ((BlkValueCompare(v, min_dv) > 0))))));
            } else {
                (dv = (dir*v));
                if (signed_arithmetic) {
                    (f = (((((dv > (dir*val))) || ((((v == val)) && ((i < row)))))) && ((dv < min_dv))));
                } else {
                    (f = (((((UnsignedCompare(dv, (dir*val)) > 0)) || ((((v == val)) && ((i < row)))))) && ((UnsignedCompare(dv, min_dv) < 0))));
                }
            }
            if (f) {
                (min_dv = dv);
                (min_at = i);
            }
        }
    }
    return min_at;
];
[ TableMoveBlanksToBack tab fromrow torow i fbl lnbl blc;
    if ((torow < fromrow)) {
        rtrue;
    }
    (fbl = 0);
    (lnbl = 0);
    for ((i = fromrow):(i <= torow):(i)++) {
        if (TableRowIsBlank(tab, i)) {
            if ((fbl == 0)) {
                (fbl = i);
            }
            (blc)++;
        } else {
            (lnbl = i);
        }
    }
    if ((((((fbl > 0)) && ((lnbl > 0)))) && ((fbl < lnbl)))) {
        TableMoveRowDown(tab, fbl, lnbl);
        TableMoveBlanksToBack(tab, fbl, (lnbl - 1));
    }
    return (torow - blc);
];
[ TableSort tab col dir algorithm i j k f;
    for ((i = 1):(i <= (tab-->(0))):(i)++) {
        (j = (tab-->(i)));
        if ((((j-->(1)))&(TB_COLUMN_DONTSORTME))) {
            return RunTimeProblem(RTP_TABLE_CANTSORT, tab);
        }
    }
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 0));
    }
    (k = TableRows(tab));
    (k = TableMoveBlanksToBack(tab, 1, k));
    SetSortDomain(TableSwapRows, TableCompareRows);
    SortArray(tab, col, dir, k, algorithm);
];
[ TablePrint tab i j k row col v tc kov;
    for ((i = 1):(i <= (tab-->(0))):(i)++) {
        (j = (tab-->(i)));
        if (((((j-->(1)))&(TB_COLUMN_CANEXCHANGE)) == 0)) {
            rtrue;
        }
    }
    (k = TableRows(tab));
    (k = TableMoveBlanksToBack(tab, 1, k));
    print "! ";
    PrintTableName(tab);
    print " (";
    print k;
    print ")^";
    for ((row = 1):(row <= k):(row)++) {
        for ((col = 1):(col <= (tab-->(0))):(col)++) {
            (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
            (kov = KindAtomic(TC_KOV(tc)));
            if ((kov == UNKNOWN_TY)) {
                (kov = NUMBER_TY);
            }
            (v = ((tab-->(col))-->((row + COL_HSIZE))));
            if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, row)))) {
                print "-- ";
            } else {
                if ((BlkValueWriteToFile(v, kov) == 0)) {
                    print v;
                }
                print " ";
            }
        }
        print "^";
    }
    rfalse;
];
[ TableRead tab auxf row maxrow col ch v sgn dg j tc kov;
    for ((col = 1):(col <= (tab-->(0))):(col)++) {
        (j = (tab-->(col)));
        if (((((j-->(1)))&(TB_COLUMN_CANEXCHANGE)) == 0)) {
            return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);
        }
    }
    (maxrow = TableRows(tab));
    for ((row = 1):(row <= maxrow):(row)++) {
        TableBlankOutRow(tab, row);
    }
    for ((row = 1):(row <= maxrow):(row)++) {
        (ch = FileIO_GetC(auxf));
        if ((ch == 33)) {
            while ((ch ~= -1 or 10 or 13)) {
                (ch = FileIO_GetC(auxf));
            }
            while ((ch == 10 or 13)) {
                (ch = FileIO_GetC(auxf));
            }
        }
        for ((col = 1):(col <= (tab-->(0))):(col)++) {
            if ((ch == -1)) {
                (row)++;
                jump NoMore;
            }
            if ((ch == 10 or 13)) {
                break;
            }
            (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
            (kov = KindAtomic(TC_KOV(tc)));
            if ((kov == UNKNOWN_TY)) {
                (kov = NUMBER_TY);
            }
            (sgn = 1);
            if ((ch == 45)) {
                (ch = FileIO_GetC(auxf));
                if ((ch == -1)) {
                    jump NotTable;
                }
                if ((ch == 45)) {
                    (ch = FileIO_GetC(auxf));
                    jump EntryDone;
                }
                (sgn = -1);
            }
            if (((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED))) {
                ForceTableEntryNonBlank(tab, col, row);
            }
            (v = BlkValueReadFromFile(0, 0, (-(1)), kov));
            if (v) {
                if (((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED))) {
                    (v = BlkValueReadFromFile(TableLookUpEntry(tab, col, row), auxf, ch, kov));
                } else {
                    (v = BlkValueReadFromFile(0, auxf, ch, kov));
                }
                (ch = 32);
            } else {
                (dg = (ch - 48));
                if ((((dg < 0)) || ((dg > 9)))) {
                    jump NotTable;
                }
                (v = dg);
                for (:1:) {
                    (ch = FileIO_GetC(auxf));
                    (dg = (ch - 48));
                    if ((((dg < 0)) || ((dg > 9)))) {
                        break;
                    }
                    (v = ((10*v) + dg));
                }
                (v = (v*sgn));
            }
            if ((((((tab-->(col))-->(1)))&(TB_COLUMN_ALLOCATED)) == 0)) {
                TableLookUpEntry(tab, col, row, 1, v);
            }
            .EntryDone;
            while ((ch == 9 or 32)) {
                (ch = FileIO_GetC(auxf));
            }
        }
        while ((ch ~= -1 or 10 or 13)) {
            if ((((ch ~= 45)) && (((((ch - 48) < 0)) || (((ch - 48) > 9)))))) {
                jump NotTable;
            }
            if ((ch ~= 9 or 32)) {
                jump WontFit;
            }
            (ch = FileIO_GetC(auxf));
        }
    }
    .NoMore;
    while ((ch == 9 or 32 or 10 or 13)) {
        (ch = FileIO_GetC(auxf));
    }
    if ((ch == -1)) {
        rtrue;
    }
    .WontFit;
    return RunTimeProblem(RTP_TABLE_WONTFIT, tab);
    .NotTable;
    return RunTimeProblem(RTP_TABLE_BADFILE, tab);
];
[ TableColumnDebug tab col k i v tc kov;
    if ((col >= 100)) {
        (col = TableFindCol(tab, col, 0));
    }
    (k = TableRows(tab));
    (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
    (kov = TC_KOV(tc));
    for ((i = 1):(i <= k):(i)++) {
        if ((i > 1)) {
            print ", ";
        }
        (v = ((tab-->(col))-->((i + COL_HSIZE))));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
            print "--";
        } else {
            PrintKindValuePair(kov, v);
        }
    }
    (say__p = 1);
];
[ TableRowDebug tab i col k v tc kov;
    (k = TableRows(tab));
    if ((((i < 1)) || ((i > k)))) {
        print "No such row";
        new_line;
        rtrue;
    }
    print "(row ";
    print i;
    print ")  |";
    for ((col = 1):(col <= (tab-->(0))):(col)++) {
        print " ";
        (tc = ((((tab-->(col))-->(1)))&(TB_COLUMN_NUMBER)));
        (kov = TC_KOV(tc));
        (v = ((tab-->(col))-->((i + COL_HSIZE))));
        if ((((v == TABLE_NOVALUE)) && (CheckTableEntryIsBlank(tab, col, i)))) {
            print "-- ";
        } else {
            PrintKindValuePair(kov, v);
            print " |";
        }
    }
    (say__p = 1);
];
[ TableDebug tab i k;
    PrintTableName(tab);
    print "^";
    (k = TableRows(tab));
    for ((i = 1):(i <= k):(i)++) {
        TableRowDebug(tab, i);
        print "^";
    }
];
[ Mstack_Create_Frame creator id extent;
    if ((creator == 0)) {
        rfalse;
    }
    (extent = (creator)((MStack_Top + 2),1));
    if ((extent == 0)) {
        rfalse;
    }
    if (((MStack_Top + MAX_MSTACK_FRAME) >= (MSTACK_SIZE + 2))) {
        RunTimeProblem(RTP_MSTACKMEMORY, MSTACK_SIZE);
        Mstack_Backtrace();
        rfalse;
    }
    (MStack_Top)++;
    ((MStack-->(MStack_Top)) = id);
    (MStack_Top)++;
    (MStack_Top = (MStack_Top + extent));
    ((MStack-->(MStack_Top)) = (-((extent + 2))));
    rtrue;
];
[ Mstack_Destroy_Frame creator id pos;
    (pos = Mstack_Seek_Frame(id));
    if ((pos == 0)) {
        rfalse;
    }
    (MStack_Top = (pos - 2));
    if (creator) {
        (creator)(pos,(-(1)));
    }
    rtrue;
];
[ Mstack_Seek_Frame id pos;
    (pos = MStack_Top);
    while ((((pos > 0)) && (((MStack-->(pos)) ~= 0)))) {
        (MStack_Frame_Extent = (MStack-->(pos)));
        (pos = (pos + MStack_Frame_Extent));
        (MStack_Frame_Extent = (-2 - MStack_Frame_Extent));
        if (((MStack-->((pos + 1))) == id)) {
            return (pos + 2);
        }
    }
    (MStack_Frame_Extent = 0);
    rfalse;
];
[ Mstack_Backtrace pos k;
    print "Mstack backtrace: size ";
    print (MStack_Top + 1);
    print " words^";
    (pos = MStack_Top);
    while (((MStack-->(pos)) ~= 0)) {
        (MStack_Frame_Extent = (MStack-->(pos)));
        (pos = (pos + MStack_Frame_Extent));
        (MStack_Frame_Extent = (-2 - MStack_Frame_Extent));
        print "Block at ";
        print (pos + 2);
        print " owner ID ";
        print (MStack-->((pos + 1)));
        print " size ";
        print MStack_Frame_Extent;
        print "^";
        for ((k = 0):(k < MStack_Frame_Extent):(k)++) {
            print (MStack-->(((pos + 2) + k)));
            print " ";
        }
        print "^";
    }
];
[ MstVO id off pos;
    (pos = Mstack_Seek_Frame(id));
    if ((pos == 0)) {
        print "Variable unavailable for this action, activity or rulebook: ";
        print "internal ID number ";
        print id;
        print "/";
        print off;
        print "^";
        rfalse;
    }
    if ((((off < 0)) || ((off >= MStack_Frame_Extent)))) {
        print "Variable stack offset wrong: ";
        print id;
        print "/";
        print off;
        print " at ";
        print pos;
        print "^";
        rfalse;
    }
    return (pos + off);
];
[ MstVON id off pos;
    (pos = Mstack_Seek_Frame(id));
    if ((pos == 0)) {
        rfalse;
    }
    if ((((off < 0)) || ((off >= MStack_Frame_Extent)))) {
        print "Variable stack offset wrong: ";
        print id;
        print "/";
        print off;
        print " at ";
        print pos;
        print "^";
        rfalse;
    }
    return (pos + off);
];
[ MStack_CreateRBVars rb cr;
    (cr = MStack_GetRBVarCreator(rb));
    if (cr) {
        Mstack_Create_Frame(cr, rb);
    }
];
[ MStack_DestroyRBVars rb cr;
    (cr = MStack_GetRBVarCreator(rb));
    if (cr) {
        Mstack_Destroy_Frame(cr, rb);
    }
];
[ MStack_CreateAVVars av cr;
    (cr = (activity_var_creators-->(av)));
    if ((cr == 0)) {
        rtrue;
    }
    Mstack_Create_Frame(cr, (av + 10000));
];
[ MStack_DestroyAVVars av cr;
    (cr = (activity_var_creators-->(av)));
    if ((cr == 0)) {
        rtrue;
    }
    Mstack_Destroy_Frame(cr, (av + 10000));
];
[ RecordRuleOutcome usage strong_kind val;
    if (((((latest_rule_result-->(0)) == RS_SUCCEEDS or RS_FAILS)) && (KOVIsBlockValue((latest_rule_result-->(1)))))) {
        BlkValueFree((latest_rule_result-->(2)));
    }
    if ((((usage == RS_SUCCEEDS or RS_FAILS)) && (KOVIsBlockValue(strong_kind)))) {
        (val = BlkValueCopy(BlkValueCreate(strong_kind), val));
    }
    ((latest_rule_result-->(0)) = usage);
    ((latest_rule_result-->(1)) = strong_kind);
    ((latest_rule_result-->(2)) = val);
];
[ FollowRulebook rulebook parameter no_paragraph_skips rv ss spv;
    (ss = self);
    if (((((Protect_I7_Arrays-->(0)) ~= 16339)) || (((Protect_I7_Arrays-->(1)) ~= 12345)))) {
        print "^^*** Fatal programming error: I7 arrays corrupted ***^^";
        @quit;
    }
    if (parameter) {
        (self = parameter);
        (parameter_object = parameter);
    }
    (spv = parameter_value);
    (parameter_value = parameter);
    (parameter = debugging_rules);
    if (debugging_rules) {
        DebugRulebooks(rulebook, parameter);
        (process_rulebook_count = (process_rulebook_count + debugging_rules));
    }
    if ((((rulebook >= 0)) && ((rulebook < NUMBER_RULEBOOKS_CREATED)))) {
        (rv = (rulebooks_array-->(rulebook)));
        if ((rv ~= EMPTY_RULEBOOK)) {
            if ((rulebook ~= ACTION_PROCESSING_RB)) {
                MStack_CreateRBVars(rulebook);
            }
            if (say__p) {
                RulebookParBreak(no_paragraph_skips);
            }
            (rv = (rv)(no_paragraph_skips));
            if ((rulebook ~= ACTION_PROCESSING_RB)) {
                MStack_DestroyRBVars(rulebook);
            }
        } else {
            (rv = 0);
        }
    } else {
        if (say__p) {
            RulebookParBreak(no_paragraph_skips);
        }
        (rv = (rulebook)());
        if ((rv == 2)) {
            (rv = reason_the_action_failed);
        } else {
            if (rv) {
                (rv = rulebook);
            }
        }
    }
    if (rv) {
        if (debugging_rules) {
            (process_rulebook_count = (process_rulebook_count - debugging_rules));
            if ((process_rulebook_count < 0)) {
                (process_rulebook_count = 0);
            }
            spaces (2*process_rulebook_count);
            if (((latest_rule_result-->(0)) == RS_SUCCEEDS)) {
                print "[stopped: success]^";
            }
            if (((latest_rule_result-->(0)) == RS_FAILS)) {
                print "[stopped: fail]^";
            }
        }
    } else {
        if (debugging_rules) {
            (process_rulebook_count = (process_rulebook_count - debugging_rules));
        }
        ((latest_rule_result-->(0)) = RS_NEITHER);
    }
    (debugging_rules = parameter);
    (self = ss);
    (parameter_value = spv);
    return rv;
];
[ RulebookParBreak no_paragraph_skips;
    if ((((no_paragraph_skips == 0)) && ((((say__pc)&(PARA_NORULEBOOKBREAKS)) == 0)))) {
        DivideParagraphPoint();
    }
];
[ ActRulebookSucceeds rule_id;
    if (rule_id) {
        (reason_the_action_failed = rule_id);
    }
    RulebookSucceeds();
];
[ ActRulebookFails rule_id;
    if (rule_id) {
        (reason_the_action_failed = rule_id);
    }
    RulebookFails();
];
[ RulebookSucceeds strong_kind value;
    RecordRuleOutcome(RS_SUCCEEDS, strong_kind, value);
];
[ RulebookFails strong_kind value;
    RecordRuleOutcome(RS_FAILS, strong_kind, value);
];
[ RuleHasNoOutcome;
    RecordRuleOutcome(RS_NEITHER, 0, 0);
];
[ SetRulebookOutcome a;
    ((latest_rule_result-->(0)) = a);
];
[ RulebookOutcome a;
    (a = (latest_rule_result-->(0)));
    if ((((a == RS_FAILS)) || ((a == RS_SUCCEEDS)))) {
        return a;
    }
    return RS_NEITHER;
];
[ RulebookFailed;
    if (((latest_rule_result-->(0)) == RS_FAILS)) {
        rtrue;
    }
    rfalse;
];
[ RulebookSucceeded;
    if (((latest_rule_result-->(0)) == RS_SUCCEEDS)) {
        rtrue;
    }
    rfalse;
];
[ ResultOfRule RB V F K a;
    if (RB) {
        FollowRulebook(RB, V, F);
    }
    (a = (latest_rule_result-->(0)));
    if ((((a == RS_FAILS)) || ((a == RS_SUCCEEDS)))) {
        (a = (latest_rule_result-->(1)));
        if (a) {
            return (latest_rule_result-->(2));
        }
    }
    if (K) {
        return DefaultValueOfKOV(K);
    }
    rfalse;
];
[ RULEBOOK_TY_to_RULE_TY r;
    return r;
];
[ DebugRulebooks subs parameter i;
    spaces (2*process_rulebook_count);
    print "[";
    RulePrintingRule(subs);
    if (parameter) {
        print " / on O";
        print parameter;
    }
    print "]^";
];
[ DB_Rule R N blocked;
    if ((R == 0)) {
        rtrue;
    }
    print "[Rule ~";
    RulePrintingRule(R);
    print "~ ";
    if ((blocked == 0)) {
        print "applies.]";
        new_line;
        rtrue;
    }
    print "does not apply (wrong ";
    if ((blocked == 1)) {
        print "scene";
    }
    if ((blocked == 2)) {
        print "action";
    }
    if ((blocked == 3)) {
        print "actor";
    }
    if ((blocked == 4)) {
        print "context";
    }
    print ").]^";
];
[ LITTLE_USED_DO_NOTHING_R;
    rfalse;
];
[ EMPTY_RULEBOOK forbid_breaks;
    rfalse;
];
[ HeapInitialise n bsize blk2;
    (blk2 = (Flex_Heap + BLK_DATA_MULTI_OFFSET));
    ((Flex_Heap->(BLK_HEADER_N)) = 4);
    ((Flex_Heap-->(BLK_HEADER_KOV)) = 0);
    ((Flex_Heap-->(BLK_HEADER_RCOUNT)) = MAX_POSITIVE_NUMBER);
    ((Flex_Heap->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
    ((Flex_Heap-->(BLK_NEXT)) = blk2);
    ((Flex_Heap-->(BLK_PREV)) = NULL);
    for ((bsize = 1):(bsize < MEMORY_HEAP_SIZE):(bsize = (bsize*2))) {
        (n)++;
    }
    ((blk2->(BLK_HEADER_N)) = n);
    ((blk2-->(BLK_HEADER_KOV)) = 0);
    ((blk2-->(BLK_HEADER_RCOUNT)) = 0);
    ((blk2->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
    ((blk2-->(BLK_NEXT)) = NULL);
    ((blk2-->(BLK_PREV)) = Flex_Heap);
];
[ HeapNetFreeSpace multiple txb asize;
    for ((txb = (Flex_Heap-->(BLK_NEXT))):(txb ~= NULL):(txb = (txb-->(BLK_NEXT)))) {
        (asize = (asize + FlexSize(txb)));
        if (multiple) {
            (asize = (asize - BLK_DATA_MULTI_OFFSET));
        } else {
            (asize = (asize - BLK_DATA_OFFSET));
        }
    }
    return asize;
];
[ HeapMakeSpace size multiple newblocksize newblock B n hsize;
    for (:1:) {
        if (multiple) {
            (hsize = BLK_DATA_MULTI_OFFSET);
            if ((HeapNetFreeSpace(multiple) >= size)) {
                rtrue;
            }
        } else {
            (hsize = BLK_DATA_OFFSET);
            if ((HeapLargestFreeBlock(0) >= size)) {
                rtrue;
            }
        }
        (newblocksize = 1);
        for ((n = 0):(((n < SMALLEST_BLK_WORTH_ALLOCATING)) || ((newblocksize < (size + hsize)))):(n)++) {
            (newblocksize = (newblocksize*2));
        }
        (newblock = VM_AllocateMemory(newblocksize));
        if ((newblock == 0)) {
            rfalse;
        }
        ((newblock->(BLK_HEADER_N)) = n);
        ((newblock-->(BLK_HEADER_KOV)) = 0);
        ((newblock-->(BLK_HEADER_RCOUNT)) = 0);
        ((newblock->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
        ((newblock-->(BLK_NEXT)) = NULL);
        ((newblock-->(BLK_PREV)) = NULL);
        for ((B = (Flex_Heap-->(BLK_NEXT))):(B ~= NULL):(B = (B-->(BLK_NEXT)))) {
            if (((B-->(BLK_NEXT)) == NULL)) {
                ((B-->(BLK_NEXT)) = newblock);
                ((newblock-->(BLK_PREV)) = B);
                jump Linked;
            }
        }
        ((Flex_Heap-->(BLK_NEXT)) = newblock);
        ((newblock-->(BLK_PREV)) = Flex_Heap);
        .Linked;
    }
    rtrue;
];
[ HeapLargestFreeBlock multiple txb asize best;
    (best = 0);
    for ((txb = (Flex_Heap-->(BLK_NEXT))):(txb ~= NULL):(txb = (txb-->(BLK_NEXT)))) {
        (asize = FlexSize(txb));
        if (multiple) {
            (asize = (asize - BLK_DATA_MULTI_OFFSET));
        } else {
            (asize = (asize - BLK_DATA_OFFSET));
        }
        if ((asize > best)) {
            (best = asize);
        }
    }
    return best;
];
[ HeapDebug full;
    if (full) {
        print "Managing a heap of initially ";
        print (MEMORY_HEAP_SIZE + 16);
        print " bytes.^";
        print HeapNetFreeSpace(0);
        print " bytes currently free.^";
        print "Free space decomposition: ";
        FlexDebugDecomposition(Flex_Heap);
        print "Free space map: ";
        FlexDebug(Flex_Heap);
    } else {
        print HeapNetFreeSpace(0);
        print " of ";
        print (MEMORY_HEAP_SIZE + 16);
        print " bytes free.^";
    }
];
[ FlexAllocate size kov flags dsize n m free_block min_m max_m smallest_oversized_block secondhalf i hsize head tail;
    if ((HeapMakeSpace(size, ((flags)&(BLK_FLAG_MULTIPLE))) == 0)) {
        FlexError("ran out");
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (hsize = BLK_DATA_MULTI_OFFSET);
    } else {
        (hsize = BLK_DATA_OFFSET);
    }
    (n = 0);
    for ((dsize = 1):(((dsize < (hsize + size))) || ((n < (3 + (WORDSIZE/2))))):(dsize = (dsize*2))) {
        (n)++;
    }
    (min_m = 10000);
    (max_m = 0);
    for ((free_block = (Flex_Heap-->(BLK_NEXT))):(free_block ~= NULL):(free_block = (free_block-->(BLK_NEXT)))) {
        (m = (free_block->(BLK_HEADER_N)));
        if ((m == n)) {
            jump CorrectSizeFound;
        }
        if ((m > n)) {
            if ((min_m > m)) {
                (min_m = m);
                (smallest_oversized_block = free_block);
            }
        }
        if ((m < n)) {
            if ((max_m < m)) {
                (max_m = m);
            }
        }
    }
    if ((min_m == 10000)) {
        if ((((flags)&(BLK_FLAG_MULTIPLE)) == 0)) {
            FlexError("too fragmented");
        }
        for ((dsize = 1):(max_m > 0):(dsize = (dsize*2))) {
            (max_m)--;
        }
        (head = FlexAllocate((dsize - hsize), kov, flags));
        if ((head == 0)) {
            FlexError("for head block not available");
        }
        (tail = FlexAllocate((size - (dsize - hsize)), kov, flags));
        if ((tail == 0)) {
            FlexError("for tail block not available");
        }
        ((head-->(BLK_NEXT)) = tail);
        ((tail-->(BLK_PREV)) = head);
        return head;
    }
    for (((dsize = 1),(m = 1)):(m <= min_m):(dsize = (dsize*2))) {
        (m)++;
    }
    (free_block = smallest_oversized_block);
    while ((min_m > n)) {
        (dsize = (dsize/2));
        (secondhalf = (free_block + dsize));
        ((secondhalf-->(BLK_NEXT)) = (free_block-->(BLK_NEXT)));
        if (((secondhalf-->(BLK_NEXT)) ~= NULL)) {
            (((secondhalf-->(BLK_NEXT))-->(BLK_PREV)) = secondhalf);
        }
        ((secondhalf-->(BLK_PREV)) = free_block);
        ((free_block-->(BLK_NEXT)) = secondhalf);
        ((free_block->(BLK_HEADER_N)) = ((free_block->(BLK_HEADER_N)) - 1));
        ((secondhalf->(BLK_HEADER_N)) = (free_block->(BLK_HEADER_N)));
        ((secondhalf-->(BLK_HEADER_KOV)) = (free_block-->(BLK_HEADER_KOV)));
        ((secondhalf-->(BLK_HEADER_RCOUNT)) = 0);
        ((secondhalf->(BLK_HEADER_FLAGS)) = (free_block->(BLK_HEADER_FLAGS)));
        (min_m)--;
    }
    .CorrectSizeFound;
    if (((free_block-->(BLK_NEXT)) == NULL)) {
        (((free_block-->(BLK_PREV))-->(BLK_NEXT)) = NULL);
    } else {
        (((free_block-->(BLK_PREV))-->(BLK_NEXT)) = (free_block-->(BLK_NEXT)));
        (((free_block-->(BLK_NEXT))-->(BLK_PREV)) = (free_block-->(BLK_PREV)));
    }
    ((free_block-->(BLK_HEADER_KOV)) = KindAtomic(kov));
    ((free_block-->(BLK_HEADER_RCOUNT)) = 1);
    ((free_block->(BLK_HEADER_FLAGS)) = flags);
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        ((free_block-->(BLK_NEXT)) = NULL);
        ((free_block-->(BLK_PREV)) = NULL);
    }
    for ((i = hsize):(i < dsize):(i)++) {
        ((free_block->(i)) = 0);
    }
    return free_block;
];
[ FlexError reason;
    print "*** Memory ";
    print (string) reason;
    print " ***^";
    RunTimeProblem(RTP_HEAPERROR);
    @quit;
];
[ FlexMergeInternal block first last pv nx;
    (first = block);
    (last = block);
    while (((last-->(BLK_NEXT)) == (last + FlexSize(last)))) {
        (last = (last-->(BLK_NEXT)));
    }
    while ((((((first-->(BLK_PREV)) + FlexSize((first-->(BLK_PREV)))) == first)) && (((first-->(BLK_PREV)) ~= Flex_Heap)))) {
        (first = (first-->(BLK_PREV)));
    }
    (pv = (first-->(BLK_PREV)));
    (nx = (last-->(BLK_NEXT)));
    if (FlexRecutInternal(first, last)) {
    }
];
[ FlexRecutInternal first last tsize backsize mfrom mto bnext backend n dsize fine_so_far;
    if ((first == last)) {
        rfalse;
    }
    (mfrom = first);
    (mto = (last + FlexSize(last)));
    (bnext = (last-->(BLK_NEXT)));
    (fine_so_far = 1);
    for (:(mto > mfrom):(mto = (mto - backsize))) {
        for (((n = 0),(backsize = 1)):((backsize*2) <= (mto - mfrom)):(n)++) {
            (backsize = (backsize*2));
        }
        if (((fine_so_far) && ((backsize == FlexSize(last))))) {
            (bnext = last);
            (last = (last-->(BLK_PREV)));
            ((bnext-->(BLK_PREV)) = last);
            ((last-->(BLK_NEXT)) = bnext);
            continue;
        }
        (fine_so_far = 0);
        (backend = (mto - backsize));
        ((backend->(BLK_HEADER_N)) = n);
        ((backend-->(BLK_HEADER_KOV)) = 0);
        ((backend-->(BLK_HEADER_RCOUNT)) = 0);
        ((backend->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
        ((backend-->(BLK_NEXT)) = bnext);
        if ((bnext ~= NULL)) {
            ((bnext-->(BLK_PREV)) = backend);
            (bnext = backend);
        }
    }
    if (fine_so_far) {
        rfalse;
    }
    rtrue;
];
[ FlexFree block fromtxb ptxb;
    if ((block == 0)) {
        rtrue;
    }
    if ((((block->(BLK_HEADER_FLAGS)))&(BLK_FLAG_RESIDENT))) {
        rtrue;
    }
    if ((((block->(BLK_HEADER_N)))&(128))) {
        rtrue;
    }
    if ((((block->(BLK_HEADER_FLAGS)))&(BLK_FLAG_MULTIPLE))) {
        if (((block-->(BLK_PREV)) ~= NULL)) {
            (((block-->(BLK_PREV))-->(BLK_NEXT)) = NULL);
        }
        (fromtxb = block);
        for (:((block-->(BLK_NEXT)) ~= NULL):(block = (block-->(BLK_NEXT)))) {
        }
        while ((block ~= fromtxb)) {
            (ptxb = (block-->(BLK_PREV)));
            FlexFreeSingleBlockInternal(block);
            (block = ptxb);
        }
    }
    FlexFreeSingleBlockInternal(block);
];
[ FlexFreeSingleBlockInternal block free nx;
    ((block-->(BLK_HEADER_KOV)) = 0);
    ((block-->(BLK_HEADER_RCOUNT)) = 0);
    ((block->(BLK_HEADER_FLAGS)) = BLK_FLAG_MULTIPLE);
    for ((free = Flex_Heap):(free ~= NULL):(free = (free-->(BLK_NEXT)))) {
        (nx = (free-->(BLK_NEXT)));
        if ((nx == NULL)) {
            ((free-->(BLK_NEXT)) = block);
            ((block-->(BLK_PREV)) = free);
            ((block-->(BLK_NEXT)) = NULL);
            FlexMergeInternal(block);
            rtrue;
        }
        if ((UnsignedCompare(nx, block) == 1)) {
            ((free-->(BLK_NEXT)) = block);
            ((block-->(BLK_PREV)) = free);
            ((block-->(BLK_NEXT)) = nx);
            ((nx-->(BLK_PREV)) = block);
            FlexMergeInternal(block);
            rtrue;
        }
    }
];
[ FlexResize block req newsize dsize newblk kov n i otxb flags;
    if ((block == 0)) {
        FlexError("failed resizing null block");
    }
    (kov = (block-->(BLK_HEADER_KOV)));
    (flags = (block->(BLK_HEADER_FLAGS)));
    if ((((flags)&(BLK_FLAG_MULTIPLE)) == 0)) {
        FlexError("failed resizing inextensible block");
    }
    (otxb = block);
    (newsize = req);
    for (:1:(block = (block-->(BLK_NEXT)))) {
        (n = (block->(BLK_HEADER_N)));
        for ((dsize = 1):(n > 0):(n)--) {
            (dsize = (dsize*2));
        }
        (i = (dsize - BLK_DATA_MULTI_OFFSET));
        (newsize = (newsize - i));
        if ((newsize > 0)) {
            if (((block-->(BLK_NEXT)) ~= NULL)) {
                continue;
            }
            (newblk = FlexAllocate(newsize, kov, flags));
            if ((newblk == 0)) {
                rfalse;
            }
            ((block-->(BLK_NEXT)) = newblk);
            ((newblk-->(BLK_PREV)) = block);
            rtrue;
        }
        if (((block-->(BLK_NEXT)) ~= NULL)) {
            FlexFree((block-->(BLK_NEXT)));
            ((block-->(BLK_NEXT)) = NULL);
        }
        rtrue;
    }
];
[ FlexSize txb bsize n m;
    if ((txb == 0)) {
        rfalse;
    }
    (m = (txb->(BLK_HEADER_N)));
    for ((bsize = 1):(n < m):(bsize = (bsize*2))) {
        (n)++;
    }
    return bsize;
];
[ FlexTotalSize txb size_in_bytes;
    if ((txb == 0)) {
        rfalse;
    }
    if (((((txb->(BLK_HEADER_FLAGS)))&(BLK_FLAG_MULTIPLE)) == 0)) {
        return (FlexSize(txb) - BLK_DATA_OFFSET);
    }
    for (:(txb ~= NULL):(txb = (txb-->(BLK_NEXT)))) {
        (size_in_bytes = ((size_in_bytes + FlexSize(txb)) - BLK_DATA_MULTI_OFFSET));
    }
    return size_in_bytes;
];
[ FlexDebug txb n k i bsize tot dtot kov;
    if ((txb == 0)) {
        print "Block never created.";
        new_line;
        rtrue;
    }
    (kov = (txb-->(BLK_HEADER_KOV)));
    print "Block ";
    print txb;
    print " (kov ";
    print kov;
    print "): ";
    for (:(txb ~= NULL):(txb = (txb-->(BLK_NEXT)))) {
        if (((k)++ == 100)) {
            print " ... and so on.";
            new_line;
            rtrue;
        }
        if (((txb-->(BLK_HEADER_KOV)) ~= kov)) {
            print "*Wrong kov=";
            print (txb-->(BLK_HEADER_KOV));
            print "* ";
        }
        (n = (txb->(BLK_HEADER_N)));
        for ((bsize = 1):(n > 0):(n)--) {
            (bsize = (bsize*2));
        }
        (i = (bsize - BLK_DATA_OFFSET));
        (dtot = (dtot + i));
        (tot = (tot + bsize));
        print txb;
        print "(";
        print bsize;
        print ") > ";
    }
    print dtot;
    print " data in ";
    print tot;
    print " bytes^";
];
[ FlexDebugDecomposition from to txb pf;
    if ((to == 0)) {
        (to = NULL);
    }
    for ((txb = from):(((txb ~= to)) && ((txb ~= NULL))):(txb = (txb-->(BLK_NEXT)))) {
        if (pf) {
            print "+";
        }
        print FlexSize(txb);
        (pf = 1);
    }
    print "^";
];
[ BlkValueGetLongBlock bv o;
    if (bv) {
        (o = (bv-->(0)));
        if ((o == 0)) {
            return (bv + WORDSIZE);
        }
        if ((((o)&(BLK_BVBITMAP)) == o)) {
            if (((o)&(BLK_BVBITMAP_LONGBLOCK))) {
                return (bv-->(1));
            }
            rfalse;
        }
        return o;
    }
    return bv;
];
[ BlkValueWeakKind bv o;
    if (bv) {
        (o = (bv-->(0)));
        if ((o == 0)) {
            return (bv-->((BLK_HEADER_KOV + 1)));
        }
        if ((((o)&(BLK_BVBITMAP)) == o)) {
            if (((o)&(BLK_BVBITMAP_TEXT))) {
                return TEXT_TY;
            }
            (o = (bv-->(1)));
        }
        return (o-->(BLK_HEADER_KOV));
    }
    return NIL_TY;
];
[ BlkValueGetRefCountPrimitive bv long_block;
    (long_block = BlkValueGetLongBlock(bv));
    if (long_block) {
        return (long_block-->(BLK_HEADER_RCOUNT));
    }
    return RC_INFINITY;
];
[ BlkValueIncRefCountPrimitive bv long_block refc;
    (long_block = BlkValueGetLongBlock(bv));
    if (long_block) {
        (refc = (long_block-->(BLK_HEADER_RCOUNT)));
        if ((refc < RC_INFINITY)) {
            ((long_block-->(BLK_HEADER_RCOUNT)) = (refc + 1));
        }
    }
];
[ BlkValueDecRefCountPrimitive bv long_block refc;
    (long_block = BlkValueGetLongBlock(bv));
    if (long_block) {
        (refc = (long_block-->(BLK_HEADER_RCOUNT)));
        if ((refc < RC_INFINITY)) {
            (refc)--;
            if ((refc < 0)) {
                BlkValueError("reference count negative");
            }
            ((long_block-->(BLK_HEADER_RCOUNT)) = refc);
        }
        return refc;
    }
    return RC_INFINITY;
];
[ BlkValueLBCapacity bv long_block array_size_in_bytes entry_size_in_bytes flags;
    (long_block = BlkValueGetLongBlock(bv));
    if ((long_block == 0)) {
        rfalse;
    }
    (array_size_in_bytes = FlexTotalSize(long_block));
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    return (array_size_in_bytes/entry_size_in_bytes);
];
[ BlkValueSetLBCapacity bv new_capacity long_block flags entry_size_in_bytes;
    if ((bv == 0)) {
        rfalse;
    }
    BlkMakeMutable(bv);
    (long_block = BlkValueGetLongBlock(bv));
    if ((long_block == 0)) {
        rfalse;
    }
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    FlexResize(long_block, (new_capacity*entry_size_in_bytes));
    rtrue;
];
[ BlkValueRead from pos do_not_indirect long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes seek_byte_position;
    if ((from == 0)) {
        rfalse;
    }
    if (do_not_indirect) {
        (long_block = from);
    } else {
        (long_block = BlkValueGetLongBlock(from));
    }
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (seek_byte_position = (pos*entry_size_in_bytes));
    for (:(long_block ~= NULL):(long_block = (long_block-->(BLK_NEXT)))) {
        (chunk_size_in_bytes = (FlexSize(long_block) - header_size_in_bytes));
        if ((((seek_byte_position >= 0)) && ((seek_byte_position < chunk_size_in_bytes)))) {
            (long_block = ((long_block + header_size_in_bytes) + seek_byte_position));
            switch (entry_size_in_bytes) {
                1:
                    return (long_block->(0));
                    ;
                2:
                    return (((long_block->(0))*256) + (long_block->(1)));
                    ;
                4:
                    return (long_block-->(0));
                    ;
            }
        }
        (seek_byte_position = (seek_byte_position - chunk_size_in_bytes));
    }
    print "*** BlkValueRead: reading from index out of range: ";
    print pos;
    print " in ";
    print from;
    print " ***";
    print "^";
    rtrue;
];
[ BlkValueWrite to pos val do_not_indirect long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes seek_byte_position;
    if ((to == 0)) {
        rfalse;
    }
    if (do_not_indirect) {
        (long_block = to);
    } else {
        BlkMakeMutable(to);
        (long_block = BlkValueGetLongBlock(to));
    }
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (seek_byte_position = (pos*entry_size_in_bytes));
    for (:(long_block ~= NULL):(long_block = (long_block-->(BLK_NEXT)))) {
        (chunk_size_in_bytes = (FlexSize(long_block) - header_size_in_bytes));
        if ((((seek_byte_position >= 0)) && ((seek_byte_position < chunk_size_in_bytes)))) {
            (long_block = ((long_block + header_size_in_bytes) + seek_byte_position));
            switch (entry_size_in_bytes) {
                1:
                    ((long_block->(0)) = val);
                    ;
                2:
                    ((long_block->(0)) = ((val/256)%256));
                    ((long_block->(1)) = (val%256));
                    ;
                4:
                    ((long_block-->(0)) = val);
                    ;
            }
            rtrue;
        }
        (seek_byte_position = (seek_byte_position - chunk_size_in_bytes));
    }
    print "*** BlkValueWrite: writing to index out of range: ";
    print pos;
    print " in ";
    print to;
    print " ***";
    print "^";
    rtrue;
];
[ BlkValueSeekZeroEntry from long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes byte_position addr from_addr to_addr;
    if ((from == 0)) {
        return (-(1));
    }
    (long_block = BlkValueGetLongBlock(from));
    (flags = (long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (byte_position = 0);
    for (:(long_block ~= NULL):(long_block = (long_block-->(BLK_NEXT)))) {
        (chunk_size_in_bytes = (FlexSize(long_block) - header_size_in_bytes));
        (from_addr = (long_block + header_size_in_bytes));
        (to_addr = (from_addr + chunk_size_in_bytes));
        switch (entry_size_in_bytes) {
            1:
                for ((addr = from_addr):(addr < to_addr):(addr)++) {
                    if (((addr->(0)) == 0)) {
                        return ((byte_position + addr) - from_addr);
                    }
                }
                ;
            2:
                for ((addr = from_addr):(addr < to_addr):(addr = (addr + 2))) {
                    if (((((addr->(0)) == 0)) && (((addr->(1)) == 0)))) {
                        return (((byte_position + addr) - from_addr)/2);
                    }
                }
                ;
            4:
                for ((addr = from_addr):(addr < to_addr):(addr = (addr + 4))) {
                    if (((addr-->(0)) == 0)) {
                        return (((byte_position + addr) - from_addr)/4);
                    }
                }
                ;
        }
        (byte_position = (byte_position + chunk_size_in_bytes));
    }
    return (-(1));
];
[ BlkValueMassCopyEntries to_bv from_bv no_entries_to_copy from_long_block from_addr from_bytes_left from_header_size_in_bytes to_long_block to_addr to_bytes_left to_header_size_in_bytes bytes_to_copy flags entry_size_in_bytes min;
    BlkMakeMutable(to_bv);
    (from_long_block = BlkValueGetLongBlock(from_bv));
    (to_long_block = BlkValueGetLongBlock(to_bv));
    (flags = (from_long_block->(BLK_HEADER_FLAGS)));
    (entry_size_in_bytes = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (entry_size_in_bytes = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (entry_size_in_bytes = WORDSIZE);
        }
    }
    if (((((flags)&((BLK_FLAG_MULTIPLE + BLK_FLAG_TRUNCMULT)))) && ((BlkValueSetLBCapacity(to_bv, no_entries_to_copy) == 0)))) {
        BlkValueError("copy resizing failed");
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (from_header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (from_header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (flags = (to_long_block->(BLK_HEADER_FLAGS)));
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (to_header_size_in_bytes = BLK_DATA_MULTI_OFFSET);
    } else {
        (to_header_size_in_bytes = BLK_DATA_OFFSET);
    }
    (from_addr = (from_long_block + from_header_size_in_bytes));
    (from_bytes_left = (FlexSize(from_long_block) - from_header_size_in_bytes));
    (to_addr = (to_long_block + to_header_size_in_bytes));
    (to_bytes_left = (FlexSize(to_long_block) - to_header_size_in_bytes));
    (bytes_to_copy = (entry_size_in_bytes*no_entries_to_copy));
    while (1) {
        if ((from_bytes_left == 0)) {
            (from_long_block = (from_long_block-->(BLK_NEXT)));
            if ((from_long_block == 0)) {
                BlkValueError("copy destination exhausted");
            }
            (from_addr = (from_long_block + from_header_size_in_bytes));
            (from_bytes_left = (FlexSize(from_long_block) - from_header_size_in_bytes));
        } else {
            if ((to_bytes_left == 0)) {
                (to_long_block = (to_long_block-->(BLK_NEXT)));
                if ((to_long_block == 0)) {
                    BlkValueError("copy source exhausted");
                }
                (to_addr = (to_long_block + to_header_size_in_bytes));
                (to_bytes_left = (FlexSize(to_long_block) - to_header_size_in_bytes));
            } else {
                (min = from_bytes_left);
                if ((to_bytes_left < min)) {
                    (min = to_bytes_left);
                }
                if ((bytes_to_copy <= min)) {
                    Memcpy(to_addr, from_addr, bytes_to_copy);
                    rtrue;
                }
                Memcpy(to_addr, from_addr, min);
                (bytes_to_copy = (bytes_to_copy - min));
                (from_addr = (from_addr + min));
                (from_bytes_left = (from_bytes_left - min));
                (to_addr = (to_addr + min));
                (to_bytes_left = (to_bytes_left - min));
            }
        }
    }
];
[ BlkValueMassCopyFromArray to_bv from_array from_entry_size no_entries_to_copy to_long_block to_addr to_entries_left to_header_size to_entry_size flags;
    BlkMakeMutable(to_bv);
    (to_long_block = BlkValueGetLongBlock(to_bv));
    (flags = (to_long_block->(BLK_HEADER_FLAGS)));
    (to_entry_size = 1);
    if (((flags)&(BLK_FLAG_16_BIT))) {
        (to_entry_size = 2);
    } else {
        if (((flags)&(BLK_FLAG_WORD))) {
            (to_entry_size = WORDSIZE);
        }
    }
    if (((((flags)&((BLK_FLAG_MULTIPLE + BLK_FLAG_TRUNCMULT)))) && ((BlkValueSetLBCapacity(to_bv, no_entries_to_copy) == 0)))) {
        BlkValueError("copy resizing failed");
    }
    if (((flags)&(BLK_FLAG_MULTIPLE))) {
        (to_header_size = BLK_DATA_MULTI_OFFSET);
    } else {
        (to_header_size = BLK_DATA_OFFSET);
    }
    (to_addr = (to_long_block + to_header_size));
    (to_entries_left = ((FlexSize(to_long_block) - to_header_size)/to_entry_size));
    while ((no_entries_to_copy > to_entries_left)) {
        Arrcpy(to_addr, to_entry_size, from_array, from_entry_size, to_entries_left);
        (no_entries_to_copy = (no_entries_to_copy - to_entries_left));
        (from_array = (from_array + (to_entries_left*from_entry_size)));
        (to_long_block = (to_long_block-->(BLK_NEXT)));
        if ((to_long_block == 0)) {
            BlkValueError("copy source exhausted");
        }
        (to_addr = (to_long_block + to_header_size));
        (to_entries_left = ((FlexSize(to_long_block) - to_header_size)/to_entry_size));
    }
    if ((no_entries_to_copy > 0)) {
        Arrcpy(to_addr, to_entry_size, from_array, from_entry_size, no_entries_to_copy);
    }
];
[ BlkValueCreate strong_kind short_block kovs;
    (kovs = KOVSupportFunction(strong_kind, "impossible allocation"));
    (short_block = (kovs)(CREATE_KOVS,strong_kind,short_block));
    return short_block;
];
[ BlkValueError reason;
    print "*** Value handling failed: ";
    print (string) reason;
    print " ***^";
    RunTimeProblem(RTP_HEAPERROR);
    @quit;
];
[ BlkValueCreateSB1 short_block val;
    if ((short_block == 0)) {
        (short_block = (FlexAllocate(WORDSIZE, 0, BLK_FLAG_WORD) + BLK_DATA_OFFSET));
    }
    ((short_block-->(0)) = val);
    return short_block;
];
[ BlkValueCreateSB2 short_block val1 val2;
    if ((short_block == 0)) {
        (short_block = (FlexAllocate((2*WORDSIZE), 0, BLK_FLAG_WORD) + BLK_DATA_OFFSET));
    }
    ((short_block-->(0)) = val1);
    ((short_block-->(1)) = val2);
    return short_block;
];
[ StackFramingInitialise;
    (I7SFRAME = (blockv_stack + (WORDSIZE*BLOCKV_STACK_SIZE)));
];
[ StackFrameCreate size new;
    (new = (I7SFRAME - (WORDSIZE*size)));
    if ((new < blockv_stack)) {
        RunTimeProblem(RTP_HEAPERROR);
        @quit;
    }
    (I7SFRAME = new);
];
[ BlkValueCreateOnStack offset strong_kind;
    BlkValueCreate(strong_kind, (I7SFRAME + (WORDSIZE*offset)));
];
[ BlkValueFreeOnStack offset;
    BlkValueFree((I7SFRAME + (WORDSIZE*offset)));
];
[ BlkValueFree bv kovs d;
    if ((bv == 0)) {
        rtrue;
    }
    (kovs = KOVSupportFunction(BlkValueWeakKind(bv), "impossible deallocation"));
    BlkValueDestroyPrimitive(bv, kovs);
    (d = (bv - Flex_Heap));
    if ((((d >= 0)) && ((d < (MEMORY_HEAP_SIZE + 16))))) {
        FlexFree((bv - BLK_DATA_OFFSET));
    }
];
[ BlkValueQuickCopyPrimitive to_bv from_bv kovs;
    BlkValueDestroyPrimitive(to_bv, kovs);
    (kovs)(COPYSB_KOVS,to_bv,from_bv);
    BlkValueIncRefCountPrimitive(from_bv);
];
[ BlkValueCopySB1 to_bv from_bv;
    ((to_bv-->(0)) = (from_bv-->(0)));
    if (((to_bv-->(0)) == 0)) {
        ((to_bv-->(0)) = (from_bv + WORDSIZE));
    }
];
[ BlkValueCopySB2 to_bv from_bv;
    ((to_bv-->(0)) = (from_bv-->(0)));
    ((to_bv-->(1)) = (from_bv-->(1)));
    if (((to_bv-->(1)) == 0)) {
        ((to_bv-->(1)) = (from_bv + (2*WORDSIZE)));
    }
];
[ BlkValueSlowCopyPrimitive to_bv from_bv kovs recycling k from_long_block no_entries_to_copy;
    (k = (kovs)(KINDDATA_KOVS,to_bv,from_bv));
    (from_long_block = BlkValueGetLongBlock(from_bv));
    if (from_long_block) {
        if (recycling) {
            BlkValueRecyclePrimitive(to_bv, kovs);
        }
        (no_entries_to_copy = (kovs)(EXTENT_KOVS,from_bv));
        if ((no_entries_to_copy == -1)) {
            (no_entries_to_copy = BlkValueLBCapacity(from_bv));
        }
        BlkValueMassCopyEntries(to_bv, from_bv, no_entries_to_copy);
    }
    (kovs)(COPY_KOVS,to_bv,from_bv,k);
];
[ BlkValueCopy to_bv from_bv to_kind from_kind kovs;
    if ((to_bv == 0)) {
        BlkValueError("copy to null value");
    }
    if ((from_bv == 0)) {
        BlkValueError("copy from null value");
    }
    if ((to_bv == from_bv)) {
        rtrue;
    }
    (to_kind = BlkValueWeakKind(to_bv));
    (from_kind = BlkValueWeakKind(from_bv));
    if ((to_kind ~= from_kind)) {
        BlkValueError("copy incompatible kinds");
    }
    (kovs = KOVSupportFunction(to_kind, "impossible copy"));
    if ((kovs)(COPYQUICK_KOVS,to_bv,from_bv)) {
        BlkValueQuickCopyPrimitive(to_bv, from_bv, kovs);
    } else {
        BlkValueSlowCopyPrimitive(to_bv, from_bv, kovs, 1);
    }
    return to_bv;
];
[ BlkValueCopyAZ to_bv from_bv;
    if (from_bv) {
        return BlkValueCopy(to_bv, from_bv);
    }
    return to_bv;
];
[ BlkValueDestroyPrimitive bv kovs long_block;
    if ((BlkValueDecRefCountPrimitive(bv) == 0)) {
        (kovs)(DESTROY_KOVS,bv);
        (long_block = BlkValueGetLongBlock(bv));
        if (long_block) {
            FlexFree(long_block);
        }
    }
];
[ BlkValueRecyclePrimitive bv kovs;
    if ((BlkValueDecRefCountPrimitive(bv) == 0)) {
        (kovs)(DESTROY_KOVS,bv);
        BlkValueIncRefCountPrimitive(bv);
    } else {
        BlkValueCreate(BlkValueWeakKind(bv), bv);
    }
];
[ BlkMakeMutable bv block bv_kind kovs sb_size;
    if ((bv == 0)) {
        BlkValueError("tried to make null block mutable");
    }
    if ((BlkValueGetRefCountPrimitive(bv) > 1)) {
        BlkValueDecRefCountPrimitive(bv);
        (bv_kind = BlkValueWeakKind(bv));
        (kovs = KOVSupportFunction(bv_kind, "impossible mutability"));
        (sb_size = (kovs)(MAKEMUTABLE_KOVS,bv));
        if ((sb_size > 0)) {
            @push I7SFRAME;
            StackFrameCreate(sb_size);
            BlkValueCreateOnStack(0, bv_kind);
            (kovs)(COPYKIND_KOVS,I7SFRAME,bv);
            BlkValueSlowCopyPrimitive(I7SFRAME, bv, kovs, 0);
            (kovs)(COPYSB_KOVS,bv,I7SFRAME);
            @pull I7SFRAME;
        }
    }
];
[ BlkValueCast to_bv original_kind original_value kovs;
    (kovs = KOVSupportFunction(BlkValueWeakKind(to_bv), "impossible cast"));
    (kovs)(CAST_KOVS,to_bv,original_kind,original_value);
    return to_bv;
];
[ BlkValueCompare bv_left bv_right kind_left kind_right kovs;
    if ((((bv_left == 0)) && ((bv_right == 0)))) {
        rfalse;
    }
    if ((bv_left == 0)) {
        rtrue;
    }
    if ((bv_right == 0)) {
        return (-(1));
    }
    (kind_left = BlkValueWeakKind(bv_left));
    (kind_right = BlkValueWeakKind(bv_right));
    if ((kind_left ~= kind_right)) {
        return (kind_left - kind_right);
    }
    (kovs = KOVSupportFunction(kind_left, "impossible comparison"));
    return (kovs)(COMPARE_KOVS,bv_left,bv_right);
];
[ GetHashValue kind value;
    if (KOVIsBlockValue(kind)) {
        return BlkValueHash(value);
    }
    return value;
];
[ BlkValueHash bv bv_kind kovs;
    if ((bv == 0)) {
        rfalse;
    }
    (bv_kind = BlkValueWeakKind(bv));
    (kovs = KOVSupportFunction(bv_kind, "impossible hashing"));
    return (kovs)(HASH_KOVS,bv);
];
[ BlkValueReadFromFile bv auxf ch bv_kind kovs;
    (kovs = KOVSupportFunction(bv_kind));
    if (kovs) {
        return (kovs)(READ_FILE_KOVS,bv,auxf,ch);
    }
    rfalse;
];
[ BlkValueWriteToFile bv bv_kind kovs;
    (kovs = KOVSupportFunction(bv_kind));
    if (kovs) {
        return (kovs)(WRITE_FILE_KOVS,bv);
    }
    rfalse;
];
[ BlkValueDebug bv flag refc long_block kovs;
    print "(BV";
    if (bv) {
        BlkDebugAddress(bv, flag);
        (long_block = BlkValueGetLongBlock(bv));
        if (long_block) {
            if (((bv-->(0)) == 0)) {
                print "...";
            } else {
                print "-->";
            }
            print "L";
            BlkDebugAddress(long_block, flag);
            print " 2**";
            print (long_block->(BLK_HEADER_N));
            (refc = BlkValueGetRefCountPrimitive(bv));
            if ((refc == RC_INFINITY)) {
                print " resident";
            } else {
                print " ";
                print refc;
                print " ref";
                if ((refc ~= 1)) {
                    print "s";
                }
            }
        }
        (kovs = KOVSupportFunction(BlkValueWeakKind(bv)));
        if (kovs) {
            (kovs)(DEBUG_KOVS,bv);
        }
    }
    print ")";
];
[ BlkDebugAddress addr flag d;
    if (flag) {
        print "###";
        rtrue;
    }
    (d = (addr - blockv_stack));
    if ((((d >= 0)) && ((d <= (WORDSIZE*BLOCKV_STACK_SIZE))))) {
        print "s+";
        BlkPrintHexadecimal(d);
        (d = (addr - I7SFRAME));
        print "=f";
        if ((d >= 0)) {
            print "+";
        }
        print d;
        rtrue;
    }
    (d = (addr - Flex_Heap));
    if ((((d >= 0)) && ((d < (MEMORY_HEAP_SIZE + 16))))) {
        print "h+";
        BlkPrintHexadecimal(d);
        rtrue;
    }
    BlkPrintHexadecimal(addr);
];
[ BlkPrintHexadecimal v;
    if (((v)&(-65536))) {
        if (((v)&(-16777216))) {
            BlkPrintHexDigit((v/268435456));
            BlkPrintHexDigit((v/16777216));
        }
        BlkPrintHexDigit((v/1048576));
        BlkPrintHexDigit((v/65536));
    }
    BlkPrintHexDigit((v/4096));
    BlkPrintHexDigit((v/256));
    BlkPrintHexDigit((v/16));
    BlkPrintHexDigit(v);
];
[ BlkPrintHexDigit v;
    (v = ((v)&(15)));
    if ((v < 10)) {
        print v;
    } else {
        print (char) ((65 + v) - 10);
    }
];
[ TEXT_TY_Extent arg1 x;
    (x = BlkValueSeekZeroEntry(arg1));
    if ((x < 0)) {
        return (-(1));
    }
    return (x + 1);
];
[ TEXT_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return TEXT_TY_Create(arg2);
            ;
        CAST_KOVS:
            TEXT_TY_Cast(arg1, arg2, arg3);
            ;
        MAKEMUTABLE_KOVS:
            return TEXT_TY_Mutable(arg1);
            ;
        COPYQUICK_KOVS:
            rtrue;
            ;
        COPYSB_KOVS:
            TEXT_TY_CopySB(arg1, arg2);
            ;
        KINDDATA_KOVS:
            rfalse;
            ;
        EXTENT_KOVS:
            return TEXT_TY_Extent(arg1);
            ;
        COMPARE_KOVS:
            return TEXT_TY_Compare(arg1, arg2);
            ;
        READ_FILE_KOVS:
            if ((arg3 == -1)) {
                rtrue;
            }
            return TEXT_TY_ReadFile(arg1, arg2, arg3);
            ;
        WRITE_FILE_KOVS:
            return TEXT_TY_WriteFile(arg1);
            ;
        HASH_KOVS:
            return TEXT_TY_Hash(arg1);
            ;
        DEBUG_KOVS:
            TEXT_TY_Debug(arg1);
            ;
    }
    rfalse;
];
[ TEXT_TY_Debug txt;
    switch ((txt-->(0))) {
        CONSTANT_PACKED_TEXT_STORAGE:
            print " = cp~";
            PrintI6Text((txt-->(1)));
            print "~";
            ;
        CONSTANT_PERISHABLE_TEXT_STORAGE:
            print " = cp~";
            PrintI6Text((txt-->(1)));
            print "~";
            ;
        PACKED_TEXT_STORAGE:
            print " = p~";
            PrintI6Text((txt-->(1)));
            print "~";
            ;
        UNPACKED_TEXT_STORAGE:
            print " = ~";
            TEXT_TY_Say(txt);
            print "~";
            ;
        default:
            print " broken?";
            ;
    }
];
[ TEXT_TY_Create short_block x;
    return BlkValueCreateSB2(short_block, PACKED_TEXT_STORAGE, EMPTY_TEXT_PACKED);
];
[ TEXT_TY_CopySB to_bv from_bv;
    BlkValueCopySB2(to_bv, from_bv);
    if ((((to_bv-->(0)))&(BLK_BVBITMAP_CONSTANTMASK))) {
        ((to_bv-->(0)) = PACKED_TEXT_STORAGE);
    }
];
[ TEXT_TY_Transmute txt;
    TEXT_TY_Temporarily_Transmute(txt);
];
[ TEXT_TY_Temporarily_Transmute txt x;
    if (((txt) && (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)))) {
        (x = (txt-->(1)));
        ((txt-->(0)) = UNPACKED_TEXT_STORAGE);
        ((txt-->(1)) = FlexAllocate(32, TEXT_TY, TEXT_TY_Storage_Flags));
        if ((x ~= EMPTY_TEXT_PACKED)) {
            TEXT_TY_CastPrimitive(txt, 0, x);
        }
        return x;
    }
    rfalse;
];
[ TEXT_TY_Untransmute txt pk cp x;
    if (((pk) && (((txt-->(0)) == UNPACKED_TEXT_STORAGE)))) {
        (x = (txt-->(1)));
        FlexFree(x);
        ((txt-->(0)) = cp);
        ((txt-->(1)) = pk);
    }
    return txt;
];
[ TEXT_TY_Mutable txt;
    if (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        TEXT_TY_Transmute(txt);
        rfalse;
    }
    return 2;
];
[ TEXT_TY_Cast to_txt from_kind from_value;
    if ((from_kind == TEXT_TY)) {
        BlkValueCopy(to_txt, from_value);
    } else {
        if ((from_kind == SNIPPET_TY)) {
            TEXT_TY_Transmute(to_txt);
            TEXT_TY_CastPrimitive(to_txt, 1, from_value);
        } else {
            BlkValueError("impossible cast to text");
        }
    }
];
[ SNIPPET_TY_to_TEXT_TY to_txt snippet;
    return BlkValueCast(to_txt, SNIPPET_TY, snippet);
];
[ TEXT_TY_CastPrimitive to_txt from_snippet from_value len i stream saved_stream news buffer buffer_size memory_to_free results;
    if ((to_txt == 0)) {
        BlkValueError("no destination for cast");
    }
    (buffer_size = ((TEXT_TY_BufferSize + 2)*WORDSIZE));
    (RawBufferSize = TEXT_TY_BufferSize);
    (buffer = (RawBufferAddress + (TEXT_TY_CastPrimitiveNesting*buffer_size)));
    (TEXT_TY_CastPrimitiveNesting)++;
    if ((TEXT_TY_CastPrimitiveNesting > TEXT_TY_NoBuffers)) {
        (buffer = VM_AllocateMemory(buffer_size));
        (memory_to_free = buffer);
        if ((buffer == 0)) {
            FlexError("ran out with too many simultaneous text conversions");
        }
    }
    if (unicode_gestalt_ok) {
        SuspendRTP();
        .RetryWithLargerBuffer;
        (saved_stream = glk_stream_get_current());
        (stream = glk_stream_open_memory_uni(buffer, RawBufferSize, filemode_Write, 0));
        glk_stream_set_current(stream);
        @push say__p;
        @push say__pc;
        ClearParagraphing(7);
        if (from_snippet) {
            PrintSnippet(from_value);
        } else {
            PrintI6Text(from_value);
        }
        @pull say__pc;
        @pull say__p;
        (results = ((buffer + buffer_size) - (2*WORDSIZE)));
        glk_stream_close(stream, results);
        if (saved_stream) {
            glk_stream_set_current(saved_stream);
        }
        ResumeRTP();
        (len = (results-->(1)));
        if ((len > (RawBufferSize - 1))) {
            (news = RawBufferSize);
            while ((news < len)) {
                (news = (news*2));
            }
            (i = VM_AllocateMemory((news*WORDSIZE)));
            if ((i ~= 0)) {
                if (memory_to_free) {
                    VM_FreeMemory(memory_to_free);
                }
                (memory_to_free = i);
                (buffer = i);
                (RawBufferSize = news);
                (buffer_size = ((RawBufferSize + 2)*WORDSIZE));
                jump RetryWithLargerBuffer;
            }
            (len = (RawBufferSize - 1));
        }
        ((buffer-->(len)) = 0);
        (TEXT_TY_CastPrimitiveNesting)--;
        BlkValueMassCopyFromArray(to_txt, buffer, 4, (len + 1));
    } else {
        RunTimeProblem(RTP_NOGLULXUNICODE);
    }
    if (memory_to_free) {
        VM_FreeMemory(memory_to_free);
    }
];
[ TEXT_TY_Compare left_txt right_txt rv;
    @push say__comp;
    (say__comp = 1);
    (rv = TEXT_TY_Compare_Inner(left_txt, right_txt));
    @pull say__comp;
    return rv;
];
[ TEXT_TY_Compare_Inner left_txt right_txt pos ch1 ch2 capacity_left capacity_right fl fr cl cr cpl cpr;
    if (((((left_txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        (fl = 1);
    }
    if (((((right_txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        (fr = 1);
    }
    if (((fl) && (fr))) {
        if (((((left_txt-->(1)) ofclass String)) && (((right_txt-->(1)) ofclass String)))) {
            return ((left_txt-->(1)) - (right_txt-->(1)));
        }
        if (((((left_txt-->(1)) ofclass Routine)) && (((right_txt-->(1)) ofclass Routine)))) {
            if (((left_txt-->(1)) == (right_txt-->(1)))) {
                rfalse;
            }
        }
        (cpl = (left_txt-->(0)));
        (cl = TEXT_TY_Temporarily_Transmute(left_txt));
        (cpr = (right_txt-->(0)));
        (cr = TEXT_TY_Temporarily_Transmute(right_txt));
    } else {
        if (fl) {
            (cpl = (left_txt-->(0)));
            (cl = TEXT_TY_Temporarily_Transmute(left_txt));
        } else {
            if (fr) {
                (cpr = (right_txt-->(0)));
                (cr = TEXT_TY_Temporarily_Transmute(right_txt));
            }
        }
    }
    if (((cl) || (cr))) {
        (pos = TEXT_TY_Compare(left_txt, right_txt));
        TEXT_TY_Untransmute(left_txt, cl, cpl);
        TEXT_TY_Untransmute(right_txt, cr, cpr);
        return pos;
    }
    (capacity_left = BlkValueLBCapacity(left_txt));
    (capacity_right = BlkValueLBCapacity(right_txt));
    for ((pos = 0):(((pos < capacity_left)) && ((pos < capacity_right))):(pos)++) {
        (ch1 = BlkValueRead(left_txt, pos));
        (ch2 = BlkValueRead(right_txt, pos));
        if ((ch1 ~= ch2)) {
            return (ch1 - ch2);
        }
        if ((ch1 == 0)) {
            rfalse;
        }
    }
    if ((pos == capacity_left)) {
        return (-(1));
    }
    rtrue;
];
[ TEXT_TY_Distinguish left_txt right_txt;
    if ((TEXT_TY_Compare(left_txt, right_txt) == 0)) {
        rfalse;
    }
    rtrue;
];
[ TEXT_TY_Hash txt rv len i p cp;
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (rv = 0);
    (len = BlkValueLBCapacity(txt));
    for ((i = 0):(i < len):(i)++) {
        (rv = ((rv*33) + BlkValueRead(txt, i)));
    }
    TEXT_TY_Untransmute(txt, p, cp);
    return rv;
];
[ TEXT_TY_Say txt ch i dsize;
    if ((txt == 0)) {
        rfalse;
    }
    if (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        return PrintI6Text((txt-->(1)));
    }
    (dsize = BlkValueLBCapacity(txt));
    for ((i = 0):(i < dsize):(i)++) {
        (ch = BlkValueRead(txt, i));
        if ((ch == 0)) {
            break;
        }
        @streamunichar ch;
    }
    if ((i == 0)) {
        rfalse;
    }
    rtrue;
];
[ TEXT_TY_Say_Capitalised txt mod rc;
    (mod = BlkValueCreate(TEXT_TY));
    TEXT_TY_SubstitutedForm(mod, txt);
    if ((TEXT_TY_CharacterLength(mod) > 0)) {
        BlkValueWrite(mod, 0, CharToCase(BlkValueRead(mod, 0), 1));
        TEXT_TY_Say(mod);
        (rc = 1);
        (say__p = 1);
    }
    BlkValueFree(mod);
    return rc;
];
[ TEXT_TY_WriteFile txt len pos ch p cp;
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (len = BlkValueLBCapacity(txt));
    print "S";
    for ((pos = 0):(pos <= len):(pos)++) {
        if ((pos == len)) {
            (ch = 0);
        } else {
            (ch = BlkValueRead(txt, pos));
        }
        if ((ch == 0)) {
            print "0;";
            break;
        } else {
            print ch;
            print ",";
        }
    }
    TEXT_TY_Untransmute(txt, p, cp);
];
[ TEXT_TY_ReadFile txt auxf ch i v dg pos tsize p;
    TEXT_TY_Transmute(txt);
    (tsize = BlkValueLBCapacity(txt));
    while ((ch ~= 32 or 9 or 10 or 13 or 0 or -1)) {
        (ch = FileIO_GetC(auxf));
        if ((ch == 44 or 59)) {
            if (((pos + 1) >= tsize)) {
                if ((BlkValueSetLBCapacity(txt, (2*pos)) == 0)) {
                    break;
                }
                (tsize = BlkValueLBCapacity(txt));
            }
            BlkValueWrite(txt, (pos)++, v);
            (v = 0);
            if ((ch == 59)) {
                break;
            }
        } else {
            (dg = (ch - 48));
            (v = ((v*10) + dg));
        }
    }
    BlkValueWrite(txt, pos, 0);
    return txt;
];
[ TEXT_TY_SubstitutedForm to txt;
    if (txt) {
        BlkValueCopy(to, txt);
        TEXT_TY_Transmute(to);
    }
    return to;
];
[ TEXT_TY_IsSubstituted txt;
    if (((((txt) && (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)))) && (((txt-->(1)) ofclass Routine)))) {
        rfalse;
    }
    rtrue;
];
[ TEXT_TY_ExpandIfPerishable to from;
    if (((from) && (((from-->(0)) == CONSTANT_PERISHABLE_TEXT_STORAGE)))) {
        return TEXT_TY_SubstitutedForm(to, from);
    }
    return from;
];
[ TEXT_TY_BlobAccess txt blobtype ctxt wanted rtxt p1 p2 cp1 cp2 r;
    if ((txt == 0)) {
        rfalse;
    }
    if ((blobtype == CHR_BLOB)) {
        return TEXT_TY_CharacterLength(txt);
    }
    (cp1 = (txt-->(0)));
    (p1 = TEXT_TY_Temporarily_Transmute(txt));
    (cp2 = (rtxt-->(0)));
    (p2 = TEXT_TY_Temporarily_Transmute(rtxt));
    TEXT_TY_Transmute(ctxt);
    if (ctxt) {
        BlkMakeMutable(ctxt);
    }
    (r = TEXT_TY_BlobAccessI(txt, blobtype, ctxt, wanted, rtxt));
    TEXT_TY_Untransmute(txt, p1, cp1);
    TEXT_TY_Untransmute(rtxt, p2, cp2);
    return r;
];
[ TEXT_TY_BlobAccessI txt blobtype ctxt wanted rtxt brm oldbrm ch i dsize blobcount gp cl j;
    (dsize = BlkValueLBCapacity(txt));
    if (((rtxt) && ((ctxt == 0)))) {
        print "*** rtxt without ctxt ***";
        new_line;
        rtrue;
    }
    (brm = WS_BRM);
    for ((i = 0):(i < dsize):(i)++) {
        (ch = BlkValueRead(txt, i));
        if ((ch == 0)) {
            break;
        }
        (oldbrm = brm);
        if ((ch == 10 or 13 or 32 or 9)) {
            if ((oldbrm ~= WS_BRM)) {
                (gp = 0);
                for ((j = i):(j < dsize):(j)++) {
                    (ch = BlkValueRead(txt, j));
                    if ((ch == 0)) {
                        (brm = WS_BRM);
                        break;
                    }
                    if ((ch == 10 or 13)) {
                        (gp)++;
                        continue;
                    }
                    if ((ch ~= 32 or 9)) {
                        break;
                    }
                }
                (ch = BlkValueRead(txt, i));
                if ((j == dsize)) {
                    (brm = WS_BRM);
                }
                switch (blobtype) {
                    PARA_BLOB:
                        if ((gp >= 2)) {
                            (brm = WS_BRM);
                        }
                        ;
                    LINE_BLOB:
                        if ((gp >= 1)) {
                            (brm = WS_BRM);
                        }
                        ;
                    default:
                        (brm = WS_BRM);
                        ;
                }
            }
        } else {
            (gp = 0);
            if ((((blobtype == WORD_BLOB or PWORD_BLOB or UWORD_BLOB)) && ((ch == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                (gp = 1);
            }
            switch (oldbrm) {
                WS_BRM:
                    (brm = ACCEPTED_BRM);
                    if ((blobtype == WORD_BLOB)) {
                        if (gp) {
                            (brm = SKIPPED_BRM);
                        }
                    }
                    if ((blobtype == PWORD_BLOB)) {
                        if (gp) {
                            (brm = ACCEPTEDP_BRM);
                        }
                    }
                    ;
                SKIPPED_BRM:
                    if ((blobtype == WORD_BLOB)) {
                        if ((gp == 0)) {
                            (brm = ACCEPTED_BRM);
                        }
                    }
                    ;
                ACCEPTED_BRM:
                    if ((blobtype == WORD_BLOB)) {
                        if (gp) {
                            (brm = SKIPPED_BRM);
                        }
                    }
                    if ((blobtype == PWORD_BLOB)) {
                        if (gp) {
                            (brm = ACCEPTEDP_BRM);
                        }
                    }
                    ;
                ACCEPTEDP_BRM:
                    if ((blobtype == PWORD_BLOB)) {
                        if ((gp == 0)) {
                            (brm = ACCEPTED_BRM);
                        } else {
                            if ((((ch == BlkValueRead(txt, (i - 1)))) && ((ch == 45 or 46)))) {
                                (blobcount)--;
                            }
                            (blobcount)++;
                        }
                    }
                    ;
                ACCEPTEDN_BRM:
                    if ((blobtype == WORD_BLOB)) {
                        if (gp) {
                            (brm = SKIPPED_BRM);
                        }
                    }
                    if ((blobtype == PWORD_BLOB)) {
                        if (gp) {
                            (brm = ACCEPTEDP_BRM);
                        }
                    }
                    ;
                ACCEPTEDPN_BRM:
                    if ((blobtype == PWORD_BLOB)) {
                        if ((gp == 0)) {
                            (brm = ACCEPTED_BRM);
                        } else {
                            if ((((ch == BlkValueRead(txt, (i - 1)))) && ((ch == 45 or 46)))) {
                                (blobcount)--;
                            }
                            (blobcount)++;
                        }
                    }
                    ;
            }
        }
        if ((brm == ACCEPTED_BRM or ACCEPTEDP_BRM)) {
            if ((oldbrm ~= brm)) {
                (blobcount)++;
            }
            if (((ctxt) && ((blobcount == wanted)))) {
                if (rtxt) {
                    if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
                        if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                            break;
                        }
                    }
                    BlkValueWrite(ctxt, cl, 0);
                    TEXT_TY_Concatenate(ctxt, rtxt, CHR_BLOB);
                    (cl = TEXT_TY_CharacterLength(ctxt));
                    if ((brm == ACCEPTED_BRM)) {
                        (brm = ACCEPTEDN_BRM);
                    }
                    if ((brm == ACCEPTEDP_BRM)) {
                        (brm = ACCEPTEDPN_BRM);
                    }
                } else {
                    if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
                        if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                            break;
                        }
                    }
                    BlkValueWrite(ctxt, (cl)++, ch);
                }
            } else {
                if (rtxt) {
                    if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
                        if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                            break;
                        }
                    }
                    BlkValueWrite(ctxt, (cl)++, ch);
                }
            }
        } else {
            if (((rtxt) && ((brm ~= ACCEPTEDN_BRM or ACCEPTEDPN_BRM)))) {
                if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
                    if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                        break;
                    }
                }
                BlkValueWrite(ctxt, (cl)++, ch);
            }
        }
    }
    if (ctxt) {
        if (((cl + 1) >= BlkValueLBCapacity(ctxt))) {
            BlkValueSetLBCapacity(ctxt, (2*cl));
        }
        BlkValueWrite(ctxt, (cl)++, 0);
    }
    return blobcount;
];
[ TEXT_TY_GetBlob ctxt txt wanted blobtype;
    if ((txt == 0)) {
        rtrue;
    }
    if ((blobtype == CHR_BLOB)) {
        return TEXT_TY_GetCharacter(ctxt, txt, wanted);
    }
    TEXT_TY_BlobAccess(txt, blobtype, ctxt, wanted);
    return ctxt;
];
[ TEXT_TY_ReplaceBlob blobtype txt wanted rtxt ctxt ilen rlen i p cp;
    TEXT_TY_Transmute(txt);
    (cp = (rtxt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(rtxt));
    if ((blobtype == CHR_BLOB)) {
        (ilen = TEXT_TY_CharacterLength(txt));
        (rlen = TEXT_TY_CharacterLength(rtxt));
        (wanted)--;
        if ((((wanted >= 0)) && ((wanted < ilen)))) {
            if ((rlen == 1)) {
                BlkValueWrite(txt, wanted, BlkValueRead(rtxt, 0));
            } else {
                (ctxt = BlkValueCreate(TEXT_TY));
                TEXT_TY_Transmute(ctxt);
                if (BlkValueSetLBCapacity(ctxt, ((ilen + rlen) + 1))) {
                    for ((i = 0):(i < wanted):(i)++) {
                        BlkValueWrite(ctxt, i, BlkValueRead(txt, i));
                    }
                    for ((i = 0):(i < rlen):(i)++) {
                        BlkValueWrite(ctxt, (wanted + i), BlkValueRead(rtxt, i));
                    }
                    for ((i = (wanted + 1)):(i < ilen):(i)++) {
                        BlkValueWrite(ctxt, ((rlen + i) - 1), BlkValueRead(txt, i));
                    }
                    BlkValueWrite(ctxt, (rlen + ilen), 0);
                    BlkValueCopy(txt, ctxt);
                }
                BlkValueFree(ctxt);
            }
        }
    } else {
        (ctxt = BlkValueCreate(TEXT_TY));
        TEXT_TY_BlobAccess(txt, blobtype, ctxt, wanted, rtxt);
        BlkValueCopy(txt, ctxt);
        BlkValueFree(ctxt);
    }
    TEXT_TY_Untransmute(rtxt, p, cp);
];
[ TEXT_TY_ReplaceText blobtype txt ftxt rtxt r p1 p2 cp1 cp2;
    TEXT_TY_Transmute(txt);
    (cp1 = (ftxt-->(0)));
    (p1 = TEXT_TY_Temporarily_Transmute(ftxt));
    (cp2 = (rtxt-->(0)));
    (p2 = TEXT_TY_Temporarily_Transmute(rtxt));
    (r = TEXT_TY_ReplaceTextI(blobtype, txt, ftxt, rtxt));
    TEXT_TY_Untransmute(ftxt, p1, cp1);
    TEXT_TY_Untransmute(rtxt, p2, cp2);
    return r;
];
[ TEXT_TY_ReplaceTextI blobtype txt ftxt rtxt ctxt csize ilen flen i cl mpos ch chm whitespace punctuation;
    if ((blobtype == REGEXP_BLOB or CHR_BLOB)) {
        return TEXT_TY_Replace_RE(blobtype, txt, ftxt, rtxt);
    }
    (ilen = TEXT_TY_CharacterLength(txt));
    (flen = TEXT_TY_CharacterLength(ftxt));
    (ctxt = BlkValueCreate(TEXT_TY));
    TEXT_TY_Transmute(ctxt);
    (csize = BlkValueLBCapacity(ctxt));
    (mpos = 0);
    (whitespace = 1);
    (punctuation = 0);
    for ((i = 0):(i <= ilen):(i)++) {
        (ch = BlkValueRead(txt, i));
        (chm = BlkValueRead(ftxt, (mpos)++));
        if ((mpos == 1)) {
            switch (blobtype) {
                WORD_BLOB:
                    if ((((whitespace == 0)) && ((punctuation == 0)))) {
                        (chm = -1);
                    }
                    ;
            }
        }
        (whitespace = 0);
        if ((ch == 10 or 13 or 32 or 9)) {
            (whitespace = 1);
        }
        (punctuation = 0);
        if ((ch == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
            if ((blobtype == WORD_BLOB)) {
                (chm = -1);
            }
            (punctuation = 1);
        }
        if ((ch == chm)) {
            if ((mpos == flen)) {
                if ((i == ilen)) {
                    (chm = 0);
                } else {
                    (chm = BlkValueRead(txt, (i + 1)));
                }
                if ((((((blobtype == CHR_BLOB)) || ((chm == 0 or 10 or 13 or 32 or 9)))) || ((chm == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                    (mpos = 0);
                    (cl = (cl - (flen - 1)));
                    BlkValueWrite(ctxt, cl, 0);
                    TEXT_TY_Concatenate(ctxt, rtxt, CHR_BLOB);
                    (csize = BlkValueLBCapacity(ctxt));
                    (cl = TEXT_TY_CharacterLength(ctxt));
                    continue;
                }
            }
        } else {
            (mpos = 0);
        }
        if (((cl + 1) >= csize)) {
            if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                break;
            }
            (csize = BlkValueLBCapacity(ctxt));
        }
        BlkValueWrite(ctxt, (cl)++, ch);
    }
    BlkValueCopy(txt, ctxt);
    BlkValueFree(ctxt);
];
[ TEXT_TY_CharacterLength txt ch i dsize p cp r;
    if ((txt == 0)) {
        rfalse;
    }
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (dsize = BlkValueLBCapacity(txt));
    (r = dsize);
    for ((i = 0):(i < dsize):(i)++) {
        (ch = BlkValueRead(txt, i));
        if ((ch == 0)) {
            (r = i);
            break;
        }
    }
    TEXT_TY_Untransmute(txt, p, cp);
    return r;
];
[ TEXT_TY_Empty txt;
    if ((txt == 0)) {
        rtrue;
    }
    if (((((txt-->(0)))&(BLK_BVBITMAP_LONGBLOCKMASK)) == 0)) {
        if (((txt-->(1)) == EMPTY_TEXT_PACKED)) {
            rtrue;
        }
        rfalse;
    }
    if ((TEXT_TY_CharacterLength(txt) == 0)) {
        rtrue;
    }
    rfalse;
];
[ TEXT_TY_GetCharacter ctxt txt i ch p cp;
    if ((txt == 0)) {
        rfalse;
    }
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    TEXT_TY_Transmute(ctxt);
    if ((((i <= 0)) || ((i > TEXT_TY_CharacterLength(txt))))) {
        (ch = 0);
    } else {
        (ch = BlkValueRead(txt, (i - 1)));
    }
    BlkValueWrite(ctxt, 0, ch);
    BlkValueWrite(ctxt, 1, 0);
    TEXT_TY_Untransmute(txt, p, cp);
    return ctxt;
];
[ TEXT_TY_CharactersOfCase txt case i ch len p cp r;
    if ((txt == 0)) {
        rfalse;
    }
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (len = TEXT_TY_CharacterLength(txt));
    (r = 1);
    for ((i = 0):(i < len):(i)++) {
        (ch = BlkValueRead(txt, i));
        if (((ch) && ((CharIsOfCase(ch, case) == 0)))) {
            (r = 0);
            break;
        }
    }
    TEXT_TY_Untransmute(txt, p, cp);
    return r;
];
[ TEXT_TY_CharactersToCase ctxt txt case i ch len bnd pk cp;
    if ((txt == 0)) {
        rfalse;
    }
    (cp = (txt-->(0)));
    (pk = TEXT_TY_Temporarily_Transmute(txt));
    TEXT_TY_Transmute(ctxt);
    (len = TEXT_TY_CharacterLength(txt));
    if (BlkValueSetLBCapacity(ctxt, (len + 1))) {
        (bnd = 1);
        for ((i = 0):(i < len):(i)++) {
            (ch = BlkValueRead(txt, i));
            if ((case < 2)) {
                BlkValueWrite(ctxt, i, CharToCase(ch, case));
            } else {
                BlkValueWrite(ctxt, i, CharToCase(ch, bnd));
                if ((case == 2)) {
                    (bnd = 0);
                    if ((ch == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                        (bnd = 1);
                    }
                }
                if ((case == 3)) {
                    if ((ch ~= 0 or 10 or 13 or 32 or 9)) {
                        if ((bnd == 1)) {
                            (bnd = 0);
                        } else {
                            if ((ch == 46 or 33 or 63)) {
                                (bnd = 1);
                            }
                        }
                    }
                }
            }
        }
        BlkValueWrite(ctxt, len, 0);
    }
    TEXT_TY_Untransmute(txt, pk, cp);
    return ctxt;
];
[ TEXT_TY_Concatenate to_txt from_txt blobtype ref_txt p cp r;
    if ((to_txt == 0)) {
        rfalse;
    }
    if ((from_txt == 0)) {
        return to_txt;
    }
    TEXT_TY_Transmute(to_txt);
    (cp = (from_txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(from_txt));
    (r = TEXT_TY_ConcatenateI(to_txt, from_txt, blobtype, ref_txt));
    TEXT_TY_Untransmute(from_txt, p, cp);
    return r;
];
[ TEXT_TY_ConcatenateI to_txt from_txt blobtype ref_txt pos len ch i tosize x y case;
    switch (blobtype) {
        CHR_BLOB, 0:
            (pos = TEXT_TY_CharacterLength(to_txt));
            (len = TEXT_TY_CharacterLength(from_txt));
            if ((BlkValueSetLBCapacity(to_txt, ((pos + len) + 1)) == 0)) {
                return to_txt;
            }
            for ((i = 0):(i < len):(i)++) {
                (ch = BlkValueRead(from_txt, i));
                BlkValueWrite(to_txt, (i + pos), ch);
            }
            BlkValueWrite(to_txt, (len + pos), 0);
            return to_txt;
            ;
        REGEXP_BLOB:
            return TEXT_TY_RE_Concatenate(to_txt, from_txt, blobtype, ref_txt);
            ;
    }
    print "*** TEXT_TY_Concatenate used on impossible blob type ***^";
    rfalse;
];
[ CharIsOfCase c case i tab min max len par;
    if ((c < 65)) {
        rfalse;
    }
    if ((case == 0)) {
        if ((((c >= 97)) && ((c <= 122)))) {
            rtrue;
        }
        (tab = CharCasingChart0);
    } else {
        if ((((c >= 65)) && ((c <= 90)))) {
            rtrue;
        }
        (tab = CharCasingChart1);
    }
    if ((c < 128)) {
        rfalse;
    }
    while ((tab-->(i))) {
        (min = (tab-->(i)));
        (i)++;
        (len = (tab-->(i)));
        (i)++;
        (i)++;
        (par = 0);
        if ((len < 0)) {
            (par = 1);
            (len = (-(len)));
        }
        if ((c < min)) {
            rfalse;
        }
        if ((c < (min + len))) {
            if (par) {
                if ((((c - min)%2) == 0)) {
                    rtrue;
                }
            } else {
                rtrue;
            }
        }
    }
    rfalse;
];
[ CharToCase c case i tab min max len par del f;
    if ((c < 65)) {
        return c;
    }
    if ((case == 1)) {
        if ((((c >= 97)) && ((c <= 122)))) {
            return (c - 32);
        }
        (tab = CharCasingChart0);
    } else {
        if ((((c >= 65)) && ((c <= 90)))) {
            return (c + 32);
        }
        (tab = CharCasingChart1);
    }
    if ((c < 128)) {
        return c;
    }
    while ((tab-->(i))) {
        (min = (tab-->(i)));
        (i)++;
        (len = (tab-->(i)));
        (i)++;
        (del = (tab-->(i)));
        (i)++;
        (par = 0);
        if ((len < 0)) {
            (par = 1);
            (len = (-(len)));
        }
        if ((c < min)) {
            return c;
        }
        if ((c < (min + len))) {
            (f = 0);
            if (par) {
                if ((((c - min)%2) == 0)) {
                    (f = 1);
                }
            } else {
                (f = 1);
            }
            if (f) {
                if ((del == UNIC_NCT)) {
                    return c;
                }
                return (c + del);
            }
        }
    }
    return c;
];
[ TEXT_TY_RevCase ch;
    if ((ch < 65)) {
        return ch;
    }
    if ((((ch >= 97)) && ((ch <= 122)))) {
        return ((ch - 97) + 65);
    }
    if ((((ch >= 65)) && ((ch <= 90)))) {
        return ((ch - 65) + 97);
    }
    if ((ch < 128)) {
        return ch;
    }
    if (CharIsOfCase(ch, 0)) {
        return CharToCase(ch, 1);
    }
    if (CharIsOfCase(ch, 1)) {
        return CharToCase(ch, 0);
    }
    return ch;
];
[ DigitToValue c n;
    (n = (c - 48));
    if ((((n < 0)) || ((n > 9)))) {
        return (-(1));
    }
    return n;
];
[ CharTestCases case i j;
    for ((i = 32):(i < 224):(i)++) {
        if ((((i >= 127)) && ((i < 155)))) {
            continue;
        }
        print i;
        print " - ";
        print (char) i;
        print " -";
        if (CharIsOfCase(i, 0)) {
            print "  lower";
        }
        if (CharIsOfCase(i, 1)) {
            print "  upper";
        }
        (j = CharToCase(i, 0));
        if ((j ~= i)) {
            print "  tolower: ";
            print (char) j;
        }
        (j = CharToCase(i, 1));
        if ((j ~= i)) {
            print "  toupper: ";
            print (char) j;
        }
        print "^";
    }
];
[ TEXT_TY_RE_SetTrace F;
    (TEXT_TY_RE_Trace = F);
];
[ TEXT_TY_RE_Node n cc par1 par2 par3 offset;
    if ((((n < 0)) || ((n >= RE_MAX_PACKETS)))) {
        rfalse;
    }
    (offset = (RE_PACKET_space + (n*RE_PACKET_SIZE_IN_BYTES)));
    ((offset-->(RE_CCLASS)) = cc);
    ((offset-->(RE_PAR1)) = par1);
    ((offset-->(RE_PAR2)) = par2);
    ((offset-->(RE_PAR3)) = par3);
    ((offset-->(RE_NEXT)) = NULL);
    ((offset-->(RE_PREVIOUS)) = NULL);
    ((offset-->(RE_DOWN)) = NULL);
    ((offset-->(RE_UP)) = NULL);
    ((offset-->(RE_DATA1)) = -1);
    ((offset-->(RE_DATA2)) = -1);
    ((offset-->(RE_CONSTRAINT)) = -1);
    return offset;
];
[ TEXT_TY_RE_NodeAddress n;
    if ((((n < 0)) || ((n >= RE_MAX_PACKETS)))) {
        return (-(1));
    }
    return (RE_PACKET_space + (n*RE_PACKET_SIZE_IN_BYTES));
];
[ TEXT_TY_RE_DebugMatchVars txt offset n i;
    print (RE_Subexpressions-->(10));
    print " collecting subexps^";
    for ((n = 0):(((n < (RE_Subexpressions-->(10)))) && ((n < 10))):(n)++) {
        (offset = (RE_Subexpressions-->(n)));
        print "Subexp ";
        print (offset-->(RE_PAR1));
        print " = [";
        print (offset-->(RE_DATA1));
        print ",";
        print (offset-->(RE_DATA2));
        print "] = ";
        for ((i = (offset-->(RE_DATA1))):(i < (offset-->(RE_DATA2))):(i)++) {
            print (char) BlkValueRead(txt, i);
        }
        print "^";
    }
];
[ TEXT_TY_RE_CreateMatchVars txt offset n i ch ctxt cl csize;
    for ((n = 0):(((n < (RE_Subexpressions-->(10)))) && ((n < 10))):(n)++) {
        (offset = (RE_Subexpressions-->(n)));
        if ((Allocated_Match_Vars-->(n))) {
            BlkValueFree((Allocated_Match_Vars-->(n)));
        }
        ((Allocated_Match_Vars-->(n)) = BlkValueCreate(TEXT_TY));
        TEXT_TY_Transmute((Allocated_Match_Vars-->(n)));
        (ctxt = (Allocated_Match_Vars-->(n)));
        (csize = BlkValueLBCapacity(ctxt));
        (cl = 0);
        for ((i = (offset-->(RE_DATA1))):(i < (offset-->(RE_DATA2))):(i)++) {
            (ch = BlkValueRead(txt, i));
            if (((cl + 1) >= csize)) {
                if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                    break;
                }
                (csize = BlkValueLBCapacity(ctxt));
            }
            BlkValueWrite(ctxt, (cl)++, ch);
        }
        BlkValueWrite(ctxt, cl, 0);
    }
];
[ TEXT_TY_RE_EmptyMatchVars txt n;
    for ((n = 0):(((n < (RE_Subexpressions-->(10)))) && ((n < 10))):(n)++) {
        if (((Allocated_Match_Vars-->(n)) ~= 0)) {
            BlkValueWrite((Allocated_Match_Vars-->(n)), 0, 0);
        }
    }
];
[ TEXT_TY_RE_GetMatchVar vn offset;
    if ((((((vn < 0)) || ((vn >= 10)))) || ((vn >= (RE_Subexpressions-->(10)))))) {
        return EMPTY_TEXT_VALUE;
    }
    (offset = (RE_Subexpressions-->(vn)));
    if ((offset == 0)) {
        return EMPTY_TEXT_VALUE;
    }
    if (((offset-->(RE_DATA1)) < 0)) {
        return EMPTY_TEXT_VALUE;
    }
    if (((Allocated_Match_Vars-->(vn)) == 0)) {
        print "*** ";
        print vn;
        print " unallocated! ***^";
        return EMPTY_TEXT_VALUE;
    }
    return (Allocated_Match_Vars-->(vn));
];
[ TEXT_TY_MV_End n end offset;
    (offset = (RE_Subexpressions-->(n)));
    if ((end == 0)) {
        return (offset-->(RE_DATA1));
    }
    return (offset-->(RE_DATA2));
];
[ TEXT_TY_RE_Clear_Markers token;
    for (:(token ~= NULL):(token = (token-->(RE_NEXT)))) {
        if (((token-->(RE_DOWN)) ~= NULL)) {
            TEXT_TY_RE_Clear_Markers((token-->(RE_DOWN)));
        }
        ((token-->(RE_DATA1)) = -1);
        ((token-->(RE_DATA2)) = -1);
        ((token-->(RE_CONSTRAINT)) = -1);
    }
];
[ TEXT_TY_RE_DebugTree ftxt detail;
    print "Pattern: ";
    TEXT_TY_Say(ftxt);
    print "^";
    TEXT_TY_RE_DebugSubtree(ftxt, 1, RE_PACKET_space, detail);
];
[ TEXT_TY_RE_DebugSubtree ftxt depth offset detail cup;
    if ((offset ~= NULL)) {
        (cup = (offset-->(RE_UP)));
        if (((offset-->(RE_PREVIOUS)) ~= NULL)) {
            print "*** broken initial previous ***^";
        }
    }
    while ((offset ~= NULL)) {
        if (((offset-->(RE_UP)) ~= cup)) {
            print "*** broken up matching ***^";
        }
        spaces (depth*2);
        TEXT_TY_RE_DebugNode(offset, ftxt, detail);
        if (((offset-->(RE_DOWN)) ~= NULL)) {
            if ((((offset-->(RE_DOWN))-->(RE_UP)) ~= offset)) {
                print "*** broken down/up ***^";
            }
            TEXT_TY_RE_DebugSubtree(ftxt, (depth + 1), (offset-->(RE_DOWN)), detail);
        }
        if (((offset-->(RE_NEXT)) ~= NULL)) {
            if ((((offset-->(RE_NEXT))-->(RE_PREVIOUS)) ~= offset)) {
                print "*** broken next/previous ***^";
            }
        }
        (offset = (offset-->(RE_NEXT)));
    }
];
[ TEXT_TY_RE_DebugNode offset ftxt detail i par1 par2 par3;
    if ((offset == NULL)) {
        print "[NULL]";
        new_line;
        rtrue;
    }
    print "[";
    print ((offset - RE_PACKET_space)/RE_PACKET_SIZE_IN_BYTES);
    print "] ";
    (par1 = (offset-->(RE_PAR1)));
    (par2 = (offset-->(RE_PAR2)));
    (par3 = (offset-->(RE_PAR3)));
    switch ((offset-->(RE_CCLASS))) {
        DIGIT_RE_CC:
            print "DIGIT";
            ;
        NONDIGIT_RE_CC:
            print "NONDIGIT";
            ;
        UCASE_RE_CC:
            print "UCASE";
            ;
        NONUCASE_RE_CC:
            print "NONUCASE";
            ;
        LCASE_RE_CC:
            print "LCASE";
            ;
        NONLCASE_RE_CC:
            print "NONLCASE";
            ;
        WHITESPACE_RE_CC:
            print "WHITESPACE";
            ;
        NONWHITESPACE_RE_CC:
            print "NONWHITESPACE";
            ;
        PUNCTUATION_RE_CC:
            print "PUNCTUATION";
            ;
        NONPUNCTUATION_RE_CC:
            print "NONPUNCTUATION";
            ;
        WORD_RE_CC:
            print "WORD";
            ;
        NONWORD_RE_CC:
            print "NONWORD";
            ;
        ALWAYS_RE_CC:
            print "ALWAYS";
            ;
        NEVER_RE_CC:
            print "NEVER";
            ;
        START_RE_CC:
            print "START";
            ;
        END_RE_CC:
            print "END";
            ;
        BOUNDARY_RE_CC:
            print "BOUNDARY";
            ;
        NONBOUNDARY_RE_CC:
            print "NONBOUNDARY";
            ;
        ANYTHING_RE_CC:
            print "ANYTHING";
            ;
        NOTHING_RE_CC:
            print "NOTHING";
            ;
        RANGE_RE_CC:
            print "RANGE";
            if ((par3 == 1)) {
                print " (negated)";
            }
            print " ";
            for ((i = par1):(i < par2):(i)++) {
                print (char) BlkValueRead(ftxt, i);
            }
            ;
        VARIABLE_RE_CC:
            print "VARIABLE ";
            print par1;
            ;
        SUBEXP_RE_CC:
            if ((par1 == 0)) {
                print "EXP";
            } else {
                print "SUBEXP ";
            }
            if ((par1 >= 0)) {
                print "= V";
                print par1;
            }
            if ((par2 == 1)) {
                if ((par3 == 0)) {
                    print " (?=...) lookahead";
                } else {
                    print " (?<=...) lookbehind of width ";
                    print par3;
                }
            }
            if ((par2 == 2)) {
                if ((par3 == 0)) {
                    print " (?!...) negated lookahead";
                } else {
                    print " (?<!...) negated lookbehind of width ";
                    print par3;
                }
            }
            if ((par2 == 3)) {
                print " uncollecting";
            }
            if ((par2 == 0 or 3)) {
                if ((par3 == 1)) {
                    print " forcing case sensitivity";
                }
                if ((par3 == 2)) {
                    print " forcing case insensitivity";
                }
            }
            if ((par2 == 4)) {
                print " (?>...) possessive";
            }
            ;
        NEWLINE_RE_CC:
            print "NEWLINE";
            ;
        TAB_RE_CC:
            print "TAB";
            ;
        QUANTIFIER_RE_CC:
            print "QUANTIFIER min=";
            print par1;
            print " max=";
            print par2;
            if (par3) {
                print " (lazy)";
            } else {
                print " (greedy)";
            }
            ;
        LITERAL_RE_CC:
            print "LITERAL";
            print " ";
            for ((i = par1):(i < par2):(i)++) {
                print (char) BlkValueRead(ftxt, i);
            }
            ;
        DISJUNCTION_RE_CC:
            print "DISJUNCTION of ";
            print par1;
            print " choices";
            ;
        CHOICE_RE_CC:
            print "CHOICE no ";
            print par1;
            ;
        SENSITIVITY_RE_CC:
            print "SENSITIVITY";
            if (par1) {
                print " off";
            } else {
                print " on";
            }
            ;
        IF_RE_CC:
            print "IF";
            if ((par1 >= 1)) {
                print " = V";
                print par1;
            }
            ;
        CONDITION_RE_CC:
            print "CONDITION";
            if ((par1 >= 1)) {
                print " = V";
                print par1;
            }
            ;
        THEN_RE_CC:
            print "THEN";
            ;
        ELSE_RE_CC:
            print "ELSE";
            ;
    }
    if (detail) {
        print ": ";
        print (offset-->(RE_DATA1));
        print ", ";
        print (offset-->(RE_DATA2));
        print ", ";
        print (offset-->(RE_CONSTRAINT));
    }
    print "^";
];
[ TEXT_TY_CHR_CompileTree ftxt exactly root literal fto no_packets token attach_to;
    (fto = TEXT_TY_CharacterLength(ftxt));
    (root = TEXT_TY_RE_Node(0, SUBEXP_RE_CC, 0, 0, 0));
    (literal = TEXT_TY_RE_Node(1, LITERAL_RE_CC, 0, fto, 0));
    ((root-->(RE_DOWN)) = literal);
    ((literal-->(RE_UP)) = root);
    if (exactly) {
        (no_packets = 2);
        if (((no_packets + 3) > RE_MAX_PACKETS)) {
            return "regexp too complex";
        }
        (exactly = (RE_PACKET_space-->(RE_DOWN)));
        (token = TEXT_TY_RE_Node((no_packets)++, START_RE_CC, 0, 0, 0));
        ((RE_PACKET_space-->(RE_DOWN)) = token);
        ((token-->(RE_UP)) = RE_PACKET_space);
        (attach_to = TEXT_TY_RE_Node((no_packets)++, SUBEXP_RE_CC, (-(1)), 3, 0));
        ((token-->(RE_NEXT)) = attach_to);
        ((attach_to-->(RE_PREVIOUS)) = token);
        ((attach_to-->(RE_UP)) = RE_PACKET_space);
        ((attach_to-->(RE_NEXT)) = TEXT_TY_RE_Node((no_packets)++, END_RE_CC, 0, 0, 0));
        (((attach_to-->(RE_NEXT))-->(RE_PREVIOUS)) = attach_to);
        (((attach_to-->(RE_NEXT))-->(RE_UP)) = RE_PACKET_space);
        ((attach_to-->(RE_DOWN)) = exactly);
        while ((exactly ~= NULL)) {
            ((exactly-->(RE_UP)) = attach_to);
            (exactly = (exactly-->(RE_NEXT)));
        }
    }
    (no_packets = TEXT_TY_RE_ExpandChoices(RE_PACKET_space, no_packets));
];
[ TEXT_TY_RE_CompileTree ftxt exactly no_packets ffrom fto cc par1 par2 par3 quantifiable token attach_to no_subs blevel bits;
    (fto = TEXT_TY_CharacterLength(ftxt));
    if ((fto == 0)) {
        TEXT_TY_RE_Node((no_packets)++, NEVER_RE_CC, 0, 0, 0);
        rtrue;
    }
    (attach_to = TEXT_TY_RE_Node((no_packets)++, SUBEXP_RE_CC, 0, 0, 0));
    ((RE_Subexpressions-->(0)) = attach_to);
    ((RE_Subexpressions-->(10)) = 1);
    (no_subs = 1);
    (quantifiable = 0);
    (blevel = 0);
    for ((ffrom = 0):(ffrom < fto):) {
        (cc = BlkValueRead(ftxt, (ffrom)++));
        (par1 = 0);
        (par2 = 0);
        (par3 = 0);
        if ((cc == 92)) {
            if ((ffrom == fto)) {
                return "Search pattern not terminated";
            }
            (cc = BlkValueRead(ftxt, (ffrom)++));
            switch (cc) {
                98:
                    (cc = BOUNDARY_RE_CC);
                    ;
                66:
                    (cc = NONBOUNDARY_RE_CC);
                    ;
                100:
                    (cc = DIGIT_RE_CC);
                    ;
                68:
                    (cc = NONDIGIT_RE_CC);
                    ;
                108:
                    (cc = LCASE_RE_CC);
                    ;
                76:
                    (cc = NONLCASE_RE_CC);
                    ;
                110:
                    (cc = NEWLINE_RE_CC);
                    ;
                112:
                    (cc = PUNCTUATION_RE_CC);
                    ;
                80:
                    (cc = NONPUNCTUATION_RE_CC);
                    ;
                115:
                    (cc = WHITESPACE_RE_CC);
                    ;
                83:
                    (cc = NONWHITESPACE_RE_CC);
                    ;
                116:
                    (cc = TAB_RE_CC);
                    ;
                117:
                    (cc = UCASE_RE_CC);
                    ;
                85:
                    (cc = NONUCASE_RE_CC);
                    ;
                119:
                    (cc = WORD_RE_CC);
                    ;
                87:
                    (cc = NONWORD_RE_CC);
                    ;
                default:
                    if ((((cc >= 49)) && ((cc <= 57)))) {
                        (par1 = (cc - 48));
                        (cc = VARIABLE_RE_CC);
                    } else {
                        if ((((((cc >= 97)) && ((cc <= 122)))) || ((((cc >= 65)) && ((cc <= 90)))))) {
                            return "unknown escape";
                        }
                        (cc = LITERAL_RE_CC);
                        (par1 = (ffrom - 1));
                        (par2 = ffrom);
                    }
                    ;
            }
            (quantifiable = 1);
        } else {
            switch (cc) {
                40:
                    (par2 = 0);
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (bits = 1);
                        if ((BlkValueRead(ftxt, ffrom) == 45)) {
                            (ffrom)++;
                            (bits = 0);
                        } else {
                            if ((BlkValueRead(ftxt, ffrom) == 60)) {
                                (ffrom)++;
                                (bits = 0);
                            }
                        }
                        switch ((cc = BlkValueRead(ftxt, (ffrom)++))) {
                            35:
                                while ((BlkValueRead(ftxt, (ffrom)++) ~= 0 or 41)) {
                                }
                                if ((BlkValueRead(ftxt, (ffrom - 1)) == 0)) {
                                    return "comment never ends";
                                }
                                continue;
                                ;
                            40:
                                (cc = BlkValueRead(ftxt, ffrom));
                                if ((((cc == 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)) && ((BlkValueRead(ftxt, (ffrom + 1)) == 41)))) {
                                    (ffrom = (ffrom + 2));
                                    (par1 = (cc - 48));
                                } else {
                                    (ffrom)--;
                                }
                                (cc = IF_RE_CC);
                                (quantifiable = 0);
                                if ((blevel == 20)) {
                                    return "subexpressions too deep";
                                }
                                ((Subexp_Posns-->((blevel)++)) = TEXT_TY_RE_NodeAddress(no_packets));
                                jump CClassKnown;
                                ;
                            61:
                                (par2 = 1);
                                (par3 = 0);
                                if ((bits == 0)) {
                                    (par3 = -1);
                                }
                                ;
                            33:
                                (par2 = 2);
                                (par3 = 0);
                                if ((bits == 0)) {
                                    (par3 = -1);
                                }
                                ;
                            58:
                                (par2 = 3);
                                ;
                            62:
                                (par2 = 4);
                                ;
                            default:
                                if ((BlkValueRead(ftxt, ffrom) == 41)) {
                                    if ((cc == 105)) {
                                        (cc = SENSITIVITY_RE_CC);
                                        (par1 = bits);
                                        (ffrom)++;
                                        jump CClassKnown;
                                    }
                                }
                                if ((BlkValueRead(ftxt, ffrom) == 58)) {
                                    if ((cc == 105)) {
                                        (par1 = bits);
                                        (par2 = 3);
                                        (par3 = (bits + 1));
                                        (ffrom)++;
                                        jump AllowForm;
                                    }
                                }
                                return "unknown (?...) form";
                                ;
                        }
                    }
                    .AllowForm;
                    if ((par2 == 0)) {
                        (par1 = (no_subs)++);
                    } else {
                        (par1 = -1);
                    }
                    (cc = SUBEXP_RE_CC);
                    (quantifiable = 0);
                    if ((blevel == 20)) {
                        return "subexpressions too deep";
                    }
                    ((Subexp_Posns-->((blevel)++)) = TEXT_TY_RE_NodeAddress(no_packets));
                    ;
                41:
                    if ((blevel == 0)) {
                        return "subexpression bracket mismatch";
                    }
                    (blevel)--;
                    (attach_to = (Subexp_Posns-->(blevel)));
                    if (((attach_to-->(RE_DOWN)) == NULL)) {
                        if ((no_packets >= RE_MAX_PACKETS)) {
                            return "regexp too complex";
                        }
                        ((attach_to-->(RE_DOWN)) = TEXT_TY_RE_Node((no_packets)++, ALWAYS_RE_CC, 0, 0, 0));
                        (((attach_to-->(RE_DOWN))-->(RE_UP)) = attach_to);
                    }
                    (quantifiable = 1);
                    continue;
                    ;
                46:
                    (cc = ANYTHING_RE_CC);
                    (quantifiable = 1);
                    ;
                124:
                    (cc = CHOICE_RE_CC);
                    (quantifiable = 0);
                    ;
                94:
                    (cc = START_RE_CC);
                    (quantifiable = 0);
                    ;
                36:
                    (cc = END_RE_CC);
                    (quantifiable = 0);
                    ;
                123:
                    if ((quantifiable == 0)) {
                        return "quantifier misplaced";
                    }
                    (par1 = 0);
                    (par2 = -1);
                    (bits = 1);
                    while (((cc = BlkValueRead(ftxt, (ffrom)++)) ~= 0 or 125)) {
                        if ((cc == 44)) {
                            (bits)++;
                            if ((bits >= 3)) {
                                return "too many colons in ?{...}";
                            }
                            continue;
                        }
                        if ((((cc >= 48)) || ((cc <= 57)))) {
                            if ((bits == 1)) {
                                if ((par1 < 0)) {
                                    (par1 = 0);
                                }
                                (par1 = ((par1*10) + (cc - 48)));
                            } else {
                                if ((par2 < 0)) {
                                    (par2 = 0);
                                }
                                (par2 = ((par2*10) + (cc - 48)));
                            }
                        } else {
                            return "non-digit in ?{...}";
                        }
                    }
                    if ((cc ~= 125)) {
                        return "{x,y} quantifier never ends";
                    }
                    (cc = QUANTIFIER_RE_CC);
                    if ((par2 == -1)) {
                        if ((bits == 2)) {
                            (par2 = 30000);
                        } else {
                            (par2 = par1);
                        }
                    }
                    if ((par1 > par2)) {
                        return "{x,y} with x greater than y";
                    }
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (quantifiable = 0);
                    ;
                60, 91:
                    (par3 = 0);
                    if ((cc == 60)) {
                        (bits = 62);
                    } else {
                        (bits = 93);
                    }
                    if ((BlkValueRead(ftxt, ffrom) == 94)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (par1 = ffrom);
                    if ((BlkValueRead(ftxt, ffrom) == bits)) {
                        (ffrom)++;
                    }
                    while ((cc ~= bits or 0)) {
                        (cc = BlkValueRead(ftxt, (ffrom)++));
                        if ((cc == 92)) {
                            (cc = BlkValueRead(ftxt, (ffrom)++));
                            if ((cc ~= 0)) {
                                (cc = BlkValueRead(ftxt, (ffrom)++));
                            }
                        }
                    }
                    if ((cc == 0)) {
                        return "Character range never ends";
                    }
                    (par2 = (ffrom - 1));
                    if ((((((((par2 > (par1 + 1))) && ((BlkValueRead(ftxt, par1) == 58)))) && ((BlkValueRead(ftxt, (par2 - 1)) == 58)))) && ((BlkValueRead(ftxt, (par2 - 2)) ~= 92)))) {
                        return "POSIX named character classes unsupported";
                    }
                    (bits = TEXT_TY_RE_RangeSyntaxCorrect(ftxt, par1, par2));
                    if (bits) {
                        return bits;
                    }
                    if ((par1 < par2)) {
                        (cc = RANGE_RE_CC);
                    } else {
                        (cc = NOTHING_RE_CC);
                    }
                    (quantifiable = 1);
                    ;
                42:
                    if ((quantifiable == 0)) {
                        return "quantifier misplaced";
                    }
                    (cc = QUANTIFIER_RE_CC);
                    (par1 = 0);
                    (par2 = 30000);
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (quantifiable = 0);
                    ;
                43:
                    if ((quantifiable == 0)) {
                        return "quantifier misplaced";
                    }
                    (cc = QUANTIFIER_RE_CC);
                    (par1 = 1);
                    (par2 = 30000);
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (quantifiable = 0);
                    ;
                63:
                    if ((quantifiable == 0)) {
                        return "quantifier misplaced";
                    }
                    (cc = QUANTIFIER_RE_CC);
                    (par1 = 0);
                    (par2 = 1);
                    if ((BlkValueRead(ftxt, ffrom) == 63)) {
                        (ffrom)++;
                        (par3 = 1);
                    }
                    (quantifiable = 0);
                    ;
            }
        }
        .CClassKnown;
        if ((cc >= 0)) {
            (quantifiable = 1);
            if (((((attach_to-->(RE_CCLASS)) == LITERAL_RE_CC)) && ((BlkValueRead(ftxt, ffrom) ~= 42 or 43 or 63 or 123)))) {
                ((attach_to-->(RE_PAR2)))++;
                if ((TEXT_TY_RE_Trace == 2)) {
                    print "Extending literal by ";
                    print cc;
                    print "=";
                    print (char) cc;
                    print "^";
                }
                continue;
            }
            (cc = LITERAL_RE_CC);
            (par1 = (ffrom - 1));
            (par2 = ffrom);
        }
        if ((no_packets >= RE_MAX_PACKETS)) {
            return "regexp too complex";
        }
        if ((TEXT_TY_RE_Trace == 2)) {
            print "Attaching packet ";
            print (no_packets + 1);
            print " to ";
            TEXT_TY_RE_DebugNode(attach_to, ftxt);
            TEXT_TY_RE_DebugTree(ftxt);
        }
        (token = TEXT_TY_RE_Node((no_packets)++, cc, par1, par2, par3));
        if (((((token-->(RE_CCLASS)) == SUBEXP_RE_CC)) && (((token-->(RE_PAR2)) == 0)))) {
            ((RE_Subexpressions-->((token-->(RE_PAR1)))) = token);
            ((RE_Subexpressions-->(10)))++;
        }
        if (((((attach_to-->(RE_CCLASS)) == SUBEXP_RE_CC or CHOICE_RE_CC or IF_RE_CC)) && (((attach_to-->(RE_DOWN)) == NULL)))) {
            ((attach_to-->(RE_DOWN)) = token);
            ((token-->(RE_UP)) = attach_to);
        } else {
            if (((((token-->(RE_CCLASS)) == CHOICE_RE_CC)) && ((((attach_to-->(RE_UP))-->(RE_CCLASS)) == CHOICE_RE_CC)))) {
                (no_packets)--;
                (token = (attach_to-->(RE_UP)));
            } else {
                if (((token-->(RE_CCLASS)) == CHOICE_RE_CC)) {
                    while (((attach_to-->(RE_PREVIOUS)) ~= NULL)) {
                        (attach_to = (attach_to-->(RE_PREVIOUS)));
                    }
                }
                if (((token-->(RE_CCLASS)) == QUANTIFIER_RE_CC or CHOICE_RE_CC)) {
                    ((token-->(RE_PREVIOUS)) = (attach_to-->(RE_PREVIOUS)));
                    ((token-->(RE_UP)) = (attach_to-->(RE_UP)));
                    if (((((attach_to-->(RE_UP)) ~= NULL)) && (((attach_to-->(RE_PREVIOUS)) == NULL)))) {
                        (((attach_to-->(RE_UP))-->(RE_DOWN)) = token);
                    }
                    ((token-->(RE_DOWN)) = attach_to);
                    (bits = attach_to);
                    while ((bits ~= NULL)) {
                        ((bits-->(RE_UP)) = token);
                        (bits = (bits-->(RE_NEXT)));
                    }
                    ((attach_to-->(RE_PREVIOUS)) = NULL);
                    if (((token-->(RE_PREVIOUS)) ~= NULL)) {
                        (((token-->(RE_PREVIOUS))-->(RE_NEXT)) = token);
                    }
                } else {
                    ((attach_to-->(RE_NEXT)) = token);
                    ((token-->(RE_PREVIOUS)) = attach_to);
                    ((token-->(RE_UP)) = (attach_to-->(RE_UP)));
                }
            }
        }
        if (((token-->(RE_CCLASS)) == CHOICE_RE_CC)) {
            if ((no_packets >= RE_MAX_PACKETS)) {
                return "regexp too complex";
            }
            ((token-->(RE_NEXT)) = TEXT_TY_RE_Node((no_packets)++, CHOICE_RE_CC, 0, 0, 0));
            (((token-->(RE_NEXT))-->(RE_PREVIOUS)) = token);
            (((token-->(RE_NEXT))-->(RE_UP)) = (token-->(RE_UP)));
            (token = (token-->(RE_NEXT)));
        }
        (attach_to = token);
        if ((TEXT_TY_RE_Trace == 2)) {
            print "Result:^";
            TEXT_TY_RE_DebugTree(ftxt);
        }
    }
    if ((blevel ~= 0)) {
        return "subexpression bracket mismatch";
    }
    if (exactly) {
        if (((no_packets + 3) > RE_MAX_PACKETS)) {
            return "regexp too complex";
        }
        (exactly = (RE_PACKET_space-->(RE_DOWN)));
        (token = TEXT_TY_RE_Node((no_packets)++, START_RE_CC, 0, 0, 0));
        ((RE_PACKET_space-->(RE_DOWN)) = token);
        ((token-->(RE_UP)) = RE_PACKET_space);
        (attach_to = TEXT_TY_RE_Node((no_packets)++, SUBEXP_RE_CC, (-(1)), 3, 0));
        ((token-->(RE_NEXT)) = attach_to);
        ((attach_to-->(RE_PREVIOUS)) = token);
        ((attach_to-->(RE_UP)) = RE_PACKET_space);
        ((attach_to-->(RE_NEXT)) = TEXT_TY_RE_Node((no_packets)++, END_RE_CC, 0, 0, 0));
        (((attach_to-->(RE_NEXT))-->(RE_PREVIOUS)) = attach_to);
        (((attach_to-->(RE_NEXT))-->(RE_UP)) = RE_PACKET_space);
        ((attach_to-->(RE_DOWN)) = exactly);
        while ((exactly ~= NULL)) {
            ((exactly-->(RE_UP)) = attach_to);
            (exactly = (exactly-->(RE_NEXT)));
        }
    }
    (no_packets = TEXT_TY_RE_ExpandChoices(RE_PACKET_space, no_packets));
    if (TEXT_TY_RE_Trace) {
        print "Compiled pattern:^";
        TEXT_TY_RE_DebugTree(ftxt);
    }
    (bits = TEXT_TY_RE_CheckTree(RE_PACKET_space, no_subs));
    if (bits) {
        return bits;
    }
    return no_packets;
];
[ TEXT_TY_RE_RangeSyntaxCorrect ftxt rf rt i chm;
    for ((i = rf):(i < rt):(i)++) {
        (chm = BlkValueRead(ftxt, i));
        if ((((chm == 92)) && (((i + 1) < rt)))) {
            (chm = BlkValueRead(ftxt, ++(i)));
            if ((((((chm >= 97)) && ((chm <= 122)))) || ((((chm >= 65)) && ((chm <= 90)))))) {
                if ((chm ~= 115 or 83 or 112 or 80 or 119 or 87 or 100 or 68 or 110 or 116 or 108 or 76 or 117 or 85)) {
                    return "Invalid escape in {} range";
                }
            }
        }
        if (((((i + 2) < rt)) && ((BlkValueRead(ftxt, (i + 1)) == 45)))) {
            if ((chm > BlkValueRead(ftxt, (i + 2)))) {
                return "Invalid {} range";
            }
            (i = (i + 2));
        }
    }
    rfalse;
];
[ TEXT_TY_RE_ExpandChoices token no_packets rv prev nex holder new ct n cond_node then_node else_node;
    while ((token ~= NULL)) {
        if (((token-->(RE_CCLASS)) == IF_RE_CC)) {
            if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == CHOICE_RE_CC)) {
                for (((nex = (token-->(RE_DOWN))),(n = 0)):(nex ~= NULL):(nex = (nex-->(RE_NEXT)))) {
                    (n)++;
                }
                if ((n ~= 2)) {
                    return "conditional has too many clauses";
                }
                if ((no_packets >= RE_MAX_PACKETS)) {
                    return "regexp too complex";
                }
                (cond_node = TEXT_TY_RE_Node((no_packets)++, CONDITION_RE_CC, 0, 0, 0));
                if (((token-->(RE_PAR1)) >= 1)) {
                    ((cond_node-->(RE_PAR1)) = (token-->(RE_PAR1)));
                }
                (then_node = (token-->(RE_DOWN)));
                ((then_node-->(RE_CCLASS)) = THEN_RE_CC);
                (else_node = (then_node-->(RE_NEXT)));
                ((else_node-->(RE_CCLASS)) = ELSE_RE_CC);
                if (((cond_node-->(RE_PAR1)) < 1)) {
                    ((cond_node-->(RE_DOWN)) = (then_node-->(RE_DOWN)));
                    ((then_node-->(RE_DOWN)) = ((then_node-->(RE_DOWN))-->(RE_NEXT)));
                    if (((then_node-->(RE_DOWN)) ~= NULL)) {
                        (((then_node-->(RE_DOWN))-->(RE_PREVIOUS)) = NULL);
                    }
                    (((cond_node-->(RE_DOWN))-->(RE_NEXT)) = NULL);
                    (((cond_node-->(RE_DOWN))-->(RE_UP)) = cond_node);
                }
                ((token-->(RE_DOWN)) = cond_node);
                ((cond_node-->(RE_UP)) = token);
                ((cond_node-->(RE_NEXT)) = then_node);
                ((then_node-->(RE_PREVIOUS)) = cond_node);
            } else {
                if ((no_packets >= RE_MAX_PACKETS)) {
                    return "regexp too complex";
                }
                (cond_node = TEXT_TY_RE_Node((no_packets)++, CONDITION_RE_CC, 0, 0, 0));
                if ((no_packets >= RE_MAX_PACKETS)) {
                    return "regexp too complex";
                }
                (then_node = TEXT_TY_RE_Node((no_packets)++, THEN_RE_CC, 0, 0, 0));
                if (((token-->(RE_PAR1)) >= 1)) {
                    ((cond_node-->(RE_PAR1)) = (token-->(RE_PAR1)));
                    ((then_node-->(RE_DOWN)) = (token-->(RE_DOWN)));
                } else {
                    ((cond_node-->(RE_DOWN)) = (token-->(RE_DOWN)));
                    ((then_node-->(RE_DOWN)) = ((token-->(RE_DOWN))-->(RE_NEXT)));
                    (((cond_node-->(RE_DOWN))-->(RE_NEXT)) = NULL);
                    (((cond_node-->(RE_DOWN))-->(RE_UP)) = cond_node);
                }
                ((token-->(RE_DOWN)) = cond_node);
                ((cond_node-->(RE_UP)) = token);
                ((cond_node-->(RE_NEXT)) = then_node);
                ((then_node-->(RE_PREVIOUS)) = cond_node);
                ((then_node-->(RE_UP)) = token);
                ((then_node-->(RE_NEXT)) = NULL);
                if (((then_node-->(RE_DOWN)) ~= NULL)) {
                    (((then_node-->(RE_DOWN))-->(RE_PREVIOUS)) = NULL);
                }
                for ((nex = (then_node-->(RE_DOWN))):(nex ~= NULL):(nex = (nex-->(RE_NEXT)))) {
                    ((nex-->(RE_UP)) = then_node);
                }
            }
            if (((cond_node-->(RE_DOWN)) ~= NULL)) {
                (nex = (cond_node-->(RE_DOWN)));
                if (((((((nex-->(RE_CCLASS)) ~= SUBEXP_RE_CC)) || (((nex-->(RE_NEXT)) ~= NULL)))) || (((nex-->(RE_PAR2)) ~= 1 or 2)))) {
                    return "condition not lookahead/behind";
                }
            }
        }
        if (((((token-->(RE_CCLASS)) == CHOICE_RE_CC)) && (((token-->(RE_PAR1)) < 1)))) {
            (prev = (token-->(RE_PREVIOUS)));
            (nex = (token-->(RE_NEXT)));
            while ((((nex ~= NULL)) && (((nex-->(RE_CCLASS)) == CHOICE_RE_CC)))) {
                (nex = (nex-->(RE_NEXT)));
            }
            (holder = (token-->(RE_UP)));
            if ((holder == NULL)) {
                return "bang";
            }
            if ((no_packets >= RE_MAX_PACKETS)) {
                return "regexp too complex";
            }
            (new = TEXT_TY_RE_Node((no_packets)++, DISJUNCTION_RE_CC, 0, 0, 0));
            ((holder-->(RE_DOWN)) = new);
            ((new-->(RE_UP)) = holder);
            if ((prev ~= NULL)) {
                ((prev-->(RE_NEXT)) = new);
                ((new-->(RE_PREVIOUS)) = prev);
            }
            if ((nex ~= NULL)) {
                ((nex-->(RE_PREVIOUS)) = new);
                ((new-->(RE_NEXT)) = nex);
            }
            ((new-->(RE_DOWN)) = token);
            ((token-->(RE_PREVIOUS)) = NULL);
            (ct = 1);
            while ((token ~= NULL)) {
                ((token-->(RE_PAR1)) = (ct)++);
                ((token-->(RE_UP)) = new);
                if (((((token-->(RE_NEXT)) ~= NULL)) && ((((token-->(RE_NEXT))-->(RE_CCLASS)) ~= CHOICE_RE_CC)))) {
                    ((token-->(RE_NEXT)) = NULL);
                }
                (token = (token-->(RE_NEXT)));
            }
            ((new-->(RE_PAR1)) = (ct - 1));
            if ((token ~= NULL)) {
                ((token-->(RE_NEXT)) = NULL);
            }
            (token = new);
            continue;
        }
        if (((token-->(RE_DOWN)) ~= NULL)) {
            (no_packets = TEXT_TY_RE_ExpandChoices((token-->(RE_DOWN)), no_packets));
            if ((((no_packets < 0)) || ((no_packets >= RE_MAX_PACKETS)))) {
                break;
            }
        }
        (token = (token-->(RE_NEXT)));
    }
    return no_packets;
];
[ TEXT_TY_RE_CheckTree token no_subs rv;
    while ((token ~= NULL)) {
        if (((token-->(RE_CCLASS)) == VARIABLE_RE_CC)) {
            if (((token-->(RE_PAR1)) >= no_subs)) {
                return "reference to nonexistent group";
            }
        }
        if (((((((token-->(RE_CCLASS)) == SUBEXP_RE_CC)) && (((token-->(RE_PAR2)) == 1 or 2)))) && (((token-->(RE_PAR3)) == -1)))) {
            ((token-->(RE_PAR3)) = TEXT_TY_RE_Width((token-->(RE_DOWN))));
            if (((token-->(RE_PAR3)) == -1)) {
                return "variable length lookbehind not implemented";
            }
        }
        if (((token-->(RE_DOWN)) ~= NULL)) {
            (rv = TEXT_TY_RE_CheckTree((token-->(RE_DOWN)), no_subs));
            if (rv) {
                return rv;
            }
        }
        (token = (token-->(RE_NEXT)));
    }
    rfalse;
];
[ TEXT_TY_RE_Width token downwards w rv aw choice;
    while ((token ~= NULL)) {
        switch ((token-->(RE_CCLASS))) {
            DIGIT_RE_CC, NONDIGIT_RE_CC, WHITESPACE_RE_CC, NONWHITESPACE_RE_CC, PUNCTUATION_RE_CC, NONPUNCTUATION_RE_CC, WORD_RE_CC, NONWORD_RE_CC, ANYTHING_RE_CC, NOTHING_RE_CC, RANGE_RE_CC, NEWLINE_RE_CC, TAB_RE_CC, UCASE_RE_CC, NONUCASE_RE_CC, LCASE_RE_CC, NONLCASE_RE_CC:
                (w)++;
                ;
            START_RE_CC, END_RE_CC, BOUNDARY_RE_CC, NONBOUNDARY_RE_CC, ALWAYS_RE_CC:
                ;
            LITERAL_RE_CC:
                (w = ((w + (token-->(RE_PAR2))) - (token-->(RE_PAR1))));
                ;
            VARIABLE_RE_CC:
                return (-(1));
                ;
            IF_RE_CC:
                (rv = TEXT_TY_RE_Width(((token-->(RE_DOWN))-->(RE_NEXT))));
                if ((rv == -1)) {
                    return (-(1));
                }
                if ((rv ~= TEXT_TY_RE_Width((((token-->(RE_DOWN))-->(RE_NEXT))-->(RE_NEXT))))) {
                    return (-(1));
                }
                (w = (w + rv));
                ;
            SUBEXP_RE_CC:
                if (((token-->(RE_PAR2)) == 1 or 2)) {
                    (rv = 0);
                } else {
                    (rv = TEXT_TY_RE_Width((token-->(RE_DOWN))));
                    if ((rv == -1)) {
                        return (-(1));
                    }
                }
                (w = (w + rv));
                ;
            QUANTIFIER_RE_CC:
                if (((token-->(RE_PAR1)) ~= (token-->(RE_PAR2)))) {
                    return (-(1));
                }
                (rv = TEXT_TY_RE_Width((token-->(RE_DOWN))));
                if ((rv == -1)) {
                    return (-(1));
                }
                (w = (w + (rv*(token-->(RE_PAR1)))));
                ;
            DISJUNCTION_RE_CC:
                (aw = -1);
                for ((choice = (token-->(RE_DOWN))):(choice ~= NULL):(choice = (choice-->(RE_NEXT)))) {
                    (rv = TEXT_TY_RE_Width((choice-->(RE_DOWN))));
                    if ((rv == -1)) {
                        return (-(1));
                    }
                    if ((((aw >= 0)) && ((aw ~= rv)))) {
                        return (-(1));
                    }
                    (aw = rv);
                }
                (w = (w + aw));
                ;
            SENSITIVITY_RE_CC:
                ;
        }
        if (downwards) {
            return w;
        }
        if ((token ~= NULL)) {
            (token = (token-->(RE_NEXT)));
        }
    }
    return w;
];
[ TEXT_TY_RE_PrintNoRewinds;
    print TEXT_TY_RE_RewindCount;
];
[ TEXT_TY_RE_Parse ftxt txt ipos insens ilen rv root i initial_mode;
    (ilen = TEXT_TY_CharacterLength(txt));
    if ((((ipos < 0)) || ((ipos > ilen)))) {
        return (-(1));
    }
    (root = RE_PACKET_space);
    (initial_mode = 0);
    if (insens) {
        (initial_mode = CIS_MFLAG);
    }
    TEXT_TY_RE_Clear_Markers(RE_PACKET_space);
    for (:(ipos <= ilen):(ipos)++) {
        if (((((((RE_PACKET_space-->(RE_DOWN)) ~= NULL)) && ((((RE_PACKET_space-->(RE_DOWN))-->(RE_CCLASS)) == START_RE_CC)))) && ((ipos > 0)))) {
            (rv = -1);
            break;
        }
        if ((ipos > 0)) {
            TEXT_TY_RE_EraseConstraints(RE_PACKET_space);
        }
        (TEXT_TY_RE_RewindCount = 0);
        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ilen, RE_PACKET_space, initial_mode));
        if ((rv >= 0)) {
            break;
        }
    }
    if ((rv == -1)) {
        ((root-->(RE_DATA1)) = -1);
        ((root-->(RE_DATA2)) = -1);
    } else {
        ((root-->(RE_DATA1)) = ipos);
        ((root-->(RE_DATA2)) = (ipos + rv));
    }
    return rv;
];
[ TEXT_TY_RE_ParseAtPosition ftxt txt ifrom ito token mode_flags outcome ipos npos rv i ch edge rewind_this;
    if ((ifrom > ito)) {
        return (-(1));
    }
    (ipos = ifrom);
    .Rewind;
    while ((token ~= NULL)) {
        (outcome = 0);
        if (TEXT_TY_RE_Trace) {
            print "Matching at ";
            print ipos;
            print ": ";
            TEXT_TY_RE_DebugNode(token, ftxt, 1);
        }
        if ((ipos < ito)) {
            (ch = BlkValueRead(txt, ipos));
        } else {
            (ch = 0);
        }
        ((token-->(RE_MODES)) = mode_flags);
        switch ((token-->(RE_CCLASS))) {
            CHOICE_RE_CC:
                return "internal error";
                ;
            SENSITIVITY_RE_CC:
                if ((token-->(RE_PAR1))) {
                    (mode_flags = ((mode_flags)|(CIS_MFLAG)));
                } else {
                    (mode_flags = ((mode_flags)&((~(CIS_MFLAG)))));
                }
                (outcome = 1);
                ;
            ALWAYS_RE_CC:
                (outcome = 1);
                ;
            NEVER_RE_CC:
                ;
            START_RE_CC:
                if ((ipos == 0)) {
                    (outcome = 1);
                }
                ;
            END_RE_CC:
                if ((BlkValueRead(txt, ipos) == 0)) {
                    (outcome = 1);
                }
                ;
            BOUNDARY_RE_CC:
                (rv = 0);
                if ((BlkValueRead(txt, ipos) == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (rv)++;
                }
                if ((ipos == 0)) {
                    (ch = 0);
                } else {
                    (ch = BlkValueRead(txt, (ipos - 1)));
                }
                if ((ch == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (rv)++;
                }
                if ((rv == 1)) {
                    (outcome = 1);
                }
                ;
            NONBOUNDARY_RE_CC:
                (rv = 0);
                if ((BlkValueRead(txt, ipos) == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (rv)++;
                }
                if ((ipos == 0)) {
                    (ch = 0);
                } else {
                    (ch = BlkValueRead(txt, (ipos - 1)));
                }
                if ((ch == 0 or 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (rv)++;
                }
                if ((rv ~= 1)) {
                    (outcome = 1);
                }
                ;
            IF_RE_CC:
                (i = (token-->(RE_PAR1)));
                (ch = 0);
                if (TEXT_TY_RE_Trace) {
                    print "Trying conditional from ";
                    print ipos;
                    print ": ";
                    TEXT_TY_RE_DebugNode(token, ftxt, 1);
                }
                if ((i >= 1)) {
                    if ((((i < (RE_Subexpressions-->(10)))) && ((((RE_Subexpressions-->(i))-->(RE_DATA1)) >= 0)))) {
                        (ch = 1);
                    }
                } else {
                    (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, ((token-->(RE_DOWN))-->(RE_DOWN)), mode_flags));
                    if ((rv >= 0)) {
                        (ch = 1);
                    }
                }
                if (TEXT_TY_RE_Trace) {
                    print "Condition found to be ";
                    print ch;
                    print "^";
                }
                if (ch) {
                    (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (((token-->(RE_DOWN))-->(RE_NEXT))-->(RE_DOWN)), mode_flags));
                } else {
                    if (((((token-->(RE_DOWN))-->(RE_NEXT))-->(RE_NEXT)) == NULL)) {
                        (rv = 0);
                    } else {
                        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, ((((token-->(RE_DOWN))-->(RE_NEXT))-->(RE_NEXT))-->(RE_DOWN)), mode_flags));
                    }
                }
                if ((rv >= 0)) {
                    (outcome = 1);
                    (ipos = (ipos + rv));
                }
                ;
            DISJUNCTION_RE_CC:
                if (TEXT_TY_RE_Trace) {
                    print "Trying disjunction from ";
                    print ipos;
                    print ": ";
                    TEXT_TY_RE_DebugNode(token, ftxt, 1);
                }
                for ((ch = (token-->(RE_DOWN))):(ch ~= NULL):(ch = (ch-->(RE_NEXT)))) {
                    if (((ch-->(RE_PAR1)) <= (token-->(RE_CONSTRAINT)))) {
                        continue;
                    }
                    if (TEXT_TY_RE_Trace) {
                        print "Trying choice at ";
                        print ipos;
                        print ": ";
                        TEXT_TY_RE_DebugNode(ch, ftxt, 1);
                    }
                    (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (ch-->(RE_DOWN)), mode_flags));
                    if ((rv >= 0)) {
                        ((token-->(RE_DATA1)) = ipos);
                        ((token-->(RE_DATA2)) = (ch-->(RE_PAR1)));
                        (ipos = (ipos + rv));
                        (outcome = 1);
                        if (TEXT_TY_RE_Trace) {
                            print "Choice worked with width ";
                            print rv;
                            print ": ";
                            TEXT_TY_RE_DebugNode(ch, ftxt, 1);
                        }
                        break;
                    } else {
                        if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                            TEXT_TY_RE_FailSubexpressions((ch-->(RE_DOWN)));
                        }
                    }
                }
                if ((outcome == 0)) {
                    if (TEXT_TY_RE_Trace) {
                        print "Failed disjunction from ";
                        print ipos;
                        print ": ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                    ((token-->(RE_DATA1)) = ipos);
                    ((token-->(RE_DATA2)) = -1);
                }
                ;
            SUBEXP_RE_CC:
                if (((token-->(RE_PAR2)) == 1 or 2)) {
                    (npos = (ipos - (token-->(RE_PAR3))));
                    if ((npos < 0)) {
                        (rv = -1);
                    } else {
                        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, (token-->(RE_DOWN)), mode_flags));
                    }
                } else {
                    switch ((token-->(RE_PAR3))) {
                        0:
                            (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (token-->(RE_DOWN)), mode_flags));
                            ;
                        1:
                            (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (token-->(RE_DOWN)), ((mode_flags)&((~(CIS_MFLAG))))));
                            ;
                        2:
                            (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, (token-->(RE_DOWN)), ((mode_flags)|(CIS_MFLAG))));
                            ;
                    }
                }
                (npos = ipos);
                if ((rv >= 0)) {
                    (npos = (ipos + rv));
                }
                switch ((token-->(RE_PAR2))) {
                    1:
                        if ((rv >= 0)) {
                            (rv = 0);
                        }
                        ;
                    2:
                        if ((rv >= 0)) {
                            (rv = -1);
                        } else {
                            (rv = 0);
                        }
                        ;
                }
                if ((rv >= 0)) {
                    ((token-->(RE_DATA1)) = ipos);
                    (ipos = (ipos + rv));
                    ((token-->(RE_DATA2)) = npos);
                    (outcome = 1);
                } else {
                    if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                        ((token-->(RE_DATA1)) = -1);
                        ((token-->(RE_DATA2)) = -1);
                    }
                }
                if (((token-->(RE_PAR2)) == 2)) {
                    TEXT_TY_RE_FailSubexpressions(token, 1);
                }
                ;
            QUANTIFIER_RE_CC:
                ((token-->(RE_DATA1)) = ipos);
                if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
                    (((token-->(RE_DOWN))-->(RE_CACHE1)) = -1);
                    (((token-->(RE_DOWN))-->(RE_CACHE2)) = -1);
                }
                if (TEXT_TY_RE_Trace) {
                    print "Trying quantifier from ";
                    print ipos;
                    print ": ";
                    TEXT_TY_RE_DebugNode(token, ftxt, 1);
                }
                if (((token-->(RE_PAR3)) == 0)) {
                    (edge = (token-->(RE_PAR2)));
                    if (((token-->(RE_CONSTRAINT)) >= 0)) {
                        (edge = (token-->(RE_CONSTRAINT)));
                    }
                    (rv = -1);
                    for (((i = 0),(npos = ipos)):(i < edge):(i)++) {
                        if (TEXT_TY_RE_Trace) {
                            print "Trying quant rep ";
                            print (i + 1);
                            print " at ";
                            print npos;
                            print ": ";
                            TEXT_TY_RE_DebugNode(token, ftxt, 1);
                        }
                        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, (token-->(RE_DOWN)), ((mode_flags)|(ACCUM_MFLAG))));
                        if ((rv < 0)) {
                            break;
                        }
                        if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
                            (((token-->(RE_DOWN))-->(RE_CACHE1)) = ((token-->(RE_DOWN))-->(RE_DATA1)));
                            (((token-->(RE_DOWN))-->(RE_CACHE2)) = ((token-->(RE_DOWN))-->(RE_DATA2)));
                        }
                        if ((((((rv == 0)) && (((token-->(RE_PAR2)) == 30000)))) && ((i >= 1)))) {
                            (i)++;
                            break;
                        }
                        (npos = (npos + rv));
                    }
                    if ((((i >= (token-->(RE_PAR1)))) && ((i <= (token-->(RE_PAR2)))))) {
                        (outcome = 1);
                    }
                } else {
                    (edge = (token-->(RE_PAR1)));
                    if (((token-->(RE_CONSTRAINT)) > edge)) {
                        (edge = (token-->(RE_CONSTRAINT)));
                    }
                    for (((i = 0),(npos = ipos)):(((npos < ito)) && ((i < (token-->(RE_PAR2))))):(i)++) {
                        if ((i >= edge)) {
                            break;
                        }
                        if (TEXT_TY_RE_Trace) {
                            print "Trying quant rep ";
                            print (i + 1);
                            print " at ";
                            print npos;
                            print ": ";
                            TEXT_TY_RE_DebugNode(token, ftxt, 1);
                        }
                        (rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, (token-->(RE_DOWN)), ((mode_flags)|(ACCUM_MFLAG))));
                        if ((rv < 0)) {
                            break;
                        }
                        if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
                            (((token-->(RE_DOWN))-->(RE_CACHE1)) = ((token-->(RE_DOWN))-->(RE_DATA1)));
                            (((token-->(RE_DOWN))-->(RE_CACHE2)) = ((token-->(RE_DOWN))-->(RE_DATA2)));
                        }
                        if ((((((rv == 0)) && (((token-->(RE_PAR2)) == 30000)))) && ((i >= 1)))) {
                            (i)++;
                            break;
                        }
                        (npos = (npos + rv));
                    }
                    if ((((i >= edge)) && ((i <= (token-->(RE_PAR2)))))) {
                        (outcome = 1);
                    }
                }
                if (outcome) {
                    if (((token-->(RE_PAR3)) == 0)) {
                        if ((i > (token-->(RE_PAR1)))) {
                            ((token-->(RE_DATA2)) = (i - 1));
                        } else {
                            ((token-->(RE_DATA2)) = -1);
                        }
                    } else {
                        if ((i < (token-->(RE_PAR2)))) {
                            ((token-->(RE_DATA2)) = (i + 1));
                        } else {
                            ((token-->(RE_DATA2)) = -1);
                        }
                    }
                    (ipos = npos);
                    if ((((i == 0)) && ((((mode_flags)&(ACCUM_MFLAG)) == 0)))) {
                        TEXT_TY_RE_FailSubexpressions((token-->(RE_DOWN)));
                    }
                    if ((((token-->(RE_DOWN))-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
                        (((token-->(RE_DOWN))-->(RE_DATA1)) = ((token-->(RE_DOWN))-->(RE_CACHE1)));
                        (((token-->(RE_DOWN))-->(RE_DATA2)) = ((token-->(RE_DOWN))-->(RE_CACHE2)));
                    }
                    if (TEXT_TY_RE_Trace) {
                        print "Successful quant reps ";
                        print i;
                        print ": ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                } else {
                    if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                        TEXT_TY_RE_FailSubexpressions((token-->(RE_DOWN)));
                    }
                    if (TEXT_TY_RE_Trace) {
                        print "Failed quant reps ";
                        print i;
                        print ": ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                }
                ;
            NOTHING_RE_CC:
                ;
            ANYTHING_RE_CC:
                if (ch) {
                    (outcome = 1);
                }
                (ipos)++;
                ;
            WHITESPACE_RE_CC:
                if ((ch == 10 or 13 or 32 or 9)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONWHITESPACE_RE_CC:
                if (((ch) && ((ch ~= 10 or 13 or 32 or 9)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            PUNCTUATION_RE_CC:
                if ((ch == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONPUNCTUATION_RE_CC:
                if (((ch) && ((ch ~= 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            WORD_RE_CC:
                if (((ch) && ((ch ~= 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONWORD_RE_CC:
                if ((ch == 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            DIGIT_RE_CC:
                if ((ch == 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONDIGIT_RE_CC:
                if (((ch) && ((ch ~= 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            LCASE_RE_CC:
                if (CharIsOfCase(ch, 0)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONLCASE_RE_CC:
                if (((ch) && ((CharIsOfCase(ch, 0) == 0)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            UCASE_RE_CC:
                if (CharIsOfCase(ch, 1)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NONUCASE_RE_CC:
                if (((ch) && ((CharIsOfCase(ch, 1) == 0)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            NEWLINE_RE_CC:
                if ((ch == 10)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            TAB_RE_CC:
                if ((ch == 9)) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            RANGE_RE_CC:
                if (TEXT_TY_RE_Range(ch, ftxt, (token-->(RE_PAR1)), (token-->(RE_PAR2)), (token-->(RE_PAR3)), ((mode_flags)&(CIS_MFLAG)))) {
                    (outcome = 1);
                    (ipos)++;
                }
                ;
            LITERAL_RE_CC:
                (rv = TEXT_TY_RE_MatchSubstring(txt, ipos, ftxt, (token-->(RE_PAR1)), (token-->(RE_PAR2)), ((mode_flags)&(CIS_MFLAG))));
                if ((rv >= 0)) {
                    (ipos = (ipos + rv));
                    (outcome = 1);
                }
                ;
            VARIABLE_RE_CC:
                (i = (token-->(RE_PAR1)));
                if ((((RE_Subexpressions-->(i))-->(RE_DATA1)) >= 0)) {
                    (rv = TEXT_TY_RE_MatchSubstring(txt, ipos, txt, ((RE_Subexpressions-->(i))-->(RE_DATA1)), ((RE_Subexpressions-->(i))-->(RE_DATA2)), ((mode_flags)&(CIS_MFLAG))));
                    if ((rv >= 0)) {
                        (ipos = (ipos + rv));
                        (outcome = 1);
                    }
                }
                ;
        }
        if ((outcome == 0)) {
            if (((TEXT_TY_RE_RewindCount)++ >= 10000)) {
                if ((TEXT_TY_RE_RewindCount == 10001)) {
                    style bold;
                    print "OVERFLOW^";
                    style roman;
                }
                return (-(1));
            }
            if (TEXT_TY_RE_Trace) {
                print "Rewind sought from failure at pos ";
                print ipos;
                print " with: ";
                TEXT_TY_RE_DebugNode(token, ftxt, 1);
            }
            if (((((token-->(RE_CCLASS)) == QUANTIFIER_RE_CC)) && (TEXT_TY_RE_SeekBacktrack((token-->(RE_DOWN)), ftxt, 0, ito, 0)))) {
                jump RewindFound;
            }
            if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                TEXT_TY_RE_FailSubexpressions(token);
            }
            (token = (token-->(RE_PREVIOUS)));
            while ((token ~= NULL)) {
                if (TEXT_TY_RE_SeekBacktrack(token, ftxt, 1, ito, 0)) {
                    .RewindFound;
                    (ipos = (token-->(RE_DATA1)));
                    (mode_flags = (token-->(RE_MODES)));
                    if ((((mode_flags)&(ACCUM_MFLAG)) == 0)) {
                        TEXT_TY_RE_FailSubexpressions(token, 1);
                    }
                    if ((ipos == -1)) {
                        TEXT_TY_RE_DebugTree(ftxt, 1);
                    }
                    if (TEXT_TY_RE_Trace) {
                        print "^[";
                        print ifrom;
                        print ",";
                        print ito;
                        print "] rewinding to ";
                        print ipos;
                        print " at ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                    jump Rewind;
                }
                (token = (token-->(RE_PREVIOUS)));
            }
            if (TEXT_TY_RE_Trace) {
                print "^Rewind impossible^";
            }
            return (-(1));
        }
        (token = (token-->(RE_NEXT)));
    }
    return (ipos - ifrom);
];
[ TEXT_TY_RE_SeekBacktrack token ftxt downwards ito report_only untried;
    for (:(token ~= NULL):(token = (token-->(RE_NEXT)))) {
        if (((TEXT_TY_RE_Trace) && ((report_only == 0)))) {
            print "Scan for rewind: ";
            TEXT_TY_RE_DebugNode(token, ftxt, 1);
        }
        if (((((token-->(RE_CCLASS)) == SUBEXP_RE_CC)) && (((token-->(RE_PAR2)) == 1 or 2 or 4)))) {
            if (downwards) {
                rfalse;
            }
            continue;
        }
        if (((token-->(RE_DOWN)) ~= NULL)) {
            if (((TEXT_TY_RE_Trace) && ((report_only == 0)))) {
                print "Descend^";
            }
            if (TEXT_TY_RE_SeekBacktrack((token-->(RE_DOWN)), ftxt, 0, ito, report_only)) {
                rtrue;
            }
        }
        (untried = 0);
        switch ((token-->(RE_CCLASS))) {
            DISJUNCTION_RE_CC:
                if (((((((token-->(RE_DATA2)) >= 1)) && (((token-->(RE_DATA2)) < (token-->(RE_PAR1)))))) && (((token-->(RE_CONSTRAINT)) < (token-->(RE_PAR1)))))) {
                    if (report_only) {
                        rtrue;
                    }
                    if (((token-->(RE_CONSTRAINT)) == -1)) {
                        ((token-->(RE_CONSTRAINT)) = 1);
                    } else {
                        ((token-->(RE_CONSTRAINT)))++;
                    }
                    (untried = 1);
                }
                ;
            QUANTIFIER_RE_CC:
                if (((token-->(RE_CONSTRAINT)) ~= -2)) {
                    if (((TEXT_TY_RE_Trace) && ((report_only == 0)))) {
                        print "Quant with cons not -2: ";
                        TEXT_TY_RE_DebugNode(token, ftxt, 1);
                    }
                    if (((token-->(RE_DATA2)) >= 0)) {
                        if (report_only) {
                            rtrue;
                        }
                        ((token-->(RE_CONSTRAINT)) = (token-->(RE_DATA2)));
                        (untried = 1);
                    }
                }
                ;
        }
        if (untried) {
            if (TEXT_TY_RE_Trace) {
                print "Grounds for rewind at: ";
                TEXT_TY_RE_DebugNode(token, ftxt, 1);
            }
            TEXT_TY_RE_EraseConstraints((token-->(RE_NEXT)));
            TEXT_TY_RE_EraseConstraints((token-->(RE_DOWN)));
            rtrue;
        }
        if (downwards) {
            rfalse;
        }
    }
    rfalse;
];
[ TEXT_TY_RE_FailSubexpressions token downwards;
    for (:(token ~= NULL):(token = (token-->(RE_NEXT)))) {
        if (((token-->(RE_DOWN)) ~= NULL)) {
            TEXT_TY_RE_FailSubexpressions((token-->(RE_DOWN)));
        }
        if (((token-->(RE_CCLASS)) == SUBEXP_RE_CC)) {
            ((token-->(RE_DATA1)) = -1);
            ((token-->(RE_DATA2)) = -1);
        }
        if (downwards) {
            break;
        }
    }
];
[ TEXT_TY_RE_EraseConstraints token;
    while ((token ~= NULL)) {
        switch ((token-->(RE_CCLASS))) {
            DISJUNCTION_RE_CC:
                ((token-->(RE_CONSTRAINT)) = -1);
                ;
            QUANTIFIER_RE_CC:
                ((token-->(RE_CONSTRAINT)) = -1);
                ;
        }
        if ((token-->(RE_DOWN))) {
            TEXT_TY_RE_EraseConstraints((token-->(RE_DOWN)));
        }
        (token = (token-->(RE_NEXT)));
    }
];
[ TEXT_TY_RE_MatchSubstring txt ipos mtxt mfrom mto insens i ch;
    if ((mfrom < 0)) {
        rfalse;
    }
    if (insens) {
        for ((i = mfrom):(i < mto):(i)++) {
            (ch = BlkValueRead(mtxt, i));
            if ((BlkValueRead(txt, (ipos)++) ~= ch or TEXT_TY_RevCase(ch))) {
                return (-(1));
            }
        }
    } else {
        for ((i = mfrom):(i < mto):(i)++) {
            if ((BlkValueRead(txt, (ipos)++) ~= BlkValueRead(mtxt, i))) {
                return (-(1));
            }
        }
    }
    return (mto - mfrom);
];
[ TEXT_TY_RE_Range ch ftxt rf rt negate insens i chm upper crev;
    if ((ch == 0)) {
        rfalse;
    }
    if ((negate == 1)) {
        if (TEXT_TY_RE_Range(ch, ftxt, rf, rt, 0, insens)) {
            rfalse;
        }
        rtrue;
    }
    for ((i = rf):(i < rt):(i)++) {
        (chm = BlkValueRead(ftxt, i));
        if ((((chm == 92)) && (((i + 1) < rt)))) {
            (chm = BlkValueRead(ftxt, ++(i)));
            switch (chm) {
                115:
                    if ((ch == 10 or 13 or 32 or 9)) {
                        rtrue;
                    }
                    ;
                83:
                    if (((ch) && ((ch ~= 10 or 13 or 32 or 9)))) {
                        rtrue;
                    }
                    ;
                112:
                    if ((ch == 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                        rtrue;
                    }
                    ;
                80:
                    if (((ch) && ((ch ~= 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                        rtrue;
                    }
                    ;
                119:
                    if (((ch) && ((ch ~= 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)))) {
                        rtrue;
                    }
                    ;
                87:
                    if ((ch == 10 or 13 or 32 or 9 or 46 or 44 or 33 or 63 or 45 or 47 or 34 or 58 or 59 or 40 or 41 or 91 or 93 or 123 or 125)) {
                        rtrue;
                    }
                    ;
                100:
                    if ((ch == 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)) {
                        rtrue;
                    }
                    ;
                68:
                    if (((ch) && ((ch ~= 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)))) {
                        rtrue;
                    }
                    ;
                108:
                    if (CharIsOfCase(ch, 0)) {
                        rtrue;
                    }
                    ;
                76:
                    if ((CharIsOfCase(ch, 0) == 0)) {
                        rtrue;
                    }
                    ;
                117:
                    if (CharIsOfCase(ch, 1)) {
                        rtrue;
                    }
                    ;
                85:
                    if ((CharIsOfCase(ch, 1) == 0)) {
                        rtrue;
                    }
                    ;
                110:
                    if ((ch == 10)) {
                        rtrue;
                    }
                    ;
                116:
                    if ((ch == 9)) {
                        rtrue;
                    }
                    ;
            }
        } else {
            if (((((i + 2) < rt)) && ((BlkValueRead(ftxt, (i + 1)) == 45)))) {
                (upper = BlkValueRead(ftxt, (i + 2)));
                if ((((ch >= chm)) && ((ch <= upper)))) {
                    rtrue;
                }
                if (insens) {
                    (crev = TEXT_TY_RevCase(ch));
                    if ((((crev >= chm)) && ((crev <= upper)))) {
                        rtrue;
                    }
                }
                (i = (i + 2));
            } else {
                if ((chm == ch)) {
                    rtrue;
                }
                if (((insens) && ((chm == TEXT_TY_RevCase(ch))))) {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ TEXT_TY_Replace_RE ftxtype txt ftxt rtxt insens exactly r p p1 p2 cp cp1 cp2;
    if ((rtxt == 0 or 1)) {
        (cp = (txt-->(0)));
        (p = TEXT_TY_Temporarily_Transmute(txt));
    } else {
        TEXT_TY_Transmute(txt);
    }
    (cp1 = (ftxt-->(0)));
    (p1 = TEXT_TY_Temporarily_Transmute(ftxt));
    (cp2 = (rtxt-->(0)));
    (p2 = TEXT_TY_Temporarily_Transmute(rtxt));
    (r = TEXT_TY_Replace_REI(ftxtype, txt, ftxt, rtxt, insens, exactly));
    TEXT_TY_Untransmute(ftxt, p1, cp1);
    TEXT_TY_Untransmute(rtxt, p2, cp2);
    if ((rtxt == 0 or 1)) {
        TEXT_TY_Untransmute(txt, p, cp);
    }
    return r;
];
[ TEXT_TY_Replace_REI ftxtype txt ftxt rtxt insens exactly ctxt csize ilen i cl mpos cpos ch chm;
    (ilen = TEXT_TY_CharacterLength(txt));
    (TEXT_TY_RE_Err = 0);
    switch (ftxtype) {
        REGEXP_BLOB:
            (i = TEXT_TY_RE_CompileTree(ftxt, exactly));
            ;
        CHR_BLOB:
            (i = TEXT_TY_CHR_CompileTree(ftxt, exactly));
            ;
        default:
            print "*** bad ftxtype ***";
            new_line;
            rtrue;
            ;
    }
    if ((((i < 0)) || ((i > RE_MAX_PACKETS)))) {
        (TEXT_TY_RE_Err = i);
        print "*** Regular expression error: ";
        print (string) TEXT_TY_RE_Err;
        print " ***^";
        RunTimeProblem(RTP_REGEXPSYNTAXERROR);
        rfalse;
    }
    if (TEXT_TY_RE_Trace) {
        TEXT_TY_RE_DebugTree(ftxt);
        print "(compiled to ";
        print i;
        print " packets)^";
    }
    if ((ftxtype == REGEXP_BLOB)) {
        TEXT_TY_RE_EmptyMatchVars();
    }
    (mpos = 0);
    (chm = 0);
    (cpos = 0);
    while ((TEXT_TY_RE_Parse(ftxt, txt, mpos, insens) >= 0)) {
        (chm)++;
        if (TEXT_TY_RE_Trace) {
            print "^*** Match ";
            print chm;
            print " found (";
            print (RE_PACKET_space-->(RE_DATA1));
            print ",";
            print (RE_PACKET_space-->(RE_DATA2));
            print "): ";
            if (((RE_PACKET_space-->(RE_DATA1)) == (RE_PACKET_space-->(RE_DATA2)))) {
                print "<empty>";
            }
            for ((i = (RE_PACKET_space-->(RE_DATA1))):(i < (RE_PACKET_space-->(RE_DATA2))):(i)++) {
                print (char) BlkValueRead(txt, i);
            }
            print " ***^";
        }
        if ((rtxt == 0)) {
            break;
        }
        if ((rtxt ~= 0 or 1)) {
            if ((chm == 1)) {
                (ctxt = BlkValueCreate(TEXT_TY));
                TEXT_TY_Transmute(ctxt);
                (csize = BlkValueLBCapacity(ctxt));
            }
            for ((i = cpos):(i < (RE_PACKET_space-->(RE_DATA1))):(i)++) {
                (ch = BlkValueRead(txt, i));
                if (((cl + 1) >= csize)) {
                    if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                        break;
                    }
                    (csize = BlkValueLBCapacity(ctxt));
                }
                BlkValueWrite(ctxt, (cl)++, ch);
            }
            BlkValueWrite(ctxt, cl, 0);
            TEXT_TY_Concatenate(ctxt, rtxt, ftxtype, txt);
            (csize = BlkValueLBCapacity(ctxt));
            (cl = TEXT_TY_CharacterLength(ctxt));
        }
        (mpos = (RE_PACKET_space-->(RE_DATA2)));
        (cpos = mpos);
        if (((RE_PACKET_space-->(RE_DATA1)) == (RE_PACKET_space-->(RE_DATA2)))) {
            (mpos)++;
        }
        if (TEXT_TY_RE_Trace) {
            if ((chm == 100)) {
                print "(Stopping after 100 matches.)^";
                break;
            }
        }
    }
    if ((chm > 0)) {
        if ((rtxt ~= 0 or 1)) {
            for ((i = cpos):(i < ilen):(i)++) {
                (ch = BlkValueRead(txt, i));
                if (((cl + 1) >= csize)) {
                    if ((BlkValueSetLBCapacity(ctxt, (2*cl)) == 0)) {
                        break;
                    }
                    (csize = BlkValueLBCapacity(ctxt));
                }
                BlkValueWrite(ctxt, (cl)++, ch);
            }
        }
        if ((ftxtype == REGEXP_BLOB)) {
            TEXT_TY_RE_CreateMatchVars(txt);
            if (TEXT_TY_RE_Trace) {
                TEXT_TY_RE_DebugMatchVars(txt);
            }
        }
        if ((rtxt ~= 0 or 1)) {
            BlkValueWrite(ctxt, cl, 0);
            BlkValueCopy(txt, ctxt);
            BlkValueFree(ctxt);
        }
    }
    return chm;
];
[ TEXT_TY_RE_Concatenate txt_to txt_from blobtype txt_ref pos len ch i tosize x y case;
    if ((((txt_to == 0)) || ((BlkValueWeakKind(txt_to) ~= TEXT_TY)))) {
        rfalse;
    }
    if ((((txt_from == 0)) || ((BlkValueWeakKind(txt_from) ~= TEXT_TY)))) {
        return txt_to;
    }
    (pos = TEXT_TY_CharacterLength(txt_to));
    (tosize = BlkValueLBCapacity(txt_to));
    (len = TEXT_TY_CharacterLength(txt_from));
    for ((i = 0):(i < len):(i)++) {
        (ch = BlkValueRead(txt_from, i));
        if ((((ch == 92)) && ((i < (len - 1))))) {
            (ch = BlkValueRead(txt_from, ++(i)));
            if ((ch == 110)) {
                (ch = 10);
            }
            if ((ch == 116)) {
                (ch = 9);
            }
            (case = -1);
            if ((ch == 108)) {
                (case = 0);
            }
            if ((ch == 117)) {
                (case = 1);
            }
            if ((case >= 0)) {
                (ch = BlkValueRead(txt_from, ++(i)));
            }
            if ((((ch >= 48)) && ((ch <= 57)))) {
                (ch = (ch - 48));
                if ((ch < (RE_Subexpressions-->(10)))) {
                    (x = ((RE_Subexpressions-->(ch))-->(RE_DATA1)));
                    (y = ((RE_Subexpressions-->(ch))-->(RE_DATA2)));
                    if ((x >= 0)) {
                        for (:(x < y):(x)++) {
                            (ch = BlkValueRead(txt_ref, x));
                            if (((pos + 1) >= tosize)) {
                                if ((BlkValueSetLBCapacity(txt_to, (2*tosize)) == 0)) {
                                    break;
                                }
                                (tosize = BlkValueLBCapacity(txt_to));
                            }
                            if ((case >= 0)) {
                                BlkValueWrite(txt_to, (pos)++, CharToCase(ch, case));
                            } else {
                                BlkValueWrite(txt_to, (pos)++, ch);
                            }
                        }
                    }
                }
                continue;
            }
        }
        if (((pos + 1) >= tosize)) {
            if ((BlkValueSetLBCapacity(txt_to, (2*tosize)) == 0)) {
                break;
            }
            (tosize = BlkValueLBCapacity(txt_to));
        }
        BlkValueWrite(txt_to, (pos)++, ch);
    }
    BlkValueWrite(txt_to, pos, 0);
    return txt_to;
];
[ LIST_OF_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return LIST_OF_TY_Create(arg1, arg2);
            ;
        DESTROY_KOVS:
            LIST_OF_TY_Destroy(arg1);
            ;
        MAKEMUTABLE_KOVS:
            rtrue;
            ;
        COPYKIND_KOVS:
            return LIST_OF_TY_CopyKind(arg1, arg2);
            ;
        COPYQUICK_KOVS:
            return LIST_OF_TY_QuickCopy(arg1, arg2);
            ;
        COPYSB_KOVS:
            BlkValueCopySB1(arg1, arg2);
            ;
        KINDDATA_KOVS:
            return LIST_OF_TY_KindData(arg1, arg2);
            ;
        EXTENT_KOVS:
            return (BlkValueRead(arg1, LIST_LENGTH_F) + LIST_ITEM_BASE);
            ;
        COPY_KOVS:
            LIST_OF_TY_Copy(arg1, arg2, arg3);
            ;
        COMPARE_KOVS:
            return LIST_OF_TY_Compare(arg1, arg2);
            ;
        HASH_KOVS:
            return LIST_OF_TY_Hash(arg1);
            ;
        DEBUG_KOVS:
            print " = {";
            LIST_OF_TY_Say(arg1);
            print "} of kind ";
            print BlkValueRead(arg1, LIST_ITEM_KOV_F);
            ;
    }
    rfalse;
];
[ LIST_OF_TY_Create skov sb list;
    (skov = KindBaseTerm(skov, 0));
    (list = FlexAllocate((27*WORDSIZE), LIST_OF_TY, (BLK_FLAG_MULTIPLE + BLK_FLAG_WORD)));
    BlkValueWrite(list, LIST_ITEM_KOV_F, skov, 1);
    BlkValueWrite(list, LIST_LENGTH_F, 0, 1);
    (sb = BlkValueCreateSB1(sb, list));
    return sb;
];
[ LIST_OF_TY_Destroy list no_items i k;
    (k = BlkValueRead(list, LIST_ITEM_KOV_F));
    if (KOVIsBlockValue(k)) {
        (no_items = BlkValueRead(list, LIST_LENGTH_F));
        for ((i = 0):(i < no_items):(i)++) {
            BlkValueFree(BlkValueRead(list, (i + LIST_ITEM_BASE)));
        }
    }
];
[ LIST_OF_TY_CopyKind to from;
    BlkValueWrite(to, LIST_ITEM_KOV_F, BlkValueRead(from, LIST_ITEM_KOV_F));
];
[ LIST_OF_TY_QuickCopy to from;
    if ((BlkValueRead(to, LIST_ITEM_KOV_F) ~= BlkValueRead(from, LIST_ITEM_KOV_F))) {
        rfalse;
    }
    rtrue;
];
[ LIST_OF_TY_KindData list dummy;
    return BlkValueRead(list, LIST_ITEM_KOV_F);
];
[ LIST_OF_TY_Copy lto lfrom precopied_list_kov no_items i nv bk val splk;
    (no_items = BlkValueRead(lfrom, LIST_LENGTH_F));
    (bk = BlkValueRead(lfrom, LIST_ITEM_KOV_F));
    if ((precopied_list_kov ~= 0 or UNKNOWN_TY)) {
        BlkValueWrite(lto, LIST_ITEM_KOV_F, precopied_list_kov);
    } else {
        BlkValueWrite(lto, LIST_ITEM_KOV_F, bk);
    }
    if (KOVIsBlockValue(bk)) {
        for ((i = 0):(i < no_items):(i)++) {
            (val = BlkValueRead(lfrom, (i + LIST_ITEM_BASE)));
            if ((precopied_list_kov ~= 0 or UNKNOWN_TY)) {
                (nv = BlkValueCreate(precopied_list_kov));
            } else {
                (nv = BlkValueCreate(bk));
            }
            BlkValueCopy(nv, val);
            BlkValueWrite(lto, (i + LIST_ITEM_BASE), nv);
        }
    }
];
[ LIST_OF_TY_Compare listleft listright delta no_items i cf;
    (delta = (BlkValueRead(listleft, LIST_LENGTH_F) - BlkValueRead(listright, LIST_LENGTH_F)));
    if (delta) {
        return delta;
    }
    (no_items = BlkValueRead(listleft, LIST_LENGTH_F));
    if ((no_items == 0)) {
        rfalse;
    }
    (delta = (BlkValueRead(listleft, LIST_ITEM_KOV_F) - BlkValueRead(listright, LIST_ITEM_KOV_F)));
    if (delta) {
        return delta;
    }
    (cf = LIST_OF_TY_ComparisonFn(listleft));
    if ((cf == 0 or UnsignedCompare)) {
        for ((i = 0):(i < no_items):(i)++) {
            (delta = (BlkValueRead(listleft, (i + LIST_ITEM_BASE)) - BlkValueRead(listright, (i + LIST_ITEM_BASE))));
            if (delta) {
                return delta;
            }
        }
    } else {
        for ((i = 0):(i < no_items):(i)++) {
            (delta = (cf)(BlkValueRead(listleft, (i + LIST_ITEM_BASE)),BlkValueRead(listright, (i + LIST_ITEM_BASE))));
            if (delta) {
                return delta;
            }
        }
    }
    rfalse;
];
[ LIST_OF_TY_ComparisonFn list;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    return KOVComparisonFunction(BlkValueRead(list, LIST_ITEM_KOV_F));
];
[ LIST_OF_TY_Distinguish txb1 txb2;
    if ((LIST_OF_TY_Compare(txb1, txb2) == 0)) {
        rfalse;
    }
    rtrue;
];
[ LIST_OF_TY_Hash list len kov rv i;
    (rv = 0);
    (len = BlkValueRead(list, LIST_LENGTH_F));
    (kov = BlkValueRead(list, LIST_ITEM_KOV_F));
    for ((i = 0):(i < len):(i)++) {
        (rv = ((rv*33) + GetHashValue(kov, BlkValueRead(list, (i + LIST_ITEM_BASE)))));
    }
    return rv;
];
[ LIST_OF_TY_Say list format no_items v i bk;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rtrue;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    (bk = KindAtomic(BlkValueRead(list, LIST_ITEM_KOV_F)));
    if ((format == 1)) {
        print "{";
    }
    for ((i = 0):(i < no_items):(i)++) {
        (v = BlkValueRead(list, (i + LIST_ITEM_BASE)));
        switch (format) {
            2:
                DefArt(v);
                ;
            3:
                IndefArt(v);
                ;
            default:
                if ((bk == LIST_OF_TY)) {
                    LIST_OF_TY_Say(v, 1);
                } else {
                    if ((((bk == TEXT_TY)) && ((format == 1)))) {
                        print "~";
                        PrintKindValuePair(bk, v);
                        print "~";
                    } else {
                        PrintKindValuePair(bk, v);
                    }
                }
                ;
        }
        if ((i < (no_items - 2))) {
            print ", ";
        }
        if ((i == (no_items - 2))) {
            if ((format == 1)) {
                print ", ";
            } else {
                if (((KIT_CONFIGURATION_BITMAP)&(SERIAL_COMMA_TCBIT))) {
                    if ((no_items ~= 2)) {
                        print ",";
                    }
                }
                LIST_WRITER_INTERNAL_RM(67);
            }
        }
    }
    if ((format == 1)) {
        print "}";
    }
    (prior_named_list = no_items);
    (prior_named_list_gender = -1);
];
[ LIST_OF_TY_Desc list desc kov obj no_items ex len i;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (ex = BlkValueLBCapacity(list));
    (len = (desc)(-3));
    if (((len + LIST_ITEM_BASE) > ex)) {
        if ((BlkValueSetLBCapacity(list, (len + LIST_ITEM_BASE)) == 0)) {
            rfalse;
        }
    }
    if (kov) {
        BlkValueWrite(list, LIST_ITEM_KOV_F, kov);
    } else {
        BlkValueWrite(list, LIST_ITEM_KOV_F, OBJECT_TY);
    }
    BlkValueWrite(list, LIST_LENGTH_F, len);
    (obj = 0);
    for ((i = 0):(i < len):(i)++) {
        (obj = (desc)(-2,obj,i));
        BlkValueWrite(list, (i + LIST_ITEM_BASE), obj);
    }
    return list;
];
[ LIST_OF_TY_FindItem list v i no_items cf;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (cf = LIST_OF_TY_ComparisonFn(list));
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((cf == 0 or UnsignedCompare)) {
        for ((i = 0):(i < no_items):(i)++) {
            if ((v == BlkValueRead(list, (i + LIST_ITEM_BASE)))) {
                rtrue;
            }
        }
    } else {
        for ((i = 0):(i < no_items):(i)++) {
            if (((cf)(v,BlkValueRead(list, (i + LIST_ITEM_BASE))) == 0)) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ LIST_OF_TY_InsertItem list v posnflag posn nodups i no_items ex nv contents_kind;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    if (((nodups) && (LIST_OF_TY_FindItem(list, v)))) {
        return list;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    BlkValueWrite(list, LIST_LENGTH_F, no_items);
    (contents_kind = BlkValueRead(list, LIST_ITEM_KOV_F));
    if (((posnflag) && ((((posn < 1)) || ((posn > (no_items + 1))))))) {
        print "*** Couldn't add at entry ";
        print posn;
        print " in the list ";
        LIST_OF_TY_Say(list, 1);
        print ", which has entries in the range 1 to ";
        print no_items;
        print " ***^";
        RunTimeProblem(RTP_LISTRANGEERROR);
        rfalse;
    }
    (ex = BlkValueLBCapacity(list));
    if ((((no_items + LIST_ITEM_BASE) + 1) > ex)) {
        if ((BlkValueSetLBCapacity(list, (ex + 16)) == 0)) {
            rfalse;
        }
    }
    if (KOVIsBlockValue(contents_kind)) {
        (nv = BlkValueCreate(contents_kind));
        BlkValueCopy(nv, v);
        (v = nv);
    }
    if (posnflag) {
        (posn)--;
        for ((i = no_items):(i > posn):(i)--) {
            BlkValueWrite(list, (i + LIST_ITEM_BASE), BlkValueRead(list, ((i - 1) + LIST_ITEM_BASE)));
        }
        BlkValueWrite(list, (posn + LIST_ITEM_BASE), v);
    } else {
        BlkValueWrite(list, (no_items + LIST_ITEM_BASE), v);
    }
    BlkValueWrite(list, LIST_LENGTH_F, (no_items + 1));
    return list;
];
[ LIST_OF_TY_AppendList list more posnflag posn nodups v i j no_items msize ex nv;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    if ((((more == 0)) || ((BlkValueWeakKind(more) ~= LIST_OF_TY)))) {
        return list;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    BlkValueWrite(list, LIST_LENGTH_F, no_items);
    if (((posnflag) && ((((posn < 1)) || ((posn > (no_items + 1))))))) {
        print "*** Couldn't add at entry ";
        print posn;
        print " in the list ";
        LIST_OF_TY_Say(list, 1);
        print ", which has entries in the range 1 to ";
        print no_items;
        print " ***^";
        RunTimeProblem(RTP_LISTRANGEERROR);
        rfalse;
    }
    (msize = BlkValueRead(more, LIST_LENGTH_F));
    (ex = BlkValueLBCapacity(list));
    if ((((no_items + msize) + LIST_ITEM_BASE) > ex)) {
        if ((BlkValueSetLBCapacity(list, (((no_items + msize) + LIST_ITEM_BASE) + 8)) == 0)) {
            rfalse;
        }
    }
    if (posnflag) {
        (posn)--;
        for ((i = (no_items + msize)):(i >= (posn + msize)):(i)--) {
            BlkValueWrite(list, (i + LIST_ITEM_BASE), BlkValueRead(list, ((i - msize) + LIST_ITEM_BASE)));
        }
        for ((j = 0):(j < msize):(j)++) {
            (v = BlkValueRead(more, (j + LIST_ITEM_BASE)));
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                (nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F)));
                BlkValueCopy(nv, v);
                (v = nv);
            }
            BlkValueWrite(list, ((posn + j) + LIST_ITEM_BASE), v);
        }
    } else {
        for (((i = 0),(j = 0)):(i < msize):(i)++) {
            (v = BlkValueRead(more, (i + LIST_ITEM_BASE)));
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                (nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F)));
                BlkValueCopy(nv, v);
                (v = nv);
            }
            if ((((nodups == 0)) || ((LIST_OF_TY_FindItem(list, v) == 0)))) {
                BlkValueWrite(list, ((no_items + j) + LIST_ITEM_BASE), v);
                (j)++;
            }
        }
    }
    BlkValueWrite(list, LIST_LENGTH_F, (no_items + j));
    return list;
];
[ LIST_OF_TY_RemoveValue list v forgive i j no_items odsize f cf delendum;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (cf = LIST_OF_TY_ComparisonFn(list));
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    (odsize = no_items);
    BlkValueWrite(list, LIST_LENGTH_F, no_items);
    for ((i = 0):(i < no_items):(i)++) {
        (delendum = BlkValueRead(list, (i + LIST_ITEM_BASE)));
        if ((cf == 0 or UnsignedCompare)) {
            (f = (v == delendum));
        } else {
            (f = ((cf)(v,delendum) == 0));
        }
        if (f) {
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                BlkValueFree(delendum);
            }
            for ((j = (i + 1)):(j < no_items):(j)++) {
                BlkValueWrite(list, ((j - 1) + LIST_ITEM_BASE), BlkValueRead(list, (j + LIST_ITEM_BASE)));
            }
            (no_items)--;
            (i)--;
            BlkValueWrite(list, LIST_LENGTH_F, no_items);
        }
    }
    if ((odsize ~= no_items)) {
        rfalse;
    }
    if (forgive) {
        rfalse;
    }
    print "*** Couldn't remove: the value ";
    PrintKindValuePair(BlkValueRead(list, LIST_ITEM_KOV_F), v);
    print " was not present in the list ";
    LIST_OF_TY_Say(list, 1);
    print " ***^";
    RunTimeProblem(RTP_LISTRANGEERROR);
];
[ LIST_OF_TY_RemoveItemRange list from to forgive i d no_items;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((((((from > to)) || ((from <= 0)))) || ((to > no_items)))) {
        if (forgive) {
            if ((from <= 0)) {
                (from = 1);
            }
            if ((to >= no_items)) {
                (to = no_items);
            }
            if ((from > to)) {
                return list;
            }
        } else {
            print "*** Couldn't remove entries ";
            print from;
            print " to ";
            print to;
            print " from the list ";
            LIST_OF_TY_Say(list, 1);
            print ", which has entries in the range 1 to ";
            print no_items;
            print " ***^";
            RunTimeProblem(RTP_LISTRANGEERROR);
            rfalse;
        }
    }
    (to)--;
    (from)--;
    (d = ((to - from) + 1));
    if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
        for ((i = 0):(i < d):(i)++) {
            BlkValueFree(BlkValueRead(list, ((from + i) + LIST_ITEM_BASE)));
        }
    }
    for ((i = from):(i < (no_items - d)):(i)++) {
        BlkValueWrite(list, (i + LIST_ITEM_BASE), BlkValueRead(list, ((i + d) + LIST_ITEM_BASE)));
    }
    BlkValueWrite(list, LIST_LENGTH_F, (no_items - d));
    return list;
];
[ LIST_OF_TY_Remove_List list rlist i j k v w no_items odsize rsize cf f;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    (odsize = no_items);
    (rsize = BlkValueRead(rlist, LIST_LENGTH_F));
    (cf = LIST_OF_TY_ComparisonFn(list));
    for ((i = 0):(i < no_items):(i)++) {
        (v = BlkValueRead(list, (i + LIST_ITEM_BASE)));
        for ((k = 0):(k < rsize):(k)++) {
            (w = BlkValueRead(rlist, (k + LIST_ITEM_BASE)));
            if ((cf == 0 or UnsignedCompare)) {
                (f = (v == w));
            } else {
                (f = ((cf)(v,w) == 0));
            }
            if (f) {
                if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                    BlkValueFree(v);
                }
                for ((j = (i + 1)):(j < no_items):(j)++) {
                    BlkValueWrite(list, ((j + LIST_ITEM_BASE) - 1), BlkValueRead(list, (j + LIST_ITEM_BASE)));
                }
                (no_items)--;
                (i)--;
                BlkValueWrite(list, LIST_LENGTH_F, no_items);
                break;
            }
        }
    }
    rfalse;
];
[ LIST_OF_TY_GetLength list;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    return BlkValueRead(list, LIST_LENGTH_F);
];
[ LIST_OF_TY_Empty list;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    if ((BlkValueRead(list, LIST_LENGTH_F) == 0)) {
        rtrue;
    }
    rfalse;
];
[ LIST_OF_TY_SetLength list newsize this_way_only truncation_end no_items ex i dv;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    if ((newsize < 0)) {
        return RunTimeProblem(RTP_LISTSIZENEGATIVE, newsize);
    }
    BlkMakeMutable(list);
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((no_items < newsize)) {
        if ((this_way_only == -1)) {
            return list;
        }
        (ex = BlkValueLBCapacity(list));
        if (((newsize + LIST_ITEM_BASE) > ex)) {
            if ((BlkValueSetLBCapacity(list, (newsize + LIST_ITEM_BASE)) == 0)) {
                rfalse;
            }
        }
        (dv = DefaultValueOfKOV(BlkValueRead(list, LIST_ITEM_KOV_F)));
        for ((i = no_items):(i < newsize):(i)++) {
            BlkValueWrite(list, (LIST_ITEM_BASE + i), dv);
        }
        BlkValueWrite(list, LIST_LENGTH_F, newsize);
    }
    if ((no_items > newsize)) {
        if ((this_way_only == 1)) {
            return list;
        }
        if ((truncation_end == -1)) {
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                for ((i = 0):(i < (no_items - newsize)):(i)++) {
                    BlkValueFree(BlkValueRead(list, (LIST_ITEM_BASE + i)));
                }
            }
            for ((i = 0):(i < newsize):(i)++) {
                BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, (((LIST_ITEM_BASE + no_items) - newsize) + i)));
            }
        } else {
            if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
                for ((i = newsize):(i < no_items):(i)++) {
                    BlkValueFree(BlkValueRead(list, (LIST_ITEM_BASE + i)));
                }
            }
        }
        BlkValueWrite(list, LIST_LENGTH_F, newsize);
    }
    return list;
];
[ LIST_OF_TY_GetItem list i forgive no_items;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((((i <= 0)) || ((i > no_items)))) {
        if (forgive) {
            rfalse;
        }
        print "*** Couldn't read from entry ";
        print i;
        print " of a list which";
        switch (no_items) {
            0:
                print " is empty ***^";
                ;
            1:
                print " has only one entry, numbered 1 ***^";
                ;
            default:
                print " has entries numbered from 1 to ";
                print no_items;
                print " ***^";
                ;
        }
        RunTimeProblem(RTP_LISTRANGEERROR);
        if ((no_items >= 1)) {
            (i = 1);
        } else {
            rfalse;
        }
    }
    return BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1));
];
[ WriteLIST_OF_TY_GetItem list i val no_items;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((((i <= 0)) || ((i > no_items)))) {
        print "*** Couldn't write to list entry ";
        print i;
        print " of a list which";
        switch (no_items) {
            0:
                print " is empty ***^";
                ;
            1:
                print " has only one entry, numbered 1 ***^";
                ;
            default:
                print " has entries numbered from 1 to ";
                print no_items;
                print " ***^";
                ;
        }
        return RunTimeProblem(RTP_LISTRANGEERROR);
    }
    BlkValueWrite(list, ((LIST_ITEM_BASE + i) - 1), val);
];
[ LIST_OF_TY_PutItem list i v no_items nv;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {
        (nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F)));
        BlkValueCopy(nv, v);
        (v = nv);
    }
    if ((((i <= 0)) || ((i > no_items)))) {
        rfalse;
    }
    BlkValueWrite(list, ((LIST_ITEM_BASE + i) - 1), v);
];
[ LIST_OF_TY_Reverse list no_items i v;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((no_items < 2)) {
        return list;
    }
    for ((i = 0):((i*2) < no_items):(i)++) {
        (v = BlkValueRead(list, (LIST_ITEM_BASE + i)));
        BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, (((LIST_ITEM_BASE + no_items) - 1) - i)));
        BlkValueWrite(list, (((LIST_ITEM_BASE + no_items) - 1) - i), v);
    }
    return list;
];
[ LIST_OF_TY_Rotate list backwards no_items i v;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((no_items < 2)) {
        return list;
    }
    if (backwards) {
        (v = BlkValueRead(list, LIST_ITEM_BASE));
        for ((i = 0):(i < (no_items - 1)):(i)++) {
            BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, ((LIST_ITEM_BASE + i) + 1)));
        }
        BlkValueWrite(list, ((no_items - 1) + LIST_ITEM_BASE), v);
    } else {
        (v = BlkValueRead(list, ((no_items - 1) + LIST_ITEM_BASE)));
        for ((i = (no_items - 1)):(i > 0):(i)--) {
            BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1)));
        }
        BlkValueWrite(list, LIST_ITEM_BASE, v);
    }
    return list;
];
[ LIST_OF_TY_Sort list dir prop cf i j no_items v;
    BlkMakeMutable(list);
    (no_items = BlkValueRead(list, LIST_LENGTH_F));
    if ((dir == 2)) {
        if ((no_items < 2)) {
            rtrue;
        }
        for ((i = 1):(i < no_items):(i)++) {
            (j = (random((i + 1)) - 1));
            (v = BlkValueRead(list, (LIST_ITEM_BASE + i)));
            BlkValueWrite(list, (LIST_ITEM_BASE + i), BlkValueRead(list, (LIST_ITEM_BASE + j)));
            BlkValueWrite(list, (LIST_ITEM_BASE + j), v);
        }
        rtrue;
    }
    SetSortDomain(ListSwapEntries, ListCompareEntries);
    if (cf) {
        (LIST_OF_TY_Sort_cf = BlkValueCompare);
    } else {
        (LIST_OF_TY_Sort_cf = 0);
    }
    SortArray(list, prop, dir, no_items, 0);
];
[ ListSwapEntries list i j v;
    if ((i == j)) {
        rtrue;
    }
    (v = BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1)));
    BlkValueWrite(list, ((LIST_ITEM_BASE + i) - 1), BlkValueRead(list, ((LIST_ITEM_BASE + j) - 1)));
    BlkValueWrite(list, ((LIST_ITEM_BASE + j) - 1), v);
];
[ ListCompareEntries list col i j d cf;
    if ((i == j)) {
        rfalse;
    }
    (i = BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1)));
    (j = BlkValueRead(list, ((LIST_ITEM_BASE + j) - 1)));
    if (I7S_Col) {
        if ((_final_propertyexists(OBJECT_TY, i, I7S_Col))) {
            (i = _final_propertyvalue(OBJECT_TY, i, I7S_Col));
        } else {
            (i = 0);
        }
        if ((_final_propertyexists(OBJECT_TY, j, I7S_Col))) {
            (j = _final_propertyvalue(OBJECT_TY, j, I7S_Col));
        } else {
            (j = 0);
        }
        (cf = LIST_OF_TY_Sort_cf);
    } else {
        (cf = LIST_OF_TY_ComparisonFn(list));
    }
    if ((cf == 0)) {
        if ((i > j)) {
            rtrue;
        }
        if ((i < j)) {
            return (-(1));
        }
        rfalse;
    } else {
        return (cf)(i,j);
    }
];
[ COMBINATION_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return COMBINATION_TY_Create(arg1, arg2);
            ;
        DESTROY_KOVS:
            COMBINATION_TY_Destroy(arg1);
            ;
        MAKEMUTABLE_KOVS:
            rtrue;
            ;
        COPYKIND_KOVS:
            return COMBINATION_TY_CopyKind(arg1, arg2);
            ;
        COPYQUICK_KOVS:
            rtrue;
            ;
        COPYSB_KOVS:
            BlkValueCopySB1(arg1, arg2);
            ;
        KINDDATA_KOVS:
            return COMBINATION_TY_KindData(arg1);
            ;
        EXTENT_KOVS:
            return (-(1));
            ;
        COPY_KOVS:
            COMBINATION_TY_Copy(arg1, arg2, arg3);
            ;
        COMPARE_KOVS:
            return COMBINATION_TY_Compare(arg1, arg2);
            ;
        HASH_KOVS:
            return COMBINATION_TY_Hash(arg1);
            ;
        DEBUG_KOVS:
            print " = ";
            COMBINATION_TY_Say(arg1);
            ;
    }
    rfalse;
];
[ COMBINATION_TY_Create kind sb long_block N i bk v;
    (N = KindBaseArity(kind));
    (long_block = FlexAllocate(((COMBINATION_ITEM_BASE + N)*WORDSIZE), COMBINATION_TY, BLK_FLAG_WORD));
    BlkValueWrite(long_block, COMBINATION_KIND_F, kind, 1);
    for ((i = 0):(i < N):(i)++) {
        (bk = KindBaseTerm(kind, i));
        if (KOVIsBlockValue(bk)) {
            (v = BlkValueCreate(bk));
        } else {
            (v = DefaultValueOfKOV(bk));
        }
        BlkValueWrite(long_block, (COMBINATION_ITEM_BASE + i), v, 1);
    }
    return BlkValueCreateSB1(sb, long_block);
];
[ COMBINATION_TY_Destroy comb kind no_items i bk;
    (kind = BlkValueRead(comb, COMBINATION_KIND_F));
    (no_items = KindBaseArity(kind));
    for ((i = 0):(i < no_items):(i)++) {
        (bk = KindBaseTerm(kind, i));
        if (KOVIsBlockValue(bk)) {
            BlkValueFree(BlkValueRead(comb, (i + COMBINATION_ITEM_BASE)));
        }
    }
];
[ COMBINATION_TY_CopyKind to from;
    BlkValueWrite(to, COMBINATION_KIND_F, BlkValueRead(from, COMBINATION_KIND_F));
];
[ COMBINATION_TY_CopySB to from;
    BlkValueCopySB1(to, from);
];
[ COMBINATION_TY_KindData comb;
    return BlkValueRead(comb, COMBINATION_KIND_F);
];
[ COMBINATION_TY_Copy to_comb from_comb precopied_comb_kov no_items i nv kind bk;
    (no_items = KindBaseArity(precopied_comb_kov));
    BlkValueWrite(to_comb, COMBINATION_KIND_F, precopied_comb_kov);
    for ((i = 0):(i < no_items):(i)++) {
        (bk = KindBaseTerm(kind, i));
        if (KOVIsBlockValue(bk)) {
            (nv = BlkValueCreate(bk));
            BlkValueCopy(nv, BlkValueRead(from_comb, (i + COMBINATION_ITEM_BASE)));
            BlkValueWrite(to_comb, (i + COMBINATION_ITEM_BASE), nv);
        }
    }
];
[ COMBINATION_TY_Compare left_comb right_comb delta no_items i cf kind bk;
    (kind = BlkValueRead(left_comb, COMBINATION_KIND_F));
    (no_items = KindBaseArity(kind));
    for ((i = 0):(i < no_items):(i)++) {
        (bk = KindBaseTerm(kind, i));
        (cf = KOVComparisonFunction(bk));
        if ((cf == 0 or UnsignedCompare)) {
            (delta = (BlkValueRead(left_comb, (i + COMBINATION_ITEM_BASE)) - BlkValueRead(right_comb, (i + COMBINATION_ITEM_BASE))));
            if (delta) {
                return delta;
            }
        } else {
            (delta = (cf)(BlkValueRead(left_comb, (i + COMBINATION_ITEM_BASE)),BlkValueRead(right_comb, (i + COMBINATION_ITEM_BASE))));
            if (delta) {
                return delta;
            }
        }
    }
    rfalse;
];
[ COMBINATION_TY_Distinguish left_comb right_comb;
    if ((COMBINATION_TY_Compare(left_comb, right_comb) == 0)) {
        rfalse;
    }
    rtrue;
];
[ COMBINATION_TY_Hash comb kind rv no_items i bk;
    (rv = 0);
    (kind = BlkValueRead(comb, COMBINATION_KIND_F));
    (no_items = KindBaseArity(kind));
    for ((i = 0):(i < no_items):(i)++) {
        (bk = KindBaseTerm(kind, i));
        (rv = ((rv*33) + GetHashValue(bk, BlkValueRead(comb, (i + COMBINATION_ITEM_BASE)))));
    }
    return rv;
];
[ COMBINATION_TY_Say comb format no_items v i kind bk;
    if ((((comb == 0)) || ((BlkValueWeakKind(comb) ~= COMBINATION_TY)))) {
        rtrue;
    }
    (kind = BlkValueRead(comb, COMBINATION_KIND_F));
    (no_items = KindBaseArity(kind));
    print "(";
    for ((i = 0):(i < no_items):(i)++) {
        if ((i > 0)) {
            print ", ";
        }
        (bk = KindBaseTerm(kind, i));
        (v = BlkValueRead(comb, (i + COMBINATION_ITEM_BASE)));
        if ((bk == LIST_OF_TY)) {
            LIST_OF_TY_Say(v, 1);
        } else {
            PrintKindValuePair(bk, v);
        }
    }
    print ")";
];
[ RELATION_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return RELATION_TY_Create(arg1, 0, arg2);
            ;
        DESTROY_KOVS:
            RELATION_TY_Destroy(arg1);
            ;
        MAKEMUTABLE_KOVS:
            rtrue;
            ;
        COPYQUICK_KOVS:
            rtrue;
            ;
        COPYSB_KOVS:
            BlkValueCopySB1(arg1, arg2);
            ;
        KINDDATA_KOVS:
            rfalse;
            ;
        EXTENT_KOVS:
            return (-(1));
            ;
        COPY_KOVS:
            RELATION_TY_Copy(arg1, arg2);
            ;
        COMPARE_KOVS:
            return RELATION_TY_Compare(arg1, arg2);
            ;
        HASH_KOVS:
            return arg1;
            ;
        DEBUG_KOVS:
            print " = ";
            RELATION_TY_Say(arg1);
            ;
    }
    rfalse;
];
[ RelationTest relation task X Y handler;
    (handler = RlnGetF(relation, RR_HANDLER));
    return (handler)(relation,task,X,Y);
];
[ RlnGetF rel fld i;
    (rel = BlkValueGetLongBlock(rel));
    return (rel-->(fld));
];
[ RlnSetF rel fld v;
    (rel = BlkValueGetLongBlock(rel));
    ((rel-->(fld)) = v);
];
[ EmptyRelationHandler relation task X Y;
    if ((task == RELS_EMPTY)) {
        rtrue;
    }
    rfalse;
];
[ RELATION_TY_Create kov from sb rel i skov handler;
    (rel = FlexAllocate(((RRV_DATA_BASE + (3*RRP_MIN_SIZE))*WORDSIZE), RELATION_TY, (BLK_FLAG_WORD + BLK_FLAG_MULTIPLE)));
    if ((((from == 0)) && ((kov ~= 0)))) {
        (from = DefaultValueFinder(kov));
    }
    if (from) {
        for ((i = 0):(i < RRV_DATA_BASE):(i)++) {
            BlkValueWrite(rel, i, BlkValueRead(from, i), 1);
        }
        if ((BlkValueRead(from, RRV_HANDLER) == EmptyRelationHandler)) {
            (handler = ChooseRelationHandler(BlkValueRead(rel, RRV_KIND, 1)));
            BlkValueWrite(rel, RRV_NAME, "anonymous relation", 1);
            BlkValueWrite(rel, RRV_PERMISSIONS, (((RELS_TEST + RELS_ASSERT_TRUE) + RELS_ASSERT_FALSE) + RELS_SHOW), 1);
            BlkValueWrite(rel, RRV_HANDLER, handler, 1);
            BlkValueWrite(rel, RRV_STORAGE, (RRP_MIN_SIZE - 1), 1);
            BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation", 1);
            BlkValueWrite(rel, RRV_USED, 0, 1);
            BlkValueWrite(rel, RRV_FILLED, 0, 1);
        }
    } else {
        (handler = ChooseRelationHandler(kov));
        BlkValueWrite(rel, RRV_NAME, "anonymous relation", 1);
        BlkValueWrite(rel, RRV_PERMISSIONS, (((RELS_TEST + RELS_ASSERT_TRUE) + RELS_ASSERT_FALSE) + RELS_SHOW), 1);
        BlkValueWrite(rel, RRV_STORAGE, (RRP_MIN_SIZE - 1), 1);
        BlkValueWrite(rel, RRV_KIND, kov, 1);
        BlkValueWrite(rel, RRV_HANDLER, handler, 1);
        BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation", 1);
        BlkValueWrite(rel, RRV_USED, 0, 1);
        BlkValueWrite(rel, RRV_FILLED, 0, 1);
    }
    return BlkValueCreateSB1(sb, rel);
];
[ RELATION_TY_Destroy rel handler;
    (handler = BlkValueRead(rel, RRV_HANDLER));
    (handler)(rel,RELS_DESTROY);
];
[ RELATION_TY_Copy lto lfrom handler;
    (handler = BlkValueRead(lto, RRV_HANDLER));
    (handler)(lto,RELS_COPY);
];
[ RELATION_TY_Compare rleft rright ind1 ind2;
    (ind1 = BlkValueRead(rleft, RRV_HANDLER));
    (ind2 = BlkValueRead(rright, RRV_HANDLER));
    if ((ind1 ~= ind2)) {
        return (ind1 - ind2);
    }
    if ((IsMutableRelationHandler(ind1) == 0)) {
        rfalse;
    }
    return (rleft - rright);
];
[ RELATION_TY_Distinguish rleft rright;
    if ((RELATION_TY_Compare(rleft, rright) == 0)) {
        rfalse;
    }
    rtrue;
];
[ RELATION_TY_Say rel;
    if ((rel == 0)) {
        print "(null relation)";
    } else {
        print (string) RlnGetF(rel, RR_NAME);
    }
];
[ RELATION_TY_Name rel txt;
    if (rel) {
        BlkValueWrite(rel, RRV_NAME, txt);
        BlkValueWrite(rel, RRV_DESCRIPTION, txt);
    }
];
[ ChooseRelationHandler kov sym;
    if (KOVIsBlockValue(KindBaseTerm(kov, 0))) {
        if (sym) {
            return SymHashListRelationHandler;
        }
        return HashListRelationHandler;
    }
    if (sym) {
        return SymDoubleHashSetRelationHandler;
    }
    return DoubleHashSetRelationHandler;
];
[ IsMutableRelationHandler h;
    if ((h == SymHashListRelationHandler or HashListRelationHandler or SymDoubleHashSetRelationHandler or DoubleHashSetRelationHandler)) {
        rtrue;
    }
    rfalse;
];
[ RELATION_TY_SetValency rel val kov filled cur handler ext;
    (filled = BlkValueRead(rel, RRV_FILLED));
    if (filled) {
        RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE);
        rfalse;
    }
    (kov = BlkValueRead(rel, RRV_KIND));
    if ((val == RRVAL_EQUIV or RRVAL_SYM_V_TO_V or RRVAL_SYM_O_TO_O)) {
        if ((KindBaseTerm(kov, 0) ~= KindBaseTerm(kov, 1))) {
            RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE);
            rfalse;
        }
    }
    (cur = BlkValueRead(rel, RRV_HANDLER));
    switch (val) {
        RRVAL_V_TO_V:
            (handler = ChooseRelationHandler(kov, 0));
            ;
        RRVAL_V_TO_O:
            (handler = HashTableRelationHandler);
            ;
        RRVAL_O_TO_V:
            (handler = ReversedHashTableRelationHandler);
            ;
        RRVAL_O_TO_O:
            (handler = TwoInOneHashTableRelationHandler);
            ;
        RRVAL_EQUIV:
            (handler = EquivHashTableRelationHandler);
            ;
        RRVAL_SYM_V_TO_V:
            (handler = ChooseRelationHandler(kov, 1));
            ;
        RRVAL_SYM_O_TO_O:
            (handler = Sym2in1HashTableRelationHandler);
            ;
        default:
            RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE);
            rfalse;
            ;
    }
    if ((cur == handler)) {
        rtrue;
    }
    if ((cur == TwoInOneHashTableRelationHandler)) {
        (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
        BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (3*ext)));
    } else {
        if ((handler == TwoInOneHashTableRelationHandler)) {
            (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
            BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (4*ext)));
        }
    }
    BlkValueWrite(rel, RRV_HANDLER, handler);
];
[ RELATION_TY_GetValency rel handler;
    return ((BlkValueRead(rel, RRV_PERMISSIONS))&(VALENCY_MASK));
];
[ DoubleHashSetRelationHandler rel task X Y sym kov kx ky at tmp v;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    if ((task == RELS_SET_VALENCY)) {
        return RELATION_TY_SetValency(rel, X);
    } else {
        if ((task == RELS_DESTROY)) {
            (kx = KOVIsBlockValue(kx));
            (ky = KOVIsBlockValue(ky));
            if ((~~(((kx) || (ky))))) {
                rtrue;
            }
            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                (tmp = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                if (((tmp)&(RRF_USED))) {
                    if (kx) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                    }
                    if (ky) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                    }
                }
                (at)--;
            }
            rtrue;
        } else {
            if ((task == RELS_COPY)) {
                (X = KOVIsBlockValue(kx));
                (Y = KOVIsBlockValue(ky));
                if ((~~(((X) || (Y))))) {
                    rtrue;
                }
                (at = BlkValueRead(rel, RRV_STORAGE));
                while ((at >= 0)) {
                    (tmp = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                    if (((tmp)&(RRF_USED))) {
                        if (X) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (tmp = BlkValueCopy(BlkValueCreate(kx), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), tmp);
                        }
                        if (Y) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                            (tmp = BlkValueCopy(BlkValueCreate(ky), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), tmp);
                        }
                    }
                    (at)--;
                }
                rtrue;
            } else {
                if ((task == RELS_SHOW)) {
                    print (string) BlkValueRead(rel, RRV_DESCRIPTION);
                    print ":^";
                    if (sym) {
                        (kov = KOVComparisonFunction(kx));
                        if ((~~(kov))) {
                            (kov = UnsignedCompare);
                        }
                    }
                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                        (tmp = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                        if (((tmp)&(RRF_USED))) {
                            (X = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (Y = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                            if (((sym) && (((kov)(X,Y) > 0)))) {
                                continue;
                            }
                            print "  ";
                            PrintKindValuePair(kx, X);
                            if (sym) {
                                print " <=> ";
                            } else {
                                print " >=> ";
                            }
                            PrintKindValuePair(ky, Y);
                            print "^";
                        }
                    }
                    rtrue;
                } else {
                    if ((task == RELS_EMPTY)) {
                        if ((BlkValueRead(rel, RRV_USED) == 0)) {
                            rtrue;
                        }
                        if ((X == 1)) {
                            DoubleHashSetRelationHandler(rel, RELS_DESTROY);
                            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                (tmp = (RRV_DATA_BASE + (3*at)));
                                BlkValueWrite(rel, tmp, 0);
                                BlkValueWrite(rel, (tmp + 1), 0);
                                BlkValueWrite(rel, (tmp + 2), 0);
                            }
                            BlkValueWrite(rel, RRV_USED, 0);
                            BlkValueWrite(rel, RRV_FILLED, 0);
                            rtrue;
                        }
                        rfalse;
                    } else {
                        if ((task == RELS_LOOKUP_ANY)) {
                            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                (tmp = (RRV_DATA_BASE + (3*at)));
                                if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                    if ((Y == RLANY_GET_X or RLANY_CAN_GET_X)) {
                                        (v = BlkValueRead(rel, (tmp + 2)));
                                        if (KOVIsBlockValue(ky)) {
                                            if ((BlkValueCompare(v, X) ~= 0)) {
                                                continue;
                                            }
                                        } else {
                                            if ((v ~= X)) {
                                                continue;
                                            }
                                        }
                                        if ((Y == RLANY_CAN_GET_X)) {
                                            rtrue;
                                        }
                                        return BlkValueRead(rel, (tmp + 1));
                                    } else {
                                        (v = BlkValueRead(rel, (tmp + 1)));
                                        if (KOVIsBlockValue(kx)) {
                                            if ((BlkValueCompare(v, X) ~= 0)) {
                                                continue;
                                            }
                                        } else {
                                            if ((v ~= X)) {
                                                continue;
                                            }
                                        }
                                        if ((Y == RLANY_CAN_GET_Y)) {
                                            rtrue;
                                        }
                                        return BlkValueRead(rel, (tmp + 2));
                                    }
                                }
                            }
                            if ((Y == RLANY_GET_X or RLANY_GET_Y)) {
                                print "*** Lookup failed: value not found ***^";
                            }
                            rfalse;
                        } else {
                            if ((task == RELS_LOOKUP_ALL_X)) {
                                if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                    rfalse;
                                }
                                LIST_OF_TY_SetLength(Y, 0);
                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                    if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                        (v = BlkValueRead(rel, (tmp + 2)));
                                        if (KOVIsBlockValue(ky)) {
                                            if ((BlkValueCompare(v, X) ~= 0)) {
                                                continue;
                                            }
                                        } else {
                                            if ((v ~= X)) {
                                                continue;
                                            }
                                        }
                                        LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 1)));
                                    }
                                }
                                return Y;
                            } else {
                                if ((task == RELS_LOOKUP_ALL_Y)) {
                                    if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                        rfalse;
                                    }
                                    LIST_OF_TY_SetLength(Y, 0);
                                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                        (tmp = (RRV_DATA_BASE + (3*at)));
                                        if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                            (v = BlkValueRead(rel, (tmp + 1)));
                                            if (KOVIsBlockValue(kx)) {
                                                if ((BlkValueCompare(v, X) ~= 0)) {
                                                    continue;
                                                }
                                            } else {
                                                if ((v ~= X)) {
                                                    continue;
                                                }
                                            }
                                            LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 2)));
                                        }
                                    }
                                    return Y;
                                } else {
                                    if ((task == RELS_LIST)) {
                                        if ((((X == 0)) || ((BlkValueWeakKind(X) ~= LIST_OF_TY)))) {
                                            rfalse;
                                        }
                                        LIST_OF_TY_SetLength(X, 0);
                                        switch (Y) {
                                            RLIST_ALL_X, RLIST_ALL_Y:
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                                        (tmp)++;
                                                        if ((Y == RLIST_ALL_Y)) {
                                                            (tmp)++;
                                                        }
                                                        (v = BlkValueRead(rel, tmp));
                                                        LIST_OF_TY_InsertItem(X, v, 0, 0, 1);
                                                    }
                                                }
                                                return X;
                                                ;
                                            RLIST_ALL_PAIRS:
                                                (Y = BlkValueCreate(kov));
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    if (((BlkValueRead(rel, tmp))&(RRF_USED))) {
                                                        (v = BlkValueRead(rel, (tmp + 1)));
                                                        BlkValueWrite(Y, COMBINATION_ITEM_BASE, v);
                                                        (v = BlkValueRead(rel, (tmp + 2)));
                                                        BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), v);
                                                        LIST_OF_TY_InsertItem(X, Y);
                                                    }
                                                }
                                                BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
                                                BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), 0);
                                                BlkValueFree(Y);
                                                return X;
                                                ;
                                        }
                                        rfalse;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    (at = DoubleHashSetLookUp(rel, kx, ky, X, Y));
    switch (task) {
        RELS_TEST:
            if ((at >= 0)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_ASSERT_TRUE:
            if ((at >= 0)) {
                rtrue;
            }
            (at = (~(at)));
            BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
            if ((BlkValueRead(rel, (RRV_DATA_BASE + (3*at))) == 0)) {
                BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
            }
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), (RRF_USED + RRF_SINGLE));
            if (KOVIsBlockValue(kx)) {
                (X = BlkValueCopy(BlkValueCreate(kx), X));
            }
            if (KOVIsBlockValue(ky)) {
                (Y = BlkValueCopy(BlkValueCreate(ky), Y));
            }
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
            DoubleHashSetCheckResize(rel);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            if ((at < 0)) {
                rtrue;
            }
            BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) - 1));
            if (KOVIsBlockValue(kx)) {
                BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
            }
            if (KOVIsBlockValue(ky)) {
                BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            }
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), RRF_DELETED);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), 0);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), 0);
            rtrue;
            ;
    }
];
[ DoubleHashSetLookUp rel kx ky X Y hashv i free mask perturb flags;
    (hashv = (GetHashValue(kx, X) + GetHashValue(ky, Y)));
    (mask = BlkValueRead(rel, RRV_STORAGE));
    (i = ((hashv)&(mask)));
    (flags = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
    if ((flags == 0)) {
        return (~(i));
    }
    if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y)) {
        return i;
    }
    (free = -1);
    if (((flags)&(RRF_DELETED))) {
        (free = i);
    }
    (perturb = hashv);
    (hashv = i);
    for (:1:) {
        (hashv = (((hashv*5) + perturb) + 1));
        (i = ((hashv)&(mask)));
        (flags = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
        if ((flags == 0)) {
            if ((free >= 0)) {
                return (~(free));
            }
            return (~(i));
        }
        if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y)) {
            return i;
        }
        if ((((free < 0)) && (((flags)&(RRF_DELETED))))) {
            (free = i);
        }
        @ushiftr perturb RRP_PERTURB_SHIFT perturb;
    }
];
[ DoubleHashSetCheckResize rel filled ext newext temp i at kov kx ky F X Y;
    (filled = BlkValueRead(rel, RRV_FILLED));
    (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
    if ((filled >= ((ext - filled)*RRP_CROWDED_IS))) {
        (temp = FlexAllocate((ext*(3*WORDSIZE)), TEXT_TY, (BLK_FLAG_WORD + BLK_FLAG_MULTIPLE)));
        for ((i = 0):(i < (ext*3)):(i)++) {
            BlkValueWrite(temp, i, BlkValueRead(rel, (RRV_DATA_BASE + i)), 1);
        }
        if ((ext >= RRP_LARGE_IS)) {
            (newext = (ext*RRP_RESIZE_LARGE));
        } else {
            (newext = (ext*RRP_RESIZE_SMALL));
        }
        BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (newext*3)));
        BlkValueWrite(rel, RRV_STORAGE, (newext - 1));
        BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
        for ((i = 0):(i < (newext*3)):(i)++) {
            BlkValueWrite(rel, (RRV_DATA_BASE + i), 0);
        }
        (kov = BlkValueRead(rel, RRV_KIND));
        (kx = KindBaseTerm(kov, 0));
        (ky = KindBaseTerm(kov, 1));
        for ((i = 0):(i < ext):(i)++) {
            (F = BlkValueRead(temp, (3*i), 1));
            if ((((F == 0)) || (((F)&(RRF_DELETED))))) {
                continue;
            }
            (X = BlkValueRead(temp, ((3*i) + 1), 1));
            (Y = BlkValueRead(temp, ((3*i) + 2), 1));
            (at = DoubleHashSetLookUp(rel, kx, ky, X, Y));
            if ((at >= 0)) {
                print "*** Duplicate entry while resizing ***^";
                rfalse;
            }
            (at = (~(at)));
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), F);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
        }
        FlexFree(temp);
    }
];
[ DoubleHashSetEntryMatches rel at kx ky X Y cx cy;
    (cx = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
    if (KOVIsBlockValue(kx)) {
        if ((BlkValueCompare(cx, X) ~= 0)) {
            rfalse;
        }
    } else {
        if ((cx ~= X)) {
            rfalse;
        }
    }
    (cy = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
    if (KOVIsBlockValue(ky)) {
        if ((BlkValueCompare(cy, Y) ~= 0)) {
            rfalse;
        }
    } else {
        if ((cy ~= Y)) {
            rfalse;
        }
    }
    rtrue;
];
[ HashListRelationHandler rel task X Y sym kov kx ky;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 1);
];
[ HashTableRelationHandler rel task X Y kov kx ky;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];
[ ReversedHashTableRelationHandler rel task X Y kov kx ky swap;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    switch (task) {
        RELS_SET_VALENCY:
            return RELATION_TY_SetValency(rel, X);
            ;
        RELS_TEST, RELS_ASSERT_TRUE, RELS_ASSERT_FALSE:
            return HashCoreRelationHandler(rel, task, ky, kx, Y, X, 0);
            ;
        RELS_LOOKUP_ANY:
            switch (Y) {
                RLANY_GET_X:
                    (Y = RLANY_GET_Y);
                    ;
                RLANY_GET_Y:
                    (Y = RLANY_GET_X);
                    ;
                RLANY_CAN_GET_X:
                    (Y = RLANY_CAN_GET_Y);
                    ;
                RLANY_CAN_GET_Y:
                    (Y = RLANY_CAN_GET_X);
                    ;
            }
            ;
        RELS_LOOKUP_ALL_X:
            (task = RELS_LOOKUP_ALL_Y);
            ;
        RELS_LOOKUP_ALL_Y:
            (task = RELS_LOOKUP_ALL_X);
            ;
        RELS_SHOW:
            (swap = X);
            (X = Y);
            (Y = swap);
            (swap = kx);
            (kx = ky);
            (ky = swap);
            ;
        RELS_LIST:
            switch (Y) {
                RLIST_ALL_X:
                    (Y = RLIST_ALL_Y);
                    ;
                RLIST_ALL_Y:
                    (Y = RLIST_ALL_X);
                    ;
            }
            ;
    }
    return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);
];
[ SymDoubleHashSetRelationHandler rel task X Y;
    if ((task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)) {
        DoubleHashSetRelationHandler(rel, task, Y, X);
    }
    return DoubleHashSetRelationHandler(rel, task, X, Y, 1);
];
[ SymHashListRelationHandler rel task X Y;
    if ((task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)) {
        HashListRelationHandler(rel, task, Y, X);
    }
    return HashListRelationHandler(rel, task, X, Y);
];
[ Sym2in1HashTableRelationHandler rel task X Y;
    if ((task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)) {
        TwoInOneHashTableRelationHandler(rel, task, Y, X);
    }
    return TwoInOneHashTableRelationHandler(rel, task, X, Y, 1);
];
[ HashCoreRelationHandler rel task kx ky X Y mult sym rev at tmp fl;
    if ((task == RELS_SET_VALENCY)) {
        return RELATION_TY_SetValency(rel, X);
    } else {
        if ((task == RELS_DESTROY)) {
            (kx = KOVIsBlockValue(kx));
            (ky = KOVIsBlockValue(ky));
            if ((~~(((kx) || (ky))))) {
                rtrue;
            }
            (at = BlkValueRead(rel, RRV_STORAGE));
            while ((at >= 0)) {
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                if (((fl)&(RRF_USED))) {
                    if (kx) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                    }
                    if (((ky) || ((~~(((fl)&(RRF_SINGLE))))))) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                    }
                }
                (at)--;
            }
            rtrue;
        } else {
            if ((task == RELS_COPY)) {
                (X = KOVIsBlockValue(kx));
                (Y = KOVIsBlockValue(ky));
                if ((~~(((X) || (Y))))) {
                    rtrue;
                }
                (at = BlkValueRead(rel, RRV_STORAGE));
                while ((at >= 0)) {
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                    if (((fl)&(RRF_USED))) {
                        if (X) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (tmp = BlkValueCopy(BlkValueCreate(kx), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), tmp);
                        }
                        if (((Y) || ((~~(((fl)&(RRF_SINGLE))))))) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                            (tmp = BlkValueCopy(BlkValueCreate(BlkValueWeakKind(tmp)), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), tmp);
                        }
                    }
                    (at)--;
                }
                rtrue;
            } else {
                if ((task == RELS_SHOW)) {
                    print (string) BlkValueRead(rel, RRV_DESCRIPTION);
                    print ":^";
                    switch (RELATION_TY_GetValency(rel)) {
                        RRVAL_SYM_V_TO_V:
                            (sym = 1);
                            (tmp = KOVComparisonFunction(kx));
                            if ((~~(tmp))) {
                                (tmp = UnsignedCompare);
                            }
                            ;
                        RRVAL_O_TO_V:
                            (rev = 1);
                            ;
                    }
                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                        if (((fl)&(RRF_USED))) {
                            (X = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (Y = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                            if (((fl)&(RRF_SINGLE))) {
                                if (((sym) && (((tmp)(X,Y) > 0)))) {
                                    continue;
                                }
                                print "  ";
                                if (rev) {
                                    PrintKindValuePair(ky, Y);
                                } else {
                                    PrintKindValuePair(kx, X);
                                }
                                if (sym) {
                                    print " <=> ";
                                } else {
                                    print " >=> ";
                                }
                                if (rev) {
                                    PrintKindValuePair(kx, X);
                                } else {
                                    PrintKindValuePair(ky, Y);
                                }
                                print "^";
                            } else {
                                for ((mult = 1):(mult <= LIST_OF_TY_GetLength(Y)):(mult)++) {
                                    (fl = LIST_OF_TY_GetItem(Y, mult));
                                    if (((sym) && (((tmp)(X,fl) > 0)))) {
                                        continue;
                                    }
                                    print "  ";
                                    if (rev) {
                                        PrintKindValuePair(ky, fl);
                                    } else {
                                        PrintKindValuePair(kx, X);
                                    }
                                    if (sym) {
                                        print " <=> ";
                                    } else {
                                        print " >=> ";
                                    }
                                    if (rev) {
                                        PrintKindValuePair(kx, X);
                                    } else {
                                        PrintKindValuePair(ky, fl);
                                    }
                                    print "^";
                                }
                            }
                        }
                    }
                    rtrue;
                } else {
                    if ((task == RELS_EMPTY)) {
                        if ((BlkValueRead(rel, RRV_USED) == 0)) {
                            rtrue;
                        }
                        if ((X == 1)) {
                            HashCoreRelationHandler(rel, RELS_DESTROY);
                            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                (tmp = (RRV_DATA_BASE + (3*at)));
                                BlkValueWrite(rel, tmp, 0);
                                BlkValueWrite(rel, (tmp + 1), 0);
                                BlkValueWrite(rel, (tmp + 2), 0);
                            }
                            BlkValueWrite(rel, RRV_USED, 0);
                            BlkValueWrite(rel, RRV_FILLED, 0);
                            rtrue;
                        }
                        rfalse;
                    } else {
                        if ((task == RELS_LOOKUP_ANY)) {
                            if ((Y == RLANY_GET_Y or RLANY_CAN_GET_Y)) {
                                (at = HashCoreLookUp(rel, kx, X));
                                if ((at >= 0)) {
                                    if ((Y == RLANY_CAN_GET_Y)) {
                                        rtrue;
                                    }
                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                    (fl = BlkValueRead(rel, tmp));
                                    (tmp = BlkValueRead(rel, (tmp + 2)));
                                    if (((fl)&(RRF_SINGLE))) {
                                        return tmp;
                                    }
                                    return LIST_OF_TY_GetItem(tmp, 1);
                                }
                            } else {
                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                    (fl = BlkValueRead(rel, tmp));
                                    if (((fl)&(RRF_USED))) {
                                        (sym = BlkValueRead(rel, (tmp + 2)));
                                        if (((fl)&(RRF_SINGLE))) {
                                            if (KOVIsBlockValue(ky)) {
                                                if ((BlkValueCompare(X, sym) ~= 0)) {
                                                    continue;
                                                }
                                            } else {
                                                if ((X ~= sym)) {
                                                    continue;
                                                }
                                            }
                                        } else {
                                            if ((LIST_OF_TY_FindItem(sym, X) == 0)) {
                                                continue;
                                            }
                                        }
                                        if ((Y == RLANY_CAN_GET_X)) {
                                            rtrue;
                                        }
                                        return BlkValueRead(rel, (tmp + 1));
                                    }
                                }
                            }
                            if ((Y == RLANY_GET_X or RLANY_GET_Y)) {
                                print "*** Lookup failed: value not found ***^";
                            }
                            rfalse;
                        } else {
                            if ((task == RELS_LOOKUP_ALL_X)) {
                                if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                    rfalse;
                                }
                                LIST_OF_TY_SetLength(Y, 0);
                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                    (fl = BlkValueRead(rel, tmp));
                                    if (((fl)&(RRF_USED))) {
                                        (sym = BlkValueRead(rel, (tmp + 2)));
                                        if (((fl)&(RRF_SINGLE))) {
                                            if (KOVIsBlockValue(kx)) {
                                                if ((BlkValueCompare(X, sym) ~= 0)) {
                                                    continue;
                                                }
                                            } else {
                                                if ((X ~= sym)) {
                                                    continue;
                                                }
                                            }
                                        } else {
                                            if ((LIST_OF_TY_FindItem(sym, X) == 0)) {
                                                continue;
                                            }
                                        }
                                        LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 1)));
                                    }
                                }
                                return Y;
                            } else {
                                if ((task == RELS_LOOKUP_ALL_Y)) {
                                    if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                        rfalse;
                                    }
                                    LIST_OF_TY_SetLength(Y, 0);
                                    (at = HashCoreLookUp(rel, kx, X));
                                    if ((at >= 0)) {
                                        (tmp = (RRV_DATA_BASE + (3*at)));
                                        (fl = BlkValueRead(rel, tmp));
                                        (tmp = BlkValueRead(rel, (tmp + 2)));
                                        if (((fl)&(RRF_SINGLE))) {
                                            LIST_OF_TY_InsertItem(Y, tmp);
                                        } else {
                                            LIST_OF_TY_AppendList(Y, tmp);
                                        }
                                    }
                                    return Y;
                                } else {
                                    if ((task == RELS_LIST)) {
                                        if ((BlkValueWeakKind(X) ~= LIST_OF_TY)) {
                                            rfalse;
                                        }
                                        LIST_OF_TY_SetLength(X, 0);
                                        switch (Y) {
                                            RLIST_ALL_X:
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    (fl = BlkValueRead(rel, tmp));
                                                    if (((fl)&(RRF_USED))) {
                                                        LIST_OF_TY_InsertItem(X, BlkValueRead(rel, (tmp + 1)));
                                                    }
                                                }
                                                return X;
                                                ;
                                            RLIST_ALL_Y:
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    (fl = BlkValueRead(rel, tmp));
                                                    if (((fl)&(RRF_USED))) {
                                                        (tmp = BlkValueRead(rel, (tmp + 2)));
                                                        if (((fl)&(RRF_SINGLE))) {
                                                            LIST_OF_TY_InsertItem(X, tmp, 0, 0, 1);
                                                        } else {
                                                            LIST_OF_TY_AppendList(X, tmp, 0, 0, 1);
                                                        }
                                                    }
                                                }
                                                return X;
                                                ;
                                            RLIST_ALL_PAIRS:
                                                if ((RELATION_TY_GetValency(rel) == RRVAL_O_TO_V)) {
                                                    (rev = 1);
                                                }
                                                (Y = BlkValueCreate(COMBINATION_TY, tmp));
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (3*at)));
                                                    (fl = BlkValueRead(rel, tmp));
                                                    if (((fl)&(RRF_USED))) {
                                                        BlkValueWrite(Y, (COMBINATION_ITEM_BASE + rev), BlkValueRead(rel, (tmp + 1)));
                                                        (tmp = BlkValueRead(rel, (tmp + 2)));
                                                        if (((fl)&(RRF_SINGLE))) {
                                                            BlkValueWrite(Y, ((COMBINATION_ITEM_BASE + 1) - rev), tmp);
                                                            LIST_OF_TY_InsertItem(X, Y);
                                                        } else {
                                                            for ((mult = LIST_OF_TY_GetLength(tmp)):(mult > 0):(mult)--) {
                                                                BlkValueWrite(Y, ((COMBINATION_ITEM_BASE + 1) - rev), LIST_OF_TY_GetItem(tmp, mult));
                                                                LIST_OF_TY_InsertItem(X, Y);
                                                            }
                                                        }
                                                    }
                                                }
                                                BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
                                                BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), 0);
                                                BlkValueFree(Y);
                                                return X;
                                                ;
                                        }
                                        rfalse;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    (at = HashCoreLookUp(rel, kx, X));
    switch (task) {
        RELS_TEST:
            if ((at < 0)) {
                rfalse;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if (((fl)&(RRF_SINGLE))) {
                if (KOVIsBlockValue(ky)) {
                    if ((BlkValueCompare(tmp, Y) == 0)) {
                        rtrue;
                    }
                } else {
                    if ((tmp == Y)) {
                        rtrue;
                    }
                }
                rfalse;
            } else {
                return LIST_OF_TY_FindItem(tmp, Y);
            }
            ;
        RELS_ASSERT_TRUE:
            if ((at < 0)) {
                (at = (~(at)));
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
                if ((BlkValueRead(rel, (RRV_DATA_BASE + (3*at))) == 0)) {
                    BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), (RRF_USED + RRF_SINGLE));
                if (KOVIsBlockValue(kx)) {
                    (X = BlkValueCopy(BlkValueCreate(kx), X));
                }
                if (KOVIsBlockValue(ky)) {
                    (Y = BlkValueCopy(BlkValueCreate(ky), Y));
                }
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
                HashCoreCheckResize(rel);
                break;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if (((fl)&(RRF_SINGLE))) {
                if (KOVIsBlockValue(ky)) {
                    if ((BlkValueCompare(tmp, Y) == 0)) {
                        rtrue;
                    }
                } else {
                    if ((tmp == Y)) {
                        rtrue;
                    }
                }
                if (mult) {
                    (fl = BlkValueCreate(LIST_OF_TY));
                    BlkValueWrite(fl, LIST_ITEM_KOV_F, ky);
                    LIST_OF_TY_SetLength(fl, 2);
                    BlkValueWrite(fl, LIST_ITEM_BASE, tmp);
                    LIST_OF_TY_PutItem(fl, 2, Y);
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), fl);
                    BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), RRF_USED);
                } else {
                    if (KOVIsBlockValue(ky)) {
                        BlkValueFree(tmp);
                        (Y = BlkValueCopy(BlkValueCreate(ky), Y));
                    }
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
                }
            } else {
                LIST_OF_TY_InsertItem(tmp, Y, 0, 0, 1);
            }
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            if ((at < 0)) {
                rtrue;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if (((fl)&(RRF_SINGLE))) {
                if (KOVIsBlockValue(ky)) {
                    if ((BlkValueCompare(tmp, Y) ~= 0)) {
                        rtrue;
                    }
                } else {
                    if ((tmp ~= Y)) {
                        rtrue;
                    }
                }
                if (KOVIsBlockValue(ky)) {
                    BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                }
                .DeleteEntryIgnoringY;
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) - 1));
                if (KOVIsBlockValue(kx)) {
                    BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), RRF_DELETED);
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), 0);
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), 0);
            } else {
                LIST_OF_TY_RemoveValue(tmp, Y, 1);
                if ((LIST_OF_TY_GetLength(tmp) == 0)) {
                    BlkValueFree(tmp);
                    jump DeleteEntryIgnoringY;
                }
            }
            rtrue;
            ;
    }
    rtrue;
];
[ HashCoreLookUp rel kx X hashv i free mask perturb flags;
    (hashv = GetHashValue(kx, X));
    (mask = BlkValueRead(rel, RRV_STORAGE));
    (i = ((hashv)&(mask)));
    (flags = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
    if ((flags == 0)) {
        return (~(i));
    }
    if (HashCoreEntryMatches(rel, i, kx, X)) {
        return i;
    }
    (free = -1);
    if (((flags)&(RRF_DELETED))) {
        (free = i);
    }
    (perturb = hashv);
    (hashv = i);
    for (:1:) {
        (hashv = (((hashv*5) + perturb) + 1));
        (i = ((hashv)&(mask)));
        (flags = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
        if ((flags == 0)) {
            if ((free >= 0)) {
                return (~(free));
            }
            return (~(i));
        }
        if (HashCoreEntryMatches(rel, i, kx, X)) {
            return i;
        }
        if ((((free < 0)) && (((flags)&(RRF_DELETED))))) {
            (free = i);
        }
        @ushiftr perturb RRP_PERTURB_SHIFT perturb;
    }
];
[ HashCoreCheckResize rel filled ext newext temp i at kov kx F X Y;
    (filled = BlkValueRead(rel, RRV_FILLED));
    (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
    if ((filled >= ((ext - filled)*RRP_CROWDED_IS))) {
        (temp = FlexAllocate((ext*(3*WORDSIZE)), TEXT_TY, (BLK_FLAG_WORD + BLK_FLAG_MULTIPLE)));
        for ((i = 0):(i < (ext*3)):(i)++) {
            BlkValueWrite(temp, i, BlkValueRead(rel, (RRV_DATA_BASE + i)), 1);
        }
        if ((ext >= RRP_LARGE_IS)) {
            (newext = (ext*RRP_RESIZE_LARGE));
        } else {
            (newext = (ext*RRP_RESIZE_SMALL));
        }
        BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (newext*3)));
        BlkValueWrite(rel, RRV_STORAGE, (newext - 1));
        BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
        for ((i = 0):(i < (newext*3)):(i)++) {
            BlkValueWrite(rel, (RRV_DATA_BASE + i), 0);
        }
        (kov = BlkValueRead(rel, RRV_KIND));
        (kx = KindBaseTerm(kov, 1));
        for ((i = 0):(i < ext):(i)++) {
            (F = BlkValueRead(temp, (3*i), 1));
            if ((((F == 0)) || (((F)&(RRF_DELETED))))) {
                continue;
            }
            (X = BlkValueRead(temp, ((3*i) + 1), 1));
            (Y = BlkValueRead(temp, ((3*i) + 2), 1));
            (at = HashCoreLookUp(rel, kx, X));
            if ((at >= 0)) {
                print "*** Duplicate entry while resizing ***^";
                rfalse;
            }
            (at = (~(at)));
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), F);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), Y);
        }
        FlexFree(temp);
    }
];
[ HashCoreEntryMatches rel at kx X cx cy;
    (cx = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
    if (KOVIsBlockValue(kx)) {
        if ((BlkValueCompare(cx, X) ~= 0)) {
            rfalse;
        }
    } else {
        if ((cx ~= X)) {
            rfalse;
        }
    }
    rtrue;
];
[ EquivHashTableRelationHandler rel task X Y kx at at2 tmp fl i ext;
    (kx = KindBaseTerm(BlkValueRead(rel, RRV_KIND), 0));
    if ((task == RELS_SET_VALENCY)) {
        return RELATION_TY_SetValency(rel, X);
    } else {
        if ((task == RELS_DESTROY)) {
            if (KOVIsBlockValue(kx)) {
                (at = BlkValueRead(rel, RRV_STORAGE));
                while ((at >= 0)) {
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                    if (((fl)&(RRF_USED))) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                    }
                    (at)--;
                }
            }
            rtrue;
        } else {
            if ((task == RELS_COPY)) {
                if (KOVIsBlockValue(kx)) {
                    (at = BlkValueRead(rel, RRV_STORAGE));
                    while ((at >= 0)) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                        if (((fl)&(RRF_USED))) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
                            (tmp = BlkValueCopy(BlkValueCreate(kx), tmp));
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1));
                        }
                        (at)--;
                    }
                }
                rtrue;
            } else {
                if ((task == RELS_SHOW)) {
                    print (string) BlkValueRead(rel, RRV_DESCRIPTION);
                    print ":^";
                    (ext = BlkValueRead(rel, RRV_STORAGE));
                    for (((at = 0),(X = RRV_DATA_BASE)):(at <= ext):((at)++,(X = (X + 3)))) {
                        if (((BlkValueRead(rel, X))&(RRF_USED))) {
                            BlkValueWrite(rel, (X + 2), (-(BlkValueRead(rel, (X + 2)))));
                        }
                    }
                    for (((at = 0),((X = RRV_DATA_BASE),(fl = 0))):(at <= ext):((at)++,((X = (X + 3)),(fl = 0)))) {
                        if (((BlkValueRead(rel, X))&(RRF_USED))) {
                            (fl = BlkValueRead(rel, (X + 2)));
                            if ((fl > 0)) {
                                continue;
                            }
                            BlkValueWrite(rel, (X + 2), (-(fl)));
                            (tmp = BlkValueRead(rel, (X + 1)));
                            (i = 0);
                            for (((at2 = (at + 1)),(Y = (RRV_DATA_BASE + (3*at2)))):(at2 <= ext):((at2)++,(Y = (Y + 3)))) {
                                if (((BlkValueRead(rel, Y))&(RRF_USED))) {
                                    if ((BlkValueRead(rel, (Y + 2)) ~= fl)) {
                                        continue;
                                    }
                                    BlkValueWrite(rel, (Y + 2), (-(fl)));
                                    if ((~~(i))) {
                                        print "  { ";
                                        PrintKindValuePair(kx, tmp);
                                        (i = 1);
                                    }
                                    print ", ";
                                    PrintKindValuePair(kx, BlkValueRead(rel, (Y + 1)));
                                }
                            }
                            if (i) {
                                print " }^";
                            }
                        }
                    }
                    rtrue;
                } else {
                    if ((task == RELS_EMPTY)) {
                        rfalse;
                    } else {
                        if ((task == RELS_LOOKUP_ANY)) {
                            if ((Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y)) {
                                rtrue;
                            }
                            return X;
                        } else {
                            if ((task == RELS_LOOKUP_ALL_X or RELS_LOOKUP_ALL_Y)) {
                                if ((BlkValueWeakKind(Y) ~= LIST_OF_TY)) {
                                    rfalse;
                                }
                                LIST_OF_TY_SetLength(Y, 0);
                                BlkValueWrite(Y, LIST_ITEM_KOV_F, kx);
                                (at = HashCoreLookUp(rel, kx, X));
                                if ((at < 0)) {
                                    LIST_OF_TY_InsertItem(Y, X);
                                } else {
                                    (X = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                        (tmp = (RRV_DATA_BASE + (3*at)));
                                        (fl = BlkValueRead(rel, tmp));
                                        if (((fl)&(RRF_USED))) {
                                            if ((BlkValueRead(rel, (tmp + 2)) ~= X)) {
                                                continue;
                                            }
                                            LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 1)));
                                        }
                                    }
                                }
                                return Y;
                            } else {
                                if ((task == RELS_LIST)) {
                                    print "*** Domains of equivalence relations cannot be listed ***^";
                                    return X;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    (at = HashCoreLookUp(rel, kx, X));
    (at2 = HashCoreLookUp(rel, kx, Y));
    switch (task) {
        RELS_TEST:
            if ((at < 0)) {
                if (KOVIsBlockValue(kx)) {
                    if ((BlkValueCompare(X, Y) == 0)) {
                        rtrue;
                    }
                } else {
                    if ((X == Y)) {
                        rtrue;
                    }
                }
                rfalse;
            }
            if ((at2 < 0)) {
                rfalse;
            }
            if ((at == at2)) {
                rtrue;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if ((BlkValueRead(rel, ((RRV_DATA_BASE + (3*at2)) + 2)) == tmp)) {
                rtrue;
            }
            rfalse;
            ;
        RELS_ASSERT_TRUE:
            if (KOVIsBlockValue(kx)) {
                if ((BlkValueCompare(X, Y) == 0)) {
                    rtrue;
                }
            } else {
                if ((X == Y)) {
                    rtrue;
                }
            }
            if ((at < 0)) {
                if ((at2 < 0)) {
                    (tmp = 0);
                    (ext = BlkValueRead(rel, RRV_STORAGE));
                    for ((i = 0):(i <= ext):(i)++) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*i))));
                        if (((fl)&(RRF_USED))) {
                            (fl = BlkValueRead(rel, ((RRV_DATA_BASE + (3*i)) + 2)));
                            if ((fl > tmp)) {
                                (tmp = fl);
                            }
                        }
                    }
                    (tmp)++;
                    BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 2));
                    (at = (~(at)));
                    if (KOVIsBlockValue(kx)) {
                        (X = BlkValueCopy(BlkValueCreate(kx), X));
                    }
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                    if ((fl == 0)) {
                        BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                    }
                    BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), (RRF_USED + RRF_SINGLE));
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), tmp);
                    (at2 = (~(HashCoreLookUp(rel, kx, Y))));
                    if (KOVIsBlockValue(kx)) {
                        (Y = BlkValueCopy(BlkValueCreate(kx), Y));
                    }
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at2))));
                    if ((fl == 0)) {
                        BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                    }
                    BlkValueWrite(rel, (RRV_DATA_BASE + (3*at2)), (RRF_USED + RRF_SINGLE));
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at2)) + 1), Y);
                    BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at2)) + 2), tmp);
                    jump CheckResize;
                }
                (at = (~(at)));
                if (KOVIsBlockValue(kx)) {
                    (X = BlkValueCopy(BlkValueCreate(kx), X));
                }
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at))));
                if ((fl == 0)) {
                    BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), (RRF_USED + RRF_SINGLE));
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), X);
                (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at2)) + 2)));
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), tmp);
                jump CheckResize;
            }
            if ((at2 < 0)) {
                (at2 = (~(at2)));
                if (KOVIsBlockValue(kx)) {
                    (Y = BlkValueCopy(BlkValueCreate(kx), Y));
                }
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (3*at2))));
                if ((fl == 0)) {
                    BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (3*at2)), (RRF_USED + RRF_SINGLE));
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at2)) + 1), Y);
                (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
                BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at2)) + 2), tmp);
                jump CheckResize;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            (fl = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at2)) + 2)));
            if ((tmp < fl)) {
                (i = tmp);
                (tmp = fl);
                (fl = i);
            }
            (ext = BlkValueRead(rel, RRV_STORAGE));
            for ((at = 0):(at <= ext):(at)++) {
                (i = ((RRV_DATA_BASE + (3*at)) + 2));
                if ((BlkValueRead(rel, i) == tmp)) {
                    BlkValueWrite(rel, i, fl);
                }
            }
            .CheckResize;
            HashCoreCheckResize(rel);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            if ((((at < 0)) || ((at2 < 0)))) {
                rtrue;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 2)));
            if ((BlkValueRead(rel, ((RRV_DATA_BASE + (3*at2)) + 2)) ~= tmp)) {
                rtrue;
            }
            BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) - 1));
            if (KOVIsBlockValue(kx)) {
                BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (3*at)) + 1)));
            }
            BlkValueWrite(rel, (RRV_DATA_BASE + (3*at)), RRF_DELETED);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 1), 0);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (3*at)) + 2), 0);
            rtrue;
            ;
    }
];
[ TwoInOneHashTableRelationHandler rel task X Y sym kov kx ky at at2 tmp fl;
    (kov = BlkValueRead(rel, RRV_KIND));
    (kx = KindBaseTerm(kov, 0));
    (ky = KindBaseTerm(kov, 1));
    if ((task == RELS_SET_VALENCY)) {
        return RELATION_TY_SetValency(rel, X);
    } else {
        if ((task == RELS_DESTROY)) {
            (kx = KOVIsBlockValue(kx));
            (ky = KOVIsBlockValue(ky));
            if ((~~(((kx) || (ky))))) {
                rtrue;
            }
            (at = BlkValueRead(rel, RRV_STORAGE));
            while ((at >= 0)) {
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                if (((fl)&(RRF_USED))) {
                    if (((((kx) && (((fl)&(RRF_ENTKEYX))))) || (((ky) && (((fl)&(RRF_ENTKEYY))))))) {
                        BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
                    }
                }
                (at)--;
            }
            rtrue;
        } else {
            if ((task == RELS_COPY)) {
                (X = KOVIsBlockValue(kx));
                (Y = KOVIsBlockValue(ky));
                if ((~~(((X) || (Y))))) {
                    rtrue;
                }
                (at = BlkValueRead(rel, RRV_STORAGE));
                while ((at >= 0)) {
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                    if (((fl)&(RRF_USED))) {
                        if (((((X) && (((fl)&(RRF_ENTKEYX))))) || (((Y) && (((fl)&(RRF_ENTKEYY))))))) {
                            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
                            if (((fl)&(RRF_ENTKEYX))) {
                                (tmp = BlkValueCopy(BlkValueCreate(kx), tmp));
                            } else {
                                (tmp = BlkValueCopy(BlkValueCreate(ky), tmp));
                            }
                            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 1), tmp);
                            if (((fl)&(RRF_HASX))) {
                                (at2 = TwoInOneLookUp(rel, kx, BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 2)), RRF_ENTKEYX));
                                if ((at2 >= 0)) {
                                    BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at2)) + 3), tmp);
                                }
                            }
                            if (((fl)&(RRF_HASY))) {
                                (at2 = TwoInOneLookUp(rel, ky, BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)), RRF_ENTKEYY));
                                if ((at2 >= 0)) {
                                    BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at2)) + 2), tmp);
                                }
                            }
                        }
                    }
                    (at)--;
                }
                rtrue;
            } else {
                if ((task == RELS_SHOW)) {
                    print (string) BlkValueRead(rel, RRV_DESCRIPTION);
                    print ":^";
                    if (sym) {
                        (kov = KOVComparisonFunction(kx));
                        if ((~~(kov))) {
                            (kov = UnsignedCompare);
                        }
                    }
                    for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                        if ((((fl)&(((RRF_USED + RRF_ENTKEYX) + RRF_HASY))) == ((RRF_USED + RRF_ENTKEYX) + RRF_HASY))) {
                            (X = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
                            (Y = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)));
                            if (((sym) && (((kov)(X,Y) > 0)))) {
                                continue;
                            }
                            print "  ";
                            PrintKindValuePair(kx, X);
                            if (sym) {
                                print " <=> ";
                            } else {
                                print " >=> ";
                            }
                            PrintKindValuePair(ky, Y);
                            print "^";
                        }
                    }
                    rtrue;
                } else {
                    if ((task == RELS_EMPTY)) {
                        if ((BlkValueRead(rel, RRV_USED) == 0)) {
                            rtrue;
                        }
                        if ((X == 1)) {
                            TwoInOneHashTableRelationHandler(rel, RELS_DESTROY);
                            for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                (tmp = (RRV_DATA_BASE + (4*at)));
                                BlkValueWrite(rel, tmp, 0);
                                BlkValueWrite(rel, (tmp + 1), 0);
                                BlkValueWrite(rel, (tmp + 2), 0);
                                BlkValueWrite(rel, (tmp + 3), 0);
                            }
                            BlkValueWrite(rel, RRV_USED, 0);
                            BlkValueWrite(rel, RRV_FILLED, 0);
                            rtrue;
                        }
                        rfalse;
                    } else {
                        if ((task == RELS_LOOKUP_ANY)) {
                            switch (Y) {
                                RLANY_GET_X, RLANY_CAN_GET_X:
                                    (at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY));
                                    if ((at >= 0)) {
                                        (tmp = (RRV_DATA_BASE + (4*at)));
                                        if (((BlkValueRead(rel, tmp))&(RRF_HASX))) {
                                            if ((Y == RLANY_CAN_GET_X)) {
                                                rtrue;
                                            }
                                            return BlkValueRead(rel, (tmp + 2));
                                        }
                                    }
                                    ;
                                RLANY_GET_Y, RLANY_CAN_GET_Y:
                                    (at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX));
                                    if ((at >= 0)) {
                                        (tmp = (RRV_DATA_BASE + (4*at)));
                                        if (((BlkValueRead(rel, tmp))&(RRF_HASY))) {
                                            if ((Y == RLANY_CAN_GET_Y)) {
                                                rtrue;
                                            }
                                            return BlkValueRead(rel, (tmp + 3));
                                        }
                                    }
                                    ;
                            }
                            if ((Y == RLANY_GET_X or RLANY_GET_Y)) {
                                print "*** Lookup failed: value not found ***^";
                            }
                            rfalse;
                        } else {
                            if ((task == RELS_LOOKUP_ALL_X)) {
                                (at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY));
                                if ((at >= 0)) {
                                    (tmp = (RRV_DATA_BASE + (4*at)));
                                    if (((BlkValueRead(rel, tmp))&(RRF_HASX))) {
                                        LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 2)));
                                    }
                                }
                                return Y;
                            } else {
                                if ((task == RELS_LOOKUP_ALL_Y)) {
                                    (at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX));
                                    if ((at >= 0)) {
                                        (tmp = (RRV_DATA_BASE + (4*at)));
                                        if (((BlkValueRead(rel, tmp))&(RRF_HASY))) {
                                            LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, (tmp + 3)));
                                        }
                                    }
                                    return Y;
                                } else {
                                    if ((task == RELS_LIST)) {
                                        switch (Y) {
                                            RLIST_ALL_X:
                                                (fl = ((RRF_USED + RRF_ENTKEYX) + RRF_HASY));
                                                jump ListEntryKeys;
                                                ;
                                            RLIST_ALL_Y:
                                                (fl = ((RRF_USED + RRF_ENTKEYY) + RRF_HASX));
                                                .ListEntryKeys;
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (4*at)));
                                                    if ((((BlkValueRead(rel, tmp))&(fl)) == fl)) {
                                                        LIST_OF_TY_InsertItem(X, BlkValueRead(rel, (tmp + 1)), 0, 0, 1);
                                                    }
                                                }
                                                ;
                                            RLIST_ALL_PAIRS:
                                                (tmp = BlkValueRead(X, LIST_ITEM_KOV_F));
                                                if ((KindAtomic(tmp) ~= COMBINATION_TY)) {
                                                    rfalse;
                                                }
                                                (Y = BlkValueCreate(tmp));
                                                for ((at = BlkValueRead(rel, RRV_STORAGE)):(at >= 0):(at)--) {
                                                    (tmp = (RRV_DATA_BASE + (4*at)));
                                                    (fl = BlkValueRead(rel, tmp));
                                                    if ((((fl)&(((RRF_USED + RRF_ENTKEYX) + RRF_HASY))) == ((RRF_USED + RRF_ENTKEYX) + RRF_HASY))) {
                                                        BlkValueWrite(Y, COMBINATION_ITEM_BASE, BlkValueRead(rel, (tmp + 1)));
                                                        BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), BlkValueRead(rel, (tmp + 3)));
                                                        LIST_OF_TY_InsertItem(X, Y);
                                                    }
                                                }
                                                BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);
                                                BlkValueWrite(Y, (COMBINATION_ITEM_BASE + 1), 0);
                                                BlkValueFree(Y);
                                                return X;
                                                ;
                                        }
                                        return X;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    (at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX));
    switch (task) {
        RELS_TEST:
            if ((at < 0)) {
                rfalse;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
            if ((~~(((fl)&(RRF_HASY))))) {
                rfalse;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)));
            if (KOVIsBlockValue(ky)) {
                if ((BlkValueCompare(tmp, Y) == 0)) {
                    rtrue;
                }
            } else {
                if ((tmp == Y)) {
                    rtrue;
                }
            }
            rfalse;
            ;
        RELS_ASSERT_TRUE:
            if ((at < 0)) {
                (at = (~(at)));
                BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                if ((fl == 0)) {
                    BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
                }
                (fl = ((RRF_USED + RRF_HASY) + RRF_ENTKEYX));
                if ((((kx == ky)) || ((~~(((KOVIsBlockValue(kx)) || (KOVIsBlockValue(ky)))))))) {
                    (fl = (fl + RRF_ENTKEYY));
                }
                BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), fl);
                if (KOVIsBlockValue(kx)) {
                    (X = BlkValueCopy(BlkValueCreate(kx), X));
                }
                BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 1), X);
                BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 2), 0);
            } else {
                (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                if (((fl)&(RRF_HASY))) {
                    (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)));
                    if (KOVIsBlockValue(ky)) {
                        if ((BlkValueCompare(tmp, Y) == 0)) {
                            rtrue;
                        }
                    } else {
                        if ((tmp == Y)) {
                            rtrue;
                        }
                    }
                    (at2 = TwoInOneLookUp(rel, ky, tmp, RRF_ENTKEYY));
                    if ((at2 >= 0)) {
                        TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
                    }
                } else {
                    BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), (fl + RRF_HASY));
                }
                (X = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
            }
            (at2 = TwoInOneLookUp(rel, ky, Y, RRF_ENTKEYY));
            if (KOVIsBlockValue(ky)) {
                if ((at2 >= 0)) {
                    (Y = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at2)) + 1)));
                } else {
                    (Y = BlkValueCopy(BlkValueCreate(ky), Y));
                }
            }
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 3), Y);
            if ((at2 >= 0)) {
                TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY, 1);
            } else {
                (at2 = (~(at2)));
            }
            BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) + 1));
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at2))));
            if ((fl == 0)) {
                BlkValueWrite(rel, RRV_FILLED, (BlkValueRead(rel, RRV_FILLED) + 1));
            }
            (fl = ((fl)|(((RRF_USED + RRF_HASX) + RRF_ENTKEYY))));
            if ((((kx == ky)) || ((~~(((KOVIsBlockValue(kx)) || (KOVIsBlockValue(ky)))))))) {
                (fl = ((fl)|(RRF_ENTKEYX)));
            }
            BlkValueWrite(rel, (RRV_DATA_BASE + (4*at2)), fl);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at2)) + 1), Y);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at2)) + 2), X);
            TwoInOneCheckResize(rel);
            rtrue;
            ;
        RELS_ASSERT_FALSE:
            if ((at < 0)) {
                rtrue;
            }
            (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
            if ((((fl)&(RRF_HASY)) == 0)) {
                rtrue;
            }
            (tmp = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 3)));
            if (KOVIsBlockValue(ky)) {
                if ((BlkValueCompare(tmp, Y) ~= 0)) {
                    rtrue;
                }
            } else {
                if ((tmp ~= Y)) {
                    rtrue;
                }
            }
            TwoInOneDelete(rel, at, kx, ky, RRF_ENTKEYX, 1);
            rtrue;
            ;
    }
];
[ TwoInOneDelete rel at kx ky ekflag both fl at2 E i;
    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
    if ((ekflag == RRF_ENTKEYX)) {
        if (((fl)&(RRF_HASY))) {
            (i = ((RRV_DATA_BASE + (4*at)) + 3));
            if (both) {
                (E = BlkValueRead(rel, i));
            }
            BlkValueWrite(rel, i, 0);
            if (both) {
                (at2 = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY));
                if ((at2 >= 0)) {
                    TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);
                }
                if ((at2 == at)) {
                    (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                }
            }
            (fl = ((fl)&((~(RRF_HASY)))));
        }
    } else {
        if (((fl)&(RRF_HASX))) {
            (i = ((RRV_DATA_BASE + (4*at)) + 2));
            if (both) {
                (E = BlkValueRead(rel, i));
            }
            BlkValueWrite(rel, i, 0);
            if (both) {
                (at2 = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX));
                if ((at2 >= 0)) {
                    TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYX);
                    if ((at2 == at)) {
                        (fl = BlkValueRead(rel, (RRV_DATA_BASE + (4*at))));
                    }
                }
            }
            (fl = ((fl)&((~(RRF_HASX)))));
        }
    }
    if ((((fl)&((RRF_HASX + RRF_HASY))) == 0)) {
        if (((((((fl)&(RRF_ENTKEYX))) && (KOVIsBlockValue(kx)))) || ((((((ky ~= kx)) && (((fl)&(RRF_ENTKEYY))))) && (KOVIsBlockValue(ky)))))) {
            BlkValueFree(BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
        }
        BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), RRF_DELETED);
        BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 1), 0);
        BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 2), 0);
        BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 3), 0);
        BlkValueWrite(rel, RRV_USED, (BlkValueRead(rel, RRV_USED) - 1));
    } else {
        BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), fl);
    }
];
[ TwoInOneLookUp rel ke E ekflag hashv i free mask perturb flags;
    (hashv = GetHashValue(ke, E));
    (mask = BlkValueRead(rel, RRV_STORAGE));
    (i = ((hashv)&(mask)));
    (flags = BlkValueRead(rel, (RRV_DATA_BASE + (4*i))));
    if ((flags == 0)) {
        return (~(i));
    }
    if (((((flags)&(ekflag))) && (TwoInOneEntryMatches(rel, i, ke, E)))) {
        return i;
    }
    (free = -1);
    if (((flags)&(RRF_DELETED))) {
        (free = i);
    }
    (perturb = hashv);
    (hashv = i);
    for (:1:) {
        (hashv = (((hashv*5) + perturb) + 1));
        (i = ((hashv)&(mask)));
        (flags = BlkValueRead(rel, (RRV_DATA_BASE + (4*i))));
        if ((flags == 0)) {
            if ((free >= 0)) {
                return (~(free));
            }
            return (~(i));
        }
        if (((((flags)&(ekflag))) && (TwoInOneEntryMatches(rel, i, ke, E)))) {
            return i;
        }
        if ((((free < 0)) && (((flags)&(RRF_DELETED))))) {
            (free = i);
        }
        @ushiftr perturb RRP_PERTURB_SHIFT perturb;
    }
];
[ TwoInOneCheckResize rel filled ext newext temp i at kov kx ky F E X Y;
    (filled = BlkValueRead(rel, RRV_FILLED));
    (ext = (BlkValueRead(rel, RRV_STORAGE) + 1));
    if ((filled >= ((ext - filled)*RRP_CROWDED_IS))) {
        (temp = FlexAllocate((ext*(4*WORDSIZE)), TEXT_TY, (BLK_FLAG_WORD + BLK_FLAG_MULTIPLE)));
        for ((i = 0):(i < (ext*4)):(i)++) {
            BlkValueWrite(temp, i, BlkValueRead(rel, (RRV_DATA_BASE + i)), 1);
        }
        if ((ext >= RRP_LARGE_IS)) {
            (newext = (ext*RRP_RESIZE_LARGE));
        } else {
            (newext = (ext*RRP_RESIZE_SMALL));
        }
        BlkValueSetLBCapacity(rel, (RRV_DATA_BASE + (newext*4)));
        BlkValueWrite(rel, RRV_STORAGE, (newext - 1));
        BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));
        for ((i = 0):(i < (newext*4)):(i)++) {
            BlkValueWrite(rel, (RRV_DATA_BASE + i), 0);
        }
        (kov = BlkValueRead(rel, RRV_KIND));
        (kx = KindBaseTerm(kov, 0));
        (ky = KindBaseTerm(kov, 1));
        for ((i = 0):(i < ext):(i)++) {
            (F = BlkValueRead(temp, (4*i), 1));
            if ((((F == 0)) || (((F)&(RRF_DELETED))))) {
                continue;
            }
            (E = BlkValueRead(temp, ((4*i) + 1), 1));
            (X = BlkValueRead(temp, ((4*i) + 2), 1));
            (Y = BlkValueRead(temp, ((4*i) + 3), 1));
            if (((F)&(RRF_ENTKEYX))) {
                (at = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX));
            } else {
                (at = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY));
            }
            if ((at >= 0)) {
                print "*** Duplicate entry while resizing ***^";
                rfalse;
            }
            (at = (~(at)));
            BlkValueWrite(rel, (RRV_DATA_BASE + (4*at)), F);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 1), E);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 2), X);
            BlkValueWrite(rel, ((RRV_DATA_BASE + (4*at)) + 3), Y);
        }
        FlexFree(temp);
    }
];
[ TwoInOneEntryMatches rel at ke E ce;
    (ce = BlkValueRead(rel, ((RRV_DATA_BASE + (4*at)) + 1)));
    if (KOVIsBlockValue(ke)) {
        if ((BlkValueCompare(ce, E) ~= 0)) {
            rfalse;
        }
    } else {
        if ((ce ~= E)) {
            rfalse;
        }
    }
    rtrue;
];
[ RELATION_TY_Empty rel set handler;
    (handler = RlnGetF(rel, RR_HANDLER));
    return (handler)(rel,RELS_EMPTY,set);
];
[ RELATION_TY_EquivalenceAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if (((perms)&(RELS_EQUIVALENCE))) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        (perms = (perms + RELS_EQUIVALENCE));
        if ((((perms)&(RELS_SYMMETRIC)) == 0)) {
            (perms = (perms + RELS_SYMMETRIC));
        }
    }
    if ((((set == 0)) && (state))) {
        (perms = (perms - RELS_EQUIVALENCE));
        if (((perms)&(RELS_SYMMETRIC))) {
            (perms = (perms - RELS_SYMMETRIC));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to an equivalence relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_SymmetricAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if (((perms)&(RELS_SYMMETRIC))) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        (perms = (perms + RELS_SYMMETRIC));
    }
    if ((((set == 0)) && (state))) {
        (perms = (perms - RELS_SYMMETRIC));
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a symmetric relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_OToOAdjective rel set perms state handler i;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if ((((perms)&((RELS_X_UNIQUE + RELS_Y_UNIQUE))) == (RELS_X_UNIQUE + RELS_Y_UNIQUE))) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        if ((((perms)&(RELS_X_UNIQUE)) == 0)) {
            (perms = (perms + RELS_X_UNIQUE));
        }
        if ((((perms)&(RELS_Y_UNIQUE)) == 0)) {
            (perms = (perms + RELS_Y_UNIQUE));
        }
        if (((perms)&(RELS_EQUIVALENCE))) {
            (perms = (perms - RELS_EQUIVALENCE));
        }
    }
    if ((((set == 0)) && (state))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a one-to-one relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_OToVAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if ((((perms)&((RELS_X_UNIQUE + RELS_Y_UNIQUE))) == RELS_X_UNIQUE)) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        if ((((perms)&(RELS_X_UNIQUE)) == 0)) {
            (perms = (perms + RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
        if (((perms)&(RELS_SYMMETRIC))) {
            (perms = (perms - RELS_SYMMETRIC));
        }
        if (((perms)&(RELS_EQUIVALENCE))) {
            (perms = (perms - RELS_EQUIVALENCE));
        }
    }
    if ((((set == 0)) && (state))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a one-to-various relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_VToOAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if ((((perms)&((RELS_X_UNIQUE + RELS_Y_UNIQUE))) == RELS_Y_UNIQUE)) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if ((((perms)&(RELS_Y_UNIQUE)) == 0)) {
            (perms = (perms + RELS_Y_UNIQUE));
        }
        if (((perms)&(RELS_SYMMETRIC))) {
            (perms = (perms - RELS_SYMMETRIC));
        }
        if (((perms)&(RELS_EQUIVALENCE))) {
            (perms = (perms - RELS_EQUIVALENCE));
        }
    }
    if ((((set == 0)) && (state))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a various-to-one relation ***";
        new_line;
        rtrue;
    }
];
[ RELATION_TY_VToVAdjective rel set perms state handler;
    (perms = RlnGetF(rel, RR_PERMISSIONS));
    if ((((perms)&((RELS_X_UNIQUE + RELS_Y_UNIQUE))) == 0)) {
        (state = 1);
    }
    if ((set < 0)) {
        return state;
    }
    if (((set) && ((state == 0)))) {
        if (((perms)&(RELS_X_UNIQUE))) {
            (perms = (perms - RELS_X_UNIQUE));
        }
        if (((perms)&(RELS_Y_UNIQUE))) {
            (perms = (perms - RELS_Y_UNIQUE));
        }
    }
    if ((((set == 0)) && (state))) {
        if ((((perms)&(RELS_X_UNIQUE)) == 0)) {
            (perms = (perms + RELS_X_UNIQUE));
        }
        if ((((perms)&(RELS_Y_UNIQUE)) == 0)) {
            (perms = (perms + RELS_Y_UNIQUE));
        }
    }
    RlnSetF(rel, RR_PERMISSIONS, perms);
    (handler = RlnGetF(rel, RR_HANDLER));
    if (((handler)(rel,RELS_SET_VALENCY,((perms)&(VALENCY_MASK))) == 0)) {
        print "*** Can't change this to a various-to-various relation ***";
        new_line;
        rtrue;
    }
];
[ Relation_Now1to1 obj1 relation_property obj2 ol;
    if (obj2) {
        objectloop (ol ofclass Object && (_final_propertyexists(OBJECT_TY, ol, relation_property))) {
            if ((_final_propertyvalue(OBJECT_TY, ol, relation_property) == obj2)) {
                (_final_store_property(OBJECT_TY,ol,relation_property, 0));
            }
        }
    }
    if (obj1) {
        (_final_store_property(OBJECT_TY,obj1,relation_property, obj2));
    }
];
[ Relation_NowN1toV obj1 relation_property obj2;
    if (((obj1) && ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) == obj2)))) {
        (_final_store_property(OBJECT_TY,obj1,relation_property, 0));
    }
];
[ Relation_Now1to1V obj1 obj2 KOV relation_property ol N;
    if (obj2) {
        (N = KOVDomainSize(KOV));
        for ((ol = 1):(ol <= N):(ol)++) {
            if ((GProperty(KOV, ol, relation_property) == obj2)) {
                WriteGProperty(KOV, ol, relation_property, 0);
            }
        }
    }
    if (obj1) {
        WriteGProperty(KOV, obj1, relation_property, obj2);
    }
];
[ Relation_NowN1toVV obj1 obj2 KOV relation_property;
    if (((obj1) && ((GProperty(KOV, obj1, relation_property) == obj2)))) {
        WriteGProperty(KOV, obj1, relation_property, 0);
    }
];
[ Relation_NowS1to1 obj1 relation_property obj2;
    if ((((((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, relation_property))))) && ((obj2 ofclass Object)))) && ((_final_propertyexists(OBJECT_TY, obj2, relation_property))))) {
        if (_final_propertyvalue(OBJECT_TY, obj1, relation_property)) {
            (_final_store_property(OBJECT_TY,_final_propertyvalue(OBJECT_TY, obj1, relation_property),relation_property, 0));
        }
        if (_final_propertyvalue(OBJECT_TY, obj2, relation_property)) {
            (_final_store_property(OBJECT_TY,_final_propertyvalue(OBJECT_TY, obj2, relation_property),relation_property, 0));
        }
        (_final_store_property(OBJECT_TY,obj1,relation_property, obj2));
        (_final_store_property(OBJECT_TY,obj2,relation_property, obj1));
    }
];
[ Relation_NowSN1to1 obj1 relation_property obj2;
    if ((((((((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, relation_property))))) && ((obj2 ofclass Object)))) && ((_final_propertyexists(OBJECT_TY, obj2, relation_property))))) && ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) == obj2)))) {
        (_final_store_property(OBJECT_TY,obj1,relation_property, 0));
        (_final_store_property(OBJECT_TY,obj2,relation_property, 0));
    }
];
[ Relation_NowS1to1V obj1 obj2 KOV relation_property;
    if (GProperty(KOV, obj1, relation_property)) {
        WriteGProperty(KOV, GProperty(KOV, obj1, relation_property), relation_property, 0);
    }
    if (GProperty(KOV, obj2, relation_property)) {
        WriteGProperty(KOV, GProperty(KOV, obj2, relation_property), relation_property, 0);
    }
    WriteGProperty(KOV, obj1, relation_property, obj2);
    WriteGProperty(KOV, obj2, relation_property, obj1);
];
[ Relation_NowSN1to1V obj1 obj2 KOV relation_property;
    if ((GProperty(KOV, obj1, relation_property) == obj2)) {
        WriteGProperty(KOV, obj1, relation_property, 0);
        WriteGProperty(KOV, obj2, relation_property, 0);
    }
];
[ Relation_NowVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
    if (((sym) && ((obj2 ~= obj1)))) {
        Relation_NowVtoV(obj2, relation, obj1, 0);
    }
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    ((vtov_structure-->(VTOVS_CACHE_BROKEN)) = 1);
    if (pr) {
        if ((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, pr))))) {
            (i1 = _final_propertyvalue(OBJECT_TY, obj1, pr));
        } else {
            return RunTimeProblem(RTP_IMPREL, obj1, relation);
        }
    } else {
        (i1 = (obj1 - 1));
    }
    if (pr2) {
        if ((((obj2 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj2, pr2))))) {
            (i2 = _final_propertyvalue(OBJECT_TY, obj2, pr2));
        } else {
            return RunTimeProblem(RTP_IMPREL, obj2, relation);
        }
    } else {
        (i2 = (obj2 - 1));
    }
    (pr = ((i1*(vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))) + i2));
    (i1 = (IncreasingPowersOfTwo_TB-->((pr%16))));
    (pr = ((pr/16) + 8));
    ((vtov_structure-->(pr)) = (((vtov_structure-->(pr)))|(i1)));
];
[ Relation_NowNVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
    if (((sym) && ((obj2 ~= obj1)))) {
        Relation_NowNVtoV(obj2, relation, obj1, 0);
    }
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    ((vtov_structure-->(VTOVS_CACHE_BROKEN)) = 1);
    if (pr) {
        if ((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, pr))))) {
            (i1 = _final_propertyvalue(OBJECT_TY, obj1, pr));
        } else {
            return RunTimeProblem(RTP_IMPREL, obj1, relation);
        }
    } else {
        (i1 = (obj1 - 1));
    }
    if (pr2) {
        if ((((obj2 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj2, pr2))))) {
            (i2 = _final_propertyvalue(OBJECT_TY, obj2, pr2));
        } else {
            return RunTimeProblem(RTP_IMPREL, obj2, relation);
        }
    } else {
        (i2 = (obj2 - 1));
    }
    (pr = ((i1*(vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))) + i2));
    (i1 = (IncreasingPowersOfTwo_TB-->((pr%16))));
    (pr = ((pr/16) + 8));
    if ((((vtov_structure-->(pr)))&(i1))) {
        ((vtov_structure-->(pr)) = ((vtov_structure-->(pr)) - i1));
    }
];
[ Relation_TestVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    if (((sym) && ((obj2 > obj1)))) {
        (sym = obj1);
        (obj1 = obj2);
        (obj2 = sym);
    }
    if (pr) {
        if ((((obj1 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj1, pr))))) {
            (i1 = _final_propertyvalue(OBJECT_TY, obj1, pr));
        } else {
            RunTimeProblem(RTP_IMPREL, obj1, relation);
            rfalse;
        }
    } else {
        (i1 = (obj1 - 1));
    }
    if (pr2) {
        if ((((obj2 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj2, pr2))))) {
            (i2 = _final_propertyvalue(OBJECT_TY, obj2, pr2));
        } else {
            RunTimeProblem(RTP_IMPREL, obj2, relation);
            rfalse;
        }
    } else {
        (i2 = (obj2 - 1));
    }
    (pr = ((i1*(vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))) + i2));
    (i1 = (IncreasingPowersOfTwo_TB-->((pr%16))));
    (pr = ((pr/16) + 8));
    if ((((vtov_structure-->(pr)))&(i1))) {
        rtrue;
    }
    rfalse;
];
[ Relation_NowEquiv obj1 relation_property obj2 big little;
    (big = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
    (little = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
    if ((big == little)) {
        rtrue;
    }
    if ((big < little)) {
        (little = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
        (big = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
    }
    objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
        if ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) == big)) {
            (_final_store_property(OBJECT_TY,obj1,relation_property, little));
        }
    }
];
[ Relation_NowNEquiv obj1 relation_property obj2 old new;
    (old = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
    (new = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
    if ((old ~= new)) {
        rtrue;
    }
    (new = 0);
    objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
        if ((_final_propertyvalue(OBJECT_TY, obj2, relation_property) > new)) {
            (new = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
        }
    }
    (new)++;
    (_final_store_property(OBJECT_TY,obj1,relation_property, new));
];
[ Relation_NowEquivV obj1 obj2 KOV relation_property n big little i;
    (big = GProperty(KOV, obj1, relation_property));
    (little = GProperty(KOV, obj2, relation_property));
    if ((big == little)) {
        rtrue;
    }
    if ((big < little)) {
        (little = GProperty(KOV, obj1, relation_property));
        (big = GProperty(KOV, obj2, relation_property));
    }
    (n = KOVDomainSize(KOV));
    for ((i = 1):(i <= n):(i)++) {
        if ((GProperty(KOV, i, relation_property) == big)) {
            WriteGProperty(KOV, i, relation_property, little);
        }
    }
];
[ Relation_NowNEquivV obj1 obj2 KOV relation_property n old new i;
    (old = GProperty(KOV, obj1, relation_property));
    (new = GProperty(KOV, obj2, relation_property));
    if ((old ~= new)) {
        rtrue;
    }
    (new = 0);
    (n = KOVDomainSize(KOV));
    for ((i = 1):(i <= n):(i)++) {
        if ((GProperty(KOV, i, relation_property) > new)) {
            (new = GProperty(KOV, i, relation_property));
        }
    }
    (new)++;
    WriteGProperty(KOV, obj1, relation_property, new);
];
[ Relation_ShowVtoV relation sym x obj1 obj2 pr pr2 proutine1 proutine2 vtov_structure;
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    (proutine1 = (vtov_structure-->(VTOVS_LEFT_PRINTING_ROUTINE)));
    (proutine2 = (vtov_structure-->(VTOVS_RIGHT_PRINTING_ROUTINE)));
    if (((pr) && (pr2))) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, pr))) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, pr2))) {
                if (((sym) && ((obj2 > obj1)))) {
                    continue;
                }
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    CDefArt(obj1);
                    if (sym) {
                        print "  <=>  ";
                    } else {
                        print "  >=>  ";
                    }
                    DefArt(obj2);
                    print "^";
                }
            }
        }
        rtrue;
    }
    if (((pr) && ((pr2 == 0)))) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, pr))) {
            for ((obj2 = 1):(obj2 <= (vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))):(obj2)++) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    CDefArt(obj1);
                    print "  >=>  ";
                    (proutine2)(obj2);
                    print "^";
                }
            }
        }
        rtrue;
    }
    if ((((pr == 0)) && (pr2))) {
        for ((obj1 = 1):(obj1 <= (vtov_structure-->(2))):(obj1)++) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, pr2))) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    (proutine1)(obj1);
                    print "  >=>  ";
                    DefArt(obj2);
                    print "^";
                }
            }
        }
        rtrue;
    }
    for ((obj1 = 1):(obj1 <= (vtov_structure-->(2))):(obj1)++) {
        for ((obj2 = 1):(obj2 <= (vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))):(obj2)++) {
            if (Relation_TestVtoV(obj1, relation, obj2)) {
                if ((x == 0)) {
                    print (string) RlnGetF(relation, RR_DESCRIPTION);
                    print ":^";
                    (x = 1);
                }
                print "  ";
                (proutine1)(obj1);
                print "  >=>  ";
                (proutine2)(obj2);
                print "^";
            }
        }
    }
];
[ Relation_ShowOtoO relation sym x relation_property t tr N obj1 obj2;
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (tr = KindBaseTerm(RlnGetF(relation, RR_KIND), 1));
    if ((t == OBJECT_TY)) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            (obj2 = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
            if (((sym) && ((obj2 < obj1)))) {
                continue;
            }
            if ((obj2 == 0)) {
                continue;
            }
            if ((x == 0)) {
                print (string) RlnGetF(relation, RR_DESCRIPTION);
                print ":^";
                (x = 1);
            }
            print "  ";
            CDefArt(obj1);
            if (sym) {
                print "  ==  ";
            } else {
                print "  >=>  ";
            }
            PrintKindValuePair(tr, obj2);
            print "^";
        }
    } else {
        (N = KOVDomainSize(t));
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            (obj2 = GProperty(t, obj1, relation_property));
            if (((sym) && ((obj2 < obj1)))) {
                continue;
            }
            if ((obj2 == 0)) {
                continue;
            }
            if ((x == 0)) {
                print (string) RlnGetF(relation, RR_DESCRIPTION);
                print ":^";
                (x = 1);
            }
            print "  ";
            PrintKindValuePair(t, obj1);
            if (sym) {
                print "  ==  ";
            } else {
                print "  >=>  ";
            }
            PrintKindValuePair(tr, obj2);
            print "^";
        }
    }
];
[ Relation_RShowOtoO relation sym x relation_property obj1 obj2 t1 t2 N1 N2;
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t1 = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (t2 = KindBaseTerm(RlnGetF(relation, RR_KIND), 1));
    if ((t2 == OBJECT_TY)) {
        if ((t1 == OBJECT_TY)) {
            objectloop (obj1 ofclass Object && obj1) {
                objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
                    if ((_final_propertyvalue(OBJECT_TY, obj2, relation_property) ~= obj1)) {
                        continue;
                    }
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    CDefArt(obj1);
                    print "  >=>  ";
                    DefArt(obj2);
                    print "^";
                }
            }
        } else {
            (N1 = KOVDomainSize(t1));
            for ((obj1 = 1):(obj1 <= N1):(obj1)++) {
                objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
                    if ((_final_propertyvalue(OBJECT_TY, obj2, relation_property) ~= obj1)) {
                        continue;
                    }
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    PrintKindValuePair(t1, obj1);
                    print "  >=>  ";
                    DefArt(obj2);
                    print "^";
                }
            }
        }
    } else {
        (N2 = KOVDomainSize(t2));
        if ((t1 == OBJECT_TY)) {
            objectloop (obj1 ofclass Object && obj1) {
                for ((obj2 = 1):(obj2 <= N2):(obj2)++) {
                    if ((GProperty(t2, obj2, relation_property) ~= obj1)) {
                        continue;
                    }
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    CDefArt(obj1);
                    print "  >=>  ";
                    PrintKindValuePair(t2, obj2);
                    print "^";
                }
            }
        } else {
            (N1 = KOVDomainSize(t1));
            for ((obj1 = 1):(obj1 <= N1):(obj1)++) {
                for ((obj2 = 1):(obj2 <= N2):(obj2)++) {
                    if ((GProperty(t2, obj2, relation_property) ~= obj1)) {
                        continue;
                    }
                    if ((x == 0)) {
                        print (string) RlnGetF(relation, RR_DESCRIPTION);
                        print ":^";
                        (x = 1);
                    }
                    print "  ";
                    PrintKindValuePair(t1, obj1);
                    print "  >=>  ";
                    PrintKindValuePair(t2, obj2);
                    print "^";
                }
            }
        }
    }
];
[ RSE_Flip KOV v relation_property x;
    (x = GProperty(KOV, v, relation_property));
    (x = (-(x)));
    WriteGProperty(KOV, v, relation_property, x);
];
[ RSE_Set KOV v relation_property;
    if ((GProperty(KOV, v, relation_property) < 0)) {
        rtrue;
    }
    rfalse;
];
[ Relation_ShowEquiv relation relation_property obj1 obj2 v c d somegroups t N x;
    print (string) RlnGetF(relation, RR_DESCRIPTION);
    print ":^";
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (N = KOVDomainSize(t));
    if ((t == OBJECT_TY)) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            (_final_store_property(OBJECT_TY,obj1,relation_property, (-(_final_propertyvalue(OBJECT_TY, obj1, relation_property)))));
        }
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            if ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) < 0)) {
                (v = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
                (c = 0);
                objectloop (obj2 ofclass Object && (obj2 has workflag2)) {
                    give obj2 ~workflag2;
                }
                objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
                    if ((_final_propertyvalue(OBJECT_TY, obj2, relation_property) == v)) {
                        give obj2 workflag2;
                        (_final_store_property(OBJECT_TY,obj2,relation_property, (-(v))));
                        (c)++;
                    }
                }
                if ((c > 1)) {
                    (somegroups = 1);
                    print "  { ";
                    WriteListOfMarkedObjects(ENGLISH_BIT);
                    print " }^";
                } else {
                    (_final_store_property(OBJECT_TY,obj1,relation_property, v));
                }
            }
        }
        objectloop (obj2 ofclass Object && (obj2 has workflag2)) {
            give obj2 ~workflag2;
        }
        (c = 0);
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            if ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) < 0)) {
                (c)++;
                give obj1 workflag2;
            }
        }
        if ((c == 0)) {
            rtrue;
        }
        if (somegroups) {
            print "  and ";
        } else {
            print "  ";
        }
        if ((c < 4)) {
            WriteListOfMarkedObjects(ENGLISH_BIT);
            print " in";
        } else {
            print c;
        }
        if ((c == 1)) {
            print " a";
        }
        print " single-member group";
        if ((c > 1)) {
            print "s";
        }
        print "^";
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            if ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) < 0)) {
                (_final_store_property(OBJECT_TY,obj1,relation_property, (-(_final_propertyvalue(OBJECT_TY, obj1, relation_property)))));
            }
        }
    } else {
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            RSE_Flip(t, obj1, relation_property);
        }
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            if (RSE_Set(t, obj1, relation_property)) {
                (v = GProperty(t, obj1, relation_property));
                (c = 0);
                for ((obj2 = 1):(obj2 <= N):(obj2)++) {
                    if ((GProperty(t, obj2, relation_property) == v)) {
                        (c)++;
                    }
                }
                if ((c > 1)) {
                    (somegroups = 1);
                    print "  {";
                    (d = 0);
                    for ((obj2 = 1):(obj2 <= N):(obj2)++) {
                        if ((GProperty(t, obj2, relation_property) == v)) {
                            print " ";
                            PrintKindValuePair(t, obj2);
                            if ((d < (c - 1))) {
                                print ",";
                            }
                            print " ";
                            RSE_Flip(t, obj2, relation_property);
                            (d)++;
                        }
                    }
                    print "}^";
                } else {
                    WriteGProperty(t, obj1, relation_property, v);
                }
            }
        }
        objectloop (obj2 ofclass Object && (obj2 has workflag2)) {
            give obj2 ~workflag2;
        }
        (c = 0);
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            if (RSE_Set(t, obj1, relation_property)) {
                (c)++;
            }
        }
        if ((c == 0)) {
            rtrue;
        }
        if (somegroups) {
            print "  and ";
        } else {
            print "  ";
        }
        if ((c == 1)) {
            print "a";
        } else {
            print c;
        }
        print " single-member group";
        if ((c > 1)) {
            print "s";
        }
        print "^";
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            if (RSE_Set(t, obj1, relation_property)) {
                RSE_Flip(t, obj1, relation_property);
            }
        }
    }
];
[ Relation_EmptyOtoO relation sym clear relation_property obj1 obj2 t1 t2 N1 N2;
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t1 = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (t2 = KindBaseTerm(RlnGetF(relation, RR_KIND), 1));
    if ((t2 == OBJECT_TY)) {
        objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
            (obj1 = _final_propertyvalue(OBJECT_TY, obj2, relation_property));
            if (obj1) {
                if (clear) {
                    (_final_store_property(OBJECT_TY,obj2,relation_property, 0));
                } else {
                    rfalse;
                }
            }
        }
    } else {
        for ((obj2 = 1):(obj2 <= N2):(obj2)++) {
            (obj1 = GProperty(t2, obj2, relation_property));
            if (obj1) {
                if (clear) {
                    WriteGProperty(t2, obj2, relation_property, 0);
                } else {
                    rfalse;
                }
            }
        }
    }
    if ((t1 ~= t2)) {
        if ((t1 == OBJECT_TY)) {
            objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
                (obj2 = _final_propertyvalue(OBJECT_TY, obj1, relation_property));
                if (obj2) {
                    if (clear) {
                        (_final_store_property(OBJECT_TY,obj1,relation_property, 0));
                    } else {
                        rfalse;
                    }
                }
            }
        } else {
            for ((obj1 = 1):(obj1 <= N2):(obj1)++) {
                (obj2 = GProperty(t1, obj1, relation_property));
                if (obj2) {
                    if (clear) {
                        WriteGProperty(t1, obj1, relation_property, 0);
                    } else {
                        rfalse;
                    }
                }
            }
        }
    }
    rtrue;
];
[ Relation_EmptyEquiv relation sym clear relation_property obj1 obj2 t N v;
    (relation_property = RlnGetF(relation, RR_STORAGE));
    (t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0));
    (N = KOVDomainSize(t));
    if (clear) {
        (v = 1);
        if ((t == OBJECT_TY)) {
            objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
                (_final_store_property(OBJECT_TY,obj1,relation_property, (v)++));
            }
        } else {
            for ((obj1 = 1):(obj1 <= N):(obj1)++) {
                WriteGProperty(t, obj1, relation_property, (v)++);
            }
        }
        rtrue;
    }
    if ((t == OBJECT_TY)) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, relation_property))) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, relation_property))) {
                if ((((obj1 < obj2)) && ((_final_propertyvalue(OBJECT_TY, obj1, relation_property) == _final_propertyvalue(OBJECT_TY, obj2, relation_property))))) {
                    rfalse;
                }
            }
        }
    } else {
        for ((obj1 = 1):(obj1 <= N):(obj1)++) {
            for ((obj2 = (obj1 + 1)):(obj1 <= N):(obj1)++) {
                if ((GProperty(t, obj1, relation_property) == GProperty(t, obj2, relation_property))) {
                    rfalse;
                }
            }
        }
    }
    rtrue;
];
[ Relation_EmptyVtoV relation sym clear vtov_structure obj1 obj2 pr pr2 proutine1 proutine2;
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    (pr = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    (proutine1 = (vtov_structure-->(VTOVS_LEFT_PRINTING_ROUTINE)));
    (proutine2 = (vtov_structure-->(VTOVS_RIGHT_PRINTING_ROUTINE)));
    if (((pr) && (pr2))) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, pr))) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, pr2))) {
                if (((sym) && ((obj2 > obj1)))) {
                    continue;
                }
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if (clear) {
                        Relation_NowNVtoV(obj1, relation, obj2, sym);
                    } else {
                        rfalse;
                    }
                }
            }
        }
        rtrue;
    }
    if (((pr) && ((pr2 == 0)))) {
        objectloop (obj1 ofclass Object && (_final_propertyexists(OBJECT_TY, obj1, pr))) {
            for ((obj2 = 1):(obj2 <= (vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))):(obj2)++) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if (clear) {
                        Relation_NowNVtoV(obj1, relation, obj2, sym);
                    } else {
                        rfalse;
                    }
                }
            }
        }
        rtrue;
    }
    if ((((pr == 0)) && (pr2))) {
        for ((obj1 = 1):(obj1 <= (vtov_structure-->(2))):(obj1)++) {
            objectloop (obj2 ofclass Object && (_final_propertyexists(OBJECT_TY, obj2, pr2))) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if (clear) {
                        Relation_NowNVtoV(obj1, relation, obj2, sym);
                    } else {
                        rfalse;
                    }
                }
            }
        }
        rtrue;
    }
    for ((obj1 = 1):(obj1 <= (vtov_structure-->(2))):(obj1)++) {
        for ((obj2 = 1):(obj2 <= (vtov_structure-->(VTOVS_RIGHT_DOMAIN_SIZE))):(obj2)++) {
            if (Relation_TestVtoV(obj1, relation, obj2)) {
                if (Relation_TestVtoV(obj1, relation, obj2)) {
                    if (clear) {
                        Relation_NowNVtoV(obj1, relation, obj2, sym);
                    } else {
                        rfalse;
                    }
                }
            }
        }
    }
    rtrue;
];
[ RelationRouteTo relation from to count handler;
    if (count) {
        if ((from == 0)) {
            return (-(1));
        }
        if ((to == 0)) {
            return (-(1));
        }
        if ((relation == 0)) {
            return (-(1));
        }
    } else {
        if ((from == 0)) {
            rfalse;
        }
        if ((to == 0)) {
            rfalse;
        }
        if ((relation == 0)) {
            rfalse;
        }
    }
    if ((from == to)) {
        rfalse;
    }
    if ((((RlnGetF(relation, RR_PERMISSIONS))&(RELS_ROUTE_FIND)) == 0)) {
        RunTimeProblem(RTP_ROUTELESS);
        rfalse;
    }
    if ((RlnGetF(relation, RR_STORAGE) == 0)) {
        rfalse;
    }
    (handler = RlnGetF(relation, RR_HANDLER));
    if (count) {
        return (handler)(relation,RELS_ROUTE_FIND_COUNT,from,to);
    }
    return (handler)(relation,RELS_ROUTE_FIND,from,to);
];
[ RelFollowVector rv from to obj i;
    if ((rv == 0)) {
        return (-(1));
    }
    (i = 0);
    (obj = from);
    while ((((obj ~= to)) && ((i <= MAX_ROUTE_LENGTH)))) {
        (i)++;
        (obj = (obj.vector));
    }
    return i;
];
[ OtoVRelRouteTo relation_property from to previous;
    while (((((to) && ((_final_propertyexists(OBJECT_TY, to, relation_property))))) && (_final_propertyvalue(OBJECT_TY, to, relation_property)))) {
        (previous = _final_propertyvalue(OBJECT_TY, to, relation_property));
        ((previous.vector) = to);
        if ((previous == from)) {
            return to;
        }
        (to = previous);
    }
    rfalse;
];
[ VtoORelRouteTo relation_property from to next start;
    (start = from);
    while (((((from) && ((_final_propertyexists(OBJECT_TY, from, relation_property))))) && (_final_propertyvalue(OBJECT_TY, from, relation_property)))) {
        (next = _final_propertyvalue(OBJECT_TY, from, relation_property));
        ((from.vector) = next);
        if ((next == to)) {
            return (start.vector);
        }
        (from = next);
    }
    rfalse;
];
[ VtoVRelRouteTo relation from to count obj obj2 related progressed left_ix pr2 i vtov_structure;
    (vtov_structure = RlnGetF(relation, RR_STORAGE));
    if ((vtov_structure-->(VTOVS_CACHE))) {
        return FastVtoVRelRouteTo(relation, from, to, count);
    }
    (left_ix = (vtov_structure-->(VTOVS_LEFT_INDEX_PROP)));
    (pr2 = (vtov_structure-->(VTOVS_RIGHT_INDEX_PROP)));
    objectloop (obj ofclass Object && (((obj ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj, A_vector))))) {
        ((obj.vector) = 0);
    }
    ((to.vector) = 1);
    while (1) {
        (progressed = 0);
        objectloop (obj ofclass Object && (((obj ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj, left_ix))))) {
            if (((obj.vector) == 0)) {
                objectloop (obj2 ofclass Object && (((((obj2 ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj2, pr2))))) && (((obj2.vector) > 0)))) {
                    if (Relation_TestVtoV(obj, relation, obj2)) {
                        ((obj.vector) = ((obj2)|(WORD_HIGHBIT)));
                        (progressed = 1);
                        continue;
                    }
                }
            }
        }
        objectloop (obj ofclass Object && (((obj ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj, left_ix))))) {
            ((obj.vector) = (((obj.vector))&((~(WORD_HIGHBIT)))));
        }
        if ((from.vector)) {
            break;
        }
        if ((progressed == 0)) {
            break;
        }
    }
    if (count) {
        if (((from.vector) == 0)) {
            return (-(1));
        }
        (i = 0);
        (obj = from);
        while ((((obj ~= to)) && ((i <= MAX_ROUTE_LENGTH)))) {
            (i)++;
            (obj = (obj.vector));
        }
        return i;
    }
    return (from.vector);
];
[ FastVtoVRelRouteTo relation from to count domainsize cache cache2 left_ix ox oy oj offset axy axj ayj;
    (domainsize = (RlnGetF(relation, RR_STORAGE)-->(2)));
    (left_ix = (RlnGetF(relation, RR_STORAGE)-->(VTOVS_LEFT_INDEX_PROP)));
    if ((((_final_propertyexists(OBJECT_TY, from, left_ix))) && ((_final_propertyexists(OBJECT_TY, to, left_ix))))) {
        if ((domainsize < 256)) {
            (cache = (RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE)));
            (cache2 = (cache + (domainsize*domainsize)));
            if (((RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE_BROKEN)) == 1)) {
                ((RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE_BROKEN)) = 0);
                objectloop (oy ofclass Object && (_final_propertyexists(OBJECT_TY, oy, left_ix))) {
                    objectloop (ox ofclass Object && (_final_propertyexists(OBJECT_TY, ox, left_ix))) {
                        if (Relation_TestVtoV(oy, relation, ox)) {
                            (offset = ((_final_propertyvalue(OBJECT_TY, oy, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, ox, left_ix)));
                            ((cache->(offset)) = 1);
                            ((cache2->(offset)) = _final_propertyvalue(OBJECT_TY, ox, left_ix));
                        } else {
                            (offset = ((_final_propertyvalue(OBJECT_TY, oy, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, ox, left_ix)));
                            ((cache->(offset)) = 0);
                            ((cache2->(offset)) = 255);
                        }
                    }
                }
                for ((oy = 0):(oy < domainsize):(oy)++) {
                    for ((ox = 0):(ox < domainsize):(ox)++) {
                        (axy = (cache->(((ox*domainsize) + oy))));
                        if ((axy > 0)) {
                            for ((oj = 0):(oj < domainsize):(oj)++) {
                                (ayj = (cache->(((oy*domainsize) + oj))));
                                if ((ayj > 0)) {
                                    (offset = ((ox*domainsize) + oj));
                                    (axj = (cache->(offset)));
                                    if ((((axj == 0)) || (((axy + ayj) < axj)))) {
                                        ((cache->(offset)) = (axy + ayj));
                                        ((cache2->(offset)) = (cache2->(((ox*domainsize) + oy))));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (count) {
                (count = (cache->(((_final_propertyvalue(OBJECT_TY, from, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, to, left_ix)))));
                if ((count == 0)) {
                    return (-(1));
                }
                return count;
            }
            (oy = (cache2->(((_final_propertyvalue(OBJECT_TY, from, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, to, left_ix)))));
            if ((oy < 255)) {
                objectloop (ox ofclass Object && (_final_propertyexists(OBJECT_TY, ox, left_ix))) {
                    if ((_final_propertyvalue(OBJECT_TY, ox, left_ix) == oy)) {
                        return ox;
                    }
                }
            }
            rfalse;
        } else {
            (cache = (RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE)));
            (cache2 = (cache + ((WORDSIZE*domainsize)*domainsize)));
            if (((RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE_BROKEN)) == 1)) {
                ((RlnGetF(relation, RR_STORAGE)-->(VTOVS_CACHE_BROKEN)) = 0);
                objectloop (oy ofclass Object && (_final_propertyexists(OBJECT_TY, oy, left_ix))) {
                    objectloop (ox ofclass Object && (_final_propertyexists(OBJECT_TY, ox, left_ix))) {
                        if (Relation_TestVtoV(oy, relation, ox)) {
                            (offset = ((_final_propertyvalue(OBJECT_TY, oy, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, ox, left_ix)));
                            ((cache-->(offset)) = 1);
                            ((cache2-->(offset)) = ox);
                        } else {
                            (offset = ((_final_propertyvalue(OBJECT_TY, oy, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, ox, left_ix)));
                            ((cache-->(offset)) = 0);
                            ((cache2-->(offset)) = 0);
                        }
                    }
                }
                for ((oy = 0):(oy < domainsize):(oy)++) {
                    for ((ox = 0):(ox < domainsize):(ox)++) {
                        (axy = (cache-->(((ox*domainsize) + oy))));
                        if ((axy > 0)) {
                            for ((oj = 0):(oj < domainsize):(oj)++) {
                                (ayj = (cache-->(((oy*domainsize) + oj))));
                                if ((ayj > 0)) {
                                    (offset = ((ox*domainsize) + oj));
                                    (axj = (cache-->(offset)));
                                    if ((((axj == 0)) || (((axy + ayj) < axj)))) {
                                        ((cache-->(offset)) = (axy + ayj));
                                        ((cache2-->(offset)) = (cache2-->(((ox*domainsize) + oy))));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (count) {
                (count = (cache-->(((_final_propertyvalue(OBJECT_TY, from, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, to, left_ix)))));
                if ((count == 0)) {
                    return (-(1));
                }
                return count;
            }
            return (cache2-->(((_final_propertyvalue(OBJECT_TY, from, left_ix)*domainsize) + _final_propertyvalue(OBJECT_TY, to, left_ix))));
        }
    }
    if (count) {
        return (-(1));
    }
    rfalse;
];
[ RunTimeProblem n par1 par2 par3 ln file;
    if (((RTP_Buffer-->(0)) == -1)) {
        ((RTP_Buffer-->(0)) = n);
        ((RTP_Buffer-->(1)) = par1);
        ((RTP_Buffer-->(2)) = par2);
        ((RTP_Buffer-->(3)) = par3);
        ((RTP_Buffer-->(4)) = ln);
        ((RTP_Buffer-->(5)) = file);
    }
    RunTimeProblemShow();
];
[ ClearRTP;
    ((RTP_Buffer-->(0)) = -1);
    ((RTP_Buffer-->(6)) = 0);
];
[ SuspendRTP;
    ((RTP_Buffer-->(6)) = 1);
];
[ ResumeRTP;
    ((RTP_Buffer-->(6)) = 0);
];
[ RunTimeProblemShow n par1 par2 par3 ln file i c;
    if (((RTP_Buffer-->(0)) == -1 or -2)) {
        rtrue;
    }
    if ((RTP_Buffer-->(6))) {
        rtrue;
    }
    (n = (RTP_Buffer-->(0)));
    (par1 = (RTP_Buffer-->(1)));
    (par2 = (RTP_Buffer-->(2)));
    (par3 = (RTP_Buffer-->(3)));
    (ln = (RTP_Buffer-->(4)));
    (file = (RTP_Buffer-->(5)));
    ((RTP_Buffer-->(0)) = -2);
    print "^";
    print "*** Run-time problem P";
    print n;
    if (ln) {
        print " (at paragraph ";
        print ln;
        print " in ";
        if ((file == 0)) {
            print "the source text";
        } else {
            ShowOneExtension(file);
        }
        print ")";
    }
    print ": ";
    switch (n) {
        RTP_IMPREL:
            print "Tried to access an inappropriate relation for ";
            DefArt(par1);
            print ", violating '";
            print (string) RlnGetF(par2, RR_DESCRIPTION);
            print "'.^";
            ;
        RTP_TOOMANYRULEBOOKS:
            print "Too many rulebooks in simultaneous use.^";
            ;
        RTP_BADPROPERTY:
            print "Tried to access non-existent property for ";
            DefArt(par1);
            print ".^";
            ;
        RTP_UNPROVIDED:
            print "Since ";
            DefArt(par1);
            print " is not allowed the property ~";
            PrintPropertyName(par2);
            print "~, it is against the rules to try to use it.^";
            ;
        RTP_UNSET:
            print "Although ";
            DefArt(par1);
            print " is allowed to have the property ~";
            PrintPropertyName(par2);
            print "~, no value was ever given, so it can't now be used.^";
            ;
        RTP_TOOMANYACTS:
            print "Too many activities are going on at once.^";
            ;
        RTP_CANTABANDON:
            print "Tried to abandon an activity which wasn't going on.^";
            ;
        RTP_CANTEND:
            print "Tried to end an activity which wasn't going on.^";
            ;
        RTP_DIVZERO:
            print "You can't divide by zero.^";
            ;
        RTP_BADVALUEPROPERTY:
            print "Tried to access property for a value which didn't fit: ";
            print "if this were a number it would be ";
            print par1;
            print ".^";
            ;
        RTP_TABLE_NOCOL:
            print "Attempt to look up a non-existent column in the table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOCORR:
            print "Attempt to look up a non-existent correspondence in the table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOROW:
            print "Attempt to look up a non-existent row in the table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOENTRY:
            print "Attempt to look up a non-existent entry at column ";
            print par2;
            print ", row ";
            print par3;
            print " of the table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOTABLE:
            print "Attempt to blank out a row from a non-existent table (value ";
            print par1;
            print ").^";
            ;
        RTP_TABLE_NOTABLE2:
            print "Attempt to access an entry from a non-existent table.^";
            ;
        RTP_TABLE_NOMOREBLANKS:
            print "Attempt to choose a blank row in a table with none left: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_NOROWS:
            print "Attempt to choose a random row in an entirely blank table: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_CANTRUNTHROUGH:
            print "Attempt to repeat through a table in a tricky column order: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_CANTSORT:
            print "Attempt to sort a table whose ordering must remain fixed: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_CANTSAVE:
            print "Attempt to save a table to a file whose data is unstable: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_WONTFIT:
            print "File being read has too many rows or columns to fit into table: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_TABLE_BADFILE:
            print "File being read is not a previously saved table: table '";
            PrintTableName(par1);
            print "'.^";
            ;
        RTP_ROUTELESS:
            print "Attempt to find route or count steps through an implicit relation.^";
            ;
        RTP_PROPOFNOTHING:
            print "Attempt to use a property of the 'nothing' non-object: property ";
            PrintPropertyName(par2);
            print "^";
            ;
        RTP_DECIDEONWRONGKIND:
            print "Attempt to 'decide on V' where V is the wrong kind of object.^";
            ;
        RTP_DECIDEONNOTHING:
            print "Attempt to 'decide on nothing'.^";
            ;
        RTP_LOWLEVELERROR:
            print "Low level error.^";
            ;
        RTP_LISTWRITERMEMORY:
            print "The list-writer has run out of memory.^";
            ;
        RTP_MSTACKMEMORY:
            print "The memory stack is exhausted.^";
            ;
        RTP_TYPECHECK:
            print "Phrase applied to an incompatible kind of value.^";
            ;
        RTP_FILEIOERROR:
            print "Error handling external file.^";
            ;
        RTP_HEAPERROR:
            print "Memory allocation proved impossible.^";
            ;
        RTP_LISTRANGEERROR:
            print "Attempt to use list item which does not exist.^";
            ;
        RTP_LISTSIZENEGATIVE:
            print "Attempt to resize list to ";
            print par1;
            print " entries - there must ";
            print "always be 0 or more.^";
            ;
        RTP_REGEXPSYNTAXERROR:
            print "Syntax error in regular expression.^";
            ;
        RTP_NOGLULXUNICODE:
            print "This interpreter does not support Unicode.^";
            ;
        RTP_NEGATIVEROOT:
            print "You can't take the square root of a negative number.^";
            ;
        RTP_CANTITERATE:
            print "You can't implicitly repeat through the values of this kind: ";
            print "a problem arising from a description which started out here - ~";
            print (string) par1;
            print "~.^";
            ;
        RTP_WRONGASSIGNEDKIND:
            print "Attempt to set a variable to the wrong kind of object: ";
            print "you wrote '";
            print (string) par2;
            print "', which sets the value to ";
            DefArt(par1);
            print " - but that doesn't have the kind '";
            print (string) par3;
            print "'.^";
            ;
        RTP_RELKINDVIOLATION:
            print "Tried to change a relation for objects with the wrong kinds: ";
            print (string) RlnGetF(par3, RR_DESCRIPTION);
            print ", but you tried to ";
            print "relate (or unrelate) ";
            DefArt(par1);
            print " to ";
            DefArt(par2);
            print ".^";
            ;
        RTP_TEXTTOKENTOOHARD:
            print "This use of '[text]' is too complicated.^";
            ;
        RTP_RELATIONCHANGEIMPOSSIBLE:
            print "This change of the relation's nature is impossible in play.^";
            ;
        RTP_RELMINIMAL:
            print "This operation can't be done with the relation '";
            print (string) RlnGetF(par3, RR_DESCRIPTION);
            print "'.^";
            ;
    }
    RunTimeProblemShowWM(n, par1, par2, par3);
    print "^";
];
[ RunTimeError n p1 p2;
    print "** Library error ";
    print n;
    print " (";
    print p1;
    print ",";
    print p2;
    print ") **^** ";
    switch (n) {
        1:
            print "preposition not found (this should not occur)";
            ;
        2:
            print "Property value not routine or string: ~";
            DebugProperty(p2);
            print "~ of ~";
            PrintShortName(p1);
            print "~ (";
            print p1;
            print ")";
            ;
        3:
            print "Entry in property list not routine or string: ~";
            DebugProperty(p2);
            print "~ list of ~";
            PrintShortName(p1);
            print "~ (";
            print p1;
            print ")";
            ;
        4:
            print "Too many timers/daemons are active simultaneously. The limit is the library constant MAX_TIMERS (currently ";
            print MAX_TIMERS;
            print ") and should be increased";
            ;
        5:
            print "Object ~";
            PrintShortName(p1);
            print "~ has no ~time_left~ property";
            ;
        7:
            print "The object ~";
            PrintShortName(p1);
            print "~ can only be used as a player object if it has the ~number~ property";
            ;
        8:
            print "Attempt to take random entry from an empty table array";
            ;
        9:
            print p1;
            print " is not a valid direction property number";
            ;
        10:
            print "The player-object is outside the object tree";
            ;
        11:
            print "The room ~";
            PrintShortName(p1);
            print "~ has no ~description~ property";
            ;
        12:
            print "Tried to set a non-existent pronoun using SetPronoun";
            ;
        13:
            print "A 'topic' token can only be followed by a preposition";
            ;
        default:
            print "(unexplained)";
            ;
    }
    print " **^";
    RunTimeProblem(RTP_LOWLEVELERROR);
];
[ ArgumentTypeFailed line file;
    RunTimeProblem(RTP_TYPECHECK, 0, 0, 0, line, file);
];
[ CheckKindReturned V K;
    if ((V ofclass K)) {
        return V;
    }
    if ((V == 0)) {
        RunTimeProblem(RTP_DECIDEONNOTHING);
    } else {
        RunTimeProblem(RTP_DECIDEONWRONGKIND);
    }
    return V;
];
[ ProvidesProperty K obj q issue_rtp a l holder;
    if ((K == OBJECT_TY)) {
        if (ScanPropertyMetadata(obj, q, 4)) {
            jump PermissionFound;
        }
        if ((_final_propertyexists(OBJECT_TY, obj, A_KD_Count))) {
            (l = (obj.KD_Count));
            while ((l > 0)) {
                (a = (l*2));
                if (ScanPropertyMetadata((KindHierarchy-->(a)), q, 4)) {
                    jump PermissionFound;
                }
                (l = (KindHierarchy-->((a + 1))));
            }
        }
        if (ScanPropertyMetadata(K0_kind, q, 4)) {
            jump PermissionFound;
        }
        if (issue_rtp) {
            RunTimeProblem(RTP_UNPROVIDED, obj, q);
        }
        rfalse;
    }
    .PermissionFound;
    if ((_final_propertyexists(K, obj, q))) {
        rtrue;
    }
    if (issue_rtp) {
        RunTimeProblem(RTP_UNSET, obj, q);
    }
    rfalse;
];
[ PrintPropertyName p textual;
    if ((p < 0)) {
        (p = (~(p)));
    }
    (textual = (p-->(3)));
    print (string) textual;
];
[ ScanPropertyMetadata obj property_metadata off i;
    for ((i = off):((property_metadata-->(i)) >= 0):(i)++) {
        if ((obj == (property_metadata-->(i)))) {
            rtrue;
        }
    }
    rfalse;
];
[ GProperty K V pr err holder val;
    if (ProvidesProperty(K, V, pr, (1 - err))) {
        return _final_propertyvalue(K, V, pr);
    }
    rfalse;
];
[ WriteGProperty K V pr val holder;
    if (ProvidesProperty(K, V, pr, 1)) {
        (_final_store_property(K,V,pr, val));
    }
];
[ PROPERTY_TY_Say v;
    print "property ";
    print v;
];
[ LanguageTimeOfDay hours mins i;
    (i = (hours%12));
    if ((i == 0)) {
        (i = 12);
    }
    if ((i < 10)) {
        print " ";
    }
    print i;
    print ":";
    print (mins/10);
    print (mins%10);
    if (((hours/12) > 0)) {
        print " pm";
    } else {
        print " am";
    }
];
[ LanguageDirection d;
    PrintShortName(d);
];
[ LanguageToInformese;
];
[ LanguageContraction text;
    if (((text->(0)) == 97 or 101 or 105 or 111 or 117 or 65 or 69 or 73 or 79 or 85)) {
        rtrue;
    }
    rfalse;
];
[ LanguageVerb i;
    switch (i) {
        'i//', 'inv', 'inventory':
            print "take inventory";
            ;
        'l//':
            print "look";
            ;
        'x//':
            print "examine";
            ;
        'z//':
            print "wait";
            ;
        default:
            rfalse;
            ;
    }
    rtrue;
];
[ LanguageVerbLikesAdverb w;
    if ((w == 'look' or 'go' or 'push' or 'walk')) {
        rtrue;
    }
    rfalse;
];
[ LanguageVerbMayBeName w;
    if ((w == 'long' or 'short' or 'normal' or 'brief' or 'full' or 'verbose')) {
        rtrue;
    }
    rfalse;
];
[ LanguageIsVerb buffer parse verb_wordnum;
    rfalse;
];
[ ParserError error_type;
    if (error_type) {
        PrintSingleParagraph(error_type);
    }
    rfalse;
];
[ UnknownVerb v;
    if (((KIT_CONFIGURATION_BITMAP)&(NO_VERB_VERB_DEFINED_TCBIT))) {
        (verb_wordnum = 0);
        return 'no.verb';
    }
    rfalse;
];
[ PrintVerb v;
    if (((KIT_CONFIGURATION_BITMAP)&(NO_VERB_VERB_DEFINED_TCBIT))) {
        if ((v == 'no.verb')) {
            print "do something to";
            rtrue;
        }
    }
    rfalse;
];
[ GlkListSub id val;
    (id = glk_window_iterate(0, gg_arguments));
    while (id) {
        print "Window ";
        print id;
        print " (";
        print (gg_arguments-->(0));
        print "): ";
        (val = glk_window_get_type(id));
        switch (val) {
            1:
                print "pair";
                ;
            2:
                print "blank";
                ;
            3:
                print "textbuffer";
                ;
            4:
                print "textgrid";
                ;
            5:
                print "graphics";
                ;
            default:
                print "unknown";
                ;
        }
        (val = glk_window_get_parent(id));
        if (val) {
            print ", parent is window ";
            print val;
        } else {
            print ", no parent (root)";
        }
        (val = glk_window_get_stream(id));
        print ", stream ";
        print val;
        (val = glk_window_get_echo_stream(id));
        if (val) {
            print ", echo stream ";
            print val;
        }
        print "^";
        (id = glk_window_iterate(id, gg_arguments));
    }
    (id = glk_stream_iterate(0, gg_arguments));
    while (id) {
        print "Stream ";
        print id;
        print " (";
        print (gg_arguments-->(0));
        print ")^";
        (id = glk_stream_iterate(id, gg_arguments));
    }
    (id = glk_fileref_iterate(0, gg_arguments));
    while (id) {
        print "Fileref ";
        print id;
        print " (";
        print (gg_arguments-->(0));
        print ")^";
        (id = glk_fileref_iterate(id, gg_arguments));
    }
    if (glk_gestalt(gestalt_Sound, 0)) {
        (id = glk_schannel_iterate(0, gg_arguments));
        while (id) {
            print "Soundchannel ";
            print id;
            print " (";
            print (gg_arguments-->(0));
            print ")^";
            (id = glk_schannel_iterate(id, gg_arguments));
        }
    }
];
[ VM_Undo result_code;
    @restoreundo result_code;
    return (~~(result_code));
];
[ VM_Save_Undo result_code;
    @saveundo result_code;
    if ((result_code == -1)) {
        GGRecoverObjects();
        return 2;
    }
    return (~~(result_code));
];
[ QUIT_THE_GAME_R;
    if ((actor ~= player)) {
        rfalse;
    }
    QUIT_THE_GAME_RM(65);
    if ((YesOrNo() ~= 0)) {
        quit;
    }
];
[ RESTART_THE_GAME_R;
    if ((actor ~= player)) {
        rfalse;
    }
    RESTART_THE_GAME_RM(65);
    if ((YesOrNo() ~= 0)) {
        @restart;
        RESTART_THE_GAME_RM(66);
        print "^";
    }
];
[ RESTORE_THE_GAME_R res fref;
    if ((actor ~= player)) {
        rfalse;
    }
    (fref = glk_fileref_create_by_prompt(1, 2, 0));
    if ((fref == 0)) {
        jump RFailed;
    }
    (gg_savestr = glk_stream_open_file(fref, 2, GG_SAVESTR_ROCK));
    glk_fileref_destroy(fref);
    if ((gg_savestr == 0)) {
        jump RFailed;
    }
    @restore gg_savestr res;
    glk_stream_close(gg_savestr, 0);
    (gg_savestr = 0);
    .RFailed;
    RESTORE_THE_GAME_RM(65);
    print "^";
];
[ SAVE_THE_GAME_R fref len res;
    if ((actor ~= player)) {
        rfalse;
    }
    (fref = glk_fileref_create_by_prompt(fileusage_SavedGame, filemode_Write, 0));
    if (fref) {
        (gg_savestr = glk_stream_open_file(fref, filemode_Write, GG_SAVESTR_ROCK));
        if (gg_savestr) {
            @save gg_savestr res;
            if ((res == -1)) {
                GGRecoverObjects();
                glk_stream_close(gg_savestr, GLK_NULL);
                (gg_savestr = 0);
                RESTORE_THE_GAME_RM(66);
                print "^";
                rtrue;
            }
            glk_stream_close(gg_savestr, GLK_NULL);
            (gg_savestr = 0);
            if ((res == 0)) {
                if (glk_fileref_does_file_exist(fref)) {
                    (gg_savestr = glk_stream_open_file(fref, filemode_Read, GG_SAVESTR_ROCK));
                    if (gg_savestr) {
                        glk_stream_set_position(gg_savestr, 0, seekmode_End);
                        (len = glk_stream_get_position(gg_savestr));
                        glk_stream_close(gg_savestr, GLK_NULL);
                        (gg_savestr = 0);
                        if (len) {
                            SAVE_THE_GAME_RM(66);
                            print "^";
                            glk_fileref_destroy(fref);
                            rtrue;
                        }
                        glk_fileref_delete_file(fref);
                    }
                }
            }
        }
        glk_fileref_destroy(fref);
    }
    SAVE_THE_GAME_RM(65);
    print "^";
];
[ VERIFY_THE_STORY_FILE_R res;
    if ((actor ~= player)) {
        rfalse;
    }
    @verify res;
    if ((res == 0)) {
        VERIFY_THE_STORY_FILE_RM(65);
        print "^";
        rtrue;
    }
    VERIFY_THE_STORY_FILE_RM(66);
    print "^";
];
[ SWITCH_TRANSCRIPT_ON_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if ((gg_scriptstr ~= 0)) {
        SWITCH_TRANSCRIPT_ON_RM(65);
        print "^";
        rtrue;
    }
    .S2Failed;
    if ((gg_scriptfref == 0)) {
        (gg_scriptfref = glk_fileref_create_by_prompt(258, 5, GG_SCRIPTFREF_ROCK));
        if ((gg_scriptfref == 0)) {
            jump S1Failed;
        }
    }
    (gg_scriptstr = glk_stream_open_file(gg_scriptfref, 5, GG_SCRIPTSTR_ROCK));
    if ((gg_scriptstr == 0)) {
        glk_fileref_destroy(gg_scriptfref);
        (gg_scriptfref = 0);
        jump S2Failed;
    }
    glk_window_set_echo_stream(gg_mainwin, gg_scriptstr);
    SWITCH_TRANSCRIPT_ON_RM(66);
    print "^";
    VersionSub();
    rtrue;
    .S1Failed;
    SWITCH_TRANSCRIPT_ON_RM(67);
    print "^";
];
[ SWITCH_TRANSCRIPT_OFF_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if ((gg_scriptstr == 0)) {
        SWITCH_TRANSCRIPT_OFF_RM(65);
        print "^";
        rtrue;
    }
    SWITCH_TRANSCRIPT_OFF_RM(66);
    print "^";
    glk_stream_close(gg_scriptstr, 0);
    (gg_scriptstr = 0);
];
[ ANNOUNCE_STORY_FILE_VERSION_R ix;
    if ((actor ~= player)) {
        rfalse;
    }
    Banner();
    print "Inform 7 v";
    PrintI6Text(I7_FULL_VERSION_NUMBER);
    print "^";
    if (((UUID_ARRAY->(0)) >= 6)) {
        print "Identification number: ";
        for ((ix = 6):(ix <= (UUID_ARRAY->(0))):(ix)++) {
            print (char) (UUID_ARRAY->(ix));
        }
        print "^";
    }
    @gestalt 1 0 ix;
    print "Interpreter version ";
    print (ix/65536);
    print ".";
    print (((ix)&(65280))/256);
    print ".";
    print ((ix)&(255));
    print " / ";
    @gestalt 0 0 ix;
    print "VM ";
    print (ix/65536);
    print ".";
    print (((ix)&(65280))/256);
    print ".";
    print ((ix)&(255));
    print "^";
    ShowExtensionVersions();
    (say__p = 1);
];
[ DESCEND_TO_SPECIFIC_ACTION_R;
    ((#actions_table-->((action + 1))))();
    rtrue;
];
[ OffersLight obj j;
    while (obj) {
        if ((obj has light)) {
            rtrue;
        }
        objectloop (j in obj) {
            if (HasLightSource(j)) {
                rtrue;
            }
        }
        if ((((((obj has container)) && ((~~((obj has open)))))) && ((~~((obj has transparent)))))) {
            rfalse;
        }
        if ((((_final_propertyexists(OBJECT_TY, obj, A_component_parent))) && ((obj.component_parent)))) {
            (obj = (obj.component_parent));
        } else {
            (obj = parent(obj));
        }
    }
    rfalse;
];
[ HasLightSource i j ad sr po;
    if ((i == 0)) {
        rfalse;
    }
    if ((i has light)) {
        rtrue;
    }
    if (((IsSeeThrough(i)) && ((~~(HidesLightSource(i)))))) {
        objectloop (j in i) {
            if (HasLightSource(j)) {
                rtrue;
            }
        }
    }
    (ad = (_final_propertyarray(OBJECT_TY, i, A_add_to_scope)));
    if ((((parent(i) ~= 0)) && ((ad ~= 0)))) {
        if ((metaclass((ad-->(0))) == Routine)) {
            (ats_hls = 0);
            (ats_flag = 1);
            (sr = scope_reason);
            (po = parser_one);
            (scope_reason = LOOPOVERSCOPE_REASON);
            (parser_one = 0);
            RunRoutines(i, A_add_to_scope);
            (scope_reason = sr);
            (parser_one = po);
            (ats_flag = 0);
            if ((ats_hls == 1)) {
                rtrue;
            }
        } else {
            for ((j = 0):((WORDSIZE*j) < (_final_propertylength(OBJECT_TY, i, A_add_to_scope))):(j)++) {
                if ((((ad-->(j))) && ((HasLightSource((ad-->(j))) == 1)))) {
                    rtrue;
                }
            }
        }
    }
    if (ComponentHasLight(i)) {
        rtrue;
    }
    rfalse;
];
[ ComponentHasLight o obj next_obj;
    if ((_final_propertyexists(OBJECT_TY, o, A_component_child))) {
        (obj = (o.component_child));
        while (obj) {
            (next_obj = (obj.component_sibling));
            if ((obj has light)) {
                rtrue;
            }
            if (HasLightSource(obj)) {
                rtrue;
            }
            if ((((_final_propertyexists(OBJECT_TY, obj, A_component_child))) && (ComponentHasLight(obj)))) {
                rtrue;
            }
            (obj = next_obj);
        }
    }
    rfalse;
];
[ HidesLightSource obj;
    if ((obj == player)) {
        rfalse;
    }
    if (((or_tmp_var = obj) && (((or_tmp_var has transparent)) || ((or_tmp_var has supporter))))) {
        rfalse;
    }
    if ((obj has animate)) {
        rfalse;
    }
    if ((obj has container)) {
        return (~~((obj has open)));
    }
    return (~~((obj has enterable)));
];
[ ADJUST_LIGHT_R previous_light_condition;
    (previous_light_condition = lightflag);
    (lightflag = OffersLight(parent(player)));
    if ((((previous_light_condition == 0)) && ((lightflag == 0)))) {
        (location = thedark);
        rfalse;
    }
    if ((((previous_light_condition == 0)) && ((lightflag == 1)))) {
        (location = real_location);
        CarryOutActivity(PRINTING_NEWS_OF_LIGHT_ACT);
        rfalse;
    }
    if ((((previous_light_condition == 1)) && ((lightflag == 0)))) {
        (location = thedark);
        DivideParagraphPoint();
        BeginActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
        if ((ForActivity(PRINTING_NEWS_OF_DARKNESS_ACT) == 0)) {
            ADJUST_LIGHT_RM(65);
            print "^";
        }
        EndActivity(PRINTING_NEWS_OF_DARKNESS_ACT);
        rfalse;
    }
    if ((((previous_light_condition == 1)) && ((lightflag == 1)))) {
        (location = real_location);
        rfalse;
    }
    rfalse;
];
[ SilentlyConsiderLight;
    (lightflag = OffersLight(parent(player)));
    if (lightflag) {
        (location = real_location);
    } else {
        (location = thedark);
    }
    rfalse;
];
[ IsSeeThrough obj;
    if ((((((((obj has supporter)) || ((obj has transparent)))) || ((obj has animate)))) || ((((obj has container)) && ((obj has open)))))) {
        rtrue;
    }
    rfalse;
];
[ VisibilityParent o;
    if (((((((o) && ((o has container)))) && ((~~((o has open)))))) && ((~~((o has transparent)))))) {
        rfalse;
    }
    if (o) {
        (o = CoreOfParentOfCoreOf(o));
    }
    return o;
];
[ FindVisibilityLevels lc up;
    if ((location == thedark)) {
        (visibility_ceiling = thedark);
        (visibility_levels = 0);
    } else {
        (visibility_ceiling = player);
        while (1) {
            (up = VisibilityParent(visibility_ceiling));
            if ((up == 0)) {
                break;
            }
            (visibility_ceiling = up);
            (lc)++;
        }
        (visibility_levels = lc);
    }
];
[ TouchabilityCeiling original o p;
    (o = original);
    while (o) {
        (p = CoreOfParentOfCoreOf(o));
        if ((p ofclass K1_room)) {
            return p;
        }
        if ((p == 0)) {
            return o;
        }
        if (((FollowRulebook(REACHING_OUTSIDE_RB, p)) && (RulebookFailed()))) {
            return p;
        }
        (o = p);
    }
    return o;
];
[ ScopeCeiling pos c;
    if ((((pos == player)) && ((location == thedark)))) {
        return thedark;
    }
    (c = parent(pos));
    if ((c == 0)) {
        return pos;
    }
    while (VisibilityParent(c)) {
        (c = VisibilityParent(c));
    }
    return c;
];
[ ObjectIsUntouchable item silent_flag p save_sp decision moving x;
    if ((LocationOf(p) ~= real_location)) {
        for ((x = CoreOf(item)):x:(x = CoreOfParentOfCoreOf(x))) {
            if ((x ofclass K4_door or K7_backdrop)) {
                (moving = 1);
                MoveFloatingObjects(LocationOf(p));
                break;
            }
        }
    }
    (untouchable_object = item);
    (untouchable_silence = silent_flag);
    (touch_persona = p);
    if ((p == actor)) {
        (touch_persona = 0);
    }
    (save_sp = say__p);
    (say__p = 0);
    @push actor;
    (actor = p);
    if (FollowRulebook(ACCESSIBILITY_RB, 0, 1)) {
        if (RulebookSucceeded()) {
            (decision = 0);
        } else {
            (decision = 1);
        }
    } else {
        (decision = 0);
    }
    @pull actor;
    if ((say__p == 0)) {
        (say__p = save_sp);
    }
    if (moving) {
        MoveFloatingObjects();
    }
    (untouchable_silence = 0);
    return decision;
];
[ ACCESS_THROUGH_BARRIERS_R ancestor i j external p;
    (p = touch_persona);
    if ((p == 0)) {
        (p = actor);
    }
    (ancestor = CommonAncestor(p, untouchable_object));
    if ((((((ancestor == 0)) && ((LocationOf(untouchable_object) == 0)))) && (((untouchable_object ofclass K4_door or K7_backdrop) == 0)))) {
        if ((touch_persona == 0)) {
            if ((((actor == player)) && ((untouchable_silence == 0)))) {
                ACCESS_THROUGH_BARRIERS_RM(65, untouchable_object);
                print "^";
            }
        }
        RulebookFails();
        rtrue;
    }
    if ((CoreOf(p) ~= ancestor)) {
        (i = parent(CoreOf(p)));
        (j = CoreOf(i));
        (external = 0);
        if ((j ~= i)) {
            (i = j);
            (external = 1);
        }
        while ((((i ~= ancestor)) && (i))) {
            if ((((((external == 0)) && (FollowRulebook(REACHING_OUTSIDE_RB, i)))) && (RulebookFailed()))) {
                rtrue;
            }
            (i = parent(CoreOf(i)));
            (external = 0);
            if ((~~((i ofclass K5_container)))) {
                (j = CoreOf(i));
                if ((j ~= i)) {
                    (i = j);
                    (external = 1);
                }
            }
        }
    }
    if ((CoreOf(untouchable_object) ~= ancestor)) {
        (i = CoreOf(untouchable_object));
        (i = parent(i));
        (external = 0);
        while ((((i ~= ancestor)) && (i))) {
            if ((((((external == 0)) && (FollowRulebook(REACHING_INSIDE_RB, i)))) && (RulebookFailed()))) {
                rtrue;
            }
            (i = CoreOf(i));
            if ((i == ancestor)) {
                break;
            }
            (i = parent(i));
            (external = 0);
            if ((~~((i ofclass K5_container)))) {
                (j = CoreOf(i));
                if ((j ~= i)) {
                    (i = j);
                    (external = 1);
                }
            }
        }
    }
    RulebookSucceeds();
    rtrue;
];
[ CANT_REACH_INSIDE_CLOSED_R;
    if ((((parameter_value has container)) && ((~~((parameter_value has open)))))) {
        if ((touch_persona == 0)) {
            if ((((actor == player)) && ((untouchable_silence == 0)))) {
                CANT_REACH_INSIDE_CLOSED_RM(65, parameter_value);
                print "^";
            }
        }
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ CANT_REACH_OUTSIDE_CLOSED_R;
    if ((((parameter_value has container)) && ((~~((parameter_value has open)))))) {
        if ((touch_persona == 0)) {
            if ((((actor == player)) && ((untouchable_silence == 0)))) {
                CANT_REACH_OUTSIDE_CLOSED_RM(65, parameter_value);
                print "^";
            }
        }
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ CANT_REACH_INSIDE_ROOMS_R;
    if (((parameter_value) && ((parameter_value ofclass K1_room)))) {
        if ((touch_persona == 0)) {
            if ((((actor == player)) && ((untouchable_silence == 0)))) {
                CANT_REACH_INSIDE_ROOMS_RM(65, parameter_value);
                print "^";
            }
        }
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ RequisitionStack len top addr;
    (top = (requisition_stack_pointer + len));
    if ((top > REQUISITION_STACK_SIZE)) {
        rfalse;
    }
    (addr = (requisition_stack + (requisition_stack_pointer*WORDSIZE)));
    (requisition_stack_pointer = top);
    return addr;
];
[ FreeStack addr;
    if ((addr == 0)) {
        rtrue;
    }
    (requisition_stack_pointer = ((addr - requisition_stack)/WORDSIZE));
];
[ WriteListOfMarkedObjects in_style obj common_parent first mixed_parentage length g gc;
    (gc = -2);
    objectloop (obj ofclass Object && (((obj ofclass Object)) && ((obj has workflag2)))) {
        (length)++;
        if ((first == 0)) {
            (first = obj);
            (common_parent = parent(obj));
        } else {
            if ((parent(obj) ~= common_parent)) {
                (mixed_parentage = 1);
            }
        }
        (g = GetGNAOfObject(obj));
        (g = (g%3));
        if ((gc == -2)) {
            (gc = g);
        } else {
            if ((gc ~= g)) {
                (gc = -1);
            }
        }
    }
    if (mixed_parentage) {
        (common_parent = 0);
    }
    if ((length == 0)) {
        if ((((in_style)&(ISARE_BIT)) ~= 0)) {
            LIST_WRITER_INTERNAL_RM(87);
        } else {
            if ((((in_style)&(CFIRSTART_BIT)) ~= 0)) {
                LIST_WRITER_INTERNAL_RM(88);
            } else {
                LIST_WRITER_INTERNAL_RM(89);
            }
        }
    } else {
        @push MarkedObjectArray;
        @push MarkedObjectLength;
        (MarkedObjectArray = RequisitionStack(length));
        (MarkedObjectLength = length);
        if ((MarkedObjectArray == 0)) {
            return RunTimeProblem(RTP_LISTWRITERMEMORY);
        }
        if (common_parent) {
            ObjectTreeCoalesce(child(common_parent));
            (length = 0);
            objectloop (obj in common_parent) {
                if ((obj has workflag2)) {
                    ((MarkedObjectArray-->((length)++)) = obj);
                }
            }
        } else {
            (length = 0);
            objectloop (obj ofclass Object && (obj ofclass Object)) {
                if ((obj has workflag2)) {
                    ((MarkedObjectArray-->((length)++)) = obj);
                }
            }
        }
        WriteListFrom(first, in_style, 0, 0, MarkedListIterator);
        FreeStack(MarkedObjectArray);
        @pull MarkedObjectLength;
        @pull MarkedObjectArray;
    }
    (prior_named_list = length);
    (prior_named_list_gender = gc);
    rtrue;
];
[ RegardingMarkedObjects obj length g gc;
    (gc = -2);
    objectloop (obj ofclass Object && (((obj ofclass Object)) && ((obj has workflag2)))) {
        (length)++;
        (g = GetGNAOfObject(obj));
        (g = (g%3));
        if ((gc == -2)) {
            (gc = g);
            (prior_named_noun = obj);
        } else {
            if ((gc ~= g)) {
                (gc = -1);
            }
        }
    }
    (prior_named_list = length);
    (prior_named_list_gender = gc);
    if ((length == 0)) {
        (prior_named_noun = 0);
        (prior_named_list_gender = -1);
    }
    rtrue;
];
[ PNToVP gna;
    if ((prior_named_noun == player)) {
        return story_viewpoint;
    }
    if (prior_named_noun) {
        (gna = GetGNAOfObject(prior_named_noun));
    }
    if ((((((gna%6)/3) == 1)) || ((prior_named_list >= 2)))) {
        return 6;
    }
    return 3;
];
[ SetLWI a b c;
    ((LWI_Storage-->(0)) = a);
    ((LWI_Storage-->(1)) = b);
    ((LWI_Storage-->(2)) = c);
];
[ RegardingLWI;
    (prior_named_list = (LWI_Storage-->(0)));
    (prior_named_list_gender = (LWI_Storage-->(1)));
    (prior_named_noun = (LWI_Storage-->(2)));
];
[ ResponseViaActivity R;
    @push prior_named_noun;
    @push prior_named_list;
    @push prior_named_list_gender;
    RegardingSingleObject(0);
    CarryOutActivity(PRINTING_RESPONSE_ACT, R);
    @pull prior_named_list_gender;
    @pull prior_named_list;
    @pull prior_named_noun;
];
[ MarkedListIterator obj depth required_lt function i;
    if ((obj == 0)) {
        rfalse;
    }
    if ((required_lt == 0)) {
        (required_lt = EMPTY_TEXT_VALUE);
    }
    switch (function) {
        START_ITF:
            return (MarkedObjectArray-->(0));
            ;
        COALESCE_ITF:
            return MarkedListCoalesce();
            ;
        SEEK_ITF, ADVANCE_ITF:
            for ((i = 0):(i < MarkedObjectLength):(i)++) {
                if (((MarkedObjectArray-->(i)) == obj)) {
                    if ((function == ADVANCE_ITF)) {
                        (i)++;
                    }
                    for (:(i < MarkedObjectLength):(i)++) {
                        (obj = (MarkedObjectArray-->(i)));
                        if ((((LT_Compare(required_lt, EMPTY_TEXT_VALUE) ~= 0)) && ((LT_Compare((obj.list_together), required_lt) ~= 0)))) {
                            continue;
                        }
                        if (((((((c_style)&(WORKFLAG_BIT))) && ((depth == 0)))) && ((~~((obj has workflag)))))) {
                            continue;
                        }
                        if (((((c_style)&(CONCEAL_BIT))) && (ConcealedFromLists(obj)))) {
                            continue;
                        }
                        return obj;
                    }
                    rfalse;
                }
            }
            ;
    }
    rfalse;
];
[ ConcealedFromLists obj c;
    if ((((obj has concealed)) || ((obj has scenery)))) {
        rtrue;
    }
    (c = parent(obj));
    if (((((c) && ((c ofclass K5_container or K6_supporter)))) && (TestConcealment(c, obj)))) {
        rtrue;
    }
    rfalse;
];
[ MarkedListCoalesce o i lt l swap m;
    for ((i = 0):(i < MarkedObjectLength):(i)++) {
        (lt = ((MarkedObjectArray-->(i)).list_together));
        if ((LT_Compare(lt, EMPTY_TEXT_VALUE) ~= 0)) {
            for ((i)++:(((i < MarkedObjectLength)) && ((LT_Compare(((MarkedObjectArray-->(i)).list_together), lt) == 0))):(i)++) {
            }
            if ((i == MarkedObjectLength)) {
                return (MarkedObjectArray-->(0));
            }
            for ((l = (i + 1)):(l < MarkedObjectLength):(l)++) {
                if ((LT_Compare(((MarkedObjectArray-->(l)).list_together), lt) == 0)) {
                    (swap = (MarkedObjectArray-->(l)));
                    for ((m = l):(m > i):(m)--) {
                        ((MarkedObjectArray-->(m)) = (MarkedObjectArray-->((m - 1))));
                    }
                    ((MarkedObjectArray-->(i)) = swap);
                    (i)++;
                    if ((i == MarkedObjectLength)) {
                        return (MarkedObjectArray-->(0));
                    }
                }
            }
            (i)--;
        }
    }
    return (MarkedObjectArray-->(0));
];
[ ObjectTreeIterator obj depth required_lt function;
    if ((((obj == 0)) || ((parent(obj) == 0)))) {
        rfalse;
    }
    if ((function == START_ITF)) {
        (obj = child(parent(obj)));
    }
    if ((function == COALESCE_ITF)) {
        return ObjectTreeCoalesce(obj);
    }
    if ((function == ADVANCE_ITF)) {
        (obj = sibling(obj));
    }
    if ((required_lt == 0)) {
        (required_lt = EMPTY_TEXT_VALUE);
    }
    for (:1:(obj = sibling(obj))) {
        if ((obj == 0)) {
            rfalse;
        }
        if ((((LT_Compare(required_lt, EMPTY_TEXT_VALUE) ~= 0)) && ((LT_Compare((obj.list_together), required_lt) ~= 0)))) {
            continue;
        }
        if (((((((c_style)&(WORKFLAG_BIT))) && ((depth == 0)))) && ((~~((obj has workflag)))))) {
            continue;
        }
        if ((~~(_final_propertyvalue(OBJECT_TY, obj, list_filter_permits)))) {
            continue;
        }
        if (((((c_style)&(CONCEAL_BIT))) && (ConcealedFromLists(obj)))) {
            continue;
        }
        return obj;
    }
];
[ ObjectTreeCoalesce obj memb lt later;
    .StartAgain;
    (memb = obj);
    while ((memb ~= 0)) {
        (lt = (memb.list_together));
        if ((LT_Compare(lt, EMPTY_TEXT_VALUE) == 0)) {
            (memb = sibling(memb));
            continue;
        }
        for ((memb = sibling(memb)):((memb) && ((LT_Compare((memb.list_together), lt) == 0))):(memb = sibling(memb))) {
        }
        if ((memb == 0)) {
            return obj;
        }
        for ((later = sibling(memb)):later:(later = sibling(later))) {
            if ((LT_Compare((later.list_together), lt) == 0)) {
                (obj = GroupChildren(parent(obj), lt));
                jump StartAgain;
            }
        }
    }
    return obj;
];
[ GroupChildren par value;
    while ((child(par) ~= 0)) {
        if ((LT_Compare((child(par).list_together), value) ~= 0)) {
            move child(par) to out_obj;
        } else {
            move child(par) to in_obj;
        }
    }
    while ((child(in_obj) ~= 0)) {
        move child(in_obj) to par;
    }
    while ((child(out_obj) ~= 0)) {
        move child(out_obj) to par;
    }
    return child(par);
];
[ WriteListFrom first in_style depth noactivity iter a ol;
    @push c_iterator;
    @push c_style;
    @push c_depth;
    @push c_margin;
    if (iter) {
        (c_iterator = iter);
    } else {
        (c_iterator = ObjectTreeIterator);
    }
    (c_style = in_style);
    (c_depth = depth);
    (c_margin = 0);
    if (((in_style)&(EXTRAINDENT_BIT))) {
        (c_margin = 1);
    }
    objectloop (a ofclass Object && (a ofclass Object)) {
        (_final_store_property(OBJECT_TY,a,list_filter_permits, 1));
        if (((list_filter_routine) && (((list_filter_routine)(a) == 0)))) {
            (_final_store_property(OBJECT_TY,a,list_filter_permits, 0));
        }
    }
    (first = (c_iterator)(first,depth,0,START_ITF));
    if ((first == 0)) {
        if ((((in_style)&(ISARE_BIT)) ~= 0)) {
            LIST_WRITER_INTERNAL_RM(87);
        } else {
            LIST_WRITER_INTERNAL_RM(89);
        }
        if ((((in_style)&(NEWLINE_BIT)) ~= 0)) {
            print "^";
        }
    } else {
        if (((noactivity) || (iter))) {
            WriteListR(first, c_depth, 1);
            (say__p = 1);
        } else {
            objectloop (ol ofclass Object && (_final_propertyexists(OBJECT_TY, ol, A_list_together))) {
                BlkValueCopy((ol.list_together), EMPTY_TEXT_VALUE);
            }
            CarryOutActivity(LISTING_CONTENTS_ACT, parent(first));
        }
    }
    @pull c_margin;
    @pull c_depth;
    @pull c_style;
    @pull c_iterator;
];
[ STANDARD_CONTENTS_LISTING_R;
    WriteListFrom(child(parameter_value), c_style, c_depth, 1);
];
[ PartitionList first no_objs depth partition_classes partition_class_sizes i k l n m;
    for ((i = 0):(i < no_objs):(i)++) {
        ((partition_classes->(i)) = 0);
    }
    (n = 1);
    for (((i = first),(k = 0)):(k < no_objs):((i = (c_iterator)(i,depth,lt_value,ADVANCE_ITF)),(k)++)) {
        if (((partition_classes->(k)) == 0)) {
            ((partition_classes->(k)) = n);
            ((partition_class_sizes->(n)) = 1);
            for (((l = (c_iterator)(i,depth,lt_value,ADVANCE_ITF)),(m = (k + 1))):(((l ~= 0)) && ((m < no_objs))):((l = (c_iterator)(l,depth,lt_value,ADVANCE_ITF)),(m)++)) {
                if (((((partition_classes->(m)) == 0)) && (ListEqual(i, l)))) {
                    if (((partition_class_sizes->(n)) < 255)) {
                        ((partition_class_sizes->(n)))++;
                    }
                    ((partition_classes->(m)) = n);
                }
            }
            if ((n < 255)) {
                (n)++;
            }
        }
    }
    (n)--;
    return n;
];
[ ListEqual o1 o2;
    if (((((o1.plural) == 0)) || (((o2.plural) == 0)))) {
        rfalse;
    }
    if ((((child(o1) ~= 0)) && ((WillRecurs(o1) ~= 0)))) {
        rfalse;
    }
    if ((((child(o2) ~= 0)) && ((WillRecurs(o2) ~= 0)))) {
        rfalse;
    }
    if ((((c_style)&((FULLINV_BIT + PARTINV_BIT))) ~= 0)) {
        if ((((((~~((o1 has worn)))) && ((o2 has worn)))) || ((((~~((o2 has worn)))) && ((o1 has worn)))))) {
            rfalse;
        }
        if ((((((~~((o1 has light)))) && ((o2 has light)))) || ((((~~((o2 has light)))) && ((o1 has light)))))) {
            rfalse;
        }
        if ((o1 has container)) {
            if ((~~((o2 has container)))) {
                rfalse;
            }
            if ((((((o1 has open)) && ((~~((o2 has open)))))) || ((((o2 has open)) && ((~~((o1 has open)))))))) {
                rfalse;
            }
        } else {
            if ((o2 has container)) {
                rfalse;
            }
        }
    }
    return Identical(o1, o2);
];
[ WillRecurs o;
    if ((((c_style)&(ALWAYS_BIT)) ~= 0)) {
        rtrue;
    }
    if ((((c_style)&(RECURSE_BIT)) == 0)) {
        rfalse;
    }
    if ((((o has supporter)) || ((((o has container)) && (((or_tmp_var = o) && (((or_tmp_var has open)) || ((or_tmp_var has transparent))))))))) {
        rtrue;
    }
    rfalse;
];
[ NumberOfGroupsInList o no_classes depth partition_classes partition_class_sizes no_groups cl memb k current_lt lt;
    (current_lt = EMPTY_TEXT_VALUE);
    (lt = EMPTY_TEXT_VALUE);
    (no_groups = no_classes);
    for (((cl = 1),((memb = o),(k = 0))):(cl <= no_classes):(cl)++) {
        while (((partition_classes->(k)) ~= cl)) {
            (k)++;
            (memb = (c_iterator)(memb,depth,lt_value,ADVANCE_ITF));
        }
        if (memb) {
            (lt = (memb.list_together));
            if ((((((LT_Compare(lt, lt_value) ~= 0)) && ((LT_Compare(lt, EMPTY_TEXT_VALUE) ~= 0)))) && ((LT_Compare(lt, current_lt) == 0)))) {
                (no_groups)--;
            }
            (current_lt = lt);
        }
    }
    return no_groups;
];
[ LT_Compare lt1 lt2;
    if ((lt1 == lt2)) {
        rfalse;
    }
    if ((lt1 == 0)) {
        (lt1 = EMPTY_TEXT_VALUE);
    }
    if ((lt2 == 0)) {
        (lt2 = EMPTY_TEXT_VALUE);
    }
    if ((TEXT_TY_IsSubstituted(lt1) == 0)) {
        if ((TEXT_TY_IsSubstituted(lt2) == 0)) {
            return ((lt1-->(1)) - (lt2-->(1)));
        }
        return (-(1));
    }
    if ((TEXT_TY_IsSubstituted(lt2) == 0)) {
        return (-(1));
    }
    return BlkValueCompare(lt1, lt2);
];
[ WriteListR o depth from_start partition_classes partition_class_sizes cl memb index k2 l m no_classes q groups_to_do current_lt;
    if ((o == 0)) {
        rtrue;
    }
    if (from_start) {
        (o = (c_iterator)(o,depth,0,COALESCE_ITF));
    }
    (o = (c_iterator)(o,depth,0,SEEK_ITF));
    if ((o == 0)) {
        rtrue;
    }
    for (((memb = o),(index = 0)):memb:(memb = (c_iterator)(memb,depth,lt_value,ADVANCE_ITF))) {
        (index)++;
    }
    if ((((c_style)&(ISARE_BIT)) ~= 0)) {
        SetLWI(index, (-(1)), o);
        LIST_WRITER_INTERNAL_RM(86, o);
        if ((((c_style)&(NEWLINE_BIT)) ~= 0)) {
            print ":^";
        } else {
            print (char) 32;
        }
        (c_style = (c_style - ISARE_BIT));
    }
    (partition_classes = RequisitionStack(((index/WORDSIZE) + 2)));
    (partition_class_sizes = RequisitionStack(((index/WORDSIZE) + 2)));
    if ((((partition_classes == 0)) || ((partition_class_sizes == 0)))) {
        return RunTimeProblem(RTP_LISTWRITERMEMORY);
    }
    (no_classes = PartitionList(o, index, depth, partition_classes, partition_class_sizes));
    (groups_to_do = NumberOfGroupsInList(o, no_classes, depth, partition_classes, partition_class_sizes));
    for (((cl = 1),((memb = o),((index = 0),(current_lt = EMPTY_TEXT_VALUE)))):(groups_to_do > 0):(cl)++) {
        while (((partition_classes->(index)) ~= cl)) {
            (index)++;
            (memb = (c_iterator)(memb,depth,lt_value,ADVANCE_ITF));
            if ((memb == 0)) {
                print "*** Error in list-writer ***^";
                rtrue;
            }
        }
        if ((((LT_Compare((memb.list_together), lt_value) == 0)) || ((LT_Compare((memb.list_together), EMPTY_TEXT_VALUE) == 0)))) {
            (current_lt = EMPTY_TEXT_VALUE);
        } else {
            if ((LT_Compare((memb.list_together), current_lt) == 0)) {
                continue;
            }
            @push listing_size;
            (q = memb);
            (listing_size = 1);
            (l = index);
            (m = cl);
            while ((((m < no_classes)) && ((LT_Compare((q.list_together), (memb.list_together)) == 0)))) {
                (m)++;
                while (((partition_classes->(l)) ~= m)) {
                    (l)++;
                    (q = (c_iterator)(q,depth,lt_value,ADVANCE_ITF));
                }
                if ((LT_Compare((q.list_together), (memb.list_together)) == 0)) {
                    (listing_size)++;
                }
            }
            if ((listing_size > 1)) {
                WriteMultiClassGroup(cl, memb, depth, partition_class_sizes);
                (current_lt = (memb.list_together));
                jump GroupComplete;
            }
            (current_lt = EMPTY_TEXT_VALUE);
            @pull listing_size;
        }
        WriteSingleClassGroup(cl, memb, depth, (partition_class_sizes->(cl)));
        .GroupComplete;
        (groups_to_do)--;
        if ((((c_style)&(ENGLISH_BIT)) ~= 0)) {
            if ((groups_to_do == 1)) {
                if (((KIT_CONFIGURATION_BITMAP)&(SERIAL_COMMA_TCBIT))) {
                    if ((cl > 1)) {
                        print ",";
                    }
                }
                LIST_WRITER_INTERNAL_RM(67);
            }
            if ((groups_to_do > 1)) {
                print ", ";
            }
        }
    }
    FreeStack(partition_class_sizes);
    FreeStack(partition_classes);
];
[ WriteMultiClassGroup cl memb depth partition_class_sizes pv q k2 l;
    (q = c_style);
    if ((((c_style)&(INDENT_BIT)) ~= 0)) {
        PrintSpaces((2*(depth + c_margin)));
    }
    BeginActivity(GROUPING_TOGETHER_ACT, memb);
    if (ForActivity(GROUPING_TOGETHER_ACT, memb)) {
        (c_style = ((c_style)&((~(NEWLINE_BIT)))));
    } else {
        (pv = (memb.list_together));
        if ((TEXT_TY_IsSubstituted(pv) == 0)) {
            (inventory_stage = 1);
            (parser_one = memb);
            (parser_two = (depth + c_margin));
            if ((((pv-->(1)))() == 1)) {
                jump Omit__Sublist2;
            }
        } else {
            if (pv) {
                (k2 = 0);
                for ((l = 0):(l < listing_size):(l)++) {
                    (k2 = (k2 + (partition_class_sizes->((l + cl)))));
                }
                EnglishNumber(k2);
                print " ";
                TEXT_TY_Say(pv);
                if ((((c_style)&(ENGLISH_BIT)) ~= 0)) {
                    print " (";
                }
                if ((((c_style)&(INDENT_BIT)) ~= 0)) {
                    print ":^";
                }
            }
        }
        (c_margin)++;
        @push lt_value;
        @push listing_together;
        @push listing_size;
        (lt_value = (memb.list_together));
        (listing_together = memb);
        WriteListR(memb, depth, 0);
        @pull listing_size;
        @pull listing_together;
        @pull lt_value;
        (c_margin)--;
        (pv = (memb.list_together));
        if ((TEXT_TY_IsSubstituted(pv) == 0)) {
            (inventory_stage = 2);
            (parser_one = memb);
            (parser_two = (depth + c_margin));
            ((pv-->(1)))();
        } else {
            if ((LT_Compare(pv, EMPTY_TEXT_VALUE) ~= 0)) {
                if ((((q)&(ENGLISH_BIT)) ~= 0)) {
                    print ")";
                }
            }
        }
        .Omit__Sublist2;
    }
    EndActivity(GROUPING_TOGETHER_ACT, memb);
    if ((((((q)&(NEWLINE_BIT)) ~= 0)) && ((((c_style)&(NEWLINE_BIT)) == 0)))) {
        print "^";
    }
    (c_style = q);
];
[ WriteSingleClassGroup cl memb depth size q;
    (q = c_style);
    if (((c_style)&(INDENT_BIT))) {
        PrintSpaces((2*(depth + c_margin)));
    }
    if ((size == 1)) {
        if ((((c_style)&(NOARTICLE_BIT)) ~= 0)) {
            PrintShortName(memb);
        } else {
            if (((c_style)&(DEFART_BIT))) {
                if ((((cl == 1)) && (((c_style)&(CFIRSTART_BIT))))) {
                    CDefArt(memb);
                } else {
                    DefArt(memb);
                }
            } else {
                if ((((cl == 1)) && (((c_style)&(CFIRSTART_BIT))))) {
                    CIndefArt(memb);
                } else {
                    IndefArt(memb);
                }
            }
        }
    } else {
        if (((c_style)&(DEFART_BIT))) {
            if ((((cl == 1)) && (((c_style)&(CFIRSTART_BIT))))) {
                PrefaceByArticle(memb, 0, size);
            } else {
                PrefaceByArticle(memb, 1, size);
            }
        }
        @push listing_size;
        (listing_size = size);
        CarryOutActivity(PRINTING_A_NUMBER_OF_ACT, memb);
        @pull listing_size;
    }
    if ((((size > 1)) && ((~~((memb has pluralname)))))) {
        give memb pluralname;
        WriteAfterEntry(memb, depth);
        give memb ~pluralname;
    } else {
        WriteAfterEntry(memb, depth);
    }
    (c_style = q);
];
[ WriteAfterEntry o depth p recurse_flag parenth_flag eldest_child child_count combo;
    (inventory_stage = 2);
    if (((c_style)&(PARTINV_BIT))) {
        BeginActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o);
        if ((ForActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o) == 0)) {
            (combo = 0);
            if ((((o has light)) && ((~~((location has light)))))) {
                (combo = (combo + 1));
            }
            if ((((o has container)) && ((~~((o has open)))))) {
                (combo = (combo + 2));
            }
            if ((((((o has container)) && ((((o has open)) || ((o has transparent)))))) && ((child(o) == 0)))) {
                (combo = (combo + 4));
            }
            if (combo) {
                LIST_WRITER_INTERNAL_RM(65);
            }
            switch (combo) {
                1:
                    LIST_WRITER_INTERNAL_RM(68, o);
                    ;
                2:
                    LIST_WRITER_INTERNAL_RM(69, o);
                    ;
                3:
                    LIST_WRITER_INTERNAL_RM(72, o);
                    ;
                4:
                    LIST_WRITER_INTERNAL_RM(70, o);
                    ;
                5:
                    LIST_WRITER_INTERNAL_RM(73, o);
                    ;
                6:
                    LIST_WRITER_INTERNAL_RM(71, o);
                    ;
                7:
                    LIST_WRITER_INTERNAL_RM(74, o);
                    ;
            }
            if (combo) {
                LIST_WRITER_INTERNAL_RM(66);
            }
        }
        EndActivity(PRINTING_ROOM_DESC_DETAILS_ACT, o);
    }
    if (((c_style)&(FULLINV_BIT))) {
        BeginActivity(PRINTING_INVENTORY_DETAILS_ACT, o);
        if ((ForActivity(PRINTING_INVENTORY_DETAILS_ACT, o) == 0)) {
            if ((((o has light)) && ((o has worn)))) {
                LIST_WRITER_INTERNAL_RM(65);
                LIST_WRITER_INTERNAL_RM(75, o);
                (parenth_flag = 1);
            } else {
                if ((o has light)) {
                    LIST_WRITER_INTERNAL_RM(65);
                    LIST_WRITER_INTERNAL_RM(68, o);
                    (parenth_flag = 1);
                }
                if ((o has worn)) {
                    LIST_WRITER_INTERNAL_RM(65);
                    LIST_WRITER_INTERNAL_RM(76, o);
                    (parenth_flag = 1);
                }
            }
            if ((o has container)) {
                if ((o has openable)) {
                    if (parenth_flag) {
                        if (((KIT_CONFIGURATION_BITMAP)&(SERIAL_COMMA_TCBIT))) {
                            print ",";
                        }
                        LIST_WRITER_INTERNAL_RM(67);
                    } else {
                        LIST_WRITER_INTERNAL_RM(65, o);
                    }
                    if ((o has open)) {
                        if (child(o)) {
                            LIST_WRITER_INTERNAL_RM(77, o);
                        } else {
                            LIST_WRITER_INTERNAL_RM(78, o);
                        }
                    } else {
                        if ((((o has lockable)) && ((o has locked)))) {
                            LIST_WRITER_INTERNAL_RM(80, o);
                        } else {
                            LIST_WRITER_INTERNAL_RM(79, o);
                        }
                    }
                    (parenth_flag = 1);
                } else {
                    if ((((child(o) == 0)) && ((o has transparent)))) {
                        if (parenth_flag) {
                            LIST_WRITER_INTERNAL_RM(67);
                            LIST_WRITER_INTERNAL_RM(70);
                        } else {
                            LIST_WRITER_INTERNAL_RM(65);
                            LIST_WRITER_INTERNAL_RM(70);
                            LIST_WRITER_INTERNAL_RM(66);
                        }
                    }
                }
            }
            if (parenth_flag) {
                LIST_WRITER_INTERNAL_RM(66);
            }
        }
        EndActivity(PRINTING_INVENTORY_DETAILS_ACT, o);
    }
    (child_count = 0);
    (eldest_child = 0);
    objectloop (p in o) {
        if ((((((c_style)&(CONCEAL_BIT)) == 0)) || ((ConcealedFromLists(p) == 0)))) {
            if (_final_propertyvalue(OBJECT_TY, p, list_filter_permits)) {
                (child_count)++;
                if ((eldest_child == 0)) {
                    (eldest_child = p);
                }
            }
        }
    }
    if (((child_count) && (((c_style)&(ALWAYS_BIT))))) {
        if (((c_style)&(ENGLISH_BIT))) {
            print " ";
            LIST_WRITER_INTERNAL_RM(81, o);
            print " ";
        }
        (recurse_flag = 1);
    }
    if (((child_count) && (((c_style)&(RECURSE_BIT))))) {
        if ((o has supporter)) {
            if (((c_style)&(ENGLISH_BIT))) {
                if (((c_style)&(TERSE_BIT))) {
                    LIST_WRITER_INTERNAL_RM(65, o);
                    LIST_WRITER_INTERNAL_RM(82, o);
                } else {
                    LIST_WRITER_INTERNAL_RM(83, o);
                }
            }
            (recurse_flag = 1);
        }
        if ((((o has container)) && ((((o has open)) || ((o has transparent)))))) {
            if (((c_style)&(ENGLISH_BIT))) {
                if (((c_style)&(TERSE_BIT))) {
                    LIST_WRITER_INTERNAL_RM(65, o);
                    LIST_WRITER_INTERNAL_RM(84, o);
                } else {
                    LIST_WRITER_INTERNAL_RM(85, o);
                }
            }
            (recurse_flag = 1);
        }
    }
    if (((recurse_flag) && (((c_style)&(ENGLISH_BIT))))) {
        SetLWI(child_count, (-(1)), eldest_child);
        LIST_WRITER_INTERNAL_RM(86, o);
        print " ";
    }
    if (((c_style)&(NEWLINE_BIT))) {
        print "^";
    }
    if (recurse_flag) {
        (o = child(o));
        @push lt_value;
        @push listing_together;
        @push listing_size;
        @push c_iterator;
        (c_iterator = ObjectTreeIterator);
        (lt_value = EMPTY_TEXT_VALUE);
        (listing_together = 0);
        (listing_size = 0);
        WriteListR(o, (depth + 1), 1);
        @pull c_iterator;
        @pull listing_size;
        @pull listing_together;
        @pull lt_value;
        if (((c_style)&(TERSE_BIT))) {
            LIST_WRITER_INTERNAL_RM(66);
        }
    }
];
[ LIST_WRITER_INTERNAL_R;
];
[ Main;
    #ifdef TARGET_ZCODE; max_z_object = #largest_object - 255; #endif;
    (say__pc = ((say__pc)|(PARA_NORULEBOOKBREAKS)));
    FollowRulebook(STARTUP_RB);
    if (((say__pc)&(PARA_NORULEBOOKBREAKS))) {
        (say__pc = (say__pc - PARA_NORULEBOOKBREAKS));
    }
    while (1) {
        while ((deadflag == 0)) {
            (EarlyInTurnSequence = 1);
            (action = ##Wait);
            (meta = 0);
            (noun = 0);
            (second = 0);
            (actor = player);
            FollowRulebook(TURN_SEQUENCE_RB);
            (IterationsOfTurnSequence)++;
        }
        if ((FollowRulebook(SHUTDOWN_RB) == 0)) {
            rtrue;
        }
    }
];
[ VIRTUAL_MACHINE_STARTUP_R;
    CarryOutActivity(STARTING_VIRTUAL_MACHINE_ACT);
    VM_Initialise();
    if (((say__pc)&(PARA_NORULEBOOKBREAKS))) {
        (say__pc = (say__pc - PARA_NORULEBOOKBREAKS));
    }
    print "^^^";
    rfalse;
];
[ INITIALISE_MEMORY_R;
    VM_PreInitialise();
    (not_yet_in_play = 1);
    (lookmode = KIT_CONFIGURATION_LOOKMODE);
    (player = (InitialSituation-->(PLAYER_OBJECT_INIS)));
    (the_time = (InitialSituation-->(START_TIME_INIS)));
    (real_location = 0);
    (location = 0);
    HeapInitialise();
    StackFramingInitialise();
    CreateDynamicRelations();
    rfalse;
];
[ POSITION_PLAYER_IN_MODEL_R player_to_be;
    (player = selfobj);
    (player_to_be = (InitialSituation-->(PLAYER_OBJECT_INIS)));
    (location = LocationOf(player_to_be));
    if ((location == 0)) {
        (location = (InitialSituation-->(START_ROOM_INIS)));
        if ((InitialSituation-->(START_OBJECT_INIS))) {
            move player_to_be to (InitialSituation-->(START_OBJECT_INIS));
        } else {
            move player_to_be to location;
        }
    }
    if ((player_to_be ~= player)) {
        remove selfobj;
        ChangePlayer(player_to_be);
    } else {
        (real_location = location);
        SilentlyConsiderLight();
    }
    NOTE_OBJECT_ACQUISITIONS_R();
    MoveFloatingObjects();
    (actor = player);
    (act_requester = 0);
    (actors_location = real_location);
    (action = ##Wait);
    ((InitialSituation-->(DONE_INIS)) = 1);
    rfalse;
];
[ PARSE_COMMAND_R;
    if ((EarlyInTurnSequence == 0)) {
        rfalse;
    }
    (not_yet_in_play = 0);
    Parser__parse();
    TreatParserResults();
    rfalse;
];
[ TreatParserResults;
    if (((parser_results-->(ACTION_PRES)) == ##MistakeAction)) {
        (meta = 1);
    }
    if (((((((parser_results-->(ACTION_PRES)) == ##Tell)) && (((parser_results-->(INP1_PRES)) == player)))) && ((actor ~= player)))) {
        ((parser_results-->(ACTION_PRES)) = ##Ask);
        ((parser_results-->(INP1_PRES)) = actor);
        (actor = player);
    }
];
[ GENERATE_ACTION_R i;
    if ((EarlyInTurnSequence == 0)) {
        rfalse;
    }
    (EarlyInTurnSequence = 0);
    (action = (parser_results-->(ACTION_PRES)));
    (act_requester = 0);
    if ((actor ~= player)) {
        (act_requester = player);
    }
    (inp1 = 0);
    (inp2 = 0);
    (multiflag = 0);
    if (((parser_results-->(NO_INPS_PRES)) >= 1)) {
        (inp1 = (parser_results-->(INP1_PRES)));
        if ((inp1 == 0)) {
            (multiflag = 1);
        }
    }
    if (((parser_results-->(NO_INPS_PRES)) >= 2)) {
        (inp2 = (parser_results-->(INP2_PRES)));
        if ((inp2 == 0)) {
            (multiflag = 1);
        }
    }
    if ((inp1 == 1)) {
        (noun = 0);
    } else {
        (noun = inp1);
    }
    if ((inp2 == 1)) {
        (second = 0);
    } else {
        (second = inp2);
    }
    if (multiflag) {
        if (((multiple_object-->(0)) == 0)) {
            if ((actor == player)) {
                GENERATE_ACTION_RM(66);
                print "^";
            }
            rtrue;
        }
        if (toomany_flag) {
            (toomany_flag = 0);
            if ((actor == player)) {
                GENERATE_ACTION_RM(65);
            }
        }
        (i = (multiple_object-->(0)));
        FollowRulebook(MULTIPLE_ACTION_PROCESSING_RB);
        if (((((multiple_object-->(0)) == 1)) && ((i > 1)))) {
            (multiflag = 0);
            if ((inp1 == 0)) {
                (noun = (multiple_object-->(1)));
            }
            if ((((inp2 == 0)) && (((parser_results-->(NO_INPS_PRES)) >= 2)))) {
                (second = (multiple_object-->(1)));
            }
        }
        if (((multiple_object-->(0)) == 0)) {
            rfalse;
        }
    }
    if (multiflag) {
        GenerateMultipleActions();
        (multiflag = 0);
    } else {
        BeginAction(action, noun, second);
    }
    if ((((actor ~= player)) || (act_requester))) {
        (action = ##Wait);
    }
    (actor = player);
    (act_requester = 0);
    if (meta) {
        RulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ GenerateMultipleActions initial_location k item;
    (initial_location = location);
    for ((k = 1):(k <= (multiple_object-->(0))):(k)++) {
        (item = (multiple_object-->(k)));
        RunParagraphOn();
        if ((inp1 == 0)) {
            (inp1 = item);
            BeginAction(action, item, second, item);
            (inp1 = 0);
        } else {
            (inp2 = item);
            BeginAction(action, noun, item, item);
            (inp2 = 0);
        }
        if (deadflag) {
            rtrue;
        }
        if ((location ~= initial_location)) {
            if ((player == actor)) {
                ACTION_PROCESSING_INTERNAL_RM(74);
                print "^";
            }
            rtrue;
        }
    }
];
[ TIMED_EVENTS_R i d event_timer fire rule;
    for ((i = 1):(i <= (TimedEventsTable-->(0))):(i)++) {
        if (((rule = (TimedEventsTable-->(i))) ~= 0)) {
            (event_timer = (TimedEventTimesTable-->(i)));
            (fire = 0);
            if ((event_timer < 0)) {
                ((TimedEventTimesTable-->(i)))++;
                if (((TimedEventTimesTable-->(i)) == 0)) {
                    (fire = 1);
                }
            } else {
                (d = (((the_time - event_timer) + TWENTY_FOUR_HOURS)%TWENTY_FOUR_HOURS));
                if ((((d >= 0)) && ((d < 30)))) {
                    (fire = 1);
                }
            }
            if (fire) {
                ((TimedEventsTable-->(i)) = 0);
                FollowRulebook(rule);
            }
        }
    }
    rfalse;
];
[ SetTimedEvent rule event_time absolute_time i b;
    for ((i = 1):(i <= (TimedEventsTable-->(0))):(i)++) {
        if ((rule == (TimedEventsTable-->(i)))) {
            (b = i);
            break;
        }
        if ((((b == 0)) && (((TimedEventsTable-->(i)) == 0)))) {
            (b = i);
        }
    }
    if ((b == 0)) {
        return RunTimeProblem(RTP_TOOMANYEVENTS);
    }
    ((TimedEventsTable-->(b)) = rule);
    if (absolute_time) {
        ((TimedEventTimesTable-->(b)) = event_time);
    } else {
        ((TimedEventTimesTable-->(b)) = (-(event_time)));
    }
];
[ SetTime t s;
    (the_time = t);
    (time_rate = s);
    (time_step = 0);
    if ((s < 0)) {
        (time_step = (0 - s));
    }
];
[ ADVANCE_TIME_R;
    (turns)++;
    if ((the_time ~= NULL)) {
        if ((time_rate >= 0)) {
            (the_time = (the_time + time_rate));
        } else {
            (time_step)--;
            if ((time_step == 0)) {
                (the_time)++;
                (time_step = (-(time_rate)));
            }
        }
        (the_time = (the_time%TWENTY_FOUR_HOURS));
    }
    rfalse;
];
[ NOTE_OBJECT_ACQUISITIONS_R obj;
    objectloop (obj in player) {
        give obj moved;
    }
    objectloop (obj ofclass Object && (obj has concealed)) {
        if (IndirectlyContains(player, obj)) {
            give obj ~concealed;
        }
    }
    rfalse;
];
[ RESURRECT_PLAYER_IF_ASKED_R;
    if (resurrect_please) {
        RulebookSucceeds();
        (resurrect_please = 0);
        (deadflag = 0);
        (story_complete = 0);
        rtrue;
    }
    rfalse;
];
[ ASK_FINAL_QUESTION_R;
    print "^";
    while (1) {
        CarryOutActivity(DEALING_WITH_FINAL_QUESTION_ACT);
        DivideParagraphPoint();
        if (resurrect_please) {
            rtrue;
        }
    }
];
[ READ_FINAL_ANSWER_R;
    DrawStatusLine();
    KeyboardPrimitive(buffer, parse);
    (players_command = (100 + WordCount()));
    (num_words = WordCount());
    (wn = 1);
    rfalse;
];
[ IMMEDIATELY_RESTART_VM_R;
    @restart;
];
[ IMMEDIATELY_RESTORE_SAVED_R;
    (actor = player);
    RESTORE_THE_GAME_R();
];
[ IMMEDIATELY_QUIT_R;
    @quit;
];
[ IMMEDIATELY_UNDO_R;
    Perform_Undo();
];
[ PRINT_OBITUARY_HEADLINE_R;
    print "^^    ";
    VM_Style(ALERT_VMSTY);
    print "***";
    if ((deadflag == 1)) {
        PRINT_OBITUARY_HEADLINE_RM(65);
    }
    if ((deadflag == 2)) {
        PRINT_OBITUARY_HEADLINE_RM(66);
    }
    if ((deadflag == 3)) {
        PRINT_OBITUARY_HEADLINE_RM(67);
    }
    if ((deadflag ~= 0 or 1 or 2 or 3)) {
        print " ";
        TEXT_TY_Say(deadflag);
        print " ";
    }
    print "***";
    VM_Style(NORMAL_VMSTY);
    print "^^^";
    rfalse;
];
[ PRINT_FINAL_SCORE_R;
    if (((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT))) {
        ANNOUNCE_SCORE_R();
    }
    rfalse;
];
[ DISPLAY_FINAL_STATUS_LINE_R;
    (sline1 = score);
    (sline2 = turns);
    rfalse;
];
[ FindAction fa t;
    if ((fa == -1)) {
        (fa = action);
    }
    (t = 1);
    while ((t <= (ActionData-->(0)))) {
        if ((fa == (ActionData-->(t)))) {
            return t;
        }
        (t = (t + AD_RECORD_SIZE));
    }
    rfalse;
];
[ ActionNumberIndexed i;
    if ((((i >= 0)) && ((i < AD_RECORDS)))) {
        return (ActionData-->((((i*AD_RECORD_SIZE) + AD_ACTION) + 1)));
    }
    rfalse;
];
[ NeedToCarryNoun;
    return TestActionMask(CARRY_NOUN_ABIT);
];
[ NeedToCarrySecondNoun;
    return TestActionMask(CARRY_SECOND_ABIT);
];
[ NeedToTouchNoun;
    return TestActionMask(TOUCH_NOUN_ABIT);
];
[ NeedToTouchSecondNoun;
    return TestActionMask(TOUCH_SECOND_ABIT);
];
[ NeedLightForAction;
    return TestActionMask(LIGHT_ABIT);
];
[ TestActionMask match mask at;
    (at = FindAction(-1));
    if ((at == 0)) {
        rfalse;
    }
    (mask = (ActionData-->((at + AD_REQUIREMENTS))));
    if (((mask)&(match))) {
        rtrue;
    }
    rfalse;
];
[ TryAction req by ac n s stora smeta tbits saved_command text_of_command;
    if (stora) {
        return STORED_ACTION_TY_New(ac, n, s, by, req, stora);
    }
    (tbits = ((req)&((16 + 32))));
    (req = ((req)&(1)));
    @push actor;
    @push act_requester;
    @push inp1;
    @push inp2;
    @push parsed_number;
    (smeta = meta);
    if ((by == 0)) {
        (by = player);
    }
    (actor = by);
    if (req) {
        (act_requester = player);
    } else {
        (act_requester = 0);
    }
    (by = FindAction(ac));
    if (by) {
        if (((ActionData-->((by + AD_NOUN_KOV))) == OBJECT_TY)) {
            (inp1 = n);
        } else {
            (inp1 = 1);
            (parsed_number = n);
        }
        if (((ActionData-->((by + AD_SECOND_KOV))) == OBJECT_TY)) {
            (inp2 = s);
        } else {
            (inp2 = 1);
            (parsed_number = s);
        }
        if (((((((ActionData-->((by + AD_NOUN_KOV))) == UNDERSTANDING_TY)) || (((ActionData-->((by + AD_SECOND_KOV))) == UNDERSTANDING_TY)))) && (tbits))) {
            (saved_command = BlkValueCreate(TEXT_TY));
            BlkValueCast(saved_command, SNIPPET_TY, players_command);
            (text_of_command = BlkValueCreate(TEXT_TY));
            BlkValueCopy(text_of_command, parsed_number);
            SetPlayersCommand(text_of_command);
            if ((tbits == 16)) {
                (n = players_command);
                (inp1 = 1);
                (parsed_number = players_command);
            } else {
                (s = players_command);
                (inp2 = 1);
                (parsed_number = players_command);
            }
            BlkValueFree(text_of_command);
            @push consult_from;
            @push consult_words;
            (consult_from = 1);
            (consult_words = (parsed_number - 100));
        }
    }
    BeginAction(ac, n, s, 0, 1);
    if (saved_command) {
        @pull consult_words;
        @pull consult_from;
        SetPlayersCommand(saved_command);
        BlkValueFree(saved_command);
    }
    (meta = smeta);
    @pull parsed_number;
    @pull inp2;
    @pull inp1;
    @pull act_requester;
    @pull actor;
    TrackActions(1, smeta);
];
[ R_Process a i j;
    @push inp1;
    @push inp2;
    (inp1 = i);
    (inp2 = j);
    BeginAction(a, i, j);
    @pull inp2;
    @pull inp1;
];
[ GVS_Convert ac n s;
    (converted_action_outcome = BeginAction(ac, n, s));
    if ((converted_action_outcome == 1)) {
        FollowRulebook(AFTER_RB, 0, 1);
    }
    rtrue;
];
[ ConvertToRequest X AN Y Z;
    WORK_OUT_DETAILS_OF_SPECIFIC_R();
    if ((X == player)) {
        TryAction(0, X, AN, Y, Z);
    } else {
        TryAction(1, X, AN, Y, Z);
    }
    rtrue;
];
[ ConvertToGoingWithPush i oldrm newrm infl;
    (i = noun);
    if ((IndirectlyContains(noun, actor) == 0)) {
        move i to actor;
        (infl = 1);
    }
    (move_pushing = i);
    (oldrm = LocationOf(noun));
    BeginAction(##Go, second);
    (newrm = LocationOf(actor));
    (move_pushing = 0);
    move i to newrm;
    if ((newrm ~= oldrm)) {
        if (IndirectlyContains(i, player)) {
            TryAction(0, player, ##Look, 0, 0);
        }
        RulebookSucceeds();
    } else {
        RulebookFails();
    }
    rtrue;
];
[ ImplicitTake obj ks;
    if ((actor == player)) {
        STANDARD_IMPLICIT_TAKING_RM(65, obj);
    } else {
        if (TestVisibility(player, actor)) {
            STANDARD_IMPLICIT_TAKING_RM(66, obj, actor);
        }
    }
    ClearParagraphing(3);
    @push keep_silent;
    (keep_silent = 1);
    @push say__p;
    @push say__pc;
    ClearParagraphing(4);
    if (act_requester) {
        TryAction(1, actor, ##Take, obj, 0);
    } else {
        TryAction(0, actor, ##Take, obj, 0);
    }
    DivideParagraphPoint();
    @pull say__pc;
    @pull say__p;
    AdjustParagraphPoint();
    @pull keep_silent;
    if ((obj in actor)) {
        rtrue;
    }
    rfalse;
];
[ LookAfterGoing;
    GoingLookBreak();
    AbbreviatedRoomDescription();
];
[ AbbreviatedRoomDescription prior_action pos frame_id;
    (prior_action = action);
    (action = ##Look);
    (pos = FindAction(##Look));
    if (((pos) && ((ActionData-->((pos + AD_VARIABLES_CREATOR)))))) {
        (frame_id = (ActionData-->((pos + AD_VARIABLES_ID))));
        Mstack_Create_Frame((ActionData-->((pos + AD_VARIABLES_CREATOR))), frame_id);
        FollowRulebook(SETTING_ACTION_VARIABLES_RB);
        ((MStack-->(MstVO(frame_id, 0))) = prior_action);
        ((MStack-->(MstVO(frame_id, 1))) = 1);
    }
    LookSub();
    if (frame_id) {
        Mstack_Destroy_Frame((ActionData-->((pos + AD_VARIABLES_CREATOR))), frame_id);
    }
    (action = prior_action);
];
[ BeginAction a n s moi notrack rv;
    ChronologyPoint();
    @push action;
    @push noun;
    @push second;
    @push self;
    @push multiple_object_item;
    (action = a);
    (noun = n);
    (second = s);
    (self = noun);
    (multiple_object_item = moi);
    if ((action < 4096)) {
        (rv = ActionPrimitive());
    }
    @pull multiple_object_item;
    @pull self;
    @pull second;
    @pull noun;
    @pull action;
    if ((notrack == 0)) {
        TrackActions(1, meta);
    }
    return rv;
];
[ ActionPrimitive rv p1 p2 p3 p4 p5 frame_id;
    MStack_CreateRBVars(ACTION_PROCESSING_RB);
    if ((((keep_silent == 0)) && ((multiflag == 0)))) {
        DivideParagraphPoint();
    }
    (reason_the_action_failed = 0);
    (frame_id = -1);
    (p1 = FindAction(action));
    if (((p1) && ((ActionData-->((p1 + AD_VARIABLES_CREATOR)))))) {
        (frame_id = (ActionData-->((p1 + AD_VARIABLES_ID))));
        Mstack_Create_Frame((ActionData-->((p1 + AD_VARIABLES_CREATOR))), frame_id);
    }
    if (ActionVariablesNotTypeSafe()) {
        if ((actor ~= player)) {
            ACTION_PROCESSING_INTERNAL_RM(75);
            print "^";
        }
        if ((frame_id ~= -1)) {
            Mstack_Destroy_Frame((ActionData-->((p1 + AD_VARIABLES_CREATOR))), frame_id);
        }
        MStack_DestroyRBVars(ACTION_PROCESSING_RB);
        rtrue;
    }
    FollowRulebook(SETTING_ACTION_VARIABLES_RB);
    if (((trace_actions) && (FindAction(-1)))) {
        print "[";
        (p1 = actor);
        (p2 = act_requester);
        (p3 = action);
        (p4 = noun);
        (p5 = second);
        DB_Action(p1, p2, p3, p4, p5);
        print "]^";
        ClearParagraphing(5);
    }
    ++(debug_rule_nesting);
    TrackActions(0, meta);
    if (((meta) && ((actor ~= player)))) {
        ACTION_PROCESSING_INTERNAL_RM(65, actor);
        print "^";
        (rv = RS_FAILS);
    } else {
        if (meta) {
            DESCEND_TO_SPECIFIC_ACTION_R();
            (rv = RulebookOutcome());
        } else {
            FollowRulebook(ACTION_PROCESSING_RB);
            (rv = RulebookOutcome());
        }
    }
    --(debug_rule_nesting);
    if (((trace_actions) && (FindAction(-1)))) {
        print "[";
        DB_Action(p1, p2, p3, p4, p5);
        print " - ";
        switch (rv) {
            RS_SUCCEEDS:
                print "succeeded";
                ;
            RS_FAILS:
                print "failed";
                if (reason_the_action_failed) {
                    print " the ";
                    RulePrintingRule(reason_the_action_failed);
                }
                ;
            default:
                print "ended without result";
                ;
        }
        print "]^";
        (say__p = 1);
        SetRulebookOutcome(rv);
    }
    if ((rv == RS_SUCCEEDS)) {
        UpdateActionBitmap();
    }
    if ((frame_id ~= -1)) {
        (p1 = FindAction(action));
        Mstack_Destroy_Frame((ActionData-->((p1 + AD_VARIABLES_CREATOR))), frame_id);
    }
    MStack_DestroyRBVars(ACTION_PROCESSING_RB);
    if ((((keep_silent == 0)) && ((multiflag == 0)))) {
        DivideParagraphPoint();
    }
    if ((rv == RS_SUCCEEDS)) {
        rtrue;
    }
    rfalse;
];
[ ACTION_PROCESSING_INTERNAL_R;
];
[ ActionVariablesNotTypeSafe mask noun_kova second_kova at;
    (at = FindAction(-1));
    if ((at == 0)) {
        rfalse;
    }
    (noun_kova = (ActionData-->((at + AD_NOUN_KOV))));
    (second_kova = (ActionData-->((at + AD_SECOND_KOV))));
    if ((noun_kova == SNIPPET_TY or UNDERSTANDING_TY)) {
        if ((inp1 ~= 1)) {
            (inp2 = inp1);
            (second = noun);
        }
        (parsed_number = ((100*consult_from) + consult_words));
        (inp1 = 1);
        (noun = 0);
    }
    if ((second_kova == SNIPPET_TY or UNDERSTANDING_TY)) {
        (parsed_number = ((100*consult_from) + consult_words));
        (inp2 = 1);
        (second = 0);
    }
    (mask = (ActionData-->((at + AD_REQUIREMENTS))));
    if (((mask)&(OUT_OF_WORLD_ABIT))) {
        (meta = 1);
        rfalse;
    }
    (meta = 0);
    if ((inp1 == 1)) {
        if ((noun_kova == OBJECT_TY)) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(66);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((noun_kova ~= OBJECT_TY)) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(67);
                print "^";
            }
            rtrue;
        }
        if (((((mask)&(NEED_NOUN_ABIT))) && ((noun == 0)))) {
            @push act_requester;
            (act_requester = 0);
            CarryOutActivity(SUPPLYING_A_MISSING_NOUN_ACT);
            @pull act_requester;
            if ((noun == 0)) {
                if (say__p) {
                    rtrue;
                }
                if ((actor == player)) {
                    ACTION_PROCESSING_INTERNAL_RM(68);
                    print "^";
                }
                rtrue;
            }
        }
        if ((((((mask)&(NEED_NOUN_ABIT)) == 0)) && ((noun ~= 0)))) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(69);
                print "^";
            }
            rtrue;
        }
    }
    if ((inp2 == 1)) {
        if ((second_kova == OBJECT_TY)) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(70);
                print "^";
            }
            rtrue;
        }
    } else {
        if ((second_kova ~= OBJECT_TY)) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(71);
                print "^";
            }
            rtrue;
        }
        if (((((mask)&(NEED_SECOND_ABIT))) && ((second == 0)))) {
            @push act_requester;
            (act_requester = 0);
            CarryOutActivity(SUPPLYING_A_MISSING_SECOND_ACT);
            @pull act_requester;
            if ((second == 0)) {
                if (say__p) {
                    rtrue;
                }
                if ((actor == player)) {
                    ACTION_PROCESSING_INTERNAL_RM(72);
                    print "^";
                }
                rtrue;
            }
        }
        if ((((((mask)&(NEED_SECOND_ABIT)) == 0)) && ((second ~= 0)))) {
            if ((actor == player)) {
                ACTION_PROCESSING_INTERNAL_RM(73);
                print "^";
            }
            rtrue;
        }
    }
    rfalse;
];
[ BASIC_VISIBILITY_R;
    if (act_requester) {
        rfalse;
    }
    if (((((((NeedLightForAction()) && ((actor == player)))) && (FollowRulebook(VISIBLE_RB)))) && (RulebookSucceeded()))) {
        BeginActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
        if ((ForActivity(REFUSAL_TO_ACT_IN_DARK_ACT) == 0)) {
            BASIC_VISIBILITY_RM(65);
            print "^";
        }
        EndActivity(REFUSAL_TO_ACT_IN_DARK_ACT);
        (reason_the_action_failed = BASIC_VISIBILITY_R);
        RulebookFails();
        rtrue;
    }
    rfalse;
];
[ BASIC_ACCESSIBILITY_R mask at;
    if (act_requester) {
        rfalse;
    }
    (at = FindAction(-1));
    if ((at == 0)) {
        rfalse;
    }
    (mask = (ActionData-->((at + AD_REQUIREMENTS))));
    if (((((((mask)&(TOUCH_NOUN_ABIT))) && (noun))) && ((inp1 ~= 1)))) {
        if ((noun ofclass K3_direction)) {
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            if ((actor ~= player)) {
                rtrue;
            }
            BASIC_ACCESSIBILITY_RM(65);
            print "^";
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            rtrue;
        }
        if (ObjectIsUntouchable(noun, (actor ~= player), actor)) {
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            rtrue;
        }
    }
    if (((((((mask)&(TOUCH_SECOND_ABIT))) && (second))) && ((inp2 ~= 1)))) {
        if ((second ofclass K3_direction)) {
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            if ((actor ~= player)) {
                rtrue;
            }
            BASIC_ACCESSIBILITY_RM(65);
            print "^";
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            rtrue;
        }
        if (ObjectIsUntouchable(second, (actor ~= player), actor)) {
            RulebookFails();
            (reason_the_action_failed = BASIC_ACCESSIBILITY_R);
            rtrue;
        }
    }
    rfalse;
];
[ CARRYING_REQUIREMENTS_R mask at;
    (at = FindAction(-1));
    if ((at == 0)) {
        rfalse;
    }
    (mask = (ActionData-->((at + AD_REQUIREMENTS))));
    if (((((((mask)&(TOUCH_NOUN_ABIT))) && (noun))) && ((inp1 ~= 1)))) {
        if (((((mask)&(CARRY_NOUN_ABIT))) && ((noun notin actor)))) {
            CarryOutActivity(IMPLICITLY_TAKING_ACT, noun);
            if ((noun notin actor)) {
                RulebookFails();
                (reason_the_action_failed = CARRYING_REQUIREMENTS_R);
                rtrue;
            }
        }
    }
    if (((((((mask)&(TOUCH_SECOND_ABIT))) && (second))) && ((inp2 ~= 1)))) {
        if (((((mask)&(CARRY_SECOND_ABIT))) && ((second notin actor)))) {
            CarryOutActivity(IMPLICITLY_TAKING_ACT, second);
            if ((second notin actor)) {
                RulebookFails();
                (reason_the_action_failed = CARRYING_REQUIREMENTS_R);
                rtrue;
            }
        }
    }
    rfalse;
];
[ STANDARD_IMPLICIT_TAKING_R;
    ImplicitTake(parameter_value);
    rfalse;
];
[ REQUESTED_ACTIONS_REQUIRE_R rv;
    if ((((actor ~= player)) && (act_requester))) {
        @push say__p;
        (say__p = 0);
        (rv = FollowRulebook(PERSUADE_RB));
        if ((RulebookSucceeded() == 0)) {
            if ((((deadflag == 0)) && ((say__p == 0)))) {
                REQUESTED_ACTIONS_REQUIRE_RM(65, actor);
                print "^";
            }
            ActRulebookFails(rv);
            rtrue;
        }
        @pull say__p;
    }
    rfalse;
];
[ CARRY_OUT_REQUESTED_ACTIONS_R rv;
    if ((((actor ~= player)) && (act_requester))) {
        @push act_requester;
        (act_requester = 0);
        (rv = BeginAction(action, noun, second));
        if (((((meta) || ((rv == 0)))) && ((deadflag == 0)))) {
            if ((FollowRulebook(UNSUCCESSFUL_ATTEMPT_RB) == 0)) {
                CARRY_OUT_REQUESTED_ACTIONS_RM(65, actor);
                print "^";
            }
        }
        @pull act_requester;
        FollowRulebook(AFTER_RB);
        ActRulebookSucceeds();
        rtrue;
    }
    rfalse;
];
[ GenericVerbSub ch co re vis rv;
    @push converted_action_outcome;
    (converted_action_outcome = -1);
    ((Details_of_Specific_Action-->(0)) = 1);
    if (meta) {
        ((Details_of_Specific_Action-->(0)) = 0);
    }
    ((Details_of_Specific_Action-->(1)) = keep_silent);
    ((Details_of_Specific_Action-->(2)) = ch);
    ((Details_of_Specific_Action-->(3)) = co);
    ((Details_of_Specific_Action-->(4)) = re);
    FollowRulebook(SPECIFIC_ACTION_PROCESSING_RB, 0, 1);
    if (((RulebookFailed()) && ((converted_action_outcome == 1)))) {
        ActRulebookSucceeds();
    }
    @pull converted_action_outcome;
    rtrue;
];
[ WORK_OUT_DETAILS_OF_SPECIFIC_R;
    ((MStack-->(MstVO(SPECIFIC_ACTION_PROCESSING_RB, 0))) = (Details_of_Specific_Action-->(0)));
    ((MStack-->(MstVO(SPECIFIC_ACTION_PROCESSING_RB, 1))) = (Details_of_Specific_Action-->(1)));
    ((MStack-->(MstVO(SPECIFIC_ACTION_PROCESSING_RB, 2))) = (Details_of_Specific_Action-->(2)));
    ((MStack-->(MstVO(SPECIFIC_ACTION_PROCESSING_RB, 3))) = (Details_of_Specific_Action-->(3)));
    ((MStack-->(MstVO(SPECIFIC_ACTION_PROCESSING_RB, 4))) = (Details_of_Specific_Action-->(4)));
    rfalse;
];
[ TestActionBitmap obj act i j k bitmap;
    if ((obj == 0)) {
        (bitmap = ActionHappened);
    } else {
        if ((~~((_final_propertyexists(OBJECT_TY, obj, A_action_bitmap))))) {
            rfalse;
        }
        (bitmap = (_final_propertyarray(OBJECT_TY, obj, A_action_bitmap)));
    }
    if ((act == -1)) {
        return ((((bitmap->(0)))&(1)) ~= 0);
    }
    for (((i = 0),(k = 2)):(i < ActionCount):(i)++) {
        if ((act == (ActionCoding-->(i)))) {
            return ((((bitmap->(j)))&(k)) ~= 0);
        }
        (k = (k*2));
        if ((k == 256)) {
            (k = 1);
            (j)++;
        }
    }
    rfalse;
];
[ UpdateActionBitmap;
    SetActionBitmap(noun, action);
    if ((action == ##Go)) {
        SetActionBitmap(location, ##Enter);
    }
];
[ SetActionBitmap obj act i j k bitmap;
    for (((i = 0),(k = 2)):(i < ActionCount):(i)++) {
        if ((act == (ActionCoding-->(i)))) {
            if ((_final_propertyexists(OBJECT_TY, obj, A_action_bitmap))) {
                (bitmap = (_final_propertyarray(OBJECT_TY, obj, A_action_bitmap)));
                ((bitmap->(0)) = (((bitmap->(0)))|(1)));
                ((bitmap->(j)) = (((bitmap->(j)))|(k)));
            }
            ((ActionHappened->(0)) = (((ActionHappened->(0)))|(1)));
            ((ActionHappened->(j)) = (((ActionHappened->(j)))|(k)));
        }
        (k = (k*2));
        if ((k == 256)) {
            (k = 1);
            (j)++;
        }
    }
];
[ SayActionName act;
    DB_Action(0, 0, act, 0, 0, 2);
];
[ DA_Name n;
    if ((n ofclass K3_direction)) {
        PrintShortName(n);
    } else {
        DefArt(n);
    }
];
[ DA_Topic x a b c d i cf cw;
    (cw = (x%100));
    (cf = (x/100));
    print "~";
    for ((a = cf):(d < cw):((d)++,(a)++)) {
        (wn = a);
        (b = WordAddress(a));
        (c = WordLength(a));
        for ((i = b):(i < (b + c)):(i)++) {
            print (char) (0->(i));
        }
        if ((d < (cw - 1))) {
            print " ";
        }
    }
    print "~";
];
[ DB_Action ac acr act n s for_say t at l j v c clc;
    if ((((for_say == 0)) && ((debug_rule_nesting > 0)))) {
        print "(";
        print debug_rule_nesting;
        print ") ";
    }
    if ((((ac ~= player)) && ((for_say ~= 2)))) {
        if (acr) {
            print "asking ";
            DefArt(ac);
            print " to try ";
        } else {
            DefArt(ac);
            print " ";
        }
    }
    DB_Action_Details(act, n, s, for_say);
    if (((keep_silent) && ((for_say == 0)))) {
        print " - silently";
    }
];
[ FixInhibitFlag n act inhibit_rule_debugging;
    for ((n = 0):(n < activities_sp):(n)++) {
        (act = (activities_stack-->(n)));
        if ((act == PRINTING_THE_NAME_ACT or PRINTING_THE_PLURAL_NAME_ACT or PRINTING_ROOM_DESC_DETAILS_ACT or PRINTING_INVENTORY_DETAILS_ACT or LISTING_CONTENTS_ACT or GROUPING_TOGETHER_ACT or PRINTING_RESPONSE_ACT)) {
            (inhibit_rule_debugging = 1);
        }
    }
    if ((((inhibit_flag == 0)) && (inhibit_rule_debugging))) {
        (saved_debug_rules = debug_rules);
        (debug_rules = 0);
    }
    if (((inhibit_flag) && ((inhibit_rule_debugging == 0)))) {
        (debug_rules = saved_debug_rules);
    }
    (inhibit_flag = inhibit_rule_debugging);
];
[ TestActivity A desc val i;
    for ((i = 0):(i < activities_sp):(i)++) {
        if (((activities_stack-->(i)) == A)) {
            if (desc) {
                if ((desc)((activity_parameters_stack-->(i)))) {
                    rtrue;
                }
            } else {
                if (val) {
                    if ((val == (activity_parameters_stack-->(i)))) {
                        rtrue;
                    }
                } else {
                    rtrue;
                }
            }
        }
    }
    rfalse;
];
[ ActivityEmpty A x;
    (x = (Activity_before_rulebooks-->(A)));
    if (((rulebooks_array-->(x)) ~= EMPTY_RULEBOOK)) {
        rfalse;
    }
    (x = (Activity_for_rulebooks-->(A)));
    if (((rulebooks_array-->(x)) ~= EMPTY_RULEBOOK)) {
        rfalse;
    }
    (x = (Activity_after_rulebooks-->(A)));
    if (((rulebooks_array-->(x)) ~= EMPTY_RULEBOOK)) {
        rfalse;
    }
    rtrue;
];
[ RulebookEmpty rb;
    if (((rulebooks_array-->(rb)) ~= EMPTY_RULEBOOK)) {
        rfalse;
    }
    rtrue;
];
[ ProcessActivityRulebook rulebook parameter rv;
    @push self;
    if (parameter) {
        (self = parameter);
    }
    (rv = FollowRulebook(rulebook, parameter, 1));
    @pull self;
    if (rv) {
        rtrue;
    }
    rfalse;
];
[ CarryOutActivity A o rv;
    BeginActivity(A, o);
    (rv = ForActivity(A, o));
    EndActivity(A, o);
    return rv;
];
[ BeginActivity A o x;
    if ((activities_sp == MAX_NESTED_ACTIVITIES)) {
        return RunTimeProblem(RTP_TOOMANYACTS);
    }
    ((activity_parameters_stack-->(activities_sp)) = o);
    ((activities_stack-->((activities_sp)++)) = A);
    FixInhibitFlag();
    MStack_CreateAVVars(A);
    if ((Activity_atb_rulebooks->(A))) {
        (x = action);
        (action = action_to_be);
    }
    (o = ProcessActivityRulebook((Activity_before_rulebooks-->(A)), o));
    if ((Activity_atb_rulebooks->(A))) {
        (action = x);
    }
    return o;
];
[ ForActivity A o x;
    if ((Activity_atb_rulebooks->(A))) {
        (x = action);
        (action = action_to_be);
    }
    (o = ProcessActivityRulebook((Activity_for_rulebooks-->(A)), o));
    if ((Activity_atb_rulebooks->(A))) {
        (action = x);
    }
    return o;
];
[ EndActivity A o rv x;
    if ((((activities_sp > 0)) && (((activities_stack-->((activities_sp - 1))) == A)))) {
        if ((Activity_atb_rulebooks->(A))) {
            (x = action);
            (action = action_to_be);
        }
        (rv = ProcessActivityRulebook((Activity_after_rulebooks-->(A)), o));
        if ((Activity_atb_rulebooks->(A))) {
            (action = x);
        }
        (activities_sp)--;
        FixInhibitFlag();
        MStack_DestroyAVVars(A);
        return rv;
    }
    return RunTimeProblem(RTP_CANTEND);
];
[ AbandonActivity A o;
    if ((((activities_sp > 0)) && (((activities_stack-->((activities_sp - 1))) == A)))) {
        (activities_sp)--;
        FixInhibitFlag();
        MStack_DestroyAVVars(A);
        rtrue;
    }
    return RunTimeProblem(RTP_CANTABANDON);
];
[ DisplayFigure resource_ID one_time;
    if (((one_time) && ((ResourceUsageFlags->(resource_ID))))) {
        rtrue;
    }
    ((ResourceUsageFlags->(resource_ID)) = 1);
    print "^";
    VM_Picture(resource_ID);
    print "^";
];
[ PlaySound resource_ID one_time;
    if ((resource_ID == 0)) {
        rtrue;
    }
    if (((one_time) && ((ResourceUsageFlags->(resource_ID))))) {
        rtrue;
    }
    ((ResourceUsageFlags->(resource_ID)) = 1);
    VM_SoundEffect(resource_ID);
];
[ Perform_Undo;
    if (((KIT_CONFIGURATION_BITMAP)&(PREVENT_UNDO_TCBIT))) {
        IMMEDIATELY_UNDO_RM(65);
        print "^";
        rtrue;
    }
    if ((IterationsOfTurnSequence == 0)) {
        IMMEDIATELY_UNDO_RM(66);
        print "^";
        rtrue;
    }
    if ((undo_flag == 0)) {
        IMMEDIATELY_UNDO_RM(67);
        print "^";
        rtrue;
    }
    if ((undo_flag == 1)) {
        IMMEDIATELY_UNDO_RM(68);
        print "^";
        rtrue;
    }
    if ((VM_Undo() == 0)) {
        IMMEDIATELY_UNDO_RM(70);
        print "^";
    }
];
[ ANNOUNCE_SCORE_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if ((((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT)) == 0)) {
        ANNOUNCE_SCORE_RM(67);
        print "^";
    } else {
        ANNOUNCE_SCORE_RM(65);
        PrintRank();
    }
];
[ SWITCH_SCORE_NOTIFY_ON_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if ((((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT)) == 0)) {
        ANNOUNCE_SCORE_R();
    } else {
        (notify_mode = 1);
    }
];
[ REP_SWITCH_NOTIFY_ON_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if (((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT))) {
        REP_SWITCH_NOTIFY_ON_RM(65);
        print "^";
    }
];
[ SWITCH_SCORE_NOTIFY_OFF_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if ((((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT)) == 0)) {
        ANNOUNCE_SCORE_R();
    } else {
        (notify_mode = 0);
    }
];
[ REP_SWITCH_NOTIFY_OFF_R;
    if ((actor ~= player)) {
        rfalse;
    }
    if (((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT))) {
        REP_SWITCH_NOTIFY_OFF_RM(65);
        print "^";
    }
];
[ PREFER_SOMETIMES_ABBREVIATED_R;
    if ((actor ~= player)) {
        rfalse;
    }
    (lookmode = 1);
];
[ REP_PREFER_SOMETIMES_ABBR_R;
    if ((actor ~= player)) {
        rfalse;
    }
    TEXT_TY_Say(Story);
    REP_PREFER_SOMETIMES_ABBR_RM(65);
    print "^";
];
[ PREFER_UNABBREVIATED_R;
    if ((actor ~= player)) {
        rfalse;
    }
    (lookmode = 2);
];
[ REP_PREFER_UNABBREVIATED_R;
    if ((actor ~= player)) {
        rfalse;
    }
    TEXT_TY_Say(Story);
    REP_PREFER_UNABBREVIATED_RM(65);
    print "^";
];
[ PREFER_ABBREVIATED_R;
    if ((actor ~= player)) {
        rfalse;
    }
    (lookmode = 3);
];
[ REP_PREFER_ABBREVIATED_R;
    if ((actor ~= player)) {
        rfalse;
    }
    TEXT_TY_Say(Story);
    REP_PREFER_ABBREVIATED_RM(65);
    print "^";
];
[ ANNOUNCE_PRONOUN_MEANINGS_R x y c d;
    if ((actor ~= player)) {
        rfalse;
    }
    ANNOUNCE_PRONOUN_MEANINGS_RM(65);
    (c = ((LanguagePronouns-->(0))/3));
    if ((player ~= selfobj)) {
        (c)++;
    }
    if ((c == 0)) {
        ANNOUNCE_PRONOUN_MEANINGS_RM(68);
        rtrue;
    }
    for (((x = 1),(d = 0)):(x <= (LanguagePronouns-->(0))):(x = (x + 3))) {
        print "~";
        print (address) (LanguagePronouns-->(x));
        print "~ ";
        (y = (LanguagePronouns-->((x + 2))));
        if ((y == NULL)) {
            ANNOUNCE_PRONOUN_MEANINGS_RM(67);
        } else {
            ANNOUNCE_PRONOUN_MEANINGS_RM(66);
            DefArt(y);
        }
        (d)++;
        if ((d < (c - 1))) {
            print ", ";
        }
        if ((d == (c - 1))) {
            if (((KIT_CONFIGURATION_BITMAP)&(SERIAL_COMMA_TCBIT))) {
                print ",";
            }
            LIST_WRITER_INTERNAL_RM(67);
        }
    }
    if ((player ~= selfobj)) {
        print "~";
        print (address) ME1__WD;
        print "~ ";
        ANNOUNCE_PRONOUN_MEANINGS_RM(66);
        (c = player);
        (player = selfobj);
        DefArt(c);
        (player = c);
    }
    print ".";
    new_line;
    rtrue;
];
[ PrintPrompt i;
    RunTimeProblemShow();
    ClearRTP();
    style roman;
    EnsureBreakBeforePrompt();
    TEXT_TY_Say(CommandPromptText());
    ClearBoxedText();
    ClearParagraphing(14);
];
[ DisplayBoxedQuotation Q;
    (pending_boxed_quotation = Q);
];
[ ClearBoxedText i;
    if (pending_boxed_quotation) {
        ClearParagraphing(15);
        (pending_boxed_quotation)();
        ClearParagraphing(16);
        (pending_boxed_quotation = 0);
    }
];
[ NotifyTheScore d;
    if (((((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT))) && ((notify_mode == 1)))) {
        DivideParagraphPoint();
        VM_Style(NOTE_VMSTY);
        (d = (score - last_score));
        if ((d > 0)) {
            ANNOUNCE_SCORE_RM(68, d);
        } else {
            if ((d < 0)) {
                ANNOUNCE_SCORE_RM(69, (-(d)));
            }
        }
        print "^";
        VM_Style(NORMAL_VMSTY);
    }
];
[ PrintRank i j v;
    if (((KIT_CONFIGURATION_BITMAP)&(RANKING_TABLE_TCBIT))) {
        ANNOUNCE_SCORE_RM(66);
        (j = TableRows(RANKING_TABLE));
        for ((i = j):(i >= 1):(i)--) {
            if ((score >= TableLookUpEntry(RANKING_TABLE, 1, i))) {
                (v = TableLookUpEntry(RANKING_TABLE, 2, i));
                TEXT_TY_Say(v);
                print ".";
                new_line;
                rtrue;
            }
        }
    }
    print ".";
    new_line;
    rtrue;
];
[ DrawStatusLine width posb;
    @push say__p;
    @push say__pc;
    BeginActivity(CONSTRUCTING_STATUS_LINE_ACT);
    VM_StatusLineHeight(1);
    VM_MoveCursorInStatusLine(1, 1);
    if (statuswin_current) {
        (width = VM_ScreenWidth());
        (posb = (width - 15));
        spaces width;
        ClearParagraphing(17);
        if ((ForActivity(CONSTRUCTING_STATUS_LINE_ACT) == 0)) {
            VM_MoveCursorInStatusLine(1, 2);
            TEXT_TY_Say(left_hand_status_line);
            VM_MoveCursorInStatusLine(1, posb);
            TEXT_TY_Say(right_hand_status_line);
        }
        VM_MoveCursorInStatusLine(1, 1);
        VM_MainWindow();
    }
    ClearParagraphing(18);
    EndActivity(CONSTRUCTING_STATUS_LINE_ACT);
    @pull say__pc;
    @pull say__p;
];
[ SL_Score_Moves;
    if (not_yet_in_play) {
        rtrue;
    }
    if (((KIT_CONFIGURATION_BITMAP)&(USE_SCORING_TCBIT))) {
        print sline1;
        print "/";
        print sline2;
    }
];
[ SL_Location even_before;
    if (((not_yet_in_play) && ((even_before == 0)))) {
        rtrue;
    }
    if ((location == thedark)) {
        BeginActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
        if ((ForActivity(PRINTING_NAME_OF_DARK_ROOM_ACT) == 0)) {
            DARKNESS_NAME_INTERNAL_RM(65);
        }
        EndActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);
    } else {
        FindVisibilityLevels();
        if ((visibility_ceiling == location)) {
            PrintShortName(location);
        } else {
            CDefArt(visibility_ceiling);
        }
    }
];
[ DARKNESS_NAME_INTERNAL_R;
];
[ Banner;
    BeginActivity(PRINTING_BANNER_TEXT_ACT);
    if ((ForActivity(PRINTING_BANNER_TEXT_ACT) == 0)) {
        VM_Style(HEADER_VMSTY);
        TEXT_TY_Say(Story);
        VM_Style(NORMAL_VMSTY);
        print "^";
        TEXT_TY_Say(Headline);
        if (((KIT_CONFIGURATION_BITMAP)&(STORY_AUTHOR_TCBIT))) {
            print " by ";
            TEXT_TY_Say(Story_Author);
        }
        print "^";
        VM_Describe_Release();
        print " / Inform 7 v";
        PrintI6Text(I7_VERSION_NUMBER);
        print " / D";
        print "^";
    }
    EndActivity(PRINTING_BANNER_TEXT_ACT);
];
[ CPrintOrRun obj prop v length i;
    if ((((obj ofclass String or Routine)) || ((prop == 0)))) {
        VM_PrintToBuffer(StorageForShortName, 160, obj);
    } else {
        if ((_final_propertyvalue(OBJECT_TY, obj, prop) == NULL)) {
            rfalse;
        }
        if ((metaclass(_final_propertyvalue(OBJECT_TY, obj, prop)) == Routine or String)) {
            VM_PrintToBuffer(StorageForShortName, 160, obj, prop);
        } else {
            return RunTimeError(2, obj, prop);
        }
    }
    (length = (StorageForShortName-->(0)));
    ((StorageForShortName->(WORDSIZE)) = VM_LowerToUpperCase((StorageForShortName->(WORDSIZE))));
    for ((i = WORDSIZE):(i < (length + WORDSIZE)):(i)++) {
        print (char) (StorageForShortName->(i));
    }
    if ((i > WORDSIZE)) {
        (say__p = 1);
    }
    rtrue;
];
[ Cap str nocaps;
    if (nocaps) {
        print (string) str;
    } else {
        CPrintOrRun(str, 0);
    }
];
[ PSN__ o;
    if ((o == 0)) {
        LIST_WRITER_INTERNAL_RM(89);
        rtrue;
    }
    switch (metaclass(o)) {
        Routine:
            print "<routine ";
            print o;
            print ">";
            rtrue;
            ;
        String:
            print "<string ~";
            print (string) o;
            print "~>";
            rtrue;
            ;
        0:
            print "<illegal object number ";
            print o;
            print ">";
            rtrue;
            ;
    }
    RegardingSingleObject(o);
    CarryOutActivity(PRINTING_THE_NAME_ACT, o);
];
[ PrintShortName obj i;
    (i = indef_mode);
    (indef_mode = NULL);
    PSN__(obj);
    (indef_mode = i);
];
[ STANDARD_NAME_PRINTING_R obj;
    (obj = parameter_value);
    if ((obj == 0)) {
        LIST_WRITER_INTERNAL_RM(89);
        rtrue;
    }
    switch (metaclass(obj)) {
        Routine:
            print "<routine ";
            print obj;
            print ">";
            rtrue;
            ;
        String:
            print "<string ~";
            print (string) obj;
            print "~>";
            rtrue;
            ;
        0:
            print "<illegal object number ";
            print obj;
            print ">";
            rtrue;
            ;
    }
    if ((obj == player)) {
        if ((((indef_mode == NULL)) && (caps_mode))) {
            PRINT_PROTAGONIST_INTERNAL_RM(65);
        } else {
            PRINT_PROTAGONIST_INTERNAL_RM(66);
        }
        rtrue;
    }
    if (((((indef_mode) && ((_final_propertyexists(OBJECT_TY, obj, A_short_name_indef))))) && ((PrintOrRun(obj, A_short_name_indef, 1) ~= 0)))) {
        rtrue;
    }
    if (((((caps_mode) && ((_final_propertyexists(OBJECT_TY, obj, A_cap_short_name))))) && ((PrintOrRun(obj, A_cap_short_name, 1) ~= 0)))) {
        (caps_mode = 0);
        rtrue;
    }
    if ((((_final_propertyexists(OBJECT_TY, obj, A_short_name))) && ((PrintOrRun(obj, A_short_name, 1) ~= 0)))) {
        rtrue;
    }
    print (object) obj;
];
[ STANDARD_PLURAL_NAME_PRINTING_R obj;
    (obj = parameter_value);
    PrintOrRun(obj, A_plural, 1);
];
[ PRINT_PROTAGONIST_INTERNAL_R;
];
[ PrefaceByArticle obj acode pluralise capitalise i artform findout artval;
    if ((_final_propertyexists(OBJECT_TY, obj, A_articles))) {
        (artval = ((_final_propertyarray(OBJECT_TY, obj, A_articles))-->((acode + (short_name_case*LanguageCases)))));
        if (capitalise) {
            Cap(artval);
        } else {
            print (string) artval;
        }
        if (pluralise) {
            rtrue;
        }
        PSN__(obj);
        rtrue;
    }
    (i = GetGNAOfObject(obj));
    if (pluralise) {
        if ((((i < 3)) || ((((i >= 6)) && ((i < 9)))))) {
            (i = (i + 3));
        }
    }
    (i = (LanguageGNAsToArticles-->(i)));
    (artform = (LanguageArticles + (((3*WORDSIZE)*LanguageContractionForms)*(short_name_case + (i*LanguageCases)))));
    switch (LanguageContractionForms) {
        2:
            if (((artform-->(acode)) ~= (artform-->((acode + 3))))) {
                (findout = 1);
            }
            ;
        3:
            if (((artform-->(acode)) ~= (artform-->((acode + 3))))) {
                (findout = 1);
            }
            if (((artform-->((acode + 3))) ~= (artform-->((acode + 6))))) {
                (findout = 1);
            }
            ;
        4:
            if (((artform-->(acode)) ~= (artform-->((acode + 3))))) {
                (findout = 1);
            }
            if (((artform-->((acode + 3))) ~= (artform-->((acode + 6))))) {
                (findout = 1);
            }
            if (((artform-->((acode + 6))) ~= (artform-->((acode + 9))))) {
                (findout = 1);
            }
            ;
        default:
            (findout = 1);
            ;
    }
    if (findout) {
        if (pluralise) {
            Glulx_PrintAnyToArray(StorageForShortName, 160, EnglishNumber, pluralise);
        } else {
            Glulx_PrintAnyToArray(StorageForShortName, 160, PSN__, obj);
        }
        (acode = (acode + (3*LanguageContraction(StorageForShortName))));
    }
    Cap((artform-->(acode)), (~~(capitalise)));
    if (pluralise) {
        rtrue;
    }
    PSN__(obj);
];
[ IndefArt obj i s;
    if ((obj == 0)) {
        LIST_WRITER_INTERNAL_RM(89);
        rtrue;
    }
    (i = indef_mode);
    (indef_mode = 1);
    (s = self);
    (self = obj);
    if ((obj has proper)) {
        (indef_mode = NULL);
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    if ((((_final_propertyexists(OBJECT_TY, obj, A_article))) && ((TEXT_TY_Compare((obj.article), EMPTY_TEXT_VALUE) ~= 0)))) {
        PrintOrRun(obj, A_article, 1);
        print " ";
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    PrefaceByArticle(obj, 2);
    (indef_mode = i);
    (self = s);
];
[ CIndefArt obj i s;
    if ((obj == 0)) {
        LIST_WRITER_INTERNAL_RM(88);
        rtrue;
    }
    (i = indef_mode);
    (indef_mode = 1);
    (s = self);
    (self = obj);
    if ((obj has proper)) {
        (indef_mode = NULL);
        (caps_mode = 1);
        PSN__(obj);
        (indef_mode = i);
        (caps_mode = 0);
        (self = s);
        rtrue;
    }
    if ((((_final_propertyexists(OBJECT_TY, obj, A_article))) && ((TEXT_TY_Compare((obj.article), EMPTY_TEXT_VALUE) ~= 0)))) {
        TEXT_TY_Say_Capitalised((obj.article));
        print " ";
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    PrefaceByArticle(obj, 2, 0, 1);
    (indef_mode = i);
    (self = s);
];
[ DefArt obj i s;
    (i = indef_mode);
    (indef_mode = 0);
    (s = self);
    (self = obj);
    if ((((~~((obj ofclass Object)))) || ((obj has proper)))) {
        (indef_mode = NULL);
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    PrefaceByArticle(obj, 1);
    (indef_mode = i);
    (self = s);
];
[ CDefArt obj i s;
    (i = indef_mode);
    (indef_mode = 0);
    (s = self);
    (self = obj);
    if ((((obj ofclass Object)) && ((((obj has proper)) || ((obj == player)))))) {
        (indef_mode = NULL);
        (caps_mode = 1);
        PSN__(obj);
        (indef_mode = i);
        (caps_mode = 0);
        (self = s);
        rtrue;
    }
    if ((((~~((obj ofclass Object)))) || ((obj has proper)))) {
        (indef_mode = NULL);
        PSN__(obj);
        (indef_mode = i);
        (self = s);
        rtrue;
    }
    PrefaceByArticle(obj, 0);
    (indef_mode = i);
    (self = s);
];
[ STANDARD_RESPONSE_ISSUING_R;
    RegardingSingleObject();
    TEXT_TY_Say((ResponseTexts-->((parameter_value - 1))));
];
[ HolderOf o;
    if (((InitialSituation-->(DONE_INIS)) == 0)) {
        return thedark;
    }
    if (((o) && ((o.component_parent)))) {
        return (o.component_parent);
    }
    if (((o) && (parent(o)))) {
        return parent(o);
    }
    rfalse;
];
[ ParentOf o;
    if (o) {
        (o = parent(o));
    }
    return o;
];
[ CoreOf o;
    while (((((o) && ((_final_propertyexists(OBJECT_TY, o, A_component_parent))))) && ((o.component_parent)))) {
        (o = (o.component_parent));
    }
    return o;
];
[ CoreOfParentOfCoreOf o;
    while (((((o) && ((_final_propertyexists(OBJECT_TY, o, A_component_parent))))) && ((o.component_parent)))) {
        (o = (o.component_parent));
    }
    if (o) {
        (o = parent(o));
    }
    while (((((o) && ((_final_propertyexists(OBJECT_TY, o, A_component_parent))))) && ((o.component_parent)))) {
        (o = (o.component_parent));
    }
    return o;
];
[ LocationOf o;
    if ((~~((o ofclass K1_room or K2_thing)))) {
        rfalse;
    }
    if ((o ofclass K4_door)) {
        if ((parent(o) == real_location)) {
            return real_location;
        }
        return FrontSideOfDoor(o);
    }
    if ((o ofclass K7_backdrop)) {
        return BackdropLocation(o);
    }
    while (o) {
        if ((o ofclass K1_room)) {
            return o;
        }
        (o = CoreOfParentOfCoreOf(o));
    }
    rfalse;
];
[ CommonAncestor o1 o2 i j;
    (o1 = CoreOf(o1));
    (o2 = CoreOf(o2));
    for ((i = o1):i:(i = CoreOfParentOfCoreOf(i))) {
        for ((j = o2):j:(j = CoreOfParentOfCoreOf(j))) {
            if ((j == i)) {
                return j;
            }
        }
    }
    rfalse;
];
[ IndirectlyContains o1 o2;
    if ((((o1 == 0)) || ((o2 == 0)))) {
        rfalse;
    }
    if ((((o1 ofclass K1_room)) && ((o2 ofclass K4_door)))) {
        if ((o1 == FrontSideOfDoor(o2))) {
            rtrue;
        }
        if ((o1 == BackSideOfDoor(o2))) {
            rtrue;
        }
        rfalse;
    }
    if ((o2 ofclass K7_backdrop)) {
        rfalse;
    }
    for ((o2 = HolderOf(o2)):((o2) && ((o2 ~= thedark))):(o2 = HolderOf(o2))) {
        if ((o2 == o1)) {
            rtrue;
        }
    }
    rfalse;
];
[ WhetherIn obj;
    if ((obj has enterable)) {
        if (IndirectlyContains(obj, player)) {
            rtrue;
        }
        rfalse;
    }
    if ((obj ofclass K9_region)) {
        return TestRegionalContainment(real_location, obj);
    }
    if ((obj ofclass K1_room)) {
        if ((obj == real_location)) {
            rtrue;
        }
        rfalse;
    }
    RunTimeProblem(RTP_NOTINAROOM, obj);
    rfalse;
];
[ ContainerOf A p;
    if ((A ofclass K1_room)) {
        return (A.map_region);
    }
    (p = parent(A));
    if ((p == 0)) {
        rfalse;
    }
    if ((p ofclass K5_container)) {
        return p;
    }
    if ((p ofclass K1_room)) {
        return p;
    }
    if ((p ofclass K9_region)) {
        return p;
    }
    rfalse;
];
[ TestContainmentRange obj e f;
    if ((obj ofclass K9_region)) {
        objectloop (f ofclass K1_room && (((f ofclass K1_room)) && (((f.map_region) == obj)))) {
            if ((f > e)) {
                return f;
            }
        }
        rfalse;
    }
    if ((obj ofclass K5_container or K1_room)) {
        if ((e == 0)) {
            return child(obj);
        }
        return sibling(e);
    }
    rfalse;
];
[ SupporterOf obj p;
    (p = parent(obj));
    if ((p == 0)) {
        rfalse;
    }
    if ((p ofclass K6_supporter)) {
        return p;
    }
    rfalse;
];
[ CarrierOf obj p;
    (p = parent(obj));
    if (((((p) && ((p ofclass K8_person)))) && ((~~((obj has worn)))))) {
        return p;
    }
    rfalse;
];
[ WearerOf obj p;
    (p = parent(obj));
    if (((((p) && ((p ofclass K8_person)))) && ((obj has worn)))) {
        return p;
    }
    rfalse;
];
[ OwnerOf obj p;
    (p = parent(obj));
    if (((p) && ((p ofclass K8_person)))) {
        return p;
    }
    rfalse;
];
[ PartOf P;
    if ((P ofclass K2_thing)) {
        return (P.component_parent);
    }
    rfalse;
];
[ MakePart P Of First;
    if ((P == player)) {
        return RunTimeProblem(RTP_CANTMAKEPART, Of);
    }
    if (parent(P)) {
        remove P;
    }
    give P ~worn;
    if ((Of == 0)) {
        DetachPart(P);
        rtrue;
    }
    if ((P.component_parent)) {
        DetachPart(P);
    }
    ((P.component_parent) = Of);
    (First = (Of.component_child));
    ((Of.component_child) = P);
    ((P.component_sibling) = First);
];
[ DetachPart P From Daddy O;
    (Daddy = (P.component_parent));
    ((P.component_parent) = 0);
    if ((Daddy == 0)) {
        ((P.component_sibling) = 0);
        rtrue;
    }
    if (((Daddy.component_child) == P)) {
        ((Daddy.component_child) = (P.component_sibling));
        ((P.component_sibling) = 0);
        rtrue;
    }
    for ((O = (Daddy.component_child)):O:(O = (O.component_sibling))) {
        if (((O.component_sibling) == P)) {
            ((O.component_sibling) = (P.component_sibling));
            ((P.component_sibling) = 0);
            rtrue;
        }
    }
];
[ MoveObject F T opt going_mode was L;
    if ((F == 0)) {
        return RunTimeProblem(RTP_CANTMOVENOTHING);
    }
    if ((F ofclass K7_backdrop)) {
        if ((T ofclass K9_region)) {
            give F ~absent;
            ((F.found_in) = (T.regional_found_in));
            if (TestRegionalContainment(LocationOf(player), T)) {
                move F to LocationOf(player);
            } else {
                remove F;
            }
            rtrue;
        }
        if ((T == FoundEverywhere)) {
            give F ~absent;
            ((F.found_in) = FoundEverywhere);
            rtrue;
        }
        return RunTimeProblem(RTP_BACKDROP, F, T);
    }
    if ((T ofclass K9_region)) {
        return RunTimeProblem(RTP_NOTBACKDROP, F, T);
    }
    if ((T == FoundEverywhere)) {
        return RunTimeProblem(RTP_BACKDROPONLY, F);
    }
    if ((~~((F ofclass K2_thing)))) {
        return RunTimeProblem(RTP_NOTTHING, F, T);
    }
    if ((F has worn)) {
        give F ~worn;
        if ((F in T)) {
            rtrue;
        }
    }
    DetachPart(F);
    if ((going_mode == 0)) {
        if ((F == player)) {
            PlayerTo(T, opt);
            rtrue;
        }
        if (IndirectlyContains(F, player)) {
            (L = LocationOf(T));
            if ((L == 0)) {
                return RunTimeProblem(RTP_CANTBEOFFSTAGE);
            }
            if ((LocationOf(player) ~= L)) {
                (was = parent(player));
                move player to real_location;
                move F to T;
                PlayerTo(was, 1);
                rtrue;
            }
        }
    }
    move F to T;
];
[ RemoveFromPlay F;
    if ((F == 0)) {
        return RunTimeProblem(RTP_CANTREMOVENOTHING);
    }
    if ((F == player)) {
        return RunTimeProblem(RTP_CANTREMOVEPLAYER);
    }
    if ((F ofclass K4_door)) {
        return RunTimeProblem(RTP_CANTREMOVEDOORS);
    }
    if (IndirectlyContains(F, player)) {
        return RunTimeProblem(RTP_CANTBEOFFSTAGE);
    }
    give F ~worn;
    DetachPart(F);
    if ((F ofclass K7_backdrop)) {
        give F absent;
    }
    remove F;
];
[ OnStage O set x;
    if ((O ofclass K1_room)) {
        rfalse;
    }
    if ((set < 0)) {
        while ((metaclass(O) == Object)) {
            if ((O ofclass K1_room)) {
                rtrue;
            }
            if ((O ofclass K9_region)) {
                rfalse;
            }
            if ((O ofclass K4_door)) {
                rtrue;
            }
            if ((O ofclass K7_backdrop)) {
                if ((O has absent)) {
                    rfalse;
                }
                rtrue;
            }
            (x = (O.component_parent));
            if (x) {
                (O = x);
                continue;
            }
            (x = parent(O));
            if (x) {
                (O = x);
                continue;
            }
            rfalse;
        }
    }
    (x = OnStage(O, (-(1))));
    if (((x) && ((set == 0)))) {
        RemoveFromPlay(O);
    }
    if ((((x == 0)) && (set))) {
        MoveObject(O, real_location);
    }
    rfalse;
];
[ PlayerTo newplace flag L;
    (L = LocationOf(newplace));
    if ((L == 0)) {
        return RunTimeProblem(RTP_CANTBEOFFSTAGE);
    }
    @push actor;
    (actor = player);
    move player to newplace;
    (location = L);
    (real_location = location);
    MoveFloatingObjects();
    SilentlyConsiderLight();
    DivideParagraphPoint();
    if ((flag == 0)) {
        R_Process(##Look);
    }
    if ((flag == 1)) {
        give location visited;
    }
    if ((flag == 2)) {
        AbbreviatedRoomDescription();
    }
    @pull actor;
];
[ MoveDuringGoing F T;
    MoveObject(F, T, 0, 1);
    if ((actor == player)) {
        (location = LocationOf(player));
        (real_location = location);
    }
];
[ FoundEverywhere;
    rtrue;
];
[ BackdropEverywhere O;
    if ((O ofclass K7_backdrop)) {
        if ((O has absent)) {
            rfalse;
        }
        if (((O.found_in) == FoundEverywhere)) {
            rtrue;
        }
    }
    rfalse;
];
[ ChangePlayer obj flag;
    if ((~~((obj ofclass K8_person)))) {
        return RunTimeProblem(RTP_CANTCHANGE, obj);
    }
    if ((~~(OnStage(obj, (-(1)))))) {
        return RunTimeProblem(RTP_CANTCHANGEOFFSTAGE, obj);
    }
    if ((obj.component_parent)) {
        return RunTimeProblem(RTP_CANTMAKEPART, obj);
    }
    if ((obj == player)) {
        rtrue;
    }
    give player ~concealed;
    if ((player has remove_proper)) {
        give player ~proper;
    }
    if ((player == selfobj)) {
        ((player.saved_short_name) = (player.short_name));
        ((player.short_name) = PRINT_PROTAGONIST_INTERNAL_RM(99));
    }
    (player = obj);
    if ((player == selfobj)) {
        ((player.short_name) = (player.saved_short_name));
    }
    if ((~~((player has proper)))) {
        give player remove_proper;
    }
    give player concealed;
    give player proper;
    (location = LocationOf(player));
    (real_location = location);
    MoveFloatingObjects();
    SilentlyConsiderLight();
];
[ MoveFloatingObjects toroom i k l m address flag;
    if ((toroom == 0)) {
        (toroom = real_location);
    }
    if ((toroom == 0)) {
        rtrue;
    }
    objectloop (i ofclass Object && i) {
        (address = (_final_propertyarray(OBJECT_TY, i, A_found_in)));
        if ((((address ~= 0)) && ((~~((i has absent)))))) {
            if ((ZRegion((address-->(0))) == 2)) {
                (m = (address-->(0)));
                .TestPropositionally;
                if (((m)(toroom) ~= 0)) {
                    move i to toroom;
                } else {
                    if ((i in toroom)) {
                        remove i;
                    }
                }
            } else {
                (k = (_final_propertylength(OBJECT_TY, i, A_found_in)));
                for ((l = 0):(l < (k/WORDSIZE)):(l)++) {
                    (m = (address-->(l)));
                    if ((ZRegion(m) == 2)) {
                        jump TestPropositionally;
                    }
                    if ((((m == toroom)) || ((m in toroom)))) {
                        if ((i notin toroom)) {
                            move i to toroom;
                        }
                        (flag = 1);
                    }
                }
                if ((flag == 0)) {
                    if ((i in toroom)) {
                        remove i;
                    }
                }
            }
            if ((((i ofclass K4_door)) && ((parent(i) == 0)))) {
                move i to _final_message0(i, A_door_to);
            }
        }
    }
];
[ MoveBackdrop bd D x address;
    if ((~~((bd ofclass K7_backdrop)))) {
        return RunTimeProblem(RTP_BACKDROPONLY, bd);
    }
    if (((_final_propertylength(OBJECT_TY, bd, A_found_in)) > WORDSIZE)) {
        (address = (_final_propertyarray(OBJECT_TY, bd, A_found_in)));
        ((address-->(0)) = D);
    } else {
        ((bd.found_in) = D);
    }
    give bd ~absent;
    MoveFloatingObjects();
];
[ BackdropLocation O target address m x i k l r sl;
    if ((O has absent)) {
        rfalse;
    }
    if ((((target == 0 or real_location)) && ((parent(O) == real_location)))) {
        return real_location;
    }
    (address = (_final_propertyarray(OBJECT_TY, O, A_found_in)));
    if ((address ~= 0)) {
        (k = (_final_propertylength(OBJECT_TY, O, A_found_in)));
        for ((l = 0):(l < (k/WORDSIZE)):(l)++) {
            (m = (address-->(l)));
            if ((ZRegion(m) == 2)) {
                (sl = location);
                if (target) {
                    (location = target);
                    (r = (m)());
                    if ((r ~= 0)) {
                        (location = sl);
                        return target;
                    }
                } else {
                    objectloop (x ofclass K1_room && (x ofclass K1_room)) {
                        (location = x);
                        (r = (m)());
                        if ((r ~= 0)) {
                            (location = sl);
                            return x;
                        }
                    }
                }
                (location = sl);
            } else {
                if ((m ofclass K9_region)) {
                    objectloop (x ofclass K1_room && (x ofclass K1_room)) {
                        if (TestRegionalContainment(x, m)) {
                            if ((target == 0 or x)) {
                                return x;
                            }
                        }
                    }
                } else {
                    if ((target == 0 or m)) {
                        return m;
                    }
                }
            }
        }
    }
    rfalse;
];
[ WearObject X P opt;
    if ((X == 0)) {
        rfalse;
    }
    if ((X notin P)) {
        MoveObject(X, P, opt);
    }
    give X worn;
];
[ MapConnection from_room dir in_direction through_door;
    if ((((from_room ofclass K1_room)) && ((dir ofclass K3_direction)))) {
        (in_direction = (Map_Storage-->((((from_room.IK1_Count)*No_Directions) + (dir.IK3_Count)))));
        if ((in_direction ofclass K1_room)) {
            return in_direction;
        }
        if ((in_direction ofclass K4_door)) {
            @push location;
            (location = from_room);
            (through_door = _final_message0(in_direction, A_door_to));
            @pull location;
            if ((through_door ofclass K1_room)) {
                return through_door;
            }
        }
    }
    rfalse;
];
[ DoorFrom obj dir rv;
    (rv = RoomOrDoorFrom(obj, dir));
    if ((rv ofclass K4_door)) {
        return rv;
    }
    rfalse;
];
[ RoomOrDoorFrom obj dir use_doors in_direction sl through_door;
    if ((((obj ofclass K1_room)) && ((dir ofclass K3_direction)))) {
        (in_direction = (Map_Storage-->((((obj.IK1_Count)*No_Directions) + (dir.IK3_Count)))));
        if ((in_direction ofclass K1_room or K4_door)) {
            return in_direction;
        }
    }
    rfalse;
];
[ AssertMapConnection r1 dir r2 in_direction;
    SignalMapChange();
    (in_direction = (Map_Storage-->((((r1.IK1_Count)*No_Directions) + (dir.IK3_Count)))));
    if ((((in_direction == 0)) || ((in_direction ofclass K1_room)))) {
        ((Map_Storage-->((((r1.IK1_Count)*No_Directions) + (dir.IK3_Count)))) = r2);
        rtrue;
    }
    if ((in_direction ofclass K4_door)) {
        RunTimeProblem(RTP_EXITDOOR, r1, dir);
        rtrue;
    }
    RunTimeProblem(RTP_NOEXIT, r1, dir);
];
[ AssertMapUnconnection r1 dir r2 in_direction;
    SignalMapChange();
    (in_direction = (Map_Storage-->((((r1.IK1_Count)*No_Directions) + (dir.IK3_Count)))));
    if ((r1 ofclass K4_door)) {
        RunTimeProblem(RTP_EXITDOOR, r1, dir);
        rtrue;
    }
    if ((in_direction == r2)) {
        ((Map_Storage-->((((r1.IK1_Count)*No_Directions) + (dir.IK3_Count)))) = 0);
    }
    rtrue;
];
[ TestAdjacency R1 R2 i row;
    if ((((R1 == 0)) || ((R2 == 0)))) {
        rfalse;
    }
    if ((R1 ofclass K9_region)) {
        RunTimeProblem(RTP_REGIONSNOTADJACENT, R1);
    } else {
        if ((R2 ofclass K9_region)) {
            RunTimeProblem(RTP_REGIONSNOTADJACENT, R2);
        }
    }
    (row = ((R1.IK1_Count)*No_Directions));
    for ((i = 0):(i < No_Directions):((i)++,(row)++)) {
        if (((Map_Storage-->(row)) == R2)) {
            rtrue;
        }
    }
    rfalse;
];
[ TestRegionalContainment obj region o;
    if ((((obj == 0)) || ((region == 0)))) {
        rfalse;
    }
    if ((obj ofclass K7_backdrop or K4_door)) {
        if ((obj has absent)) {
            rfalse;
        }
        objectloop (o ofclass K1_room && (o ofclass K1_room)) {
            if (TestRegionalContainment(o, region)) {
                if (BackdropLocation(obj, o)) {
                    rtrue;
                }
            }
        }
        rfalse;
    }
    if ((obj ofclass K9_region)) {
        (o = obj);
    } else {
        if ((~~((obj ofclass K1_room)))) {
            (obj = LocationOf(obj));
        }
        if ((obj == 0)) {
            rfalse;
        }
        (o = (obj.map_region));
    }
    while (o) {
        if ((o == region)) {
            rtrue;
        }
        (o = parent(o));
    }
    rfalse;
];
[ FrontSideOfDoor D;
    if ((~~((D ofclass K4_door)))) {
        rfalse;
    }
    if ((_final_propertyexists(OBJECT_TY, D, A_found_in))) {
        return ((_final_propertyarray(OBJECT_TY, D, A_found_in))-->(0));
    }
    return parent(D);
];
[ BackSideOfDoor D;
    if ((~~((D ofclass K4_door)))) {
        rfalse;
    }
    if ((_final_propertyexists(OBJECT_TY, D, A_found_in))) {
        return ((_final_propertyarray(OBJECT_TY, D, A_found_in))-->(1));
    }
    rfalse;
];
[ OtherSideOfDoor D from_room rv;
    if ((D ofclass K4_door)) {
        @push location;
        (location = LocationOf(from_room));
        (rv = _final_message0(D, A_door_to));
        @pull location;
    }
    return rv;
];
[ DirectionDoorLeadsIn D from_room rv dir;
    if ((D ofclass K4_door)) {
        @push location;
        (location = LocationOf(from_room));
        (rv = _final_message0(D, A_door_dir));
        @pull location;
    }
    return rv;
];
[ TestVisibility A B;
    if ((~~(OffersLight(parent(CoreOf(A)))))) {
        rfalse;
    }
    if (suppress_scope_loops) {
        rtrue;
    }
    return TestScope(B, A);
];
[ TestTouchability A B rv;
    if ((A ofclass K4_door or K7_backdrop)) {
        MoveFloatingObjects(LocationOf(B));
    }
    if ((B ofclass K4_door or K7_backdrop)) {
        MoveFloatingObjects(LocationOf(A));
    }
    if ((TestScope(B, A) == 0)) {
        (rv = 1);
    } else {
        (rv = ObjectIsUntouchable(B, 1, A));
    }
    if ((A ofclass K4_door or K7_backdrop)) {
        MoveFloatingObjects();
    }
    if (rv) {
        rfalse;
    }
    rtrue;
];
[ TestConcealment A B;
    if ((((A ofclass K2_thing)) && ((B ofclass K2_thing)))) {
        if (IndirectlyContains(A, B)) {
            (particular_possession = B);
            if (CarryOutActivity(DECIDING_CONCEALED_POSSESS_ACT, A)) {
                rtrue;
            }
        }
    }
    rfalse;
];
[ SignalMapChange;
    (map_has_changed = 1);
];
[ MapRouteTo from to filter use_doors count oy oyi ds;
    if ((from == 0)) {
        rfalse;
    }
    if ((to == 0)) {
        rfalse;
    }
    if ((from == to)) {
        rfalse;
    }
    if (((filter) && (((filter)(from) == 0)))) {
        rfalse;
    }
    if (((filter) && (((filter)(to) == 0)))) {
        rfalse;
    }
    if ((((last_filter ~= filter)) || ((last_use_doors ~= use_doors)))) {
        (map_has_changed = 1);
    }
    (oyi = 0);
    objectloop (oy ofclass Object && (oy has mark_as_room)) {
        if ((((filter == 0)) || ((filter)(oy)))) {
            if (((oy.room_index) == -1)) {
                (map_has_changed = 1);
            }
            ((oy.room_index) = (oyi)++);
        } else {
            if (((oy.room_index) >= 0)) {
                (map_has_changed = 1);
            }
            ((oy.room_index) = -1);
        }
    }
    (oyi = 0);
    objectloop (oy ofclass K4_door && (oy ofclass K4_door)) {
        (ds = 0);
        if (((((((use_doors)&(2))) || ((oy has open)))) || ((((oy has openable)) && ((~~((oy has locked)))))))) {
            (ds = 1);
        }
        if (((DoorRoutingViable->(oyi)) ~= ds)) {
            (map_has_changed = 1);
        }
        ((DoorRoutingViable->(oyi)) = ds);
        (oyi)++;
    }
    if (map_has_changed) {
        ComputeFWMatrix(filter, use_doors);
        (map_has_changed = 0);
        (last_filter = filter);
        (last_use_doors = use_doors);
    }
    if (count) {
        return FastCountRouteTo(from, to, filter, use_doors);
    }
    return FastRouteTo(from, to, filter, use_doors);
];
[ FastRouteTo from to filter use_doors diri i dir oy;
    if ((from == to)) {
        rfalse;
    }
    (i = ((FWMatrix-->((((from.room_index)*NUM_ROOMS) + (to.room_index))))/No_Directions));
    if ((i == 0)) {
        rfalse;
    }
    (diri = ((FWMatrix-->((((from.room_index)*NUM_ROOMS) + (to.room_index))))%No_Directions));
    (i = 0);
    objectloop (dir ofclass K3_direction && (dir ofclass K3_direction)) {
        if ((i == diri)) {
            return dir;
        }
        (i)++;
    }
    rfalse;
];
[ FastCountRouteTo from to filter use_doors k;
    if ((from == to)) {
        rfalse;
    }
    (k = ((FWMatrix-->((((from.room_index)*NUM_ROOMS) + (to.room_index))))/No_Directions));
    if ((k == 0)) {
        return (-(1));
    }
    return k;
];
[ ComputeFWMatrix filter use_doors oy ox oj axy ayj axj dir diri nd row;
    objectloop (oy ofclass Object && (oy has mark_as_room)) {
        if (((oy.room_index) >= 0)) {
            objectloop (ox ofclass Object && (ox has mark_as_room)) {
                if (((ox.room_index) >= 0)) {
                    ((FWMatrix-->((((oy.room_index)*NUM_ROOMS) + (ox.room_index)))) = 0);
                }
            }
        }
    }
    objectloop (oy ofclass Object && (oy has mark_as_room)) {
        if (((oy.room_index) >= 0)) {
            (row = ((oy.IK1_Count)*No_Directions));
            for ((diri = 0):(diri < No_Directions):(diri)++) {
                (ox = (Map_Storage-->((row + diri))));
                if (((((ox) && ((ox has mark_as_room)))) && (((ox.room_index) >= 0)))) {
                    ((FWMatrix-->((((oy.room_index)*NUM_ROOMS) + (ox.room_index)))) = (No_Directions + diri));
                    continue;
                }
                if (((((use_doors) && ((ox ofclass K4_door)))) && (((((use_doors)&(2))) || ((DoorRoutingViable->((ox.IK4_Count)))))))) {
                    @push location;
                    (location = oy);
                    (ox = _final_message0(ox, A_door_to));
                    @pull location;
                    if (((((ox) && ((ox has mark_as_room)))) && (((ox.room_index) >= 0)))) {
                        ((FWMatrix-->((((oy.room_index)*NUM_ROOMS) + (ox.room_index)))) = (No_Directions + diri));
                        continue;
                    }
                }
            }
        }
    }
    objectloop (oy ofclass Object && (oy has mark_as_room)) {
        if (((oy.room_index) >= 0)) {
            objectloop (ox ofclass Object && (ox has mark_as_room)) {
                if (((ox.room_index) >= 0)) {
                    (axy = ((FWMatrix-->((((ox.room_index)*NUM_ROOMS) + (oy.room_index))))/No_Directions));
                    if ((axy > 0)) {
                        objectloop (oj ofclass Object && (oj has mark_as_room)) {
                            if (((oj.room_index) >= 0)) {
                                (ayj = ((FWMatrix-->((((oy.room_index)*NUM_ROOMS) + (oj.room_index))))/No_Directions));
                                if ((ayj > 0)) {
                                    (axj = ((FWMatrix-->((((ox.room_index)*NUM_ROOMS) + (oj.room_index))))/No_Directions));
                                    if ((((axj == 0)) || (((axy + ayj) < axj)))) {
                                        ((FWMatrix-->((((ox.room_index)*NUM_ROOMS) + (oj.room_index)))) = (((axy + ayj)*No_Directions) + ((FWMatrix-->((((ox.room_index)*NUM_ROOMS) + (oy.room_index))))%No_Directions)));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
];
[ RunTimeProblemShowWM n par1 par2 par3;
    switch (n) {
        RTP_BACKDROP:
            print "Tried to move ";
            DefArt(par1);
            print " (a backdrop) to ";
            DefArt(par2);
            print ", which is not a region.^";
            ;
        RTP_CANTCHANGE:
            print "Tried to change player to ";
            DefArt(par1);
            print ", which is not a person.^";
            ;
        RTP_NOEXIT:
            print "Tried to change ";
            DefArt(par2);
            print " exit of ";
            DefArt(par1);
            print ", but it didn't seem to have such an exit to change.^";
            ;
        RTP_EXITDOOR:
            print "Tried to change ";
            DefArt(par2);
            print " exit of ";
            DefArt(par1);
            print ", but it led to a door, not a room.^";
            ;
        RTP_TOOMANYEVENTS:
            print "Too many timed events are going on at once.^";
            ;
        RTP_CANTMOVENOTHING:
            print "You can't move nothing.^";
            ;
        RTP_CANTREMOVENOTHING:
            print "You can't remove nothing from play.^";
            ;
        RTP_NOTBACKDROP:
            print "Tried to move ";
            DefArt(par1);
            print " (not a backdrop) to ";
            DefArt(par2);
            print ", which is a region.^";
            ;
        RTP_NOTINAROOM:
            print "Attempt to test if the current location is '";
            DefArt(par1);
            print "', which is not a room or region.^";
            ;
        RTP_BADTOPIC:
            print "Attempt to see if a snippet of text matches something which is not a topic.^";
            ;
        RTP_DONTIGNORETURNSEQUENCE:
            print "Attempt to ignore the turn sequence rules.^";
            ;
        RTP_SAYINVALIDSNIPPET:
            print "Attempt to say a snippet value which is currently invalid: words ";
            print par1;
            print " to ";
            print par2;
            print ".^";
            ;
        RTP_SPLICEINVALIDSNIPPET:
            print "Attempt to splice a snippet value which is currently invalid: words ";
            print par1;
            print " to ";
            print par2;
            print ".^";
            ;
        RTP_INCLUDEINVALIDSNIPPET:
            print "Attempt to match a snippet value which is currently invalid: words ";
            print par1;
            print " to ";
            print par2;
            print ".^";
            ;
        RTP_CANTREMOVEPLAYER:
            print "Attempt to remove the player from play.^";
            ;
        RTP_CANTBEOFFSTAGE:
            print "Attempt to move the player off-stage.^";
            ;
        RTP_CANTREMOVEDOORS:
            print "Attempt to remove a door from play.^";
            ;
        RTP_CANTCHANGEOFFSTAGE:
            print "Attempt to change the player to a person off-stage.^";
            ;
        RTP_BACKDROPONLY:
            print "Only backdrops can be moved to multiple places.^";
            ;
        RTP_NOTTHING:
            print "Tried to move ";
            DefArt(par1);
            print " (not a thing) to ";
            DefArt(par2);
            print ", but only things can move around.^";
            ;
        RTP_CANTMAKEPART:
            print "Tried to make the player part of something: ";
            DefArt(par1);
            print ".^";
            ;
        RTP_REGIONSNOTADJACENT:
            print "You can't test whether something is adjacent to a region: ";
            print "such as, in this case, ";
            DefArt(par1);
            print ".^";
            ;
        RTP_SCENEHASNTSTARTED:
            print "The scene ";
            PrintSceneName(par1);
            print " hasn't started, so you can't ask when it did.^";
            ;
        RTP_SCENEHASNTENDED:
            print "The scene ";
            PrintSceneName(par1);
            print " hasn't ended, so you can't ask when it did.^";
            ;
    }
];
[ NUMBER_TY_to_TIME_TY n;
    (n = (n%1440));
    if ((n < 0)) {
        return (n + 1440);
    }
    return n;
];
[ PrintTimeOfDay t h aop;
    if ((t < 0)) {
        print "<no time>";
        rtrue;
    }
    if ((t >= TWELVE_HOURS)) {
        (aop = "pm");
        (t = (t - TWELVE_HOURS));
    } else {
        (aop = "am");
    }
    (h = (t/ONE_HOUR));
    if ((h == 0)) {
        (h = 12);
    }
    print h;
    print ":";
    if (((t%ONE_HOUR) < 10)) {
        print "0";
    }
    print (t%ONE_HOUR);
    print " ";
    print (string) aop;
];
[ PrintTimeOfDayEnglish t h m dir aop;
    (h = ((t/ONE_HOUR)%12));
    (m = (t%ONE_HOUR));
    if ((h == 0)) {
        (h = 12);
    }
    if ((m == 0)) {
        LanguageNumber(h);
        print " o'clock";
        rtrue;
    }
    (dir = "past");
    if ((m > HALF_HOUR)) {
        (m = (ONE_HOUR - m));
        (h = ((h + 1)%12));
        if ((h == 0)) {
            (h = 12);
        }
        (dir = "to");
    }
    switch (m) {
        QUARTER_HOUR:
            print "quarter";
            ;
        HALF_HOUR:
            print "half";
            ;
        default:
            LanguageNumber(m);
            if (((m%5) ~= 0)) {
                if ((m == 1)) {
                    print " minute";
                } else {
                    print " minutes";
                }
            }
            ;
    }
    print " ";
    print (string) dir;
    print " ";
    LanguageNumber(h);
];
[ TIME_TOKEN first_word second_word at length flag illegal_char offhour hr mn i original_wn;
    (original_wn = wn);
    (i = TIME_TOKEN_INNER());
    if ((i ~= GPR_FAIL)) {
        return i;
    }
    (wn = original_wn);
    (first_word = NextWordStopped());
    switch (first_word) {
        'midnight':
            (parsed_number = 0);
            return GPR_NUMBER;
            ;
        'midday', 'noon':
            (parsed_number = TWELVE_HOURS);
            return GPR_NUMBER;
            ;
    }
    (at = WordAddress((wn - 1)));
    (length = WordLength((wn - 1)));
    for ((i = 0):(i < length):(i)++) {
        switch ((at->(i))) {
            58:
                if ((((((flag == 0)) && ((i > 0)))) && ((i < (length - 1))))) {
                    (flag = 1);
                } else {
                    (illegal_char = 1);
                }
                ;
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57:
                ;
            default:
                (illegal_char = 1);
                ;
        }
    }
    if ((((((length < 3)) || ((length > 5)))) || (illegal_char))) {
        (flag = 0);
    }
    if (flag) {
        for ((i = 0):((at->(i)) ~= 58):((i)++,(hr = (hr*10)))) {
            (hr = ((hr + (at->(i))) - 48));
        }
        (hr = (hr/10));
        for ((i)++:(i < length):((i)++,(mn = (mn*10)))) {
            (mn = ((mn + (at->(i))) - 48));
        }
        (mn = (mn/10));
        (second_word = NextWordStopped());
        (parsed_number = HoursMinsWordToTime(hr, mn, second_word));
        if ((parsed_number == -1)) {
            return GPR_FAIL;
        }
        if ((second_word ~= 'pm' or 'am')) {
            (wn)--;
        }
        return GPR_NUMBER;
    }
    (offhour = -1);
    if ((first_word == 'half')) {
        (offhour = HALF_HOUR);
    }
    if ((first_word == 'quarter')) {
        (offhour = QUARTER_HOUR);
    }
    if ((offhour < 0)) {
        (offhour = TryNumber((wn - 1)));
    }
    if ((((offhour < 0)) || ((offhour >= ONE_HOUR)))) {
        return GPR_FAIL;
    }
    (second_word = NextWordStopped());
    switch (second_word) {
        'o^clock', 'am', 'pm', (-(1)):
            (hr = offhour);
            if ((hr > 12)) {
                return GPR_FAIL;
            }
            ;
        'to', 'past':
            (mn = offhour);
            (hr = TryNumber(wn));
            if ((hr <= 0)) {
                switch (NextWordStopped()) {
                    'noon', 'midday':
                        (hr = 12);
                        ;
                    'midnight':
                        (hr = 0);
                        ;
                    default:
                        return GPR_FAIL;
                        ;
                }
            }
            if ((hr >= 13)) {
                return GPR_FAIL;
            }
            if ((second_word == 'to')) {
                (mn = (ONE_HOUR - mn));
                (hr)--;
                if ((hr < 0)) {
                    (hr = 23);
                }
            }
            (wn)++;
            (second_word = NextWordStopped());
            ;
        default:
            (hr = offhour);
            (mn = TryNumber(--(wn)));
            if ((((mn < 0)) || ((mn >= ONE_HOUR)))) {
                return GPR_FAIL;
            }
            (wn)++;
            (second_word = NextWordStopped());
            ;
    }
    (parsed_number = HoursMinsWordToTime(hr, mn, second_word));
    if ((parsed_number < 0)) {
        return GPR_FAIL;
    }
    if ((second_word ~= 'pm' or 'am' or 'o^clock')) {
        (wn)--;
    }
    return GPR_NUMBER;
];
[ HoursMinsWordToTime hour minute word x;
    if ((hour >= 24)) {
        return (-(1));
    }
    if ((minute >= ONE_HOUR)) {
        return (-(1));
    }
    (x = ((hour*ONE_HOUR) + minute));
    if ((hour >= 13)) {
        return x;
    }
    (x = (x%TWELVE_HOURS));
    if ((word == 'pm')) {
        (x = (x + TWELVE_HOURS));
    }
    if ((((word ~= 'am' or 'pm')) && ((hour == 12)))) {
        (x = (x + TWELVE_HOURS));
    }
    return x;
];
[ RELATIVE_TIME_TOKEN first_word second_word offhour mult mn original_wn;
    (original_wn = wn);
    (wn = original_wn);
    (first_word = NextWordStopped());
    (wn)--;
    if ((first_word == 'an' or 'a//')) {
        (mn = 1);
    } else {
        (mn = TryNumber(wn));
    }
    if ((mn == -1000)) {
        (first_word = NextWordStopped());
        if ((first_word == 'half')) {
            (offhour = HALF_HOUR);
        }
        if ((first_word == 'quarter')) {
            (offhour = QUARTER_HOUR);
        }
        if ((offhour > 0)) {
            (second_word = NextWordStopped());
            if ((second_word == 'of')) {
                (second_word = NextWordStopped());
            }
            if ((second_word == 'an')) {
                (second_word = NextWordStopped());
            }
            if ((second_word == 'hour')) {
                (parsed_number = offhour);
                return GPR_NUMBER;
            }
        }
        return GPR_FAIL;
    }
    (wn)++;
    (first_word = NextWordStopped());
    switch (first_word) {
        'minutes', 'minute':
            (mult = 1);
            ;
        'hours', 'hour':
            (mult = 60);
            ;
        default:
            return GPR_FAIL;
            ;
    }
    (parsed_number = (mn*mult));
    if ((mult == 60)) {
        (mn = TryNumber(wn));
        if ((mn ~= -1000)) {
            (wn)++;
            (first_word = NextWordStopped());
            if ((first_word == 'minutes' or 'minute')) {
                (parsed_number = (parsed_number + mn));
            } else {
                (wn = (wn - 2));
            }
        }
    }
    return GPR_NUMBER;
];
[ SCENE_CHANGE_MACHINERY_R;
    DetectSceneChange();
];
[ DuringSceneMatching prop sc;
    for ((sc = 0):(sc < NUMBER_SCENES_CREATED):(sc)++) {
        if (((((scene_status-->(sc)) == 1)) && ((prop)((sc + 1))))) {
            rtrue;
        }
    }
    rfalse;
];
[ SceneUtility sc task;
    if ((sc <= 0)) {
        rfalse;
    }
    if ((task == 1 or 2)) {
        if (((scene_endings-->((sc - 1))) == 0)) {
            return RunTimeProblem(RTP_SCENEHASNTSTARTED, sc);
        }
    } else {
        if (((scene_endings-->((sc - 1))) <= 1)) {
            return RunTimeProblem(RTP_SCENEHASNTENDED, sc);
        }
    }
    switch (task) {
        1:
            return ((the_time - (scene_started-->((sc - 1))))%TWENTY_FOUR_HOURS);
            ;
        2:
            return (scene_started-->((sc - 1)));
            ;
        3:
            return ((the_time - (scene_ended-->((sc - 1))))%TWENTY_FOUR_HOURS);
            ;
        4:
            return (scene_ended-->((sc - 1)));
            ;
    }
];
[ XAbstractSub;
    if (XTestMove(noun, second)) {
        rtrue;
    }
    move noun to second;
    (say__p = 1);
    print "[Abstracted.]";
    new_line;
    rtrue;
];
[ XTestMove obj dest;
    if ((obj.component_parent)) {
        print "[Can't move ";
        PrintShortName(obj);
        print ": it's part of ";
        DefArt((obj.component_parent));
        print ".]";
        print "^";
        rtrue;
    }
    while (dest) {
        if ((dest == obj)) {
            print "[Can't move ";
            PrintShortName(obj);
            print ": it would contain itself.]";
            print "^";
            rtrue;
        }
        (dest = CoreOfParentOfCoreOf(dest));
    }
    rfalse;
];
[ ActionsOnSub;
    (trace_actions = 1);
    (say__p = 1);
    print "Actions listing on.";
    new_line;
    rtrue;
];
[ ActionsOffSub;
    (trace_actions = 0);
    (say__p = 1);
    print "Actions listing off.";
    new_line;
    rtrue;
];
[ GonearSub;
    PlayerTo(LocationOf(noun));
];
[ XPurloinSub;
    if (XTestMove(noun, player)) {
        rtrue;
    }
    move noun to player;
    give noun moved;
    give noun ~concealed;
    (say__p = 1);
    print "[Purloined.]";
    new_line;
    rtrue;
];
[ PredictableSub;
    VM_Seed_RNG(-100);
    (say__p = 1);
    print "[Random number generator now predictable.]";
    new_line;
    rtrue;
];
[ ShowRelationsSub;
    IterateRelations(ShowOneRelation);
];
[ ShowOneRelation rel;
    if (((RlnGetF(rel, RR_PERMISSIONS))&(RELS_SHOW))) {
        (RlnGetF(rel, RR_HANDLER))(rel,RELS_SHOW);
    }
];
[ ShowResponsesSub a i j reg wd set_mode;
    if ((NO_RESPONSES == 0)) {
        print "There are no lettered responses.";
        new_line;
        rtrue;
    }
    (wn = 2);
    if ((NextWordStopped() == 'now')) {
        (set_mode = 1);
    } else {
        (wn)--;
    }
    if ((NextWordStopped() == 'set')) {
        (set_mode = 2);
    } else {
        (wn)--;
    }
    (wd = NextWordStopped());
    (wn)--;
    if ((wd == 'all')) {
        (reg = 0);
    } else {
        (reg = -1);
        if ((wd ~= -1)) {
            (reg = TryNumber(wn));
        }
        if ((reg < 0)) {
            (say__p = 1);
            print ">--> The following sets of responses are available:^";
            print "    RESPONSES ALL^";
        }
    }
    for (((a = 0),((i = 1),(j = 0))):(ResponseDivisions-->(a)):((a = (a + 3)),(i)++)) {
        if (((ResponseDivisions-->(a)) ~= EMPTY_TEXT_PACKED)) {
            (j)++;
        }
        if ((((reg == 0)) || ((reg == j)))) {
            if (((ResponseDivisions-->(a)) ~= EMPTY_TEXT_PACKED)) {
                if (set_mode) {
                    print "[";
                    print (string) (ResponseDivisions-->(a));
                    print "]^";
                } else {
                    print (string) (ResponseDivisions-->(a));
                    print ":^";
                }
            }
            ShowResponsesRange((ResponseDivisions-->((a + 1))), (ResponseDivisions-->((a + 2))), set_mode);
        }
        if ((reg < 0)) {
            if (((ResponseDivisions-->(a)) ~= EMPTY_TEXT_PACKED)) {
                print "    RESPONSES ";
                print j;
                print ": ";
                print (string) (ResponseDivisions-->(a));
                print "^";
            }
        }
    }
];
[ ShowResponsesRange from to set_mode i;
    (say__p = 1);
    for ((i = from):(i <= to):(i)++) {
        switch (set_mode) {
            1:
                print "now ";
                ;
            2:
                ;
            0:
                print "    ";
                ;
        }
        PrintResponse(i);
        switch (set_mode) {
            1:
                print " is ";
                ;
            2:
                print " is ";
                ;
            0:
                print ": ";
                ;
        }
        (suppress_text_substitution = 1);
        CarryOutActivity(PRINTING_RESPONSE_ACT, i);
        (suppress_text_substitution = 0);
        switch (set_mode) {
            1:
                print ";";
                ;
            2:
                print ".";
                ;
        }
        print "^";
    }
];
[ RulesOnSub;
    (debug_rules = 1);
    (say__p = 1);
    print "Rules tracing now switched on. Type ~rules off~ to switch it off again, or ~rules all~ to include even rules which do not apply.";
    new_line;
    rtrue;
];
[ RulesAllSub;
    (debug_rules = 2);
    (say__p = 1);
    print "Rules tracing now switched to ~all~. Type ~rules off~ to switch it off again.";
    new_line;
    rtrue;
];
[ RulesOffSub;
    (debug_rules = 0);
    (say__p = 1);
    print "Rules tracing now switched off. Type ~rules~ to switch it on again.";
    new_line;
    rtrue;
];
[ ScenesOnSub;
    (debug_scenes = 1);
    ShowSceneStatus();
    (say__p = 1);
    print "(Scene monitoring now switched on. Type ~scenes off~ to switch it off again.)";
    new_line;
    rtrue;
];
[ ScenesOffSub;
    (debug_scenes = 0);
    (say__p = 1);
    print "(Scene monitoring now switched off. Type ~scenes~ to switch it on again.)";
    new_line;
    rtrue;
];
[ ScopeSub;
    (x_scope_count = 0);
    LoopOverScope(Print_ScL, noun);
    if ((x_scope_count == 0)) {
        print "Nothing is in scope.";
        new_line;
        rtrue;
    }
];
[ Print_ScL obj;
    print ++(x_scope_count);
    print ": ";
    IndefArt(obj);
    print " (";
    print obj;
    print ")";
    print "^";
    rtrue;
];
[ ShowHeapSub;
    HeapDebug();
];
[ ShowMeSub t_0 na;
    (t_0 = noun);
    if ((noun == 0)) {
        (noun = real_location);
    }
    if (ShowMeRecursively(noun, 0, (noun == real_location))) {
        if ((noun == real_location)) {
            print "* denotes things which are not in scope^";
        }
    }
    if ((t_0 ofclass K2_thing)) {
        print "location:";
        ShowRLocation(noun, 1);
        print "^";
    }
    (na = ShowMeKindDetails(0, na, t_0));
    (na = ShowMeInstanceDetails(0, na, t_0));
    (na = ShowMeKindDetails(1, na, t_0));
    (na = ShowMeInstanceDetails(1, na, t_0));
];
[ ShowRLocation obj top;
    if ((obj ofclass K1_room)) {
        rtrue;
    }
    print " ";
    if (parent(obj)) {
        if ((obj has worn)) {
            print "worn by ";
        } else {
            if ((parent(obj) has animate)) {
                print "carried by ";
            }
            if ((parent(obj) has container)) {
                print "in ";
            }
            if ((parent(obj) ofclass K1_room)) {
                print "in ";
            }
            if ((parent(obj) has supporter)) {
                print "on ";
            }
        }
        DefArt(parent(obj));
        ShowRLocation(parent(obj));
    } else {
        if ((obj.component_parent)) {
            if ((top == 0)) {
                print ", which is ";
            }
            print "part of ";
            DefArt((obj.component_parent));
            ShowRLocation((obj.component_parent));
        } else {
            print "out of play";
        }
    }
];
[ ShowMeRecursively obj depth f c i k;
    spaces (2*depth);
    if (((((f) && ((depth > 0)))) && ((TestScope(obj, player) == 0)))) {
        print "*";
        (c = 1);
    }
    PrintShortName(obj);
    if ((depth > 0)) {
        if ((obj.component_parent)) {
            print " (part of ";
            PrintShortName((obj.component_parent));
            print ")";
        }
        if ((obj has worn)) {
            print " (worn)";
        }
    }
    if ((_final_propertyexists(OBJECT_TY, obj, A_KD_Count))) {
        (k = (KindHierarchy-->(((obj.KD_Count)*2))));
        if ((((k ~= K2_thing)) || ((depth == 0)))) {
            print " - ";
            if ((k == K4_door or K5_container)) {
                if ((obj has transparent)) {
                    print "transparent ";
                }
                if ((obj has locked)) {
                    print "locked ";
                } else {
                    if ((obj has open)) {
                        print "open ";
                    } else {
                        print "closed ";
                    }
                }
            }
            I7_Kind_Name(k);
        }
    }
    print "^";
    if ((obj.component_child)) {
        (c = ((c)|(ShowMeRecursively((obj.component_child), (depth + 2), f))));
    }
    if (child(obj)) {
        (c = ((c)|(ShowMeRecursively(child(obj), (depth + 2), f))));
    }
    if ((((depth > 0)) && ((obj.component_sibling)))) {
        (c = ((c)|(ShowMeRecursively((obj.component_sibling), depth, f))));
    }
    if ((((depth > 0)) && (sibling(obj)))) {
        (c = ((c)|(ShowMeRecursively(sibling(obj), depth, f))));
    }
    return c;
];
[ AllowInShowme pr;
    if ((pr == A_workflag or A_concealed or A_mentioned)) {
        rfalse;
    }
    rtrue;
];
[ ShowVerbSub address lines meta i x;
    (wn = 2);
    (x = NextWordStopped());
    if ((((x == 0)) || (((((x->(#dict_par1)))&(1)) == 0)))) {
        print "Try typing ~showverb~ and then the name of a verb.";
        new_line;
        rtrue;
    }
    (meta = ((((x->(#dict_par1)))&(2))/2));
    (i = DictionaryWordToVerbNum(x));
    (address = VM_CommandTableAddress(i));
    (lines = (address->(0)));
    (address)++;
    print "Verb ";
    if (meta) {
        print "meta ";
    }
    VM_PrintCommandWords(i);
    print "^";
    if ((lines == 0)) {
        print "has no grammar lines.^";
    }
    for (:(lines > 0):(lines)--) {
        (address = UnpackGrammarLine(address));
        print "    ";
        DebugGrammarLine();
        print "^";
    }
    ParaContent();
];
[ DebugGrammarLine pcount;
    print " * ";
    for (:((line_token-->(pcount)) ~= ENDIT_TOKEN):(pcount)++) {
        if (((((line_token-->(pcount))->(0)))&(16))) {
            print "/ ";
        }
        DebugToken((line_token-->(pcount)));
        print " ";
    }
    print "-> ";
    DebugAction(action_to_be);
    if (action_reversed) {
        print " reverse";
    }
];
[ DebugToken token;
    AnalyseToken(token);
    switch (found_ttype) {
        ILLEGAL_TT:
            print "<illegal token number ";
            print token;
            print ">";
            ;
        ELEMENTARY_TT:
            switch (found_tdata) {
                NOUN_TOKEN:
                    print "noun";
                    ;
                HELD_TOKEN:
                    print "held";
                    ;
                MULTI_TOKEN:
                    print "multi";
                    ;
                MULTIHELD_TOKEN:
                    print "multiheld";
                    ;
                MULTIEXCEPT_TOKEN:
                    print "multiexcept";
                    ;
                MULTIINSIDE_TOKEN:
                    print "multiinside";
                    ;
                CREATURE_TOKEN:
                    print "creature";
                    ;
                SPECIAL_TOKEN:
                    print "special";
                    ;
                NUMBER_TOKEN:
                    print "number";
                    ;
                TOPIC_TOKEN:
                    print "topic";
                    ;
                ENDIT_TOKEN:
                    print "END";
                    ;
            }
            ;
        PREPOSITION_TT:
            print "'";
            print (address) found_tdata;
            print "'";
            ;
        ROUTINE_FILTER_TT:
            print "noun=Routine(";
            print found_tdata;
            print ")";
            ;
        ATTR_FILTER_TT:
            DebugAttribute(found_tdata);
            ;
        SCOPE_TT:
            print "scope=Routine(";
            print found_tdata;
            print ")";
            ;
        GPR_TT:
            print "Routine(";
            print found_tdata;
            print ")";
            ;
    }
];
[ TestStart T R l k;
    if ((test_sp >= TEST_STACK_SIZE)) {
        print ">--> Testing too many levels deep";
        new_line;
        rtrue;
    }
    ((test_stack-->(test_sp)) = T);
    ((test_stack-->((test_sp + 1))) = 0);
    ((test_stack-->((test_sp + 3))) = l);
    (test_sp = (test_sp + 4));
    if ((((R-->(0))) && (((R-->(0)) ~= real_location)))) {
        print "(first moving to ";
        PrintShortName((R-->(0)));
        print ")^";
        PlayerTo((R-->(0)), 1);
    }
    (k = 1);
    while ((R-->(k))) {
        if (((R-->(k)) notin player)) {
            print "(first acquiring ";
            DefArt((R-->(k)));
            print ")^";
            move (R-->(k)) to player;
        }
        (k)++;
    }
    print "(Testing.)^";
    (say__p = 1);
];
[ TestKeyboardPrimitive a_buffer a_table p i j l spaced ch;
    if ((test_sp == 0)) {
        ((test_stack-->(2)) = 1);
        return VM_ReadKeyboard(a_buffer, a_table);
    } else {
        (p = (test_stack-->((test_sp - 4))));
        (i = (test_stack-->((test_sp - 3))));
        (l = (test_stack-->((test_sp - 1))));
        print "[";
        print (test_stack-->(2));
        print "] ";
        ((test_stack-->(2)) = ((test_stack-->(2)) + 1));
        style bold;
        while ((((i < l)) && (((p->(i)) ~= 47)))) {
            (ch = (p->(i)));
            if (((spaced) || ((ch ~= 32)))) {
                if (((((((p->(i)) == 91)) && (((p->((i + 1))) == 47)))) && (((p->((i + 2))) == 93)))) {
                    (ch = 47);
                    (i = (i + 2));
                }
                ((a_buffer->((j + WORDSIZE))) = ch);
                print (char) ch;
                (i)++;
                (j)++;
                (spaced = 1);
            } else {
                (i)++;
            }
        }
        style roman;
        print "^";
        ((a_buffer-->(0)) = j);
        VM_Tokenise(a_buffer, a_table);
        if (((p->(i)) == 47)) {
            (i)++;
        }
        if ((i >= l)) {
            (test_sp = (test_sp - 4));
        } else {
            ((test_stack-->((test_sp - 3))) = i);
        }
    }
];
[ TraceOnSub;
    (parser_trace = 1);
    (say__p = 1);
    print "[Trace on.]";
    new_line;
    rtrue;
];
[ TraceLevelSub;
    (parser_trace = parsed_number);
    (say__p = 1);
    print "[Parser tracing set to level ";
    print parser_trace;
    print ".]^";
];
[ TraceOffSub;
    (parser_trace = 0);
    (say__p = 1);
    print "Trace off.";
    new_line;
    rtrue;
];
[ XTreeSub i;
    if ((noun == 0)) {
        objectloop (i ofclass Object && i) {
            if ((((i ofclass Object)) && ((parent(i) == 0)))) {
                XObj(i);
            }
        }
    } else {
        XObj(noun, 1);
    }
];
[ XObj obj f;
    if ((parent(obj) == 0)) {
        PrintShortName(obj);
    } else {
        IndefArt(obj);
    }
    print " (";
    print obj;
    print ") ";
    if ((((f == 1)) && ((parent(obj) ~= 0)))) {
        print "(in ";
        PrintShortName(parent(obj));
        print " ";
        print parent(obj);
        print ")";
    }
    print "^";
    if ((child(obj) == 0)) {
        rtrue;
    }
    if ((obj == Class)) {
        WriteListFrom(child(obj), (((NEWLINE_BIT + INDENT_BIT) + ALWAYS_BIT) + NOARTICLE_BIT), 1);
    } else {
        WriteListFrom(child(obj), (((NEWLINE_BIT + INDENT_BIT) + ALWAYS_BIT) + FULLINV_BIT), 1);
    }
];
[ testcommandnoun obj o2;
    switch (scope_stage) {
        1:
            rtrue;
            ;
        2:
            objectloop (obj ofclass Object && obj) {
                if ((((obj ofclass Object)) && ((_final_propertyexists(OBJECT_TY, obj, A_KD_Count))))) {
                    PlaceInScope(obj, 1);
                }
            }
            ;
        3:
            print "There seems to be no such object anywhere in the model world.^";
            ;
    }
];
[ ChronologyPoint pt;
    for ((pt = 0):(pt < NO_PAST_TENSE_CONDS):(pt)++) {
        ((past_chronological_record-->(pt)) = (present_chronological_record-->(pt)));
    }
];
[ UPDATE_CHRONOLOGICAL_RECORDS_R pt;
    for ((pt = 0):(pt < NO_PAST_TENSE_CONDS):(pt)++) {
        TestSinglePastState(0, pt, 1, (-(1)));
    }
    ChronologyPoint();
    rfalse;
];
[ TrackActions readjust oow i;
    for ((i = 0):(PastActionsI6Routines-->(i)):(i)++) {
        if (((PastActionsI6Routines-->(i)))()) {
            if (readjust) {
                continue;
            }
            ((TimesActionHasHappened-->(i)))++;
            if (((LastTurnActionHappenedOn-->(i)) ~= (turns + 5))) {
                ((LastTurnActionHappenedOn-->(i)) = (turns + 5));
                ((ActionCurrentlyHappeningFlag->(i)) = 1);
                if ((keep_silent == 0)) {
                    ((TurnsActionHasBeenHappening-->(i)))++;
                }
            }
        } else {
            if ((oow == 0)) {
                if ((keep_silent == 0)) {
                    ((TurnsActionHasBeenHappening-->(i)) = 0);
                }
                if (((LastTurnActionHappenedOn-->(i)) ~= (turns + 5))) {
                    ((ActionCurrentlyHappeningFlag->(i)) = 0);
                }
            }
        }
    }
];
[ STORED_ACTION_TY_Support task arg1 arg2 arg3;
    switch (task) {
        CREATE_KOVS:
            return STORED_ACTION_TY_Create(arg2);
            ;
        DESTROY_KOVS:
            STORED_ACTION_TY_Destroy(arg1);
            ;
        MAKEMUTABLE_KOVS:
            rtrue;
            ;
        COPYQUICK_KOVS:
            rtrue;
            ;
        COPYSB_KOVS:
            BlkValueCopySB1(arg1, arg2);
            ;
        KINDDATA_KOVS:
            rfalse;
            ;
        EXTENT_KOVS:
            return 6;
            ;
        COPY_KOVS:
            STORED_ACTION_TY_Copy(arg1, arg2);
            ;
        COMPARE_KOVS:
            return STORED_ACTION_TY_Compare(arg1, arg2);
            ;
        HASH_KOVS:
            return STORED_ACTION_TY_Hash(arg1);
            ;
        DEBUG_KOVS:
            print " = ";
            STORED_ACTION_TY_Say(arg1);
            ;
    }
    rfalse;
];
[ STORED_ACTION_TY_Create sb stora;
    (stora = FlexAllocate((6*WORDSIZE), STORED_ACTION_TY, BLK_FLAG_WORD));
    BlkValueWrite(stora, STORA_ACTION_F, ##Wait, 1);
    BlkValueWrite(stora, STORA_NOUN_F, 0, 1);
    BlkValueWrite(stora, STORA_SECOND_F, 0, 1);
    BlkValueWrite(stora, STORA_ACTOR_F, player, 1);
    BlkValueWrite(stora, STORA_REQUEST_F, 0, 1);
    BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0, 1);
    return BlkValueCreateSB1(sb, stora);
];
[ STORED_ACTION_TY_New a n s ac req stora;
    if ((stora == 0)) {
        (stora = BlkValueCreate(STORED_ACTION_TY));
    }
    BlkValueWrite(stora, STORA_ACTION_F, a);
    BlkValueWrite(stora, STORA_NOUN_F, n);
    BlkValueWrite(stora, STORA_SECOND_F, s);
    BlkValueWrite(stora, STORA_ACTOR_F, ac);
    BlkValueWrite(stora, STORA_REQUEST_F, req);
    BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0);
    return stora;
];
[ STORED_ACTION_TY_Destroy stora toc;
    (toc = BlkValueRead(stora, STORA_COMMAND_TEXT_F));
    if (toc) {
        BlkValueFree(toc);
    }
];
[ STORED_ACTION_TY_Copy storato storafrom tocfrom tocto;
    (tocfrom = BlkValueRead(storafrom, STORA_COMMAND_TEXT_F));
    if ((tocfrom == 0)) {
        rtrue;
    }
    (tocto = BlkValueCreate(TEXT_TY));
    BlkValueCopy(tocto, tocfrom);
    BlkValueWrite(storato, STORA_COMMAND_TEXT_F, tocto);
];
[ STORED_ACTION_TY_Compare storaleft storaright delta itleft itright;
    (delta = (BlkValueRead(storaleft, STORA_ACTION_F) - BlkValueRead(storaright, STORA_ACTION_F)));
    if (delta) {
        return delta;
    }
    (delta = (BlkValueRead(storaleft, STORA_NOUN_F) - BlkValueRead(storaright, STORA_NOUN_F)));
    if (delta) {
        return delta;
    }
    (delta = (BlkValueRead(storaleft, STORA_SECOND_F) - BlkValueRead(storaright, STORA_SECOND_F)));
    if (delta) {
        return delta;
    }
    (delta = (BlkValueRead(storaleft, STORA_ACTOR_F) - BlkValueRead(storaright, STORA_ACTOR_F)));
    if (delta) {
        return delta;
    }
    (delta = (BlkValueRead(storaleft, STORA_REQUEST_F) - BlkValueRead(storaright, STORA_REQUEST_F)));
    if (delta) {
        return delta;
    }
    (itleft = BlkValueRead(storaleft, STORA_COMMAND_TEXT_F));
    (itright = BlkValueRead(storaright, STORA_COMMAND_TEXT_F));
    if ((((itleft ~= 0)) && ((itright ~= 0)))) {
        return TEXT_TY_Support(COMPARE_KOVS, itleft, itright);
    }
    return (itleft - itright);
];
[ STORED_ACTION_TY_Distinguish stora1 stora2;
    if ((STORED_ACTION_TY_Compare(stora1, stora2) == 0)) {
        rfalse;
    }
    rtrue;
];
[ STORED_ACTION_TY_Hash stora rv it;
    (rv = BlkValueRead(stora, STORA_ACTION_F));
    (rv = ((rv*33) + BlkValueRead(stora, STORA_NOUN_F)));
    (rv = ((rv*33) + BlkValueRead(stora, STORA_SECOND_F)));
    (rv = ((rv*33) + BlkValueRead(stora, STORA_ACTOR_F)));
    (rv = ((rv*33) + BlkValueRead(stora, STORA_REQUEST_F)));
    (it = BlkValueRead(stora, STORA_COMMAND_TEXT_F));
    if ((it ~= 0)) {
        (rv = ((rv*33) + TEXT_TY_Support(HASH_KOVS, it)));
    }
    return rv;
];
[ STORED_ACTION_TY_Say stora text_of_command saved_command saved_pn saved_action K1 K2 at cf cw;
    if ((((stora == 0)) || ((BlkValueWeakKind(stora) ~= STORED_ACTION_TY)))) {
        rtrue;
    }
    (text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F));
    if (text_of_command) {
        (saved_command = BlkValueCreate(TEXT_TY));
        BlkValueCast(saved_command, SNIPPET_TY, players_command);
        SetPlayersCommand(text_of_command);
    }
    (saved_pn = parsed_number);
    (saved_action = action);
    (action = BlkValueRead(stora, STORA_ACTION_F));
    (cf = consult_from);
    (cw = consult_words);
    (at = FindAction(-1));
    (K1 = (ActionData-->((at + AD_NOUN_KOV))));
    (K2 = (ActionData-->((at + AD_SECOND_KOV))));
    if ((K1 ~= OBJECT_TY)) {
        (parsed_number = BlkValueRead(stora, STORA_NOUN_F));
        if ((((K1 == UNDERSTANDING_TY)) && ((text_of_command == 0)))) {
            if ((saved_command == 0)) {
                (saved_command = BlkValueCreate(TEXT_TY));
            }
            BlkValueCast(saved_command, SNIPPET_TY, players_command);
            (text_of_command = BlkValueCreate(TEXT_TY));
            BlkValueCopy(text_of_command, parsed_number);
            SetPlayersCommand(text_of_command);
            (parsed_number = players_command);
            (consult_from = (parsed_number/100));
            (consult_words = (parsed_number%100));
        }
    }
    if ((K2 ~= OBJECT_TY)) {
        (parsed_number = BlkValueRead(stora, STORA_SECOND_F));
        if ((((K2 == UNDERSTANDING_TY)) && ((text_of_command == 0)))) {
            if ((saved_command == 0)) {
                (saved_command = BlkValueCreate(TEXT_TY));
            }
            BlkValueCast(saved_command, SNIPPET_TY, players_command);
            (text_of_command = BlkValueCreate(TEXT_TY));
            BlkValueCopy(text_of_command, parsed_number);
            SetPlayersCommand(text_of_command);
            (parsed_number = players_command);
            (consult_from = (parsed_number/100));
            (consult_words = (parsed_number%100));
        }
    }
    DB_Action(BlkValueRead(stora, STORA_ACTOR_F), BlkValueRead(stora, STORA_REQUEST_F), BlkValueRead(stora, STORA_ACTION_F), BlkValueRead(stora, STORA_NOUN_F), BlkValueRead(stora, STORA_SECOND_F), 1);
    (parsed_number = saved_pn);
    (action = saved_action);
    (consult_from = cf);
    (consult_words = cw);
    if (text_of_command) {
        SetPlayersCommand(saved_command);
        BlkValueFree(saved_command);
    }
];
[ STORED_ACTION_TY_Involves stora item at;
    (at = FindAction(BlkValueRead(stora, STORA_ACTION_F)));
    if (at) {
        if (((((ActionData-->((at + AD_NOUN_KOV))) == OBJECT_TY)) && ((BlkValueRead(stora, STORA_NOUN_F) == item)))) {
            rtrue;
        }
        if (((((ActionData-->((at + AD_SECOND_KOV))) == OBJECT_TY)) && ((BlkValueRead(stora, STORA_SECOND_F) == item)))) {
            rtrue;
        }
    }
    if ((BlkValueRead(stora, STORA_ACTOR_F) == item)) {
        rtrue;
    }
    rfalse;
];
[ STORED_ACTION_TY_Part stora ind at ado;
    if ((ind == STORA_NOUN_F or STORA_SECOND_F)) {
        if ((ind == STORA_NOUN_F)) {
            (ado = AD_NOUN_KOV);
        } else {
            (ado = AD_SECOND_KOV);
        }
        (at = FindAction(BlkValueRead(stora, STORA_ACTION_F)));
        if (((at) && (((ActionData-->((at + ado))) == OBJECT_TY)))) {
            return BlkValueRead(stora, ind);
        }
        rfalse;
    }
    return BlkValueRead(stora, ind);
];
[ STORED_ACTION_TY_Adopt stora at;
    ((SAT_Tmp-->(1)) = action);
    ((SAT_Tmp-->(2)) = noun);
    ((SAT_Tmp-->(3)) = second);
    ((SAT_Tmp-->(4)) = actor);
    ((SAT_Tmp-->(5)) = act_requester);
    ((SAT_Tmp-->(6)) = parsed_number);
    (action = BlkValueRead(stora, STORA_ACTION_F));
    (at = FindAction(-1));
    if (((ActionData-->((at + AD_NOUN_KOV))) == OBJECT_TY)) {
        (noun = BlkValueRead(stora, STORA_NOUN_F));
    } else {
        (parsed_number = BlkValueRead(stora, STORA_NOUN_F));
        (noun = 0);
    }
    if (((ActionData-->((at + AD_SECOND_KOV))) == OBJECT_TY)) {
        (second = BlkValueRead(stora, STORA_SECOND_F));
    } else {
        (parsed_number = BlkValueRead(stora, STORA_SECOND_F));
        (second = 0);
    }
    (actor = BlkValueRead(stora, STORA_ACTOR_F));
    if (BlkValueRead(stora, STORA_REQUEST_F)) {
        (act_requester = player);
    } else {
        (act_requester = 0);
    }
];
[ STORED_ACTION_TY_Unadopt;
    (action = (SAT_Tmp-->(1)));
    (noun = (SAT_Tmp-->(2)));
    (second = (SAT_Tmp-->(3)));
    (actor = (SAT_Tmp-->(4)));
    (act_requester = (SAT_Tmp-->(5)));
    (parsed_number = (SAT_Tmp-->(6)));
    return (SAT_Tmp-->(0));
];
[ STORED_ACTION_TY_Current stora at text_of_command;
    if ((((stora == 0)) || ((BlkValueWeakKind(stora) ~= STORED_ACTION_TY)))) {
        rfalse;
    }
    BlkValueWrite(stora, STORA_ACTION_F, action);
    (at = FindAction(-1));
    if (((ActionData-->((at + AD_NOUN_KOV))) == OBJECT_TY)) {
        BlkValueWrite(stora, STORA_NOUN_F, noun);
    } else {
        BlkValueWrite(stora, STORA_NOUN_F, parsed_number);
    }
    if (((ActionData-->((at + AD_SECOND_KOV))) == OBJECT_TY)) {
        BlkValueWrite(stora, STORA_SECOND_F, second);
    } else {
        BlkValueWrite(stora, STORA_SECOND_F, parsed_number);
    }
    BlkValueWrite(stora, STORA_ACTOR_F, actor);
    if (act_requester) {
        BlkValueWrite(stora, STORA_REQUEST_F, 1);
    } else {
        BlkValueWrite(stora, STORA_REQUEST_F, 0);
    }
    if (((at) && (((((ActionData-->((at + AD_NOUN_KOV))) == UNDERSTANDING_TY)) || (((ActionData-->((at + AD_SECOND_KOV))) == UNDERSTANDING_TY)))))) {
        (text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F));
        if ((text_of_command == 0)) {
            (text_of_command = BlkValueCreate(TEXT_TY));
            BlkValueWrite(stora, STORA_COMMAND_TEXT_F, text_of_command);
        }
        BlkValueCast(text_of_command, SNIPPET_TY, players_command);
    } else {
        BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0);
    }
    return stora;
];
[ STORED_ACTION_TY_Try stora ks text_of_command saved_command;
    if ((((stora == 0)) || ((BlkValueWeakKind(stora) ~= STORED_ACTION_TY)))) {
        rtrue;
    }
    if (ks) {
        @push keep_silent;
        (keep_silent = 1);
    }
    (text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F));
    if (text_of_command) {
        (saved_command = BlkValueCreate(TEXT_TY));
        BlkValueCast(saved_command, SNIPPET_TY, players_command);
        SetPlayersCommand(text_of_command);
    }
    TryAction(BlkValueRead(stora, STORA_REQUEST_F), BlkValueRead(stora, STORA_ACTOR_F), BlkValueRead(stora, STORA_ACTION_F), BlkValueRead(stora, STORA_NOUN_F), BlkValueRead(stora, STORA_SECOND_F));
    if (text_of_command) {
        SetPlayersCommand(saved_command);
        BlkValueFree(saved_command);
    }
    if (ks) {
        @pull keep_silent;
    }
];
[ WordCount;
    return (parse-->(0));
];
[ WordAddress wordnum;
    return (buffer + (parse-->((wordnum*3))));
];
[ WordLength wordnum;
    return (parse-->(((wordnum*3) - 1)));
];
[ WordFrom w p i j wc;
    (wc = (p-->(0)));
    (i = ((w*3) - 2));
    if ((((w < 1)) || ((w > wc)))) {
        rfalse;
    }
    (j = (p-->(i)));
    if ((j == ',//')) {
        (j = comma_word);
    }
    if ((j == './/')) {
        (j = THEN1__WD);
    }
    return j;
];
[ NextWord i j wc;
    (wc = (parse-->(0)));
    (i = ((wn*3) - 2));
    (wn)++;
    if ((((wn < 2)) || ((wn > (wc + 1))))) {
        rfalse;
    }
    (j = (parse-->(i)));
    if ((j == ',//')) {
        (j = comma_word);
    }
    if ((j == './/')) {
        (j = THEN1__WD);
    }
    return j;
];
[ NextWordStopped wc;
    (wc = (parse-->(0)));
    if ((((wn < 1)) || ((wn > wc)))) {
        (wn)++;
        return (-(1));
    }
    return NextWord();
];
[ PrintSnippet snip from to i w1 w2;
    (w1 = (snip/100));
    (w2 = ((w1 + (snip%100)) - 1));
    if ((((((w2 < w1)) || ((w1 < 1)))) || ((w2 > WordCount())))) {
        if ((((w1 == 1)) && ((w2 == 0)))) {
            rfalse;
        }
        return RunTimeProblem(RTP_SAYINVALIDSNIPPET, w1, w2);
    }
    (from = WordAddress(w1));
    (to = ((WordAddress(w2) + WordLength(w2)) - 1));
    for ((i = from):(i <= to):(i)++) {
        print (char) (i->(0));
    }
];
[ SpliceSnippet snip t i w1 w2 nextw at endsnippet newlen saved;
    (w1 = (snip/100));
    (w2 = ((w1 + (snip%100)) - 1));
    if ((((w2 < w1)) || ((w1 < 1)))) {
        if ((((w1 == 1)) && ((w2 == 0)))) {
            rtrue;
        }
        return RunTimeProblem(RTP_SPLICEINVALIDSNIPPET, w1, w2);
    }
    @push say__p;
    @push say__pc;
    (nextw = (w2 + 1));
    (at = (WordAddress(w1) - buffer));
    if ((nextw <= WordCount())) {
        (endsnippet = ((100*nextw) + ((WordCount() - nextw) + 1)));
    }
    (saved = (buffer2-->(0)));
    ((buffer2-->(0)) = 120);
    (newlen = VM_PrintToBuffer(buffer2, 120, SpliceSnippet__TextPrinter, t, endsnippet));
    for ((i = 0):(((i < newlen)) && (((at + i) < 120))):(i)++) {
        ((buffer->((at + i))) = (buffer2->((WORDSIZE + i))));
    }
    ((buffer-->(0)) = (at + i));
    for (:((at + i) < 120):(i)++) {
        ((buffer->((at + i))) = 32);
    }
    VM_Tokenise(buffer, parse);
    (players_command = (100 + WordCount()));
    ((buffer2-->(0)) = saved);
    @pull say__pc;
    @pull say__p;
];
[ SpliceSnippet__TextPrinter t endsnippet;
    TEXT_TY_Say(t);
    if (endsnippet) {
        print " ";
        PrintSnippet(endsnippet);
    }
];
[ SnippetIncludes test snippet w1 w2 wlen i j;
    (w1 = (snippet/100));
    (w2 = ((w1 + (snippet%100)) - 1));
    if ((((w2 < w1)) || ((w1 < 1)))) {
        if ((((w1 == 1)) && ((w2 == 0)))) {
            rfalse;
        }
        return RunTimeProblem(RTP_INCLUDEINVALIDSNIPPET, w1, w2);
    }
    if ((metaclass(test) == Routine)) {
        (wlen = (snippet%100));
        for (((i = w1),(j = wlen)):(j > 0):((i)++,(j)--)) {
            if (((test)(i,0) ~= GPR_FAIL)) {
                return (((i*100) + wn) - i);
            }
        }
    }
    rfalse;
];
[ SnippetMatches snippet topic_gpr rv;
    (wn = 1);
    if ((topic_gpr == 0)) {
        rfalse;
    }
    if ((metaclass(topic_gpr) == Routine)) {
        (rv = (topic_gpr)((snippet/100),(snippet%100)));
        if ((rv ~= GPR_FAIL)) {
            rtrue;
        }
        rfalse;
    }
    RunTimeProblem(RTP_BADTOPIC);
    rfalse;
];
[ UnpackGrammarLine line_address i size;
    for ((i = 0):(i < 32):(i)++) {
        ((line_token-->(i)) = ENDIT_TOKEN);
        ((line_ttype-->(i)) = ELEMENTARY_TT);
        ((line_tdata-->(i)) = ENDIT_TOKEN);
    }
    @aloads line_address 0 action_to_be;
    (action_reversed = ((((line_address->(2)))&(1)) ~= 0));
    (line_address = (line_address - 2));
    (size = 5);
    (params_wanted = 0);
    for ((i = 0):1:(i)++) {
        (line_address = (line_address + size));
        if (((line_address->(0)) == ENDIT_TOKEN)) {
            break;
        }
        ((line_token-->(i)) = line_address);
        AnalyseToken(line_address);
        if ((found_ttype ~= PREPOSITION_TT)) {
            (params_wanted)++;
        }
        ((line_ttype-->(i)) = found_ttype);
        ((line_tdata-->(i)) = found_tdata);
    }
    return (line_address + 1);
];
[ AnalyseToken token;
    if ((token == ENDIT_TOKEN)) {
        (found_ttype = ELEMENTARY_TT);
        (found_tdata = ENDIT_TOKEN);
        rtrue;
    }
    (found_ttype = (((token->(0)))&(15)));
    (found_tdata = ((token + 1)-->(0)));
];
[ KeyboardPrimitive a_buffer a_table;
    return TestKeyboardPrimitive(a_buffer, a_table);
    return VM_ReadKeyboard(a_buffer, a_table);
];
[ Keyboard a_buffer a_table nw i w w2 x1 x2;
    (sline1 = score);
    (sline2 = turns);
    while (1) {
        for ((i = 0):(i < 64):(i)++) {
            ((oops_workspace->(i)) = (a_buffer->(i)));
        }
        PrintPrompt();
        DrawStatusLine();
        KeyboardPrimitive(a_buffer, a_table);
        (nw = (a_table-->(0)));
        if ((nw == 0)) {
            @push etype;
            (etype = BLANKLINE_PE);
            (players_command = 100);
            BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
            if ((ForActivity(PRINTING_A_PARSER_ERROR_ACT) == 0)) {
                PARSER_ERROR_INTERNAL_RM(88, noun);
                print "^";
            }
            EndActivity(PRINTING_A_PARSER_ERROR_ACT);
            @pull etype;
            continue;
        }
        (w = (a_table-->(1)));
        if ((w == OOPS1__WD or OOPS2__WD or OOPS3__WD)) {
            if ((oops_from == 0)) {
                PARSER_COMMAND_INTERNAL_RM(65);
                print "^";
                continue;
            }
            if ((nw == 1)) {
                PARSER_COMMAND_INTERNAL_RM(66);
                print "^";
                continue;
            }
            if ((nw > 2)) {
                PARSER_COMMAND_INTERNAL_RM(67);
                print "^";
                continue;
            }
            for ((i = 0):(i < INPUT_BUFFER_LEN):(i)++) {
                ((buffer2->(i)) = (a_buffer->(i)));
            }
            (x1 = (a_table-->(6)));
            (x2 = (a_table-->(5)));
            for ((i = 0):(i < 64):(i)++) {
                ((a_buffer->(i)) = (oops_workspace->(i)));
            }
            VM_Tokenise(a_buffer, a_table);
            (w = (a_table-->((3*oops_from))));
            (w2 = (a_table-->(((3*oops_from) - 1))));
            for ((i = 0):(i < w2):(i)++) {
                ((a_buffer->((i + w))) = 32);
            }
            if ((w2 < x2)) {
                for ((i = (INPUT_BUFFER_LEN - 1)):(i >= (w + x2)):(i)--) {
                    ((a_buffer->(i)) = (a_buffer->(((i - x2) + w2))));
                }
                ((a_buffer-->(0)) = ((a_buffer-->(0)) + (x2 - w2)));
            }
            for ((i = 0):(i < x2):(i)++) {
                ((a_buffer->((i + w))) = (buffer2->((i + x1))));
            }
            VM_Tokenise(a_buffer, a_table);
            (nw = (a_table-->(0)));
            return nw;
        }
        if ((((w == UNDO1__WD or UNDO2__WD or UNDO3__WD)) && ((nw == 1)))) {
            Perform_Undo();
            continue;
        }
        (i = VM_Save_Undo());
        if (((KIT_CONFIGURATION_BITMAP)&(PREVENT_UNDO_TCBIT))) {
            (undo_flag = 0);
        } else {
            (undo_flag = 2);
        }
        if ((i == -1)) {
            (undo_flag = 0);
        }
        if ((i == 0)) {
            (undo_flag = 1);
        }
        if ((i == 2)) {
            DealWithUndo();
            continue;
        }
        return nw;
    }
];
[ DealWithUndo;
    VM_RestoreWindowColours();
    VM_Style(SUBHEADER_VMSTY);
    SL_Location();
    print "^";
    VM_Style(NORMAL_VMSTY);
    IMMEDIATELY_UNDO_RM(69);
    print "^";
];
[ Parser__parse syntax line num_lines line_address i j k token l m inferred_go;
    (cobj_flag = 0);
    ((parser_results-->(ACTION_PRES)) = 0);
    ((parser_results-->(NO_INPS_PRES)) = 0);
    ((parser_results-->(INP1_PRES)) = 0);
    ((parser_results-->(INP2_PRES)) = 0);
    (meta = 0);
    if (held_back_mode) {
        (held_back_mode = 0);
        (wn = hb_wn);
        if ((verb_wordnum > 0)) {
            (i = WordAddress(verb_wordnum));
        } else {
            (i = WordAddress(1));
        }
        (j = WordAddress(wn));
        if ((i <= j)) {
            for (:(i < j):(i)++) {
                ((i->(0)) = 32);
            }
        }
        (i = NextWord());
        if ((i == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD)) {
            (i = (WordAddress((wn - 2)) - buffer));
            if ((wn > num_words)) {
                (j = (INPUT_BUFFER_LEN - 1));
            } else {
                (j = (WordAddress(wn) - buffer));
            }
            for (:(i < j):(i)++) {
                ((buffer3->(i)) = 32);
            }
        }
        VM_Tokenise(buffer, parse);
        jump ReParse;
    }
    .ReType;
    (cobj_flag = 0);
    (actors_location = ScopeCeiling(player));
    BeginActivity(READING_A_COMMAND_ACT);
    if ((ForActivity(READING_A_COMMAND_ACT) == 0)) {
        Keyboard(buffer, parse);
        (num_words = WordCount());
        (players_command = (100 + num_words));
    }
    if (EndActivity(READING_A_COMMAND_ACT)) {
        jump ReType;
    }
    .ReParse;
    (parser_inflection = A_name);
    (num_words = WordCount());
    (players_command = (100 + num_words));
    (wn = 1);
    (inferred_go = 0);
    LanguageToInformese();
    VM_Tokenise(buffer, parse);
    (num_words = WordCount());
    (players_command = (100 + num_words));
    (token_filter = 0);
    (allow_plurals = 1);
    ResetDescriptors();
    (k = 0);
    if ((parser_trace >= 2)) {
        print "[ ";
        for ((i = 0):(i < num_words):(i)++) {
            (j = (parse-->(((i*3) + 1))));
            (k = WordAddress((i + 1)));
            (l = WordLength((i + 1)));
            print "~";
            for ((m = 0):(m < l):(m)++) {
                print (char) (k->(m));
            }
            print "~ ";
            if ((j == 0)) {
                print "?";
            } else {
                if (((j->(0)) == 96)) {
                    print (address) j;
                } else {
                    print j;
                }
            }
            if ((i ~= (num_words - 1))) {
                print " / ";
            }
        }
        print " ]^";
    }
    (verb_wordnum = 1);
    (actor = player);
    (actors_location = ScopeCeiling(player));
    (usual_grammar_after = 0);
    .AlmostReParse;
    (scope_token = 0);
    (action_to_be = NULL);
    .BeginCommand;
    (wn = verb_wordnum);
    (verb_word = NextWordStopped());
    if ((verb_word == -1)) {
        (best_etype = STUCK_PE);
        jump GiveError;
    }
    if ((verb_word == comma_word)) {
        (best_etype = COMMABEGIN_PE);
        jump GiveError;
    }
    if ((verb_word == AGAIN2__WD or AGAIN3__WD)) {
        (verb_word = AGAIN1__WD);
    }
    if ((verb_word == AGAIN1__WD)) {
        if ((actor ~= player)) {
            (best_etype = ANIMAAGAIN_PE);
            jump GiveError;
        }
        if (((buffer3-->(0)) == 0)) {
            PARSER_COMMAND_INTERNAL_RM(68);
            print "^";
            jump ReType;
        }
        for ((i = 0):(i < INPUT_BUFFER_LEN):(i)++) {
            ((buffer->(i)) = (buffer3->(i)));
        }
        VM_Tokenise(buffer, parse);
        (num_words = WordCount());
        (players_command = (100 + num_words));
        jump ReParse;
    }
    if ((verb_word ~= AGAIN1__WD)) {
        for ((i = 0):(i < INPUT_BUFFER_LEN):(i)++) {
            ((buffer3->(i)) = (buffer->(i)));
        }
    }
    if ((usual_grammar_after == 0)) {
        (j = verb_wordnum);
        (i = RunRoutines(actor, A_grammar));
        if ((((parser_trace >= 2)) && (((actor.grammar) ~= 0 or NULL)))) {
            print " [Grammar property returned ";
            print i;
            print "]^";
        }
        if ((((i ~= 0 or 1)) && (VM_InvalidDictionaryAddress(i)))) {
            (usual_grammar_after = verb_wordnum);
            (i = (-(i)));
        }
        if ((i == 1)) {
            ((parser_results-->(ACTION_PRES)) = action);
            ((parser_results-->(NO_INPS_PRES)) = 0);
            ((parser_results-->(INP1_PRES)) = noun);
            ((parser_results-->(INP2_PRES)) = second);
            if (noun) {
                ((parser_results-->(NO_INPS_PRES)) = 1);
            }
            if (second) {
                ((parser_results-->(NO_INPS_PRES)) = 2);
            }
            rtrue;
        }
        if ((i ~= 0)) {
            (verb_word = i);
            (wn)--;
            (verb_wordnum)--;
        } else {
            (wn = verb_wordnum);
            (verb_word = NextWord());
        }
    } else {
        (usual_grammar_after = 0);
    }
    if ((verb_word == 0)) {
        (i = wn);
        (verb_word = LanguageIsVerb(buffer, parse, verb_wordnum));
        (wn = i);
    }
    if ((((verb_word == 0)) || (((((verb_word->(#dict_par1)))&(1)) == 0)))) {
        (wn = verb_wordnum);
        (indef_mode = 0);
        (token_filter = 0);
        (parameters = 0);
        @push actor;
        @push action;
        @push action_to_be;
        (actor = player);
        (meta = 0);
        (action = ##Go);
        (action_to_be = ##Go);
        (l = NounDomain(Compass, 0, 0));
        @pull action_to_be;
        @pull action;
        @pull actor;
        if ((l == REPARSE_CODE)) {
            jump ReParse;
        }
        if ((((l ~= 0)) && ((l ofclass K3_direction)))) {
            ((parser_results-->(ACTION_PRES)) = ##Go);
            ((parser_results-->(NO_INPS_PRES)) = 1);
            ((parser_results-->(INP1_PRES)) = l);
            (inferred_go = 1);
            jump LookForMore;
        }
    }
    if ((actor == player)) {
        for ((j = 2):(j <= num_words):(j)++) {
            (i = NextWord());
            if ((i == comma_word)) {
                jump Conversation;
            }
        }
    }
    jump NotConversation;
    .Conversation;
    (j = (wn - 1));
    (wn = 1);
    (lookahead = HELD_TOKEN);
    (scope_reason = TALKING_REASON);
    (l = NounDomain(player, actors_location, CREATURE_TOKEN));
    (scope_reason = PARSING_REASON);
    if ((l == REPARSE_CODE)) {
        jump ReParse;
    }
    if ((l == 0)) {
        if (((verb_word) && ((((verb_word->(#dict_par1)))&(1))))) {
            jump NotConversation;
        }
        (best_etype = MISSINGPERSON_PE);
        jump GiveError;
    }
    if ((((~~((l has animate)))) && ((~~((l has talkable)))))) {
        (best_etype = ANIMALISTEN_PE);
        (noun = l);
        jump GiveError;
    }
    if ((wn ~= j)) {
        if (((verb_word) && ((((verb_word->(#dict_par1)))&(1))))) {
            jump NotConversation;
        }
        (best_etype = TOTALK_PE);
        jump GiveError;
    }
    PronounNotice(l);
    (verb_wordnum = (j + 1));
    if ((l == player)) {
        (wn = verb_wordnum);
        if ((NextWordStopped() == AGAIN1__WD or AGAIN2__WD or AGAIN3__WD)) {
            (best_etype = ANIMAAGAIN_PE);
            jump GiveError;
        }
    }
    (actor = l);
    (actors_location = ScopeCeiling(l));
    if ((parser_trace >= 1)) {
        print "[Actor is ";
        DefArt(actor);
        print " in ";
        PrintShortName(actors_location);
        print "]^";
    }
    jump BeginCommand;
    .NotConversation;
    if ((((verb_word == 0)) || (((((verb_word->(#dict_par1)))&(1)) == 0)))) {
        (verb_word = UnknownVerb(verb_word));
        if ((verb_word ~= 0)) {
            jump VerbAccepted;
        }
        (best_etype = VERB_PE);
        jump GiveError;
    }
    .VerbAccepted;
    (meta = ((((verb_word->(#dict_par1)))&(2))/2));
    if ((((meta == 1)) && ((actor ~= player)))) {
        (best_etype = VERB_PE);
        (meta = 0);
        jump GiveError;
    }
    (i = DictionaryWordToVerbNum(verb_word));
    (syntax = (#grammar_table-->((i + 1))));
    (num_lines = ((syntax->(0)) - 1));
    (pronoun_word = NULL);
    (pronoun_obj = NULL);
    if ((parser_trace >= 1)) {
        print "[Parsing for the verb '";
        print (address) verb_word;
        print "' (";
        print (num_lines + 1);
        print " lines)]^";
    }
    (best_etype = STUCK_PE);
    (nextbest_etype = STUCK_PE);
    (multiflag = 0);
    (line_address = (syntax + 1));
    for ((line = 0):(line <= num_lines):(line)++) {
        (line_address = UnpackGrammarLine(line_address));
        if ((parser_trace >= 1)) {
            if ((parser_trace >= 2)) {
                print "^";
            }
            print "[line ";
            print line;
            DebugGrammarLine();
            print "]^";
        }
        (inferfrom = 0);
        (parameters = 0);
        (nsns = 0);
        (special_word = 0);
        ((multiple_object-->(0)) = 0);
        (multi_context = 0);
        (etype = STUCK_PE);
        (multi_had = 0);
        (wn = (verb_wordnum + 1));
        (advance_warning = -1);
        (indef_mode = 0);
        for (((i = 0),((m = 0),(pcount = 0))):((line_token-->(pcount)) ~= ENDIT_TOKEN):(pcount)++) {
            (scope_token = 0);
            if (((line_ttype-->(pcount)) ~= PREPOSITION_TT)) {
                (i)++;
            }
            if (((line_ttype-->(pcount)) == ELEMENTARY_TT)) {
                if (((line_tdata-->(pcount)) == MULTI_TOKEN)) {
                    (m = 1);
                }
                if (((((line_tdata-->(pcount)) == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) && ((i == 1)))) {
                    if ((parser_trace >= 2)) {
                        print " [Trying look-ahead]^";
                    }
                    (pcount)++;
                    if (((line_ttype-->(pcount)) == PREPOSITION_TT)) {
                        do {(l = NextWord());
                        } until (
                            (((wn > num_words)) || (((l) && (((((l->(#dict_par1)))&(8)) ~= 0))))))
                        ;
                        if ((wn > num_words)) {
                            if ((parser_trace >= 2)) {
                                print " [Look-ahead aborted: prepositions missing]^";
                            }
                            jump EmptyLine;
                        }
                        do {if ((PrepositionChain(l, pcount) ~= -1)) {
                            if ((((((line_token-->(pcount))->(0)))&(32)) ~= 0)) {
                                (pcount)++;
                                while (((((line_token-->(pcount)) ~= ENDIT_TOKEN)) && ((((((line_token-->(pcount))->(0)))&(16)) ~= 0)))) {
                                    (pcount)++;
                                }
                            } else {
                                (pcount)++;
                            }
                        } else {
                            do {(l = NextWord());
                            } until (
                                (((wn >= num_words)) || (((l) && (((((l->(#dict_par1)))&(8)) ~= 0))))))
                            ;
                            if (((l) && ((((l->(#dict_par1)))&(8))))) {
                                continue;
                            }
                            if ((parser_trace >= 2)) {
                                print " [Look-ahead aborted: prepositions don't match]^";
                            }
                            jump LineFailed;
                        }
                        if ((wn <= num_words)) {
                            (l = NextWord());
                        }
                        } until (
                            ((line_ttype-->(pcount)) ~= PREPOSITION_TT))
                        ;
                        .EmptyLine;
                        (wn)--;
                        if (((((line_ttype-->(pcount)) == ELEMENTARY_TT)) && (((line_tdata-->(pcount)) == NOUN_TOKEN)))) {
                            (l = Descriptors());
                            if ((l ~= 0)) {
                                (etype = l);
                            }
                            (k = (parser_results-->(INP1_PRES)));
                            @push k;
                            @push parameters;
                            (parameters = 1);
                            ((parser_results-->(INP1_PRES)) = 0);
                            (l = NounDomain(actors_location, actor, NOUN_TOKEN, 1));
                            @pull parameters;
                            @pull k;
                            ((parser_results-->(INP1_PRES)) = k);
                            if ((parser_trace >= 2)) {
                                print " [Advanced to ~noun~ token: ";
                                if ((l == REPARSE_CODE)) {
                                    print "re-parse request]^";
                                } else {
                                    if ((l == 1)) {
                                        print "but multiple found]^";
                                    }
                                    if ((l == 0)) {
                                        print "error ";
                                        print etype;
                                        print "]^";
                                    }
                                    if ((l >= 2)) {
                                        DefArt(l);
                                        print "]^";
                                    }
                                }
                            }
                            if ((l == REPARSE_CODE)) {
                                jump ReParse;
                            }
                            if ((l >= 2)) {
                                (advance_warning = l);
                            }
                        }
                    }
                    break;
                }
            }
        }
        (take_all_rule = 0);
        if (((((m) && ((params_wanted == 1)))) && ((action_to_be == ##Take)))) {
            (take_all_rule = 1);
        }
        (inferfrom = 0);
        (parameters = 0);
        (nsns = 0);
        (special_word = 0);
        ((multiple_object-->(0)) = 0);
        (etype = STUCK_PE);
        (multi_had = 1);
        (wn = (verb_wordnum + 1));
        (m = 1);
        for ((pcount = 1):1:(pcount)++) {
            if (((line_token-->((pcount - 1))) == ENDIT_TOKEN)) {
                if ((pcount >= 2)) {
                    while ((((((line_token-->((pcount - 2)))->(0)))&(16)) ~= 0)) {
                        (pcount)--;
                    }
                    AnalyseToken((line_token-->((pcount - 2))));
                    if ((found_ttype == PREPOSITION_TT)) {
                        (l = -1);
                        while (1) {
                            (m = NextWordStopped());
                            if ((m == -1)) {
                                break;
                            }
                            (l = m);
                        }
                        if ((PrepositionChain(l, (pcount - 2)) == -1)) {
                            (m = 0);
                            if ((parser_trace >= 2)) {
                                print "[line rejected for not ending with correct preposition]^";
                            }
                        } else {
                            (m = 1);
                        }
                    }
                }
                break;
            }
        }
        (wn = (verb_wordnum + 1));
        if (m) {
            for ((pcount = 1):1:(pcount)++) {
                ((pattern-->(pcount)) = PATTERN_NULL);
                (scope_token = 0);
                (token = (line_token-->((pcount - 1))));
                (lookahead = (line_token-->(pcount)));
                if ((parser_trace >= 2)) {
                    print " [line ";
                    print line;
                    print " token ";
                    print pcount;
                    print " word ";
                    print wn;
                    print " : ";
                    DebugToken(token);
                    print "]^";
                }
                if ((token ~= ENDIT_TOKEN)) {
                    (scope_reason = PARSING_REASON);
                    AnalyseToken(token);
                    (l = ParseToken(found_ttype, found_tdata, (pcount - 1), token));
                    while ((((l >= GPR_NOUN)) && ((l < -1)))) {
                        (l = ParseToken(ELEMENTARY_TT, (l + 256)));
                    }
                    (scope_reason = PARSING_REASON);
                    if ((l == GPR_PREPOSITION)) {
                        if ((((found_ttype ~= PREPOSITION_TT)) && ((((found_ttype ~= ELEMENTARY_TT)) || ((found_tdata ~= TOPIC_TOKEN)))))) {
                            (params_wanted)--;
                        }
                        (l = 1);
                    } else {
                        if ((l < 0)) {
                            (l = 0);
                        } else {
                            if ((l ~= GPR_REPARSE)) {
                                if ((l == GPR_NUMBER)) {
                                    if ((nsns == 0)) {
                                        (special_number1 = parsed_number);
                                    } else {
                                        (special_number2 = parsed_number);
                                    }
                                    (nsns)++;
                                    (l = 1);
                                }
                                if ((l == GPR_MULTIPLE)) {
                                    (l = 0);
                                }
                                ((parser_results-->((parameters + INP1_PRES))) = l);
                                (parameters)++;
                                ((pattern-->(pcount)) = l);
                                (l = 1);
                            }
                        }
                    }
                    if ((parser_trace >= 3)) {
                        print "  [token resulted in ";
                        if ((l == REPARSE_CODE)) {
                            print "re-parse request]^";
                        }
                        if ((l == 0)) {
                            print "failure with error type ";
                            print etype;
                            print "]^";
                        }
                        if ((l == 1)) {
                            print "success]^";
                        }
                    }
                    if ((l == REPARSE_CODE)) {
                        jump ReParse;
                    }
                    if ((l == 0)) {
                        break;
                    }
                } else {
                    if ((wn <= num_words)) {
                        (l = NextWord());
                        if ((l == THEN1__WD or THEN2__WD or THEN3__WD or comma_word)) {
                            (held_back_mode = 1);
                            (hb_wn = (wn - 1));
                        } else {
                            for ((m = 0):(m < 32):(m)++) {
                                ((pattern2-->(m)) = (pattern-->(m)));
                            }
                            (pcount2 = pcount);
                            (etype = UPTO_PE);
                            break;
                        }
                    }
                    if ((parameters >= 1)) {
                        if (((parser_results-->(INP1_PRES)) == 0)) {
                            (l = ReviseMulti((parser_results-->(INP2_PRES))));
                            if ((l ~= 0)) {
                                (etype = l);
                                ((parser_results-->(ACTION_PRES)) = action_to_be);
                                break;
                            }
                        }
                    }
                    if ((parameters >= 2)) {
                        if (((parser_results-->(INP2_PRES)) == 0)) {
                            (l = ReviseMulti((parser_results-->(INP1_PRES))));
                            if ((l ~= 0)) {
                                (etype = l);
                                break;
                            }
                        } else {
                            (k = (parser_results-->(INP1_PRES)));
                            (l = (parser_results-->(INP2_PRES)));
                            if (((k) && (l))) {
                                if ((((((multi_context == MULTIEXCEPT_TOKEN)) && ((k == l)))) || ((((((multi_context == MULTIINSIDE_TOKEN)) && ((k notin l)))) && ((l notin k)))))) {
                                    (best_etype = NOTHING_PE);
                                    ((parser_results-->(ACTION_PRES)) = action_to_be);
                                    jump GiveError;
                                }
                            }
                        }
                    }
                    if ((((take_all_rule == 2)) && (((parser_results-->(INP1_PRES)) == actor)))) {
                        (best_etype = NOTHING_PE);
                        jump GiveError;
                    }
                    if ((multi_had > 1)) {
                        (best_etype = TOOFEW_PE);
                        jump GiveError;
                    }
                    if ((parser_trace >= 1)) {
                        print "[Line successfully parsed]^";
                    }
                    (oops_from = 0);
                    if ((inferfrom ~= 0)) {
                        PrintInferredCommand(inferfrom);
                        ClearParagraphing(20);
                    }
                    ((parser_results-->(ACTION_PRES)) = action_to_be);
                    ((parser_results-->(NO_INPS_PRES)) = parameters);
                    if (((action_reversed) && ((parameters == 2)))) {
                        (i = (parser_results-->(INP1_PRES)));
                        ((parser_results-->(INP1_PRES)) = (parser_results-->(INP2_PRES)));
                        ((parser_results-->(INP2_PRES)) = i);
                        if ((nsns == 2)) {
                            (i = special_number1);
                            (special_number1 = special_number2);
                            (special_number2 = i);
                        }
                    }
                    if ((((parameters > 0)) && (((parser_results-->(INP1_PRES)) >= 2)))) {
                        PronounNotice((parser_results-->(INP1_PRES)));
                    }
                    if (held_back_mode) {
                        (wn = hb_wn);
                        jump LookForMore;
                    }
                    rtrue;
                }
            }
        }
        .LineFailed;
        if ((etype > best_etype)) {
            (best_etype = etype);
        }
        if ((((etype ~= ASKSCOPE_PE)) && ((etype > nextbest_etype)))) {
            (nextbest_etype = etype);
        }
        if ((((take_all_rule == 2)) && ((etype == NOTHING_PE)))) {
            break;
        }
    }
    .GiveError;
    (etype = best_etype);
    if ((actor ~= player)) {
        if ((usual_grammar_after ~= 0)) {
            (verb_wordnum = usual_grammar_after);
            jump AlmostReParse;
        }
        (m = wn);
        (wn = 1);
        while ((((wn <= num_words)) && ((NextWord() ~= comma_word)))) {
        }
        ((parser_results-->(ACTION_PRES)) = ##Answer);
        ((parser_results-->(NO_INPS_PRES)) = 2);
        ((parser_results-->(INP1_PRES)) = actor);
        ((parser_results-->(INP2_PRES)) = 1);
        (special_number1 = special_word);
        (actor = player);
        (consult_from = wn);
        (consult_words = ((num_words - consult_from) + 1));
        (wn = m);
        rtrue;
    }
    if ((((etype ofclass Routine)) || ((etype ofclass String)))) {
        if ((ParserError(etype) ~= 0)) {
            jump ReType;
        }
    } else {
        if ((((verb_wordnum == 0)) && ((etype == CANTSEE_PE)))) {
            (etype = VERB_PE);
        }
        (players_command = (100 + WordCount()));
        BeginActivity(PRINTING_A_PARSER_ERROR_ACT);
        if (ForActivity(PRINTING_A_PARSER_ERROR_ACT)) {
            jump SkipParserError;
        }
    }
    (pronoun_word = pronoun__word);
    (pronoun_obj = pronoun__obj);
    if ((etype == STUCK_PE)) {
        PARSER_ERROR_INTERNAL_RM(65);
        print "^";
        (oops_from = 1);
    }
    if ((etype == UPTO_PE)) {
        for ((m = 0):(m < 32):(m)++) {
            ((pattern-->(m)) = (pattern2-->(m)));
        }
        (pcount = pcount2);
        if (inferred_go) {
            PARSER_ERROR_INTERNAL_RM(67);
            PrintShortName((parser_results-->(INP1_PRES)));
        } else {
            PARSER_ERROR_INTERNAL_RM(66);
            PrintCommand(0);
        }
        print ".^";
    }
    if ((etype == NUMBER_PE)) {
        PARSER_ERROR_INTERNAL_RM(68);
        print "^";
    }
    if ((etype == CANTSEE_PE)) {
        PARSER_ERROR_INTERNAL_RM(69);
        print "^";
        (oops_from = saved_oops);
    }
    if ((etype == TOOLIT_PE)) {
        PARSER_ERROR_INTERNAL_RM(70);
        print "^";
    }
    if ((etype == NOTHELD_PE)) {
        PARSER_ERROR_INTERNAL_RM(71);
        print "^";
        (oops_from = saved_oops);
    }
    if ((etype == MULTI_PE)) {
        PARSER_ERROR_INTERNAL_RM(72);
        print "^";
    }
    if ((etype == MMULTI_PE)) {
        PARSER_ERROR_INTERNAL_RM(73);
        print "^";
    }
    if ((etype == VAGUE_PE)) {
        PARSER_ERROR_INTERNAL_RM(74);
        print "^";
    }
    if ((etype == ITGONE_PE)) {
        if ((pronoun_obj == NULL)) {
            PARSER_ERROR_INTERNAL_RM(74);
            print "^";
        } else {
            PARSER_ERROR_INTERNAL_RM(75, noun);
            print "^";
        }
    }
    if ((etype == EXCEPT_PE)) {
        PARSER_ERROR_INTERNAL_RM(76);
        print "^";
    }
    if ((etype == ANIMA_PE)) {
        PARSER_ERROR_INTERNAL_RM(77);
        print "^";
    }
    if ((etype == VERB_PE)) {
        PARSER_ERROR_INTERNAL_RM(78);
        print "^";
    }
    if ((etype == SCENERY_PE)) {
        PARSER_ERROR_INTERNAL_RM(79);
        print "^";
    }
    if ((etype == JUNKAFTER_PE)) {
        PARSER_ERROR_INTERNAL_RM(80);
        print "^";
    }
    if ((etype == TOOFEW_PE)) {
        PARSER_ERROR_INTERNAL_RM(81, multi_had);
        print "^";
    }
    if ((etype == NOTHING_PE)) {
        if (((((parser_results-->(ACTION_PRES)) == ##Remove)) && (((parser_results-->(INP2_PRES)) ofclass Object)))) {
            (noun = (parser_results-->(INP2_PRES)));
            if ((noun has animate)) {
                PARSER_N_ERROR_INTERNAL_RM(67, noun);
                print "^";
            } else {
                if ((~~(((or_tmp_var = noun) && (((or_tmp_var has container)) || ((or_tmp_var has supporter))))))) {
                    PARSER_N_ERROR_INTERNAL_RM(68, noun);
                    print "^";
                } else {
                    if ((((noun has container)) && ((~~((noun has open)))))) {
                        PARSER_N_ERROR_INTERNAL_RM(69, noun);
                        print "^";
                    } else {
                        if ((children(noun) == 0)) {
                            PARSER_N_ERROR_INTERNAL_RM(70, noun);
                            print "^";
                        } else {
                            ((parser_results-->(ACTION_PRES)) = 0);
                        }
                    }
                }
            }
        }
        if (((parser_results-->(ACTION_PRES)) ~= ##Remove)) {
            if ((multi_wanted == 100)) {
                PARSER_N_ERROR_INTERNAL_RM(65);
                print "^";
            } else {
                PARSER_N_ERROR_INTERNAL_RM(66);
                print "^";
            }
        }
    }
    if ((etype == NOTINCONTEXT_PE)) {
        PARSER_ERROR_INTERNAL_RM(82);
        print "^";
    }
    if ((etype == ANIMAAGAIN_PE)) {
        PARSER_ERROR_INTERNAL_RM(83);
        print "^";
    }
    if ((etype == COMMABEGIN_PE)) {
        PARSER_ERROR_INTERNAL_RM(84);
        print "^";
    }
    if ((etype == MISSINGPERSON_PE)) {
        PARSER_ERROR_INTERNAL_RM(85);
        print "^";
    }
    if ((etype == ANIMALISTEN_PE)) {
        PARSER_ERROR_INTERNAL_RM(86, noun);
        print "^";
    }
    if ((etype == TOTALK_PE)) {
        PARSER_ERROR_INTERNAL_RM(87);
        print "^";
    }
    if ((etype == ASKSCOPE_PE)) {
        (scope_stage = 3);
        if (((scope_error)() == -1)) {
            (best_etype = nextbest_etype);
            if ((~~((((etype ofclass Routine)) || ((etype ofclass String)))))) {
                EndActivity(PRINTING_A_PARSER_ERROR_ACT);
            }
            jump GiveError;
        }
    }
    .SkipParserError;
    if ((((etype ofclass Routine)) || ((etype ofclass String)))) {
        jump ReType;
    }
    (say__p = 1);
    EndActivity(PRINTING_A_PARSER_ERROR_ACT);
    jump ReType;
    .LookForMore;
    if ((wn > num_words)) {
        rtrue;
    }
    (i = NextWord());
    if ((i == THEN1__WD or THEN2__WD or THEN3__WD or comma_word)) {
        if ((wn > num_words)) {
            (held_back_mode = 0);
            rtrue;
        }
        (hb_wn = wn);
        (held_back_mode = 1);
        rtrue;
    }
    (best_etype = UPTO_PE);
    jump GiveError;
];
[ PARSER_ERROR_INTERNAL_R;
];
[ PARSER_N_ERROR_INTERNAL_R;
];
[ PARSER_COMMAND_INTERNAL_R;
];
[ ParseTokenStopped x y;
    if ((wn > WordCount())) {
        return GPR_FAIL;
    }
    return ParseToken(x, y);
];
[ ParseToken given_ttype given_tdata token_n token i t rv;
    if ((parsetoken_nesting > 0)) {
        @push match_from;
        @push token_filter;
        @push match_length;
        @push number_of_classes;
        @push oops_from;
        for ((i = 0):(i < number_matched):(i)++) {
            (t = (match_list-->(i)));
            @push t;
            (t = (match_classes-->(i)));
            @push t;
            (t = (match_scores-->(i)));
            @push t;
        }
        @push number_matched;
    }
    (parsetoken_nesting)++;
    (rv = ParseToken__(given_ttype, given_tdata, token_n, token));
    (parsetoken_nesting)--;
    if ((parsetoken_nesting > 0)) {
        @pull number_matched;
        for ((i = (number_matched - 1)):(i >= 0):(i)--) {
            @pull t;
            ((match_scores-->(i)) = t);
            @pull t;
            ((match_classes-->(i)) = t);
            @pull t;
            ((match_list-->(i)) = t);
        }
        @pull oops_from;
        @pull number_of_classes;
        @pull match_length;
        @pull token_filter;
        @pull match_from;
    }
    return rv;
];
[ ParseToken__ given_ttype given_tdata token_n token l o i j k and_parity single_object desc_wn many_flag token_allows_multiple prev_indef_wanted;
    (token_filter = 0);
    (parser_inflection = A_name);
    switch (given_ttype) {
        ELEMENTARY_TT:
            switch (given_tdata) {
                SPECIAL_TOKEN:
                    (l = TryNumber(wn));
                    (special_word = NextWord());
                    if ((l ~= -1000)) {
                        if ((parser_trace >= 3)) {
                            print "  [Read special as the number ";
                            print l;
                            print "]^";
                        }
                    }
                    if ((l == -1000)) {
                        if ((parser_trace >= 3)) {
                            print "  [Read special word at word number ";
                            print wn;
                            print "]^";
                        }
                        (l = special_word);
                    }
                    (parsed_number = l);
                    return GPR_NUMBER;
                    ;
                NUMBER_TOKEN:
                    (l = TryNumber((wn)++));
                    if ((l == -1000)) {
                        (etype = NUMBER_PE);
                        return GPR_FAIL;
                    }
                    if ((parser_trace >= 3)) {
                        print "  [Read number as ";
                        print l;
                        print "]^";
                    }
                    (parsed_number = l);
                    return GPR_NUMBER;
                    ;
                CREATURE_TOKEN:
                    if ((action_to_be == ##Answer or ##Ask or ##AskFor or ##Tell)) {
                        (scope_reason = TALKING_REASON);
                    }
                    ;
                TOPIC_TOKEN:
                    (consult_from = wn);
                    if (((((line_ttype-->((token_n + 1))) ~= PREPOSITION_TT)) && (((line_token-->((token_n + 1))) ~= ENDIT_TOKEN)))) {
                        RunTimeProblem(RTP_TEXTTOKENTOOHARD);
                        return GPR_PREPOSITION;
                    }
                    do {(o = NextWordStopped());
                    } until (
                        (((o == -1)) || ((PrepositionChain(o, (token_n + 1)) ~= -1))))
                    ;
                    (wn)--;
                    (consult_words = (wn - consult_from));
                    if ((consult_words == 0)) {
                        return GPR_FAIL;
                    }
                    if ((action_to_be == ##Ask or ##Answer or ##Tell)) {
                        (o = wn);
                        (wn = consult_from);
                        (parsed_number = NextWord());
                        (wn = o);
                        rtrue;
                    }
                    if ((((o == -1)) && (((line_ttype-->((token_n + 1))) == PREPOSITION_TT)))) {
                        return GPR_FAIL;
                    }
                    return GPR_PREPOSITION;
                    ;
            }
            ;
        PREPOSITION_TT:
            if ((parser_trace >= 5)) {
                print "  [Preposition token]^";
            }
            if ((((token->(0)))&(16))) {
                return GPR_PREPOSITION;
            }
            if ((wn > num_words)) {
                if ((((inferfrom == 0)) && ((parameters < params_wanted)))) {
                    (inferfrom = pcount);
                    (inferword = token);
                    ((pattern-->(pcount)) = (REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata)));
                }
                if ((inferfrom == 0)) {
                    return (-(1));
                }
                ((pattern-->(pcount)) = (REPARSE_CODE + VM_DictionaryAddressToNumber(given_tdata)));
                return GPR_PREPOSITION;
            }
            (o = NextWord());
            ((pattern-->(pcount)) = (REPARSE_CODE + VM_DictionaryAddressToNumber(o)));
            if ((o == given_tdata)) {
                return GPR_PREPOSITION;
            }
            if ((PrepositionChain(o, token_n) ~= -1)) {
                return GPR_PREPOSITION;
            }
            return (-(1));
            ;
        GPR_TT:
            (l = (given_tdata)());
            if ((parser_trace >= 3)) {
                print "  [Outside parsing routine returned ";
                print l;
                print "]^";
            }
            return l;
            ;
        SCOPE_TT:
            (scope_token = given_tdata);
            (scope_stage = 1);
            if ((parser_trace >= 3)) {
                print "  [Scope routine called at stage 1]^";
            }
            (l = (scope_token)());
            if ((parser_trace >= 3)) {
                print "  [Scope routine returned multiple-flag of ";
                print l;
                print "]^";
            }
            if ((l == 1)) {
                (given_tdata = MULTI_TOKEN);
            } else {
                (given_tdata = NOUN_TOKEN);
            }
            ;
        ATTR_FILTER_TT:
            (token_filter = (1 + given_tdata));
            (given_tdata = NOUN_TOKEN);
            ;
        ROUTINE_FILTER_TT:
            (token_filter = given_tdata);
            (given_tdata = NOUN_TOKEN);
            ;
    }
    (token = given_tdata);
    (token_allows_multiple = 0);
    if ((token == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
        (token_allows_multiple = 1);
    }
    (many_flag = 0);
    (and_parity = 1);
    (dont_infer = 0);
    (dont_infer_pronoun = 0);
    .ObjectList;
    if ((parser_trace >= 3)) {
        print "  [Object list from word ";
        print wn;
        print "]^";
    }
    (o = NextWord());
    (wn)--;
    (pronoun_word = NULL);
    (pronoun_obj = NULL);
    (l = PronounValue(o));
    if ((l ~= 0)) {
        (pronoun_word = o);
        (pronoun_obj = l);
        if ((l == NULL)) {
            for ((l = 1):(l <= (LanguageDescriptors-->(0))):(l = (l + 4))) {
                if ((o == (LanguageDescriptors-->(l)))) {
                    jump AssumeDescriptor;
                }
            }
            (pronoun__word = pronoun_word);
            (pronoun__obj = pronoun_obj);
            (etype = VAGUE_PE);
            if ((parser_trace >= 3)) {
                print "  [Stop: unset pronoun]^";
            }
            return GPR_FAIL;
        }
    }
    .AssumeDescriptor;
    if ((o == ME1__WD or ME2__WD or ME3__WD)) {
        (pronoun_word = o);
        (pronoun_obj = player);
    }
    (allow_plurals = 1);
    (desc_wn = wn);
    .TryAgain;
    (l = Descriptors(token_allows_multiple));
    if ((l ~= 0)) {
        (etype = l);
        rfalse;
    }
    .TryAgain2;
    (oops_from = wn);
    if ((token ~= HELD_TOKEN)) {
        (i = (multiple_object-->(0)));
        if ((parser_trace >= 3)) {
            print "  [Calling NounDomain on location and actor]^";
        }
        (l = NounDomain(actors_location, actor, token));
        if ((l == REPARSE_CODE)) {
            return l;
        }
        if ((((((indef_wanted == INDEF_ALL_WANTED)) && ((l == 0)))) && ((number_matched == 0)))) {
            (l = 1);
        }
        if (((token_allows_multiple) && ((~~(multiflag))))) {
            if ((best_etype == MULTI_PE)) {
                (best_etype = STUCK_PE);
            }
            (multiflag = 1);
        }
        if ((l == 0)) {
            if (indef_possambig) {
                ResetDescriptors();
                (wn = desc_wn);
                jump TryAgain2;
            }
            if ((((etype == MULTI_PE)) && (multiflag))) {
                (etype = STUCK_PE);
            }
            (etype = CantSee());
            jump FailToken;
        }
        if ((parser_trace >= 3)) {
            if ((l > 1)) {
                print "  [ND returned ";
                DefArt(l);
                print "]^";
            } else {
                print "  [ND appended to the multiple object list:^";
                (k = (multiple_object-->(0)));
                for ((j = (i + 1)):(j <= k):(j)++) {
                    print "  Entry ";
                    print j;
                    print ": ";
                    CDefArt((multiple_object-->(j)));
                    print " (";
                    print (multiple_object-->(j));
                    print ")^";
                }
                print "  List now has size ";
                print k;
                print "]^";
            }
        }
        if ((l == 1)) {
            if ((~~(many_flag))) {
                (many_flag = 1);
            } else {
                (k = (multiple_object-->(0)));
                ((multiple_object-->(0)) = i);
                for ((j = (i + 1)):(j <= k):(j)++) {
                    if (and_parity) {
                        MultiAdd((multiple_object-->(j)));
                    } else {
                        MultiSub((multiple_object-->(j)));
                    }
                }
                if ((parser_trace >= 3)) {
                    print "  [Merging ";
                    print (k - i);
                    print " new objects to the ";
                    print i;
                    print " old ones]^";
                }
            }
        } else {
            if ((((match_length == 0)) && (indef_possambig))) {
                ResetDescriptors();
                (wn = desc_wn);
                jump TryAgain2;
            }
            if ((((token == CREATURE_TOKEN)) && ((CreatureTest(l) == 0)))) {
                (etype = ANIMA_PE);
                jump FailToken;
            }
            if ((~~(many_flag))) {
                (single_object = l);
            } else {
                if (and_parity) {
                    MultiAdd(l);
                } else {
                    MultiSub(l);
                }
                if ((parser_trace >= 3)) {
                    print "  [Combining ";
                    DefArt(l);
                    print " with list]^";
                }
            }
        }
    } else {
        (l = NounDomain(actor, actors_location, token));
        if ((l == REPARSE_CODE)) {
            return l;
        }
        if ((l == 0)) {
            if (indef_possambig) {
                ResetDescriptors();
                (wn = desc_wn);
                jump TryAgain2;
            }
            (etype = CantSee());
            jump FailToken;
        }
        (o = parent(l));
        if ((o ~= actor)) {
            if ((parser_trace >= 3)) {
                print "  [Allowing object ";
                DefArt(l);
                print " for now]^";
            }
        }
        (single_object = l);
    }
    (wn = (match_from + match_length));
    (o = NextWord());
    if ((o == AND1__WD or AND2__WD or AND3__WD or BUT1__WD or BUT2__WD or BUT3__WD or comma_word)) {
        if ((parser_trace >= 3)) {
            print "  [Read connective '";
            print (address) o;
            print "']^";
        }
        if ((~~(token_allows_multiple))) {
            if (multiflag) {
                jump PassToken;
            }
            (etype = MULTI_PE);
            jump FailToken;
        }
        if ((o == BUT1__WD or BUT2__WD or BUT3__WD)) {
            (and_parity = (1 - and_parity));
        }
        if ((~~(many_flag))) {
            ((multiple_object-->(0)) = 1);
            ((multiple_object-->(1)) = single_object);
            (many_flag = 1);
            if ((parser_trace >= 3)) {
                print "  [Making new list from ";
                DefArt(single_object);
                print "]^";
            }
        }
        (dont_infer = 1);
        (dont_infer_pronoun = 0);
        (inferfrom = 0);
        jump ObjectList;
    }
    (wn)--;
    .PassToken;
    if (many_flag) {
        (single_object = GPR_MULTIPLE);
        (multi_context = token);
    } else {
        if ((((indef_mode == 1)) && ((((indef_type)&(PLURAL_BIT)) ~= 0)))) {
            if ((token == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
                (multi_context = token);
            }
            if ((((indef_wanted < INDEF_ALL_WANTED)) && ((indef_wanted > 1)))) {
                (multi_had = 1);
                (multi_wanted = indef_wanted);
                if ((parser_trace >= 4)) {
                    print "Too few found at letter F^";
                }
                jump FailToken;
            }
        }
    }
    return single_object;
    .FailToken;
    if (((allow_plurals) && ((indef_guess_p == 1)))) {
        if ((parser_trace >= 4)) {
            print "   [Retrying singulars after failure ";
            print etype;
            print "]^";
        }
        (prev_indef_wanted = indef_wanted);
        (allow_plurals = 0);
        (wn = desc_wn);
        jump TryAgain;
    }
    if ((((((indef_wanted > 0)) || ((prev_indef_wanted > 0)))) && ((~~(multiflag))))) {
        (etype = MULTI_PE);
    }
    return GPR_FAIL;
];
[ ResetDescriptors;
    (indef_mode = 0);
    (indef_type = 0);
    (indef_wanted = 0);
    (indef_guess_p = 0);
    (indef_possambig = 0);
    (indef_owner = 0);
    (indef_cases = 4095);
    (indef_nspec_at = 0);
];
[ ArticleDescriptors o x flag cto type n;
    if ((wn > num_words)) {
        rfalse;
    }
    for ((flag = 1):flag:) {
        (o = NextWordStopped());
        (flag = 0);
        for ((x = 1):(x <= (LanguageDescriptors-->(0))):(x = (x + 4))) {
            if ((o == (LanguageDescriptors-->(x)))) {
                (type = (LanguageDescriptors-->((x + 2))));
                if ((type == DEFART_PK or INDEFART_PK)) {
                    (flag = 1);
                }
            }
        }
    }
    (wn)--;
    rfalse;
];
[ Descriptors o x flag cto type n;
    ResetDescriptors();
    if ((wn > num_words)) {
        rfalse;
    }
    for ((flag = 1):flag:) {
        (o = NextWordStopped());
        (flag = 0);
        for ((x = 1):(x <= (LanguageDescriptors-->(0))):(x = (x + 4))) {
            if ((o == (LanguageDescriptors-->(x)))) {
                (flag = 1);
                (type = (LanguageDescriptors-->((x + 2))));
                if ((type ~= DEFART_PK)) {
                    (indef_mode = 1);
                }
                (indef_possambig = 1);
                (indef_cases = ((indef_cases)&((LanguageDescriptors-->((x + 1))))));
                if ((type == POSSESS_PK)) {
                    (cto = (LanguageDescriptors-->((x + 3))));
                    switch (cto) {
                        0:
                            (indef_type = ((indef_type)|(MY_BIT)));
                            ;
                        1:
                            (indef_type = ((indef_type)|(THAT_BIT)));
                            ;
                        default:
                            (indef_owner = PronounValue(cto));
                            if ((indef_owner == NULL)) {
                                (indef_owner = 0);
                            }
                            ;
                    }
                }
                if ((type == LIGHTED_PK)) {
                    (indef_type = ((indef_type)|(LIT_BIT)));
                }
                if ((type == UNLIGHTED_PK)) {
                    (indef_type = ((indef_type)|(UNLIT_BIT)));
                }
            }
        }
        if ((o == OTHER1__WD or OTHER2__WD or OTHER3__WD)) {
            (indef_mode = 1);
            (flag = 1);
            (indef_type = ((indef_type)|(OTHER_BIT)));
        }
        if ((o == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD)) {
            (indef_mode = 1);
            (flag = 1);
            (indef_wanted = INDEF_ALL_WANTED);
            if ((take_all_rule == 1)) {
                (take_all_rule = 2);
            }
            (indef_type = ((indef_type)|(PLURAL_BIT)));
        }
        if (allow_plurals) {
            if ((NextWordStopped() ~= -1 or THEN1__WD)) {
                (wn)--;
                (n = TryNumber((wn - 1)));
            } else {
                (n = 0);
                (wn)--;
            }
            if ((n == 1)) {
                (indef_mode = 1);
                (flag = 1);
            }
            if ((n > 1)) {
                (indef_guess_p = 1);
                (indef_mode = 1);
                (flag = 1);
                (indef_wanted = n);
                (indef_nspec_at = (wn - 1));
                (indef_type = ((indef_type)|(PLURAL_BIT)));
            }
        }
        if ((((flag == 1)) && ((NextWordStopped() ~= OF1__WD or OF2__WD or OF3__WD or OF4__WD)))) {
            (wn)--;
        }
    }
    (wn)--;
    rfalse;
];
[ SafeSkipDescriptors;
    @push indef_mode;
    @push indef_type;
    @push indef_wanted;
    @push indef_guess_p;
    @push indef_possambig;
    @push indef_owner;
    @push indef_cases;
    @push indef_nspec_at;
    Descriptors();
    @pull indef_nspec_at;
    @pull indef_cases;
    @pull indef_owner;
    @pull indef_possambig;
    @pull indef_guess_p;
    @pull indef_wanted;
    @pull indef_type;
    @pull indef_mode;
];
[ PrepositionChain wd index;
    if (((line_tdata-->(index)) == wd)) {
        return wd;
    }
    if ((((((line_token-->(index))->(0)))&(32)) == 0)) {
        return (-(1));
    }
    do {if (((line_tdata-->(index)) == wd)) {
        return wd;
    }
    (index)++;
    } until (
        ((((line_token-->(index)) == ENDIT_TOKEN)) || ((((((line_token-->(index))->(0)))&(16)) == 0))))
    ;
    return (-(1));
];
[ CreatureTest obj;
    if ((obj has animate)) {
        rtrue;
    }
    if ((~~((obj has talkable)))) {
        rfalse;
    }
    if ((action_to_be == ##Ask or ##Answer or ##Tell or ##AskFor)) {
        rtrue;
    }
    rfalse;
];
[ NounDomain domain1 domain2 context dont_ask first_word i j k l answer_words marker;
    if ((parser_trace >= 4)) {
        print "   [NounDomain called at word ";
        print wn;
        print " (domain1 ";
        PrintShortName(domain1);
        print ", domain2 ";
        PrintShortName(domain2);
        print ")^";
        print "   ";
        if (indef_mode) {
            print "seeking indefinite object: ";
            if (((indef_type)&(OTHER_BIT))) {
                print "other ";
            }
            if (((indef_type)&(MY_BIT))) {
                print "my ";
            }
            if (((indef_type)&(THAT_BIT))) {
                print "that ";
            }
            if (((indef_type)&(PLURAL_BIT))) {
                print "plural ";
            }
            if (((indef_type)&(LIT_BIT))) {
                print "lit ";
            }
            if (((indef_type)&(UNLIT_BIT))) {
                print "unlit ";
            }
            if ((indef_owner ~= 0)) {
                print "owner:";
                PrintShortName(indef_owner);
            }
            print "^";
            print "   number wanted: ";
            if ((indef_wanted == INDEF_ALL_WANTED)) {
                print "all";
            } else {
                print indef_wanted;
            }
            print "^";
            print "   most likely GNAs of names: ";
            print indef_cases;
            print "^";
        } else {
            print "seeking definite object^";
        }
    }
    (match_length = 0);
    (number_matched = 0);
    (match_from = wn);
    SearchScope(domain1, domain2, context);
    if ((parser_trace >= 4)) {
        print "   [ND made ";
        print number_matched;
        print " matches]^";
    }
    (wn = (match_from + match_length));
    if ((number_matched == 0)) {
        (wn)++;
        rfalse;
    }
    if ((match_from <= num_words)) {
        if ((number_matched == 1)) {
            (i = (match_list-->(0)));
            return i;
        }
        if ((wn <= num_words)) {
            (i = NextWord());
            (wn)--;
            if ((i ~= AND1__WD or AND2__WD or AND3__WD or comma_word or THEN1__WD or THEN2__WD or THEN3__WD or BUT1__WD or BUT2__WD or BUT3__WD)) {
                if ((lookahead == ENDIT_TOKEN)) {
                    rfalse;
                }
            }
        }
    }
    (number_of_classes = 0);
    if ((number_matched == 1)) {
        (i = (match_list-->(0)));
        if ((((indef_mode == 1)) && ((((indef_type)&(PLURAL_BIT)) ~= 0)))) {
            if ((context == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN or NOUN_TOKEN or HELD_TOKEN or CREATURE_TOKEN)) {
                BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, i);
                if (((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, i)) && (RulebookFailed()))) {
                    rfalse;
                }
                EndActivity(DECIDING_WHETHER_ALL_INC_ACT, i);
            }
        }
    }
    if ((number_matched > 1)) {
        (i = 1);
        if ((number_matched > 1)) {
            for ((j = 0):(j < (number_matched - 1)):(j)++) {
                if ((Identical((match_list-->(j)), (match_list-->((j + 1)))) == 0)) {
                    (i = 0);
                }
            }
        }
        if (i) {
            (dont_infer = 1);
        }
        (i = Adjudicate(context));
        if ((i == -1)) {
            rfalse;
        }
        if ((i == 1)) {
            rtrue;
        }
        (dont_infer_pronoun = 1);
    }
    if ((i ~= 0)) {
        if (dont_infer) {
            return i;
        }
        if ((inferfrom == 0)) {
            (inferfrom = pcount);
        }
        ((pattern-->(pcount)) = i);
        return i;
    }
    if (dont_ask) {
        return (match_list-->(0));
    }
    if ((match_from > num_words)) {
        jump Incomplete;
    }
    BeginActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);
    if (ForActivity(ASKING_WHICH_DO_YOU_MEAN_ACT)) {
        jump SkipWhichQuestion;
    }
    (j = 1);
    (marker = 0);
    for ((i = 1):(i <= number_of_classes):(i)++) {
        while (((((match_classes-->(marker)) ~= i)) && (((match_classes-->(marker)) ~= (-(i)))))) {
            (marker)++;
        }
        if ((~~(((match_list-->(marker)) has animate)))) {
            (j = 0);
        }
    }
    if (j) {
        PARSER_CLARIF_INTERNAL_RM(65);
    } else {
        PARSER_CLARIF_INTERNAL_RM(66);
    }
    (j = number_of_classes);
    (marker = 0);
    for ((i = 1):(i <= number_of_classes):(i)++) {
        while (((((match_classes-->(marker)) ~= i)) && (((match_classes-->(marker)) ~= (-(i)))))) {
            (marker)++;
        }
        (k = (match_list-->(marker)));
        if (((match_classes-->(marker)) > 0)) {
            DefArt(k);
        } else {
            IndefArt(k);
        }
        if ((i < (j - 1))) {
            print ", ";
        }
        if ((i == (j - 1))) {
            if (((KIT_CONFIGURATION_BITMAP)&(SERIAL_COMMA_TCBIT))) {
                if ((j ~= 2)) {
                    print ",";
                }
            }
            PARSER_CLARIF_INTERNAL_RM(72);
        }
    }
    print "?^";
    .SkipWhichQuestion;
    EndActivity(ASKING_WHICH_DO_YOU_MEAN_ACT);
    .WhichOne;
    (answer_words = Keyboard(buffer2, parse2));
    (first_word = (parse2-->(1)));
    if ((first_word == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD)) {
        if ((context == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
            (l = (multiple_object-->(0)));
            for ((i = 0):(((i < number_matched)) && (((l + i) < MATCH_LIST_WORDS))):(i)++) {
                (k = (match_list-->(i)));
                ((multiple_object-->(((i + 1) + l))) = k);
            }
            ((multiple_object-->(0)) = (i + l));
            rtrue;
        }
        PARSER_CLARIF_INTERNAL_RM(67);
        jump WhichOne;
    }
    for ((i = 1):(i <= answer_words):(i)++) {
        if ((WordFrom(i, parse2) == comma_word)) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }
    if ((first_word == 0)) {
        (j = wn);
        (first_word = LanguageIsVerb(buffer2, parse2, 1));
        (wn = j);
    }
    if ((first_word ~= 0)) {
        (j = (first_word->(#dict_par1)));
        if ((((0 ~= ((j)&(1)))) && ((~~(LanguageVerbMayBeName(first_word)))))) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }
    (k = (WordAddress(match_from) - buffer));
    (l = ((buffer2-->(0)) + 1));
    for ((j = ((buffer + INPUT_BUFFER_LEN) - 1)):(j >= ((buffer + k) + l)):(j)--) {
        ((j->(0)) = (j->((-(l)))));
    }
    for ((i = 0):(i < l):(i)++) {
        ((buffer->((k + i))) = (buffer2->((WORDSIZE + i))));
    }
    ((buffer->(((k + l) - 1))) = 32);
    ((buffer-->(0)) = ((buffer-->(0)) + l));
    if (((buffer-->(0)) > (INPUT_BUFFER_LEN - WORDSIZE))) {
        ((buffer-->(0)) = (INPUT_BUFFER_LEN - WORDSIZE));
    }
    .RECONSTRUCT_INPUT;
    (num_words = WordCount());
    (players_command = (100 + num_words));
    (wn = 1);
    (num_words = WordCount());
    (players_command = (100 + num_words));
    (actors_location = ScopeCeiling(player));
    FollowRulebook((Activity_after_rulebooks-->(READING_A_COMMAND_ACT)));
    return REPARSE_CODE;
    .Incomplete;
    if ((context == CREATURE_TOKEN)) {
        PARSER_CLARIF_INTERNAL_RM(68, actor);
    } else {
        PARSER_CLARIF_INTERNAL_RM(69, actor);
    }
    print "^";
    (answer_words = Keyboard(buffer2, parse2));
    for ((i = 1):(i <= answer_words):(i)++) {
        if ((WordFrom(i, parse2) == comma_word)) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }
    (first_word = (parse2-->(1)));
    if ((first_word == 0)) {
        (j = wn);
        (first_word = LanguageIsVerb(buffer2, parse2, 1));
        (wn = j);
    }
    if ((first_word ~= 0)) {
        (j = (first_word->(#dict_par1)));
        if ((((0 ~= ((j)&(1)))) && ((~~(LanguageVerbMayBeName(first_word)))))) {
            VM_CopyBuffer(buffer, buffer2);
            jump RECONSTRUCT_INPUT;
        }
    }
    if ((inferfrom ~= 0)) {
        for ((j = inferfrom):(j < pcount):(j)++) {
            if (((pattern-->(j)) == PATTERN_NULL)) {
                continue;
            }
            (i = (WORDSIZE + (buffer-->(0))));
            ((buffer-->(0)))++;
            ((buffer->((i)++)) = 32);
            if ((parser_trace >= 5)) {
                print "[Gluing in inference at ";
                print j;
                print " with pattern code ";
                print (pattern-->(j));
                print "]^";
            }
            ((parse2-->(1)) = 0);
            if (((((pattern-->(j)) >= 2)) && (((pattern-->(j)) < REPARSE_CODE)))) {
                if ((dont_infer_pronoun == 0)) {
                    PronounNotice((pattern-->(j)));
                    for ((k = 1):(k <= (LanguagePronouns-->(0))):(k = (k + 3))) {
                        if (((pattern-->(j)) == (LanguagePronouns-->((k + 2))))) {
                            ((parse2-->(1)) = (LanguagePronouns-->(k)));
                            if ((parser_trace >= 5)) {
                                print "[Using pronoun '";
                                print (address) (parse2-->(1));
                                print "']^";
                            }
                            break;
                        }
                    }
                }
            } else {
                ((parse2-->(1)) = VM_NumberToDictionaryAddress(((pattern-->(j)) - REPARSE_CODE)));
                if ((parser_trace >= 5)) {
                    print "[Using preposition '";
                    print (address) (parse2-->(1));
                    print "']^";
                }
            }
            if (((parse2-->(1)) ~= 0)) {
                (k = (buffer + i));
                (k = Glulx_PrintAnyToArray((buffer + i), (INPUT_BUFFER_LEN - i), (parse2-->(1))));
                (i = (i + k));
                ((buffer-->(0)) = (i - WORDSIZE));
            }
        }
    }
    (i = (WORDSIZE + (buffer-->(0))));
    ((buffer-->(0)))++;
    ((buffer->((i)++)) = 32);
    for ((j = 0):(j < (buffer2-->(0))):((i)++,(j)++)) {
        ((buffer->(i)) = (buffer2->((j + WORDSIZE))));
        ((buffer-->(0)))++;
        if (((buffer-->(0)) == INPUT_BUFFER_LEN)) {
            break;
        }
    }
    jump RECONSTRUCT_INPUT;
];
[ PARSER_CLARIF_INTERNAL_R;
];
[ Adjudicate context i j k good_ones last n ultimate flag offset;
    if ((parser_trace >= 4)) {
        print "   [Adjudicating match list of size ";
        print number_matched;
        print " in context ";
        print context;
        print "^";
        print "   ";
        if (indef_mode) {
            print "indefinite type: ";
            if (((indef_type)&(OTHER_BIT))) {
                print "other ";
            }
            if (((indef_type)&(MY_BIT))) {
                print "my ";
            }
            if (((indef_type)&(THAT_BIT))) {
                print "that ";
            }
            if (((indef_type)&(PLURAL_BIT))) {
                print "plural ";
            }
            if (((indef_type)&(LIT_BIT))) {
                print "lit ";
            }
            if (((indef_type)&(UNLIT_BIT))) {
                print "unlit ";
            }
            if ((indef_owner ~= 0)) {
                print "owner:";
                PrintShortName(indef_owner);
            }
            print "^";
            print "   number wanted: ";
            if ((indef_wanted == INDEF_ALL_WANTED)) {
                print "all";
            } else {
                print indef_wanted;
            }
            print "^";
            print "   most likely GNAs of names: ";
            print indef_cases;
            print "^";
        } else {
            print "definite object^";
        }
    }
    (j = (number_matched - 1));
    (good_ones = 0);
    (last = (match_list-->(0)));
    for ((i = 0):(i <= j):(i)++) {
        (n = (match_list-->(i)));
        ((match_scores-->(i)) = good_ones);
        (ultimate = ScopeCeiling(n));
        if ((((context == HELD_TOKEN)) && ((parent(n) == actor)))) {
            (good_ones)++;
            (last = n);
        }
        if ((((((((((context == MULTI_TOKEN)) && ((ultimate == ScopeCeiling(actor))))) && ((n ~= actor)))) && ((~~((n has concealed)))))) && ((~~((n has scenery)))))) {
            (good_ones)++;
            (last = n);
        }
        if ((((context == MULTIHELD_TOKEN)) && ((parent(n) == actor)))) {
            (good_ones)++;
            (last = n);
        }
        if ((context == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
            if ((advance_warning == -1)) {
                if ((context == MULTIEXCEPT_TOKEN)) {
                    (good_ones)++;
                    (last = n);
                }
                if ((context == MULTIINSIDE_TOKEN)) {
                    if ((parent(n) ~= actor)) {
                        (good_ones)++;
                        (last = n);
                    }
                }
            } else {
                if ((((context == MULTIEXCEPT_TOKEN)) && ((n ~= advance_warning)))) {
                    (good_ones)++;
                    (last = n);
                }
                if ((((context == MULTIINSIDE_TOKEN)) && ((n in advance_warning)))) {
                    (good_ones)++;
                    (last = n);
                }
            }
        }
        if ((((context == CREATURE_TOKEN)) && ((CreatureTest(n) == 1)))) {
            (good_ones)++;
            (last = n);
        }
        ((match_scores-->(i)) = (1000*(good_ones - (match_scores-->(i)))));
    }
    if ((good_ones == 1)) {
        if ((((((indef_mode == 1)) && ((((indef_type)&(PLURAL_BIT)) ~= 0)))) && ((context == MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)))) {
            BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, last);
            if (((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, last)) && (RulebookFailed()))) {
                (good_ones = 0);
            }
            EndActivity(DECIDING_WHETHER_ALL_INC_ACT, last);
            if ((good_ones == 1)) {
                return last;
            }
        } else {
            return last;
        }
    }
    if ((((context == CREATURE_TOKEN)) && ((good_ones == 0)))) {
        return (match_list-->(0));
    }
    if ((indef_mode == 0)) {
        (indef_type = 0);
    }
    ScoreMatchL(context);
    if ((number_matched == 0)) {
        return (-(1));
    }
    if ((indef_mode == 0)) {
        (i = SingleBestGuess());
        if ((i >= 0)) {
            if ((parser_trace >= 4)) {
                print "   Single best-scoring object returned.]^";
            }
            return i;
        }
    }
    if ((((indef_mode == 1)) && ((((indef_type)&(PLURAL_BIT)) ~= 0)))) {
        if ((context ~= MULTI_TOKEN or MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
            (etype = MULTI_PE);
            return (-(1));
        }
        (i = 0);
        (offset = (multiple_object-->(0)));
        for ((j = BestGuess()):(((((j ~= -1)) && ((i < indef_wanted)))) && (((i + offset) < (MATCH_LIST_WORDS - 1)))):(j = BestGuess())) {
            (flag = 0);
            BeginActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
            if ((ForActivity(DECIDING_WHETHER_ALL_INC_ACT, j) == 0)) {
                if ((((~~((j has concealed)))) && ((~~((j has worn)))))) {
                    (flag = 1);
                }
                if ((((context == MULTIHELD_TOKEN or MULTIEXCEPT_TOKEN)) && ((parent(j) ~= actor)))) {
                    (flag = 0);
                }
                if ((((action_to_be == ##Take or ##Remove)) && ((parent(j) == actor)))) {
                    (flag = 0);
                }
                (k = ChooseObjects(j, flag));
                if ((k == 1)) {
                    (flag = 1);
                } else {
                    if ((k == 2)) {
                        (flag = 0);
                    }
                }
            } else {
                (flag = 0);
                if (RulebookSucceeded()) {
                    (flag = 1);
                }
            }
            EndActivity(DECIDING_WHETHER_ALL_INC_ACT, j);
            if ((flag == 1)) {
                (i)++;
                ((multiple_object-->((i + offset))) = j);
                if ((parser_trace >= 4)) {
                    print "   Accepting it^";
                }
            } else {
                (i = i);
                if ((parser_trace >= 4)) {
                    print "   Rejecting it^";
                }
            }
        }
        if ((((i < indef_wanted)) && ((indef_wanted < INDEF_ALL_WANTED)))) {
            (multi_wanted = indef_wanted);
            if ((parser_trace >= 4)) {
                print "Too few found in Adjudicate^";
            }
            (multi_had = i);
        }
        ((multiple_object-->(0)) = (i + offset));
        (multi_context = context);
        if ((parser_trace >= 4)) {
            print "   Made multiple object of size ";
            print i;
            print "]^";
        }
        rtrue;
    }
    for ((i = 0):(i < number_matched):(i)++) {
        ((match_classes-->(i)) = 0);
    }
    (n = 1);
    for ((i = 0):(i < number_matched):(i)++) {
        if (((match_classes-->(i)) == 0)) {
            ((match_classes-->(i)) = (n)++);
            (flag = 0);
            for ((j = (i + 1)):(j < number_matched):(j)++) {
                if (((((match_classes-->(j)) == 0)) && ((Identical((match_list-->(i)), (match_list-->(j))) == 1)))) {
                    (flag = 1);
                    ((match_classes-->(j)) = (match_classes-->(i)));
                }
            }
            if ((flag == 1)) {
                ((match_classes-->(i)) = (1 - n));
            }
        }
    }
    (n)--;
    (number_of_classes = n);
    if ((parser_trace >= 4)) {
        print "   Grouped into ";
        print n;
        print " possibilities by name:^";
        for ((i = 0):(i < number_matched):(i)++) {
            if (((match_classes-->(i)) > 0)) {
                print "   ";
                CDefArt((match_list-->(i)));
                print " (";
                print (match_list-->(i));
                print ")  ---  group ";
                print (match_classes-->(i));
                print "^";
            }
        }
    }
    if ((indef_mode == 0)) {
        if ((n > 1)) {
            (k = -1);
            for ((i = 0):(i < number_matched):(i)++) {
                if (((match_scores-->(i)) > k)) {
                    (k = (match_scores-->(i)));
                    (j = (match_classes-->(i)));
                    (j = (j*j));
                    (flag = 0);
                } else {
                    if (((match_scores-->(i)) == k)) {
                        if ((((match_classes-->(i))*(match_classes-->(i))) ~= j)) {
                            (flag = 1);
                        }
                    }
                }
            }
            if (flag) {
                if ((parser_trace >= 4)) {
                    print "   Unable to choose best group, so ask player.]^";
                }
                rfalse;
            }
            if ((parser_trace >= 4)) {
                print "   Best choices are all from the same group.^";
            }
        }
    }
    if ((n == 1)) {
        (dont_infer = 1);
    }
    return BestGuess();
];
[ ReviseMulti second_p i low;
    if ((parser_trace >= 4)) {
        print "   Revising multiple object list of size ";
        print (multiple_object-->(0));
        print " with 2nd ";
        PrintShortName(second_p);
        print "^";
    }
    if ((multi_context == MULTIEXCEPT_TOKEN or MULTIINSIDE_TOKEN)) {
        for (((i = 1),(low = 0)):(i <= (multiple_object-->(0))):(i)++) {
            if ((((((multi_context == MULTIEXCEPT_TOKEN)) && (((multiple_object-->(i)) ~= second_p)))) || ((((multi_context == MULTIINSIDE_TOKEN)) && (((multiple_object-->(i)) in second_p)))))) {
                (low)++;
                ((multiple_object-->(low)) = (multiple_object-->(i)));
            }
        }
        ((multiple_object-->(0)) = low);
    }
    if ((((multi_context == MULTI_TOKEN)) && ((action_to_be == ##Take)))) {
        if ((parser_trace >= 4)) {
            print "   Token 2 plural case: number with actor ";
            print low;
            print "^";
        }
        if ((take_all_rule == 2)) {
            for (((i = 1),(low = 0)):(i <= (multiple_object-->(0))):(i)++) {
                if ((ScopeCeiling((multiple_object-->(i))) == ScopeCeiling(actor))) {
                    (low)++;
                    ((multiple_object-->(low)) = (multiple_object-->(i)));
                }
            }
            ((multiple_object-->(0)) = low);
        }
    }
    (i = (multiple_object-->(0)));
    if ((parser_trace >= 4)) {
        print "   Done: new size ";
        print i;
        print "^";
    }
    if ((i == 0)) {
        return NOTHING_PE;
    }
    rfalse;
];
[ MakeMatch obj quality i;
    if ((parser_trace >= 6)) {
        print "    Match with quality ";
        print quality;
        print "^";
    }
    if ((((token_filter ~= 0)) && ((ConsultNounFilterToken(obj) == 0)))) {
        if ((parser_trace >= 6)) {
            print "    Match filtered out: token filter ";
            print token_filter;
            print "^";
        }
        rtrue;
    }
    if ((quality < match_length)) {
        rtrue;
    }
    if ((quality > match_length)) {
        (match_length = quality);
        (number_matched = 0);
    } else {
        if ((number_matched >= MATCH_LIST_WORDS)) {
            rtrue;
        }
        for ((i = 0):(i < number_matched):(i)++) {
            if (((match_list-->(i)) == obj)) {
                rtrue;
            }
        }
    }
    ((match_list-->((number_matched)++)) = obj);
    if ((parser_trace >= 6)) {
        print "    Match added to list^";
    }
];
[ ConsultNounFilterToken obj sn rv;
    if ((token_filter ofclass Routine)) {
        (sn = noun);
        (noun = obj);
        (rv = (token_filter)());
        (noun = sn);
        return rv;
    }
    if (_final_propertyvalue(OBJECT_TY, obj, (token_filter - 1))) {
        rtrue;
    }
    rfalse;
];
[ ScoreMatchL context its_owner its_score obj i j threshold met a_s l_s;
    if ((((indef_type)&(MY_BIT)) ~= 0)) {
        (threshold)++;
    }
    if ((((indef_type)&(THAT_BIT)) ~= 0)) {
        (threshold)++;
    }
    if ((((indef_type)&(LIT_BIT)) ~= 0)) {
        (threshold)++;
    }
    if ((((indef_type)&(UNLIT_BIT)) ~= 0)) {
        (threshold)++;
    }
    if ((indef_owner ~= 0)) {
        (threshold)++;
    }
    if ((parser_trace >= 4)) {
        print "   Scoring match list: indef mode ";
        print indef_mode;
        print " type ";
        print indef_type;
        print ", satisfying ";
        print threshold;
        print " requirements:^";
    }
    (a_s = SCORE__BESTLOC);
    (l_s = SCORE__NEXTBESTLOC);
    if ((action_to_be == ##Take or ##Remove)) {
        (a_s = SCORE__NEXTBESTLOC);
        (l_s = SCORE__BESTLOC);
    }
    (context = context);
    for ((i = 0):(i < number_matched):(i)++) {
        (obj = (match_list-->(i)));
        (its_owner = parent(obj));
        (its_score = 0);
        (met = 0);
        if ((((((indef_type)&(MY_BIT)) ~= 0)) && ((its_owner == actor)))) {
            (met)++;
        }
        if ((((((indef_type)&(THAT_BIT)) ~= 0)) && ((its_owner == actors_location)))) {
            (met)++;
        }
        if ((((((indef_type)&(LIT_BIT)) ~= 0)) && ((obj has light)))) {
            (met)++;
        }
        if ((((((indef_type)&(UNLIT_BIT)) ~= 0)) && ((~~((obj has light)))))) {
            (met)++;
        }
        if ((((indef_owner ~= 0)) && ((((its_owner == indef_owner)) || ((CoreOf(obj) == indef_owner)))))) {
            (met)++;
        }
        if ((met < threshold)) {
            if ((parser_trace >= 4)) {
                print "   ";
                CDefArt((match_list-->(i)));
                print " (";
                print (match_list-->(i));
                print ") in ";
                DefArt(its_owner);
                print " is rejected (doesn't match descriptors)^";
            }
            ((match_list-->(i)) = -1);
        } else {
            (its_score = 0);
            if ((~~((obj has concealed)))) {
                (its_score = SCORE__UNCONCEALED);
            }
            if ((its_owner == actor)) {
                (its_score = (its_score + a_s));
            } else {
                if ((its_owner == actors_location)) {
                    (its_score = (its_score + l_s));
                } else {
                    if ((its_owner ~= Compass)) {
                        (its_score = (its_score + SCORE__NOTCOMPASS));
                    }
                }
            }
            (its_score = (its_score + (SCORE__CHOOSEOBJ*ChooseObjects(obj, 2))));
            if ((~~((obj has scenery)))) {
                (its_score = (its_score + SCORE__NOTSCENERY));
            }
            if ((obj ~= actor)) {
                (its_score = (its_score + SCORE__NOTACTOR));
            }
            if (((indef_cases)&((PowersOfTwo_TB-->(GetGNAOfObject(obj)))))) {
                (its_score = (its_score + SCORE__GNA));
            }
            ((match_scores-->(i)) = ((match_scores-->(i)) + its_score));
            if ((parser_trace >= 4)) {
                print "     ";
                CDefArt((match_list-->(i)));
                print " in ";
                DefArt(its_owner);
                print " : ";
                print (match_scores-->(i));
                print " points^";
            }
        }
    }
    for ((i = 0):(i < number_matched):(i)++) {
        while (((match_list-->(i)) == -1)) {
            if ((i == (number_matched - 1))) {
                (number_matched)--;
                break;
            }
            for ((j = i):(j < (number_matched - 1)):(j)++) {
                ((match_list-->(j)) = (match_list-->((j + 1))));
                ((match_scores-->(j)) = (match_scores-->((j + 1))));
            }
            (number_matched)--;
        }
    }
];
[ BestGuess earliest its_score best i;
    (earliest = 0);
    (best = -1);
    for ((i = 0):(i < number_matched):(i)++) {
        if (((match_list-->(i)) >= 0)) {
            (its_score = (match_scores-->(i)));
            if ((its_score > best)) {
                (best = its_score);
                (earliest = i);
            }
        }
    }
    if ((parser_trace >= 4)) {
        if ((best < 0)) {
            print "   Best guess ran out of choices^";
        } else {
            print "   Best guess ";
            DefArt((match_list-->(earliest)));
            print "^";
        }
    }
    if ((best < 0)) {
        return (-(1));
    }
    (i = (match_list-->(earliest)));
    ((match_list-->(earliest)) = -1);
    return i;
];
[ SingleBestGuess earliest its_score best i;
    (earliest = -1);
    (best = -1000);
    for ((i = 0):(i < number_matched):(i)++) {
        (its_score = (match_scores-->(i)));
        if ((its_score == best)) {
            (earliest = -1);
        }
        if ((its_score > best)) {
            (best = its_score);
            (earliest = (match_list-->(i)));
        }
    }
    return earliest;
];
[ Identical o1 o2 p1 p2 n1 n2 i j flag;
    if ((o1 == o2)) {
        rtrue;
    }
    if ((((o1 == 0)) || ((o2 == 0)))) {
        rfalse;
    }
    if ((((o1 ofclass K3_direction)) || ((o2 ofclass K3_direction)))) {
        rfalse;
    }
    if (((((o1.parse_name) ~= 0)) || (((o2.parse_name) ~= 0)))) {
        if (((o1.parse_name) ~= (o2.parse_name))) {
            rfalse;
        }
        (parser_action = ##TheSame);
        (parser_one = o1);
        (parser_two = o2);
        (j = wn);
        (i = RunRoutines(o1, A_parse_name));
        (wn = j);
        if ((i == -1)) {
            rtrue;
        }
        if ((i == -2)) {
            rfalse;
        }
    }
    (p1 = (_final_propertyarray(OBJECT_TY, o1, A_name)));
    (n1 = ((_final_propertylength(OBJECT_TY, o1, A_name))/WORDSIZE));
    (p2 = (_final_propertyarray(OBJECT_TY, o2, A_name)));
    (n2 = ((_final_propertylength(OBJECT_TY, o2, A_name))/WORDSIZE));
    for ((i = 0):(i < n1):(i)++) {
        (flag = 0);
        for ((j = 0):(j < n2):(j)++) {
            if (((p1-->(i)) == (p2-->(j)))) {
                (flag = 1);
            }
        }
        if ((flag == 0)) {
            rfalse;
        }
    }
    for ((j = 0):(j < n2):(j)++) {
        (flag = 0);
        for ((i = 0):(i < n1):(i)++) {
            if (((p1-->(i)) == (p2-->(j)))) {
                (flag = 1);
            }
        }
        if ((flag == 0)) {
            rfalse;
        }
    }
    rtrue;
];
[ PrintInferredCommand from singleton_noun;
    (singleton_noun = 0);
    if ((((((((from ~= 0)) && ((from == (pcount - 1))))) && (((pattern-->(from)) > 1)))) && (((pattern-->(from)) < REPARSE_CODE)))) {
        (singleton_noun = 1);
    }
    if (singleton_noun) {
        BeginActivity(CLARIFYING_PARSERS_CHOICE_ACT, (pattern-->(from)));
        if ((ForActivity(CLARIFYING_PARSERS_CHOICE_ACT, (pattern-->(from))) == 0)) {
            print "(";
            PrintCommand(from);
            print ")^";
        }
        EndActivity(CLARIFYING_PARSERS_CHOICE_ACT, (pattern-->(from)));
    } else {
        print "(";
        PrintCommand(from);
        print ")^";
    }
];
[ PrintCommand from i k spacing_flag;
    if ((from == 0)) {
        (i = verb_word);
        if ((LanguageVerb(i) == 0)) {
            if ((PrintVerb(i) == 0)) {
                print (address) i;
            }
        }
        (from)++;
        (spacing_flag = 1);
    }
    for ((k = from):(k < pcount):(k)++) {
        (i = (pattern-->(k)));
        if ((i == PATTERN_NULL)) {
            continue;
        }
        if (spacing_flag) {
            print (char) 32;
        }
        if ((i == 0)) {
            PARSER_CLARIF_INTERNAL_RM(70);
            jump TokenPrinted;
        }
        if ((i == 1)) {
            PARSER_CLARIF_INTERNAL_RM(71);
            jump TokenPrinted;
        }
        if ((i >= REPARSE_CODE)) {
            print (address) VM_NumberToDictionaryAddress((i - REPARSE_CODE));
        } else {
            if ((i ofclass K3_direction)) {
                LanguageDirection(i);
            } else {
                DefArt(i);
            }
        }
        .TokenPrinted;
        (spacing_flag = 1);
    }
];
[ CantSee i w e;
    (saved_oops = oops_from);
    if ((scope_token ~= 0)) {
        (scope_error = scope_token);
        return ASKSCOPE_PE;
    }
    (wn)--;
    (w = NextWord());
    (e = CANTSEE_PE);
    if ((w == pronoun_word)) {
        (w = NextWordStopped());
        (wn)--;
        if ((((w == -1)) || (((line_token-->(pcount)) ~= ENDIT_TOKEN)))) {
            if ((pcount > 0)) {
                AnalyseToken((line_token-->((pcount - 1))));
            }
            if ((((pcount > 0)) && ((found_ttype == ROUTINE_FILTER_TT or ATTR_FILTER_TT)))) {
                (e = NOTINCONTEXT_PE);
            } else {
                (pronoun__word = pronoun_word);
                (pronoun__obj = pronoun_obj);
                (e = ITGONE_PE);
            }
        }
    }
    if ((etype > e)) {
        return etype;
    }
    return e;
];
[ MultiAdd o i j;
    (i = (multiple_object-->(0)));
    if ((i == (MATCH_LIST_WORDS - 1))) {
        (toomany_flag = 1);
        rtrue;
    }
    for ((j = 1):(j <= i):(j)++) {
        if ((o == (multiple_object-->(j)))) {
            rtrue;
        }
    }
    (i)++;
    ((multiple_object-->(i)) = o);
    ((multiple_object-->(0)) = i);
];
[ MultiSub o i j k;
    (i = (multiple_object-->(0)));
    for ((j = 1):(j <= i):(j)++) {
        if ((o == (multiple_object-->(j)))) {
            for ((k = j):(k <= i):(k)++) {
                ((multiple_object-->(k)) = (multiple_object-->((k + 1))));
            }
            ((multiple_object-->(0)) = --(i));
            rfalse;
        }
    }
    return VAGUE_PE;
];
[ MultiFilter attr i j o;
    .MFiltl;
    (i = (multiple_object-->(0)));
    for ((j = 1):(j <= i):(j)++) {
        (o = (multiple_object-->(j)));
        if ((~~(_final_propertyvalue(OBJECT_TY, o, attr)))) {
            MultiSub(o);
            jump MFiltl;
        }
    }
];
[ PlaceInScope O opts ws;
    (ws = wn);
    (wn = match_from);
    if ((opts == 0)) {
        DoScopeActionAndRecurse(O);
    } else {
        DoScopeAction(O);
    }
    (wn = ws);
    rtrue;
];
[ AddToScope obj;
    if ((ats_flag >= 2)) {
        DoScopeActionAndRecurse(obj, 0, (ats_flag - 2));
    }
    if ((ats_flag == 1)) {
        if ((HasLightSource(obj) == 1)) {
            (ats_hls = 1);
        }
    }
];
[ TestScope obj act a al sr ss st x y;
    (x = parser_one);
    (y = parser_two);
    (parser_one = obj);
    (parser_two = 0);
    (a = actor);
    (al = actors_location);
    (ss = scope_stage);
    (st = scope_token);
    (scope_stage = 0);
    (scope_token = 0);
    (sr = scope_reason);
    (scope_reason = TESTSCOPE_REASON);
    if ((act == 0)) {
        (actor = player);
    } else {
        (actor = act);
    }
    (actors_location = ScopeCeiling(actor));
    SearchScope(actors_location, actor, 0);
    (scope_reason = sr);
    (actor = a);
    (scope_stage = ss);
    (scope_token = st);
    (actors_location = al);
    (parser_one = x);
    (x = parser_two);
    (parser_two = y);
    return x;
];
[ LoopOverScope routine act x y a al;
    (x = parser_one);
    (y = scope_reason);
    (a = actor);
    (al = actors_location);
    (parser_one = routine);
    if ((act == 0)) {
        (actor = player);
    } else {
        (actor = act);
    }
    (actors_location = ScopeCeiling(actor));
    (scope_reason = LOOPOVERSCOPE_REASON);
    SearchScope(actors_location, actor, 0);
    (parser_one = x);
    (scope_reason = y);
    (actor = a);
    (actors_location = al);
];
[ SearchScope domain1 domain2 context i;
    if ((domain1 == 0)) {
        rtrue;
    }
    if (scope_token) {
        (scope_stage = 2);
        if ((parser_trace >= 3)) {
            print "  [Scope routine called at stage 2]^";
        }
        if (((scope_token)() ~= 0)) {
            rtrue;
        }
    }
    BeginActivity(DECIDING_SCOPE_ACT, actor);
    if ((ForActivity(DECIDING_SCOPE_ACT, actor) == 0)) {
        if ((((((scope_reason == PARSING_REASON)) && ((context == MULTIINSIDE_TOKEN)))) && ((advance_warning ~= -1)))) {
            if ((IsSeeThrough(advance_warning) == 1)) {
                ScopeWithin(advance_warning, 0, context);
            }
        } else {
            if ((((((((scope_reason == PARSING_REASON)) && ((context ~= CREATURE_TOKEN)))) && ((indef_mode == 0)))) && ((domain1 == actors_location)))) {
                ScopeWithin(Compass);
            }
            if (((or_tmp_var = domain1) && (((or_tmp_var has supporter)) || ((or_tmp_var has container))))) {
                DoScopeAction(domain1);
            }
            ScopeWithin(domain1, domain2, context);
            if (domain2) {
                if (((or_tmp_var = domain2) && (((or_tmp_var has supporter)) || ((or_tmp_var has container))))) {
                    DoScopeAction(domain2);
                }
                ScopeWithin(domain2, 0, context);
            }
        }
        if ((thedark == domain1 or domain2)) {
            DoScopeActionAndRecurse(actor, actor, context);
            if (((or_tmp_var = parent(actor)) && (((or_tmp_var has supporter)) || ((or_tmp_var has container))))) {
                DoScopeActionAndRecurse(parent(actor), parent(actor), context);
            }
        }
    }
    EndActivity(DECIDING_SCOPE_ACT, actor);
];
[ ScopeWithin domain nosearch context obj next_obj;
    if ((domain == 0)) {
        rtrue;
    }
    (obj = child(domain));
    while (obj) {
        (next_obj = sibling(obj));
        if ((((domain == actor)) || ((TestConcealment(domain, obj) == 0)))) {
            DoScopeActionAndRecurse(obj, nosearch, context);
        }
        (obj = next_obj);
    }
];
[ DoScopeActionAndRecurse domain nosearch context i ad n obj next_obj;
    DoScopeAction(domain);
    if ((((domain ~= nosearch)) && ((((domain ofclass K1_room or K8_person)) || ((IsSeeThrough(domain) == 1)))))) {
        (obj = child(domain));
        while (obj) {
            (next_obj = sibling(obj));
            if ((((domain == actor)) || ((TestConcealment(domain, obj) == 0)))) {
                DoScopeActionAndRecurse(obj, nosearch, context);
            }
            (obj = next_obj);
        }
    }
    if ((_final_propertyexists(OBJECT_TY, domain, A_component_child))) {
        (obj = (domain.component_child));
        while (obj) {
            (next_obj = (obj.component_sibling));
            if ((((domain == actor)) || ((TestConcealment(domain, obj) == 0)))) {
                DoScopeActionAndRecurse(obj, 0, context);
            }
            (obj = next_obj);
        }
    }
    (ad = (_final_propertyarray(OBJECT_TY, domain, A_add_to_scope)));
    if ((ad ~= 0)) {
        (i = (metaclass((ad-->(0))) == Object));
        if (i) {
            (ats_flag = (2 + context));
            RunRoutines(domain, A_add_to_scope);
            (ats_flag = 0);
        } else {
            (n = (_final_propertylength(OBJECT_TY, domain, A_add_to_scope)));
            for ((i = 0):((WORDSIZE*i) < n):(i)++) {
                if ((ad-->(i))) {
                    DoScopeActionAndRecurse((ad-->(i)), 0, context);
                }
            }
        }
    }
];
[ DoScopeAction item;
    if ((parser_trace >= 6)) {
        print "[DSA on ";
        DefArt(item);
        print " with reason = ";
        print scope_reason;
        print " p1 = ";
        print parser_one;
        print " p2 = ";
        print parser_two;
        print "]^";
    }
    @push parser_one;
    @push scope_reason;
    switch (scope_reason) {
        TESTSCOPE_REASON:
            if ((item == parser_one)) {
                (parser_two = 1);
            }
            ;
        LOOPOVERSCOPE_REASON:
            if ((parser_one ofclass Routine)) {
                (parser_one)(item);
            }
            ;
        PARSING_REASON, TALKING_REASON:
            MatchTextAgainstObject(item);
            ;
    }
    @pull scope_reason;
    @pull parser_one;
];
[ MatchTextAgainstObject item i;
    if ((((token_filter ~= 0)) && ((ConsultNounFilterToken(item) == 0)))) {
        rtrue;
    }
    if ((match_from <= num_words)) {
        (wn = match_from);
        (i = NounWord());
        if ((((i == 1)) && ((player == item)))) {
            MakeMatch(item, 1);
        }
        if ((((((i >= 2)) && ((i < 128)))) && (((LanguagePronouns-->(i)) == item)))) {
            MakeMatch(item, 1);
        }
    }
    (wn = match_from);
    if ((TryGivenObject(item) > 0)) {
        if ((((indef_nspec_at > 0)) && ((match_from ~= indef_nspec_at)))) {
            (wn = indef_nspec_at);
            if ((TryGivenObject(item) > 0)) {
                (match_from = indef_nspec_at);
                ResetDescriptors();
            }
            (wn = match_from);
        }
    }
];
[ TryGivenObject obj nomatch threshold k w j;
    if ((parser_trace >= 5)) {
        print "    Trying ";
        DefArt(obj);
        print " at word ";
        print wn;
        print "^";
    }
    if (((nomatch) && ((obj == 0)))) {
        rfalse;
    }
    (dict_flags_of_noun = 0);
    if ((wn > num_words)) {
        if (nomatch) {
            rfalse;
        }
        if ((indef_mode ~= 0)) {
            (dict_flags_of_noun = 112);
        }
        MakeMatch(obj, 0);
        if ((parser_trace >= 5)) {
            print "    Matched (0)^";
        }
        rtrue;
    }
    if (((obj.parse_name) ~= 0)) {
        (parser_action = NULL);
        (j = wn);
        (k = RunRoutines(obj, A_parse_name));
        if ((k > 0)) {
            (wn = (j + k));
            .MMbyPN;
            if ((parser_action == ##PluralFound)) {
                (dict_flags_of_noun = ((dict_flags_of_noun)|(4)));
            }
            if (((dict_flags_of_noun)&(4))) {
                if ((~~(allow_plurals))) {
                    (k = 0);
                } else {
                    if ((indef_mode == 0)) {
                        (indef_mode = 1);
                        (indef_type = 0);
                        (indef_wanted = 0);
                    }
                    (indef_type = ((indef_type)|(PLURAL_BIT)));
                    if ((indef_wanted == 0)) {
                        (indef_wanted = INDEF_ALL_WANTED);
                    }
                }
            }
            if ((parser_trace >= 5)) {
                print "    Matched (";
                print k;
                print ")^";
            }
            if ((nomatch == 0)) {
                MakeMatch(obj, k);
            }
            return k;
        }
        if ((k == 0)) {
            jump NoWordsMatch;
        }
    }
    (parser_action = NULL);
    (w = NounWord());
    if ((((w == 1)) && ((player == obj)))) {
        (k = 1);
        jump MMbyPN;
    }
    if ((((((w >= 2)) && ((w < 128)))) && (((LanguagePronouns-->(w)) == obj)))) {
        (k = 1);
        jump MMbyPN;
    }
    if ((Refers(obj, (wn - 1)) == 0)) {
        .NoWordsMatch;
        if ((indef_mode ~= 0)) {
            (k = 0);
            (parser_action = NULL);
            jump MMbyPN;
        }
        rfalse;
    }
    (threshold = 1);
    (dict_flags_of_noun = (((w->(#dict_par1)))&(116)));
    (w = NextWord());
    while (Refers(obj, (wn - 1))) {
        (threshold)++;
        if (w) {
            (dict_flags_of_noun = ((dict_flags_of_noun)|((((w->(#dict_par1)))&(116)))));
        }
        (w = NextWord());
    }
    (k = threshold);
    jump MMbyPN;
];
[ Refers obj wnum wd k l m;
    if ((obj == 0)) {
        rfalse;
    }
    (k = wn);
    (wn = wnum);
    (wd = NextWordStopped());
    (wn = k);
    if (indirect_parser_inflection) {
        (k = (parser_inflection)(obj,wd));
        if ((k >= 0)) {
            return k;
        }
        (m = (-(k)));
    } else {
        (m = parser_inflection);
    }
    (k = (_final_propertyarray(OBJECT_TY, obj, m)));
    (l = (((_final_propertylength(OBJECT_TY, obj, m))/WORDSIZE) - 1));
    for ((m = 0):(m <= l):(m)++) {
        if ((wd == (k-->(m)))) {
            rtrue;
        }
    }
    rfalse;
];
[ WordInProperty wd obj prop k l m;
    (k = (_final_propertyarray(OBJECT_TY, obj, prop)));
    (l = ((_final_propertylength(OBJECT_TY, obj, prop))/WORDSIZE));
    for ((m = 0):(m < l):(m)++) {
        if ((wd == (k-->(m)))) {
            rtrue;
        }
    }
    rfalse;
];
[ NounWord i j s;
    (i = NextWord());
    if ((i == 0)) {
        rfalse;
    }
    if ((i == ME1__WD or ME2__WD or ME3__WD)) {
        rtrue;
    }
    (s = (LanguagePronouns-->(0)));
    for ((j = 1):(j <= s):(j = (j + 3))) {
        if ((i == (LanguagePronouns-->(j)))) {
            return (j + 2);
        }
    }
    if (((((i->(#dict_par1)))&(128)) == 0)) {
        rfalse;
    }
    return i;
];
[ TryNumber wordnum i j c num len mul tot d digit;
    (i = wn);
    (wn = wordnum);
    (j = NextWord());
    (wn = i);
    (j = NumberWord(j));
    if ((j >= 1)) {
        return j;
    }
    (i = (wordnum*3));
    (j = (parse-->(i)));
    (num = (j + buffer));
    (len = (parse-->((i - 1))));
    if ((len >= 4)) {
        (mul = 1000);
    }
    if ((len == 3)) {
        (mul = 100);
    }
    if ((len == 2)) {
        (mul = 10);
    }
    if ((len == 1)) {
        (mul = 1);
    }
    (tot = 0);
    (c = 0);
    (len = (len - 1));
    for ((c = 0):(c <= len):(c)++) {
        (digit = (num->(c)));
        if ((digit == 48)) {
            (d = 0);
            jump digok;
        }
        if ((digit == 49)) {
            (d = 1);
            jump digok;
        }
        if ((digit == 50)) {
            (d = 2);
            jump digok;
        }
        if ((digit == 51)) {
            (d = 3);
            jump digok;
        }
        if ((digit == 52)) {
            (d = 4);
            jump digok;
        }
        if ((digit == 53)) {
            (d = 5);
            jump digok;
        }
        if ((digit == 54)) {
            (d = 6);
            jump digok;
        }
        if ((digit == 55)) {
            (d = 7);
            jump digok;
        }
        if ((digit == 56)) {
            (d = 8);
            jump digok;
        }
        if ((digit == 57)) {
            (d = 9);
            jump digok;
        }
        return (-(1000));
        .digok;
        (tot = (tot + (mul*d)));
        (mul = (mul/10));
    }
    if ((len > 3)) {
        (tot = 10000);
    }
    return tot;
];
[ GetGender person;
    if ((~~((person has female)))) {
        rtrue;
    }
    rfalse;
];
[ GetGNAOfObject obj case gender;
    if ((~~((obj has animate)))) {
        (case = 6);
    }
    if ((obj has male)) {
        (gender = A_male);
    }
    if ((obj has female)) {
        (gender = A_female);
    }
    if ((obj has neuter)) {
        (gender = A_neuter);
    }
    if ((gender == 0)) {
        if ((case == 0)) {
            (gender = LanguageAnimateGender);
        } else {
            (gender = LanguageInanimateGender);
        }
    }
    if ((gender == A_female)) {
        (case = (case + 1));
    }
    if ((gender == A_neuter)) {
        (case = (case + 2));
    }
    if ((obj has pluralname)) {
        (case = (case + 3));
    }
    return case;
];
[ DetectPluralWord at n i w swn outcome;
    (swn = wn);
    (wn = at);
    for ((i = 0):(i < n):(i)++) {
        (w = NextWordStopped());
        if ((w == 0 or THEN1__WD or comma_word or -1)) {
            break;
        }
        if ((((w->(#dict_par1)))&(4))) {
            (parser_action = ##PluralFound);
            (outcome = 1);
        }
    }
    (wn = swn);
    return outcome;
];
[ SetPronoun dword value x;
    for ((x = 1):(x <= (LanguagePronouns-->(0))):(x = (x + 3))) {
        if (((LanguagePronouns-->(x)) == dword)) {
            ((LanguagePronouns-->((x + 2))) = value);
            rtrue;
        }
    }
    RunTimeError(14);
];
[ PronounValue dword x;
    for ((x = 1):(x <= (LanguagePronouns-->(0))):(x = (x + 3))) {
        if (((LanguagePronouns-->(x)) == dword)) {
            return (LanguagePronouns-->((x + 2)));
        }
    }
    rfalse;
];
[ ResetVagueWords obj;
    PronounNotice(obj);
];
[ PronounNotice obj x bm g;
    if ((obj == player)) {
        rtrue;
    }
    (g = GetGNAOfObject(obj));
    (bm = (PowersOfTwo_TB-->(g)));
    for ((x = 1):(x <= (LanguagePronouns-->(0))):(x = (x + 3))) {
        if ((((bm)&((LanguagePronouns-->((x + 1))))) ~= 0)) {
            ((LanguagePronouns-->((x + 2))) = obj);
        }
    }
    if (((((g%6) < 3)) && ((obj has ambigpluralname)))) {
        (g = (g + 3));
        (bm = (PowersOfTwo_TB-->(g)));
        for ((x = 1):(x <= (LanguagePronouns-->(0))):(x = (x + 3))) {
            if ((((bm)&((LanguagePronouns-->((x + 1))))) ~= 0)) {
                ((LanguagePronouns-->((x + 2))) = obj);
            }
        }
    }
];
[ PronounNoticeHeldObjects x;
    objectloop (x in player) {
        PronounNotice(x);
    }
    (x = 0);
    rfalse;
];
[ YesOrNo i j;
    for (:1:) {
        if ((((location ~= 0)) && ((parent(player) ~= 0)))) {
            DrawStatusLine();
        }
        KeyboardPrimitive(buffer2, parse2);
        (j = (parse2-->(0)));
        if (j) {
            (i = (parse2-->(1)));
            if ((i == YES1__WD or YES2__WD or YES3__WD)) {
                rtrue;
            }
            if ((i == NO1__WD or NO2__WD or NO3__WD)) {
                rfalse;
            }
        }
        YES_OR_NO_QUESTION_INTERNAL_RM(65);
        print "> ";
    }
];
[ YES_OR_NO_QUESTION_INTERNAL_R;
];
[ NumberWord o i n;
    (n = (LanguageNumbers-->(0)));
    for ((i = 1):(i <= n):(i = (i + 2))) {
        if ((o == (LanguageNumbers-->(i)))) {
            return (LanguageNumbers-->((i + 1)));
        }
    }
    rfalse;
];
[ COBJ__Copy words from to i;
    for ((i = 0):(i < words):(i)++) {
        ((to-->(i)) = (from-->(i)));
    }
];
[ COBJ__SwapMatches i x;
    (x = number_matched);
    (number_matched = (alt_match_list-->(0)));
    ((alt_match_list-->(0)) = x);
    if ((x < number_matched)) {
        (x = number_matched);
    }
    for ((i = x):(i > 0):(i)--) {
        (x = (match_list-->((i - 1))));
        ((match_list-->((i - 1))) = (alt_match_list-->(i)));
        ((alt_match_list-->(i)) = x);
    }
];
[ ChooseObjects obj code l i swn spcount;
    if ((code < 2)) {
        rfalse;
    }
    if ((cobj_flag == 1)) {
        .CodeOne;
        if ((parameters > 0)) {
            return ScoreDabCombo((parser_results-->(INP1_PRES)), obj);
        } else {
            (l = 0);
            for ((i = 1):(i <= (alt_match_list-->(0))):(i)++) {
                (spcount = ScoreDabCombo(obj, (alt_match_list-->(i))));
                if ((spcount == HIGHEST_DPMR_SCORE)) {
                    return spcount;
                }
                if ((spcount > l)) {
                    (l = spcount);
                }
            }
            return l;
        }
    }
    if ((cobj_flag == 2)) {
        .CodeTwo;
        @push action_to_be;
        if ((parameters == 0)) {
            if ((advance_warning > 0)) {
                (l = ScoreDabCombo(obj, advance_warning));
            } else {
                (l = ScoreDabCombo(obj, 0));
            }
        } else {
            (l = ScoreDabCombo((parser_results-->(INP1_PRES)), obj));
        }
        @pull action_to_be;
        return l;
    }
    (swn = wn);
    (spcount = pcount);
    while (((line_ttype-->(pcount)) == PREPOSITION_TT)) {
        (pcount)++;
    }
    if (((line_ttype-->(pcount)) == ELEMENTARY_TT)) {
        if (((line_tdata-->(pcount)) == TOPIC_TOKEN)) {
            (pcount = spcount);
            jump CodeTwo;
        }
        while ((wn <= num_words)) {
            (l = NextWordStopped());
            (wn)--;
            if ((l == THEN1__WD)) {
                break;
            }
            if ((((l ~= -1 or 0)) && ((((l->(#dict_par1)))&(8))))) {
                (wn)++;
                continue;
            }
            if ((l == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD)) {
                (wn)++;
                continue;
            }
            SafeSkipDescriptors();
            @push match_length;
            @push token_filter;
            @push match_from;
            ((alt_match_list-->(0)) = number_matched);
            COBJ__Copy(number_matched, match_list, (alt_match_list + WORDSIZE));
            (match_length = 0);
            (number_matched = 0);
            (match_from = wn);
            (token_filter = 0);
            SearchScope(actor, actors_location, (line_tdata-->(pcount)));
            (wn = swn);
            (cobj_flag = 1);
            COBJ__SwapMatches();
            @pull match_from;
            @pull token_filter;
            @pull match_length;
            (pcount = spcount);
            jump CodeOne;
        }
    }
    (pcount = spcount);
    (wn = swn);
    (cobj_flag = 2);
    jump CodeTwo;
];
[ ScoreDabCombo a b result;
    @push action;
    @push act_requester;
    @push noun;
    @push second;
    (action = action_to_be);
    (act_requester = player);
    if (action_reversed) {
        (noun = b);
        (second = a);
    } else {
        (noun = a);
        (second = b);
    }
    (result = CheckDPMR());
    @pull second;
    @pull noun;
    @pull act_requester;
    @pull action;
    return result;
];
[ CheckDPMR result sinp1 sinp2 rv;
    (sinp1 = inp1);
    (sinp2 = inp2);
    (inp1 = noun);
    (inp2 = second);
    (rv = FollowRulebook(DOES_THE_PLAYER_MEAN_RB));
    (inp1 = sinp1);
    (inp2 = sinp2);
    if (((rv) && (RulebookSucceeded()))) {
        (result = ResultOfRule());
        if ((result == RBNO4_OUTCOME_U1)) {
            return 4;
        }
        if ((result == RBNO3_OUTCOME_U1)) {
            return 3;
        }
        if ((result == RBNO2_OUTCOME_U1)) {
            return 2;
        }
        if ((result == RBNO1_OUTCOME_U1)) {
            rtrue;
        }
        if ((result == RBNO0_OUTCOME_U1)) {
            rfalse;
        }
    }
    return 2;
];
[ DefaultTopic;
    return GPR_FAIL;
];
[ TEXT_TY_ROGPR txt p cp r;
    if ((txt == 0)) {
        return GPR_FAIL;
    }
    (cp = (txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(txt));
    (r = TEXT_TY_ROGPRI(txt));
    TEXT_TY_Untransmute(txt, p, cp);
    return r;
];
[ TEXT_TY_ROGPRI txt pos len wa wl wpos bdm ch own;
    (bdm = 1);
    (own = wn);
    (len = BlkValueLBCapacity(txt));
    for ((pos = 0):(pos <= len):(pos)++) {
        if ((pos == len)) {
            (ch = 0);
        } else {
            (ch = BlkValueRead(txt, pos));
        }
        if ((ch == 32 or 9 or 10 or 0)) {
            if (bdm) {
                continue;
            }
            (bdm = 1);
            if ((wpos ~= wl)) {
                return GPR_FAIL;
            }
            if ((ch == 0)) {
                break;
            }
        } else {
            if (bdm) {
                (bdm = 0);
                if ((NextWordStopped() == -1)) {
                    return GPR_FAIL;
                }
                (wa = WordAddress((wn - 1)));
                (wl = WordLength((wn - 1)));
                (wpos = 0);
            }
            if (((wa->(wpos)) ~= ch or TEXT_TY_RevCase(ch))) {
                return GPR_FAIL;
            }
            (wpos)++;
        }
    }
    if ((wn == own)) {
        return GPR_FAIL;
    }
    return GPR_PREPOSITION;
];
[ RunRoutines obj prop;
    if ((obj == thedark)) {
        (obj = real_location);
    }
    if (((_final_propertyarray(OBJECT_TY, obj, prop)) == 0)) {
        rfalse;
    }
    return _final_message0(obj, prop);
];
[ SetPlayersCommand from_txt i len at p cp;
    (cp = (from_txt-->(0)));
    (p = TEXT_TY_Temporarily_Transmute(from_txt));
    (len = TEXT_TY_CharacterLength(from_txt));
    if ((len > 118)) {
        (len = 118);
    }
    ((buffer-->(0)) = len);
    (at = 4);
    for ((i = 0):(i < len):(i)++) {
        ((buffer->((i + at))) = CharToCase(BlkValueRead(from_txt, i), 0));
    }
    for (:((at + i) < 120):(i)++) {
        ((buffer->((at + i))) = 32);
    }
    VM_Tokenise(buffer, parse);
    (players_command = (100 + WordCount()));
    TEXT_TY_Untransmute(from_txt, p, cp);
];
[ LIST_OF_TY_Mol list len i;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (len = (multiple_object-->(0)));
    LIST_OF_TY_SetLength(list, len);
    for ((i = 1):(i <= len):(i)++) {
        LIST_OF_TY_PutItem(list, i, (multiple_object-->(i)));
    }
    return list;
];
[ LIST_OF_TY_Set_Mol list len i;
    if ((((list == 0)) || ((BlkValueWeakKind(list) ~= LIST_OF_TY)))) {
        rfalse;
    }
    (len = BlkValueRead(list, LIST_LENGTH_F));
    if ((len > 63)) {
        (len = 63);
    }
    ((multiple_object-->(0)) = len);
    for ((i = 1):(i <= len):(i)++) {
        ((multiple_object-->(i)) = BlkValueRead(list, ((LIST_ITEM_BASE + i) - 1)));
    }
];
[ DECIMAL_TOKEN wnc wna r n wa wl sign base digit digit_count original_wn group_wn;
    (wnc = wn);
    (original_wn = wn);
    (group_wn = wn);
    (r = DECIMAL_TOKEN_INNER());
    if ((r ~= GPR_FAIL)) {
        return r;
    }
    (wn = wnc);
    (r = ParseTokenStopped(ELEMENTARY_TT, NUMBER_TOKEN));
    if ((((r == GPR_NUMBER)) && ((parsed_number ~= 10000)))) {
        return r;
    }
    (wn = wnc);
    (wa = WordAddress(wn));
    (wl = WordLength(wn));
    (sign = 1);
    (base = 10);
    (digit_count = 0);
    if (((wa->(0)) ~= 45 or 36 or 48 or 49 or 50 or 51 or 52 or 53 or 54 or 55 or 56 or 57)) {
        return GPR_FAIL;
    }
    if (((wa->(0)) == 45)) {
        (sign = -1);
        (wl)--;
        (wa)++;
    }
    if ((wl == 0)) {
        return GPR_FAIL;
    }
    (n = 0);
    while ((wl > 0)) {
        if (((wa->(0)) >= 97)) {
            (digit = (((wa->(0)) - 97) + 10));
        } else {
            (digit = ((wa->(0)) - 48));
        }
        (digit_count)++;
        switch (base) {
            2:
                if ((digit_count == 17)) {
                    return GPR_FAIL;
                }
                ;
            10:
                if ((digit_count == 11)) {
                    return GPR_FAIL;
                }
                if ((digit_count == 10)) {
                    if ((n > 214748364)) {
                        return GPR_FAIL;
                    }
                    if ((n == 214748364)) {
                        if ((((sign == 1)) && ((digit > 7)))) {
                            return GPR_FAIL;
                        }
                        if ((((sign == -1)) && ((digit > 8)))) {
                            return GPR_FAIL;
                        }
                    }
                }
                ;
            16:
                if ((digit_count == 5)) {
                    return GPR_FAIL;
                }
                ;
        }
        if ((((digit >= 0)) && ((digit < base)))) {
            (n = ((base*n) + digit));
        } else {
            return GPR_FAIL;
        }
        (wl)--;
        (wa)++;
    }
    (parsed_number = (n*sign));
    (wn)++;
    return GPR_NUMBER;
];
[ TRUTH_STATE_TOKEN original_wn wd;
    (original_wn = wn);
    (wd = TRUTH_STATE_TOKEN_INNER());
    if ((wd ~= GPR_FAIL)) {
        return wd;
    }
    (wn = original_wn);
    (wd = NextWordStopped());
    if ((wd == 'true')) {
        (parsed_number = 1);
        return GPR_NUMBER;
    }
    if ((wd == 'false')) {
        (parsed_number = 0);
        return GPR_NUMBER;
    }
    (wn = original_wn);
    return GPR_FAIL;
];
[ FLOAT_TOKEN buf bufend ix ch firstwd newstart newlen lastchar lastwasdot;
    if ((wn > num_words)) {
        return GPR_FAIL;
    }
    (firstwd = wn);
    (buf = WordAddress(wn));
    (bufend = buf);
    (lastchar = 0);
    while ((wn <= num_words)) {
        (newstart = WordAddress(wn));
        if ((newstart ~= bufend)) {
            if ((((lastchar ~= 42 or 120 or 88 or 215)) && (((newstart->(0)) ~= 42 or 120 or 88 or 215)))) {
                break;
            }
        }
        (newlen = WordLength(wn));
        for ((ix = 0):(ix < newlen):(ix)++) {
            (ch = (newstart->(ix)));
            if ((~~((((((ch >= 48)) && ((ch <= 57)))) || ((ch == 45 or 43 or 69 or 101 or 46 or 120 or 88 or 42 or 215 or 94)))))) {
                break;
            }
        }
        if ((ix < newlen)) {
            break;
        }
        (bufend = (newstart + newlen));
        (wn)++;
        (lastchar = ((bufend - 1)->(0)));
        (lastwasdot = (((newlen == 1)) && ((lastchar == 46))));
    }
    if ((((wn > firstwd)) && (lastwasdot))) {
        (wn)--;
        (bufend)--;
    }
    if ((wn == firstwd)) {
        return GPR_FAIL;
    }
    (parsed_number = FloatParse(buf, (bufend - buf), 1));
    if ((parsed_number == FLOAT_NAN)) {
        return GPR_FAIL;
    }
    return GPR_NUMBER;
];
#ifdef BASICINFORMKIT;
[ _final_propertyvalue K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) { if (o has p) rtrue; rfalse; }
            if (o provides p) return o.p;
        }
        rfalse;
    } else {
        t = value_property_holders-->K;
        return (t.(p-->1))-->(o+COL_HSIZE);
    }
];
#endif;
#ifdef BASICINFORMKIT;
[ _final_propertyexists K o p holder;
if (K == OBJECT_TY) {
    if ((o) && (metaclass(o) == Object)) {
        if ((p-->0 == 2) || (o provides p-->1)) {
            rtrue;
        } else {
            rfalse;
        }
    } else {
        rfalse;
    }
} else {
    if ((o >= 1) && (o <= value_ranges-->K)) {
        holder = value_property_holders-->K;
        if ((holder) && (holder provides p-->1)) {
            rtrue;
        } else {
            rfalse;
        }
    } else {
        rfalse;
    }
}
rfalse; ];
#endif;
#ifdef BASICINFORMKIT;
[ _final_propertyarray K o p v t;
    if (K ~= OBJECT_TY) return 0;
    t = p-->0; p = p-->1;
    if (t == 2) return 0;
    return o.&p;
];
#endif;
#ifdef BASICINFORMKIT;
[ _final_propertylength K o p v t;
    if (K ~= OBJECT_TY) return 0;
    t = p-->0; p = p-->1;
    if (t == 2) return 0;
    return o.#p;
];
#endif;
#ifdef BASICINFORMKIT;
[ _final_store_property K o p v t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (v) give o p; else give o ~p;
            } else if (o provides p) {
                o.p = v;
            }
        }
    } else {
        ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) = v;
    }
];
[ _final_preinc_property K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (o has p) { give o ~p; rfalse; } give o p; rtrue;
            } else if (o provides p) {
                return ++(o.p);
            }
        }
    } else {
       return ++(((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE));
    }
    return 0;
];
[ _final_predec_property K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (o has p) { give o ~p; rfalse; } give o p; rtrue;
            } else if (o provides p) {
                return --(o.p);
            }
        }
    } else {
       return --(((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE));
    }
    return 0;
];
[ _final_postinc_property K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (o has p) { give o ~p; rtrue; } give o p; rfalse;
            } else if (o provides p) {
                return (o.p)++;
            }
        }
    } else {
       return (((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE))++;
    }
    return 0;
];
[ _final_postdec_property K o p t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (o has p) { give o ~p; rtrue; } give o p; rfalse;
            } else if (o provides p) {
                return (o.p)--;
            }
        }
    } else {
       return (((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE))--;
    }
    return 0;
];
[ _final_setbit_property K o p v t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (v & 1) give o p;
            } else if (o provides p) {
                o.p = o.p | v;
            }
        }
    } else {
        ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) =
            ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) | v;
    }
];
[ _final_clearbit_property K o p v t;
    if (K == OBJECT_TY) {
        if (metaclass(o) == Object) {
            t = p-->0; p = p-->1;
            if (t == 2) {
                if (v & 1) give o ~p;
            } else if (o provides p) {
                o.p = o.p & ~v;
            }
        }
    } else {
        ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) =
            ((value_property_holders-->K).(p-->1))-->(o+COL_HSIZE) & ~v;
    }
];
#endif;
#ifdef BASICINFORMKIT;
[ _final_message0 o p q x a rv;
    if (p-->0 == 2) return 0;
    q = p-->1; return o.q();
];
[ _final_message1 o p v1 q x a rv;
    if (p-->0 == 2) return 0;
    q = p-->1; return o.q(v1);
];
[ _final_message2 o p v1 v2 q x a rv;
    if (p-->0 == 2) return 0;
    q = p-->1; return o.q(v1, v2);
];
[ _final_message3 o p v1 v2 v3 q x a rv;
    if (p-->0 == 2) return 0;
    q = p-->1; return o.q(v1, v2, v3);
];
#endif;
Verb 'take' 'carry' 'hold' 
	* 'inventory' -> Inv 
	* multi -> Take 
	* 'off' noun -> Disrobe 
	* noun 'off' -> Disrobe 
	* multiinside 'from' noun -> Remove 
	* multiinside 'off' noun -> Remove;
Verb 'get' 
	* 'out' / 'off' / 'down' / 'up' -> Exit 
	* 'in' / 'on' -> Enter 
	* multi -> Take 
	* 'in' / 'into' / 'on' / 'onto' noun -> Enter 
	* 'off' / 'down' noun -> GetOff 
	* multiinside 'from' noun -> Remove;
Verb 'pick' 
	* 'up' multi -> Take 
	* multi 'up' -> Take;
Verb 'stand' 
	* -> Exit 
	* 'up' -> Exit 
	* 'on' noun -> Enter;
Verb 'remove' 
	* held -> Disrobe 
	* multiinside 'from' noun -> Remove;
Verb 'shed' 'doff' 'disrobe' 
	* held -> Disrobe;
Verb 'wear' 'don' 
	* held -> Wear;
Verb 'put' 
	* 'on' held -> Wear 
	* held 'on' -> Wear 
	* 'down' multiheld -> Drop 
	* multiheld 'down' -> Drop 
	* multiexcept 'in' / 'inside' / 'into' noun -> Insert 
	* multiexcept 'on' / 'onto' noun -> PutOn;
Verb 'insert' 
	* multiexcept 'in' / 'into' noun -> Insert;
Verb 'drop' 'throw' 'discard' 
	* multiheld -> Drop 
	* held 'at' / 'against' noun -> ThrowAt 
	* multiexcept 'in' / 'into' / 'down' noun -> Insert 
	* multiexcept 'on' / 'onto' noun -> PutOn;
Verb 'give' 'pay' 'offer' 'feed' 
	* creature held -> Give reverse 
	* held 'to' creature -> Give;
Verb 'show' 'present' 'display' 
	* creature held -> Show reverse 
	* held 'to' creature -> Show;
Verb 'go' 'walk' 'run' 
	* -> Go 
	*  noun=Noun_Filter1 -> Go 
	* noun -> Enter 
	* 'into' / 'in' / 'inside' / 'through' noun -> Enter;
Verb 'inventory' 'i//' 'inv' 
	* -> Inv;
Verb 'look' 'l//' 
	* -> Look 
	* noun -> Examine 
	* 'at' noun -> Examine 
	* 'inside' / 'in' / 'into' / 'through' noun -> Search 
	* 'under' noun -> LookUnder 
	* 'up' topic 'in' noun -> Consult reverse;
Verb 'consult' 
	* noun 'on' / 'about' topic -> Consult;
Verb 'open' 'unwrap' 'uncover' 
	* noun -> Open 
	* noun 'with' held -> Unlock;
Verb 'close' 'shut' 'cover' 
	* noun -> Close 
	* 'up' noun -> Close 
	* 'off' noun -> SwitchOff;
Verb 'enter' 'cross' 
	* -> Enter 
	* noun -> Enter;
Verb 'sit' 
	* 'on' / 'in' / 'inside' noun -> Enter 
	* 'on' 'top' 'of' noun -> Enter;
Verb 'exit' 'leave' 'out' 
	* -> Exit;
Verb 'examine' 'x//' 'watch' 'describe' 'check' 
	* noun -> Examine;
Verb 'read' 
	* noun -> Examine 
	* 'about' topic 'in' noun -> Consult reverse 
	* topic 'in' noun -> Consult reverse;
Verb 'yes' 'y//' 
	* -> Yes;
Verb 'no' 
	* -> No;
Verb 'sorry' 
	* -> Sorry;
Verb 'search' 
	* noun -> Search;
Verb 'wave' 
	* -> WaveHands 
	* noun -> Wave;
Verb 'set' 'adjust' 
	* noun 'to' topic -> SetTo;
Verb 'pull' 'drag' 
	* noun -> Pull;
Verb 'push' 'move' 'shift' 'clear' 'press' 
	* noun -> Push 
	* noun  noun=Noun_Filter2 -> PushDir 
	* noun 'to'  noun=Noun_Filter3 -> PushDir;
Verb 'turn' 'rotate' 'twist' 'unscrew' 'screw' 
	* noun -> Turn 
	* noun 'on' -> SwitchOn 
	* 'on' noun -> SwitchOn 
	* noun 'off' -> SwitchOff 
	* 'off' noun -> SwitchOff;
Verb 'switch' 
	*  noun=Noun_Filter4 -> SwitchOff 
	* noun -> SwitchOn 
	* 'on' noun -> SwitchOn 
	* noun 'on' -> SwitchOn 
	* noun 'off' -> SwitchOff 
	* 'off' noun -> SwitchOff;
Verb 'lock' 
	* noun 'with' held -> Lock;
Verb 'unlock' 
	* noun 'with' held -> Unlock;
Verb 'attack' 'break' 'smash' 'hit' 'fight' 'torture' 'wreck' 'crack' 'destroy' 'murder' 'kill' 'punch' 'thump' 
	* noun -> Attack;
Verb 'wait' 'z//' 
	* -> Wait;
Verb 'answer' 'say' 'shout' 'speak' 
	* topic 'to' creature -> Answer reverse;
Verb 'tell' 
	* creature 'about' topic -> Tell;
Verb 'ask' 
	* creature 'for' noun -> AskFor 
	* creature 'about' topic -> Ask;
Verb 'eat' 
	* held -> Eat;
Verb 'sleep' 'nap' 
	* -> Sleep;
Verb 'climb' 'scale' 
	* noun -> Climb 
	* 'up' / 'over' noun -> Climb;
Verb 'buy' 'purchase' 
	* noun -> Buy;
Verb 'squeeze' 'squash' 
	* noun -> Squeeze;
Verb 'swing' 
	* noun -> Swing 
	* 'on' noun -> Swing;
Verb 'wake' 'awake' 'awaken' 
	* -> Wake 
	* 'up' -> Wake 
	* creature -> WakeOther 
	* creature 'up' -> WakeOther 
	* 'up' creature -> WakeOther;
Verb 'kiss' 'embrace' 'hug' 
	* creature -> Kiss;
Verb 'think' 
	* -> Think;
Verb 'smell' 'sniff' 
	* -> Smell 
	* noun -> Smell;
Verb 'listen' 
	* -> Listen 
	* 'to' noun -> Listen;
Verb 'hear' 
	* noun -> Listen;
Verb 'taste' 
	* noun -> Taste;
Verb 'touch' 'feel' 
	* noun -> Touch;
Verb 'rub' 'shine' 'polish' 'sweep' 'clean' 'dust' 'wipe' 'scrub' 
	* noun -> Rub;
Verb 'tie' 'attach' 'fasten' 
	* noun 'to' noun -> Tie;
Verb 'burn' 'light' 
	* noun -> Burn;
Verb 'drink' 'swallow' 'sip' 
	* noun -> Drink;
Verb 'cut' 'slice' 'prune' 'chop' 
	* noun -> Cut;
Verb 'jump' 'skip' 'hop' 
	* -> Jump;
Verb 'score' 
	* -> Score;
Verb 'quit' 
	* -> Quit;
Verb 'q//' 
	* -> Quit;
Verb 'save' 
	* -> Save;
Verb 'restart' 
	* -> Restart;
Verb 'restore' 
	* -> Restore;
Verb 'verify' 
	* -> Verify;
Verb 'version' 
	* -> Version;
Verb 'script' 
	* -> ScriptOn 
	* 'on' -> ScriptOn 
	* 'off' -> ScriptOff;
Verb 'transcript' 
	* -> ScriptOn 
	* 'on' -> ScriptOn 
	* 'off' -> ScriptOff;
Verb 'superbrief' 
	* -> LMode3;
Verb 'short' 
	* -> LMode3;
Verb 'verbose' 
	* -> LMode2;
Verb 'long' 
	* -> LMode2;
Verb 'brief' 
	* -> LMode1;
Verb 'normal' 
	* -> LMode1;
Verb 'nouns' 
	* -> Pronouns;
Verb 'pronouns' 
	* -> Pronouns;
Verb 'notify' 
	* -> NotifyOn 
	* 'on' -> NotifyOn 
	* 'off' -> NotifyOff;
Verb meta 'glklist' 
	* -> GlkList;
Verb meta 'abstract' 
	*  scope=testcommandnoun 'to'  scope=testcommandnoun -> XAbstract;
Verb meta 'actions' 
	* -> ActionsOn 
	* 'on' -> ActionsOn 
	* 'off' -> ActionsOff;
Verb meta 'gonear' 
	*  scope=testcommandnoun -> Gonear;
Verb meta 'purloin' 
	*  scope=testcommandnoun -> XPurloin;
Verb meta 'random' 
	* -> Predictable;
Verb meta 'relations' 
	* -> ShowRelations;
Verb meta 'responses' 
	* -> ShowResponses 
	* special -> ShowResponses 
	* 'now' special -> ShowResponses 
	* 'set' special -> ShowResponses;
Verb meta 'rules' 
	* -> RulesOn 
	* 'all' -> RulesAll 
	* 'on' -> RulesOn 
	* 'off' -> RulesOff;
Verb meta 'scenes' 
	* -> ScenesOn 
	* 'on' -> ScenesOn 
	* 'off' -> ScenesOff;
Verb meta 'scope' 
	* -> Scope 
	*  scope=testcommandnoun -> Scope;
Verb meta 'showheap' 
	* -> ShowHeap;
Verb meta 'showme' 
	* -> ShowMe 
	*  scope=testcommandnoun -> ShowMe;
Verb meta 'showverb' 
	* special -> ShowVerb;
Verb meta 'test' 
	* -> TestScript 
	* special -> TestScript;
Verb meta 'trace' 
	* -> TraceOn 
	* number -> TraceLevel 
	* 'on' -> TraceOn 
	* 'off' -> TraceOff;
Verb meta 'tree' 
	* -> XTree 
	*  scope=testcommandnoun -> XTree;
